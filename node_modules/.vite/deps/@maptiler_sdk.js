import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS({
  "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
    })(exports, (function() {
      "use strict";
      var maplibregl = {};
      var modules = {};
      function define2(moduleName, _dependencies, moduleFactory) {
        modules[moduleName] = moduleFactory;
        if (moduleName !== "index") {
          return;
        }
        var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
        var sharedModule = {};
        modules.shared(sharedModule);
        modules.index(maplibregl, sharedModule);
        if (typeof window !== "undefined") {
          maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
        }
        return maplibregl;
      }
      ;
      define2("shared", ["exports"], (function(t) {
        "use strict";
        function e(t2, e2, r2, n2) {
          return new (r2 || (r2 = Promise))((function(i2, s2) {
            function a2(t3) {
              try {
                l2(n2.next(t3));
              } catch (t4) {
                s2(t4);
              }
            }
            function o2(t3) {
              try {
                l2(n2.throw(t3));
              } catch (t4) {
                s2(t4);
              }
            }
            function l2(t3) {
              var e3;
              t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2((function(t4) {
                t4(e3);
              }))).then(a2, o2);
            }
            l2((n2 = n2.apply(t2, e2 || [])).next());
          }));
        }
        function r(t2, e2) {
          this.x = t2, this.y = e2;
        }
        function n(t2) {
          return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        var i, s;
        "function" == typeof SuppressedError && SuppressedError, r.prototype = { clone() {
          return new r(this.x, this.y);
        }, add(t2) {
          return this.clone()._add(t2);
        }, sub(t2) {
          return this.clone()._sub(t2);
        }, multByPoint(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint(t2) {
          return this.clone()._divByPoint(t2);
        }, mult(t2) {
          return this.clone()._mult(t2);
        }, div(t2) {
          return this.clone()._div(t2);
        }, rotate(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        }, matMult(t2) {
          return this.clone()._matMult(t2);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr(t2) {
          const e2 = t2.x - this.x, r2 = t2.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        }, _matMult(t2) {
          const e2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
        }, _add(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate(t2) {
          const e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround(t2, e2) {
          const r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: r }, r.convert = function(t2) {
          if (t2 instanceof r) return t2;
          if (Array.isArray(t2)) return new r(+t2[0], +t2[1]);
          if (void 0 !== t2.x && void 0 !== t2.y) return new r(+t2.x, +t2.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var a = (function() {
          if (s) return i;
          function t2(t3, e2, r2, n2) {
            this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
          }
          return s = 1, i = t2, t2.prototype = { sampleCurveX: function(t3) {
            return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
          }, sampleCurveY: function(t3) {
            return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
          }, sampleCurveDerivativeX: function(t3) {
            return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
          }, solveCurveX: function(t3, e2) {
            if (void 0 === e2 && (e2 = 1e-6), t3 < 0) return 0;
            if (t3 > 1) return 1;
            for (var r2 = t3, n2 = 0; n2 < 8; n2++) {
              var i2 = this.sampleCurveX(r2) - t3;
              if (Math.abs(i2) < e2) return r2;
              var s2 = this.sampleCurveDerivativeX(r2);
              if (Math.abs(s2) < 1e-6) break;
              r2 -= i2 / s2;
            }
            var a2 = 0, o2 = 1;
            for (r2 = t3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++) t3 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
            return r2;
          }, solve: function(t3, e2) {
            return this.sampleCurveY(this.solveCurveX(t3, e2));
          } }, i;
        })(), o = n(a);
        let l, u;
        function c() {
          return null == l && (l = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), l;
        }
        function h() {
          if (null == u && (u = false, c())) {
            const t2 = 5, e2 = new OffscreenCanvas(t2, t2).getContext("2d", { willReadFrequently: true });
            if (e2) {
              for (let r3 = 0; r3 < t2 * t2; r3++) {
                const n2 = 4 * r3;
                e2.fillStyle = `rgb(${n2},${n2 + 1},${n2 + 2})`, e2.fillRect(r3 % t2, Math.floor(r3 / t2), 1, 1);
              }
              const r2 = e2.getImageData(0, 0, t2, t2).data;
              for (let e3 = 0; e3 < t2 * t2 * 4; e3++) if (e3 % 4 != 3 && r2[e3] !== e3) {
                u = true;
                break;
              }
            }
          }
          return u || false;
        }
        var p = 1e-6, f2 = "undefined" != typeof Float32Array ? Float32Array : Array;
        function d() {
          var t2 = new f2(9);
          return f2 != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }
        function y2(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function m() {
          var t2 = new f2(3);
          return f2 != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
        }
        function g(t2) {
          var e2 = t2[0], r2 = t2[1], n2 = t2[2];
          return Math.sqrt(e2 * e2 + r2 * r2 + n2 * n2);
        }
        function x(t2, e2, r2) {
          var n2 = new f2(3);
          return n2[0] = t2, n2[1] = e2, n2[2] = r2, n2;
        }
        function v(t2, e2, r2) {
          return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
        }
        function b(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
        }
        function w2(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[0], o2 = r2[1], l2 = r2[2];
          return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
        }
        var _2, S2 = g;
        function A(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
        }
        function k2() {
          var t2 = new f2(4);
          return f2 != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
        }
        function E(t2, e2, r2, n2) {
          var i2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "zyx", s2 = Math.PI / 360;
          e2 *= s2, n2 *= s2, r2 *= s2;
          var a2 = Math.sin(e2), o2 = Math.cos(e2), l2 = Math.sin(r2), u2 = Math.cos(r2), c2 = Math.sin(n2), h2 = Math.cos(n2);
          switch (i2) {
            case "xyz":
              t2[0] = a2 * u2 * h2 + o2 * l2 * c2, t2[1] = o2 * l2 * h2 - a2 * u2 * c2, t2[2] = o2 * u2 * c2 + a2 * l2 * h2, t2[3] = o2 * u2 * h2 - a2 * l2 * c2;
              break;
            case "xzy":
              t2[0] = a2 * u2 * h2 - o2 * l2 * c2, t2[1] = o2 * l2 * h2 - a2 * u2 * c2, t2[2] = o2 * u2 * c2 + a2 * l2 * h2, t2[3] = o2 * u2 * h2 + a2 * l2 * c2;
              break;
            case "yxz":
              t2[0] = a2 * u2 * h2 + o2 * l2 * c2, t2[1] = o2 * l2 * h2 - a2 * u2 * c2, t2[2] = o2 * u2 * c2 - a2 * l2 * h2, t2[3] = o2 * u2 * h2 + a2 * l2 * c2;
              break;
            case "yzx":
              t2[0] = a2 * u2 * h2 + o2 * l2 * c2, t2[1] = o2 * l2 * h2 + a2 * u2 * c2, t2[2] = o2 * u2 * c2 - a2 * l2 * h2, t2[3] = o2 * u2 * h2 - a2 * l2 * c2;
              break;
            case "zxy":
              t2[0] = a2 * u2 * h2 - o2 * l2 * c2, t2[1] = o2 * l2 * h2 + a2 * u2 * c2, t2[2] = o2 * u2 * c2 + a2 * l2 * h2, t2[3] = o2 * u2 * h2 - a2 * l2 * c2;
              break;
            case "zyx":
              t2[0] = a2 * u2 * h2 - o2 * l2 * c2, t2[1] = o2 * l2 * h2 + a2 * u2 * c2, t2[2] = o2 * u2 * c2 - a2 * l2 * h2, t2[3] = o2 * u2 * h2 + a2 * l2 * c2;
              break;
            default:
              throw new Error("Unknown angle order " + i2);
          }
          return t2;
        }
        function T2() {
          var t2 = new f2(2);
          return f2 != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
        }
        function I2(t2, e2) {
          var r2 = new f2(2);
          return r2[0] = t2, r2[1] = e2, r2;
        }
        m(), _2 = new f2(4), f2 != Float32Array && (_2[0] = 0, _2[1] = 0, _2[2] = 0, _2[3] = 0), m(), x(1, 0, 0), x(0, 1, 0), k2(), k2(), d(), T2();
        const M2 = 8192;
        function F2(t2, e2, r2) {
          return e2 * (M2 / (t2.tileSize * Math.pow(2, r2 - t2.tileID.overscaledZ)));
        }
        function D2(t2, e2) {
          return (t2 % e2 + e2) % e2;
        }
        function z2(t2, e2, r2) {
          return t2 * (1 - r2) + e2 * r2;
        }
        function P2(t2) {
          if (t2 <= 0) return 0;
          if (t2 >= 1) return 1;
          const e2 = t2 * t2, r2 = e2 * t2;
          return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
        }
        function B2(t2, e2, r2, n2) {
          const i2 = new o(t2, e2, r2, n2);
          return (t3) => i2.solve(t3);
        }
        const V2 = B2(0.25, 0.1, 0.25, 1);
        function C(t2, e2, r2) {
          return Math.min(r2, Math.max(e2, t2));
        }
        function L2(t2, e2, r2) {
          const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
          return i2 === e2 ? r2 : i2;
        }
        function O2(t2, ...e2) {
          for (const r2 of e2) for (const e3 in r2) t2[e3] = r2[e3];
          return t2;
        }
        let R2 = 1;
        function N(t2, e2, r2) {
          const n2 = {};
          for (const r3 in t2) n2[r3] = e2.call(this, t2[r3], r3, t2);
          return n2;
        }
        function $2(t2, e2, r2) {
          const n2 = {};
          for (const r3 in t2) e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
          return n2;
        }
        function U2(t2) {
          return Array.isArray(t2) ? t2.map(U2) : "object" == typeof t2 && t2 ? N(t2, U2) : t2;
        }
        const q2 = {};
        function j2(t2) {
          q2[t2] || ("undefined" != typeof console && console.warn(t2), q2[t2] = true);
        }
        function G2(t2, e2, r2) {
          return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
        }
        function X(t2) {
          return "undefined" != typeof WorkerGlobalScope && void 0 !== t2 && t2 instanceof WorkerGlobalScope;
        }
        let Y2 = null;
        function Z2(t2) {
          return "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap;
        }
        const H2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function K2(t2, r2, n2, i2, s2) {
          return e(this, void 0, void 0, (function* () {
            if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
            const e2 = new VideoFrame(t2, { timestamp: 0 });
            try {
              const a2 = null == e2 ? void 0 : e2.format;
              if (!a2 || !a2.startsWith("BGR") && !a2.startsWith("RGB")) throw new Error(`Unrecognized format ${a2}`);
              const o2 = a2.startsWith("BGR"), l2 = new Uint8ClampedArray(i2 * s2 * 4);
              if (yield e2.copyTo(l2, (function(t3, e3, r3, n3, i3) {
                const s3 = 4 * Math.max(-e3, 0), a3 = (Math.max(0, r3) - r3) * n3 * 4 + s3, o3 = 4 * n3, l3 = Math.max(0, e3), u2 = Math.max(0, r3);
                return { rect: { x: l3, y: u2, width: Math.min(t3.width, e3 + n3) - l3, height: Math.min(t3.height, r3 + i3) - u2 }, layout: [{ offset: a3, stride: o3 }] };
              })(t2, r2, n2, i2, s2)), o2) for (let t3 = 0; t3 < l2.length; t3 += 4) {
                const e3 = l2[t3];
                l2[t3] = l2[t3 + 2], l2[t3 + 2] = e3;
              }
              return l2;
            } finally {
              e2.close();
            }
          }));
        }
        let W2, J2;
        function Q2(t2, e2, r2, n2) {
          return t2.addEventListener(e2, r2, n2), { unsubscribe: () => {
            t2.removeEventListener(e2, r2, n2);
          } };
        }
        function tt2(t2) {
          return t2 * Math.PI / 180;
        }
        function et2(t2) {
          return t2 / Math.PI * 180;
        }
        const rt2 = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, nt2 = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, it2 = "AbortError";
        class st2 extends Error {
          constructor(t2 = it2) {
            super(t2 instanceof Error ? t2.message : t2), this.name = it2, t2 instanceof Error && t2.stack && (this.stack = t2.stack);
          }
        }
        function at3(t2) {
          return t2.name === it2;
        }
        const ot2 = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function lt2(t2) {
          return ot2.REGISTERED_PROTOCOLS[t2.substring(0, t2.indexOf("://"))];
        }
        const ut2 = "global-dispatcher";
        class ct2 extends Error {
          constructor(t2, e2, r2, n2) {
            super(`AJAXError: ${e2} (${t2}): ${r2}`), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
          }
        }
        const ht2 = () => X(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, pt2 = function(t2, r2) {
          if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
            const e2 = lt2(t2.url);
            if (e2) return e2(t2, r2);
            if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t2, targetMapId: ut2 }, r2);
          }
          if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(ht2()) && !/^\w+:/.test(n2))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(t3, r3) {
              return e(this, void 0, void 0, (function* () {
                const e2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, cache: t3.cache, referrer: ht2(), signal: r3.signal });
                let n3, i2;
                "json" !== t3.type || e2.headers.has("Accept") || e2.headers.set("Accept", "application/json");
                try {
                  n3 = yield fetch(e2);
                } catch (e3) {
                  if (at3(e3)) throw e3;
                  throw new ct2(0, e3.message, t3.url, new Blob());
                }
                if (!n3.ok) {
                  const e3 = yield n3.blob();
                  throw new ct2(n3.status, n3.statusText, t3.url, e3);
                }
                i2 = "arrayBuffer" === t3.type || "image" === t3.type ? n3.arrayBuffer() : "json" === t3.type ? n3.json() : n3.text();
                const s2 = yield i2;
                return r3.signal.throwIfAborted(), { data: s2, cacheControl: n3.headers.get("Cache-Control"), expires: n3.headers.get("Expires") };
              }));
            })(t2, r2);
            if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t2, mustQueue: true, targetMapId: ut2 }, r2);
          }
          var n2;
          return (function(t3, e2) {
            return new Promise(((r3, n3) => {
              var i2;
              const s2 = new XMLHttpRequest();
              s2.open(t3.method || "GET", t3.url, true), "arrayBuffer" !== t3.type && "image" !== t3.type || (s2.responseType = "arraybuffer");
              for (const e3 in t3.headers) s2.setRequestHeader(e3, t3.headers[e3]);
              "json" === t3.type && (s2.responseType = "text", (null === (i2 = t3.headers) || void 0 === i2 ? void 0 : i2.Accept) || s2.setRequestHeader("Accept", "application/json")), s2.withCredentials = "include" === t3.credentials, s2.onerror = () => {
                n3(new Error(s2.statusText));
              }, s2.onload = () => {
                if (!e2.signal.aborted) if ((s2.status >= 200 && s2.status < 300 || 0 === s2.status) && null !== s2.response) {
                  let e3 = s2.response;
                  if ("json" === t3.type) try {
                    e3 = JSON.parse(s2.response);
                  } catch (t4) {
                    return void n3(t4);
                  }
                  r3({ data: e3, cacheControl: s2.getResponseHeader("Cache-Control"), expires: s2.getResponseHeader("Expires") });
                } else {
                  const e3 = new Blob([s2.response], { type: s2.getResponseHeader("Content-Type") });
                  n3(new ct2(s2.status, s2.statusText, t3.url, e3));
                }
              }, e2.signal.addEventListener("abort", (() => {
                s2.abort(), n3(new st2(e2.signal.reason));
              })), s2.send(t3.body);
            }));
          })(t2, r2);
        };
        function ft2(t2) {
          if (!t2 || t2.indexOf("://") <= 0 || 0 === t2.indexOf("data:image/") || 0 === t2.indexOf("blob:")) return true;
          const e2 = new URL(t2), r2 = window.location;
          return e2.protocol === r2.protocol && e2.host === r2.host;
        }
        function dt(t2, e2, r2) {
          r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
        }
        function yt2(t2, e2, r2) {
          if (r2 && r2[t2]) {
            const n2 = r2[t2].indexOf(e2);
            -1 !== n2 && r2[t2].splice(n2, 1);
          }
        }
        class mt2 {
          constructor(t2, e2 = {}) {
            O2(this, e2), this.type = t2;
          }
        }
        class gt2 extends mt2 {
          constructor(t2, e2 = {}) {
            super("error", O2({ error: t2 }, e2));
          }
        }
        class xt2 {
          on(t2, e2) {
            return this._listeners = this._listeners || {}, dt(t2, e2, this._listeners), { unsubscribe: () => {
              this.off(t2, e2);
            } };
          }
          off(t2, e2) {
            return yt2(t2, e2, this._listeners), yt2(t2, e2, this._oneTimeListeners), this;
          }
          once(t2, e2) {
            return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, dt(t2, e2, this._oneTimeListeners), this) : new Promise(((e3) => this.once(t2, e3)));
          }
          fire(t2, e2) {
            "string" == typeof t2 && (t2 = new mt2(t2, e2 || {}));
            const r2 = t2.type;
            if (this.listens(r2)) {
              t2.target = this;
              const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
              for (const r3 of e3) r3.call(this, t2);
              const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
              for (const e4 of n2) yt2(r2, e4, this._oneTimeListeners), e4.call(this, t2);
              const i2 = this._eventedParent;
              i2 && (O2(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
            } else t2 instanceof gt2 && console.error(t2.error);
            return this;
          }
          listens(t2) {
            return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
          }
          setEventedParent(t2, e2) {
            return this._eventedParent = t2, this._eventedParentData = e2, this;
          }
        }
        var vt2 = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number", length: 2 }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "fontFaces" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "filter" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: false, parameters: ["global-state"] }, "property-type": "data-constant" } }, filter: { type: "boolean", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "expression_name", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } }, interpolation: { type: "array", value: "interpolation_name", minimum: 1 }, interpolation_name: { type: "enum", values: { linear: { syntax: { overloads: [{ parameters: [], "output-type": "interpolation" }], parameters: [] } }, exponential: { syntax: { overloads: [{ parameters: ["base"], "output-type": "interpolation" }], parameters: [{ name: "base", type: "number literal" }] } }, "cubic-bezier": { syntax: { overloads: [{ parameters: ["x1", "y1", "x2", "y2"], "output-type": "interpolation" }], parameters: [{ name: "x1", type: "number literal" }, { name: "y1", type: "number literal" }, { name: "x2", type: "number literal" }, { name: "y2", type: "number literal" }] } } } } };
        const bt2 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function wt2(t2, e2) {
          const r2 = {};
          for (const e3 in t2) "ref" !== e3 && (r2[e3] = t2[e3]);
          return bt2.forEach(((t3) => {
            t3 in e2 && (r2[t3] = e2[t3]);
          })), r2;
        }
        function _t2(t2, e2) {
          if (Array.isArray(t2)) {
            if (!Array.isArray(e2) || t2.length !== e2.length) return false;
            for (let r2 = 0; r2 < t2.length; r2++) if (!_t2(t2[r2], e2[r2])) return false;
            return true;
          }
          if ("object" == typeof t2 && null !== t2 && null !== e2) {
            if ("object" != typeof e2) return false;
            if (Object.keys(t2).length !== Object.keys(e2).length) return false;
            for (const r2 in t2) if (!_t2(t2[r2], e2[r2])) return false;
            return true;
          }
          return t2 === e2;
        }
        function St2(t2, e2) {
          t2.push(e2);
        }
        function At2(t2, e2, r2) {
          St2(r2, { command: "addSource", args: [t2, e2[t2]] });
        }
        function kt2(t2, e2, r2) {
          St2(e2, { command: "removeSource", args: [t2] }), r2[t2] = true;
        }
        function Et2(t2, e2, r2, n2) {
          kt2(t2, r2, n2), At2(t2, e2, r2);
        }
        function Tt2(t2, e2, r2) {
          let n2;
          for (n2 in t2[r2]) if (Object.prototype.hasOwnProperty.call(t2[r2], n2) && "data" !== n2 && !_t2(t2[r2][n2], e2[r2][n2])) return false;
          for (n2 in e2[r2]) if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && "data" !== n2 && !_t2(t2[r2][n2], e2[r2][n2])) return false;
          return true;
        }
        function It2(t2, e2, r2, n2, i2, s2) {
          t2 = t2 || {}, e2 = e2 || {};
          for (const a2 in t2) Object.prototype.hasOwnProperty.call(t2, a2) && (_t2(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
          for (const a2 in e2) Object.prototype.hasOwnProperty.call(e2, a2) && !Object.prototype.hasOwnProperty.call(t2, a2) && (_t2(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
        }
        function Mt2(t2) {
          return t2.id;
        }
        function Ft2(t2, e2) {
          return t2[e2.id] = e2, t2;
        }
        class Dt2 {
          constructor(t2, e2, r2, n2) {
            this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function zt2(t2, ...e2) {
          for (const r2 of e2) for (const e3 in r2) t2[e3] = r2[e3];
          return t2;
        }
        class Pt2 extends Error {
          constructor(t2, e2) {
            super(e2), this.message = e2, this.key = t2;
          }
        }
        class Bt2 {
          constructor(t2, e2 = []) {
            this.parent = t2, this.bindings = {};
            for (const [t3, r2] of e2) this.bindings[t3] = r2;
          }
          concat(t2) {
            return new Bt2(this, t2);
          }
          get(t2) {
            if (this.bindings[t2]) return this.bindings[t2];
            if (this.parent) return this.parent.get(t2);
            throw new Error(`${t2} not found in scope.`);
          }
          has(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          }
        }
        const Vt2 = { kind: "null" }, Ct2 = { kind: "number" }, Lt2 = { kind: "string" }, Ot2 = { kind: "boolean" }, Rt2 = { kind: "color" }, Nt2 = { kind: "projectionDefinition" }, $t2 = { kind: "object" }, Ut2 = { kind: "value" }, qt2 = { kind: "collator" }, jt2 = { kind: "formatted" }, Gt2 = { kind: "padding" }, Xt2 = { kind: "colorArray" }, Yt2 = { kind: "numberArray" }, Zt2 = { kind: "resolvedImage" }, Ht2 = { kind: "variableAnchorOffsetCollection" };
        function Kt2(t2, e2) {
          return { kind: "array", itemType: t2, N: e2 };
        }
        function Wt2(t2) {
          if ("array" === t2.kind) {
            const e2 = Wt2(t2.itemType);
            return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
          }
          return t2.kind;
        }
        const Jt2 = [Vt2, Ct2, Lt2, Ot2, Rt2, Nt2, jt2, $t2, Kt2(Ut2), Gt2, Yt2, Xt2, Zt2, Ht2];
        function Qt2(t2, e2) {
          if ("error" === e2.kind) return null;
          if ("array" === t2.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Qt2(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N)) return null;
          } else {
            if (t2.kind === e2.kind) return null;
            if ("value" === t2.kind) {
              for (const t3 of Jt2) if (!Qt2(t3, e2)) return null;
            }
          }
          return `Expected ${Wt2(t2)} but found ${Wt2(e2)} instead.`;
        }
        function te2(t2, e2) {
          return e2.some(((e3) => e3.kind === t2.kind));
        }
        function ee2(t2, e2) {
          return e2.some(((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2));
        }
        function re2(t2, e2) {
          return "array" === t2.kind && "array" === e2.kind ? t2.itemType.kind === e2.itemType.kind && "number" == typeof t2.N : t2.kind === e2.kind;
        }
        const ne2 = 0.96422, ie2 = 0.82521, se2 = 4 / 29, ae2 = 6 / 29, oe2 = 3 * ae2 * ae2, le = ae2 * ae2 * ae2, ue2 = Math.PI / 180, ce2 = 180 / Math.PI;
        function he2(t2) {
          return (t2 %= 360) < 0 && (t2 += 360), t2;
        }
        function pe2([t2, e2, r2, n2]) {
          let i2, s2;
          const a2 = de2((0.2225045 * (t2 = fe2(t2)) + 0.7168786 * (e2 = fe2(e2)) + 0.0606169 * (r2 = fe2(r2))) / 1);
          t2 === e2 && e2 === r2 ? i2 = s2 = a2 : (i2 = de2((0.4360747 * t2 + 0.3850649 * e2 + 0.1430804 * r2) / ne2), s2 = de2((0.0139322 * t2 + 0.0971045 * e2 + 0.7141733 * r2) / ie2));
          const o2 = 116 * a2 - 16;
          return [o2 < 0 ? 0 : o2, 500 * (i2 - a2), 200 * (a2 - s2), n2];
        }
        function fe2(t2) {
          return t2 <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function de2(t2) {
          return t2 > le ? Math.pow(t2, 1 / 3) : t2 / oe2 + se2;
        }
        function ye2([t2, e2, r2, n2]) {
          let i2 = (t2 + 16) / 116, s2 = isNaN(e2) ? i2 : i2 + e2 / 500, a2 = isNaN(r2) ? i2 : i2 - r2 / 200;
          return i2 = 1 * ge2(i2), s2 = ne2 * ge2(s2), a2 = ie2 * ge2(a2), [me2(3.1338561 * s2 - 1.6168667 * i2 - 0.4906146 * a2), me2(-0.9787684 * s2 + 1.9161415 * i2 + 0.033454 * a2), me2(0.0719453 * s2 - 0.2289914 * i2 + 1.4052427 * a2), n2];
        }
        function me2(t2) {
          return (t2 = t2 <= 304e-5 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055) < 0 ? 0 : t2 > 1 ? 1 : t2;
        }
        function ge2(t2) {
          return t2 > ae2 ? t2 * t2 * t2 : oe2 * (t2 - se2);
        }
        const xe2 = Object.hasOwn || function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        };
        function ve2(t2, e2) {
          return xe2(t2, e2) ? t2[e2] : void 0;
        }
        function be2(t2) {
          return parseInt(t2.padEnd(2, t2), 16) / 255;
        }
        function we2(t2, e2) {
          return _e2(e2 ? t2 / 100 : t2, 0, 1);
        }
        function _e2(t2, e2, r2) {
          return Math.min(Math.max(e2, t2), r2);
        }
        function Se2(t2) {
          return !t2.some(Number.isNaN);
        }
        const Ae2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function ke2(t2, e2, r2) {
          return t2 + r2 * (e2 - t2);
        }
        function Ee2(t2, e2, r2) {
          return t2.map(((t3, n2) => ke2(t3, e2[n2], r2)));
        }
        class Te2 {
          constructor(t2, e2, r2, n2 = 1, i2 = true) {
            this.r = t2, this.g = e2, this.b = r2, this.a = n2, i2 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [t2, e2, r2, n2]));
          }
          static parse(t2) {
            if (t2 instanceof Te2) return t2;
            if ("string" != typeof t2) return;
            const e2 = (function(t3) {
              if ("transparent" === (t3 = t3.toLowerCase().trim())) return [0, 0, 0, 0];
              const e3 = ve2(Ae2, t3);
              if (e3) {
                const [t4, r3, n2] = e3;
                return [t4 / 255, r3 / 255, n2 / 255, 1];
              }
              if (t3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t3)) {
                const e4 = t3.length < 6 ? 1 : 2;
                let r3 = 1;
                return [be2(t3.slice(r3, r3 += e4)), be2(t3.slice(r3, r3 += e4)), be2(t3.slice(r3, r3 += e4)), be2(t3.slice(r3, r3 + e4) || "ff")];
              }
              if (t3.startsWith("rgb")) {
                const e4 = t3.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (e4) {
                  const [t4, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2] = e4, f3 = [i2 || " ", o2 || " ", c2].join("");
                  if ("  " === f3 || "  /" === f3 || ",," === f3 || ",,," === f3) {
                    const t5 = [n2, a2, u2].join(""), e5 = "%%%" === t5 ? 100 : "" === t5 ? 255 : 0;
                    if (e5) {
                      const t6 = [_e2(+r3 / e5, 0, 1), _e2(+s2 / e5, 0, 1), _e2(+l2 / e5, 0, 1), h2 ? we2(+h2, p2) : 1];
                      if (Se2(t6)) return t6;
                    }
                  }
                  return;
                }
              }
              const r2 = t3.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (r2) {
                const [t4, e4, n2, i2, s2, a2, o2, l2, u2] = r2, c2 = [n2 || " ", s2 || " ", o2].join("");
                if ("  " === c2 || "  /" === c2 || ",," === c2 || ",,," === c2) {
                  const t5 = [+e4, _e2(+i2, 0, 100), _e2(+a2, 0, 100), l2 ? we2(+l2, u2) : 1];
                  if (Se2(t5)) return (function([t6, e5, r3, n3]) {
                    function i3(n4) {
                      const i4 = (n4 + t6 / 30) % 12, s3 = e5 * Math.min(r3, 1 - r3);
                      return r3 - s3 * Math.max(-1, Math.min(i4 - 3, 9 - i4, 1));
                    }
                    return t6 = he2(t6), e5 /= 100, r3 /= 100, [i3(0), i3(8), i3(4), n3];
                  })(t5);
                }
              }
            })(t2);
            return e2 ? new Te2(...e2, false) : void 0;
          }
          get rgb() {
            const { r: t2, g: e2, b: r2, a: n2 } = this, i2 = n2 || 1 / 0;
            return this.overwriteGetter("rgb", [t2 / i2, e2 / i2, r2 / i2, n2]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t2) {
              const [e2, r2, n2, i2] = pe2(t2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
              return [Math.round(1e4 * s2) ? he2(Math.atan2(n2, r2) * ce2) : NaN, s2, e2, i2];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", pe2(this.rgb));
          }
          overwriteGetter(t2, e2) {
            return Object.defineProperty(this, t2, { value: e2 }), e2;
          }
          toString() {
            const [t2, e2, r2, n2] = this.rgb;
            return `rgba(${[t2, e2, r2].map(((t3) => Math.round(255 * t3))).join(",")},${n2})`;
          }
          static interpolate(t2, e2, r2, n2 = "rgb") {
            switch (n2) {
              case "rgb": {
                const [n3, i2, s2, a2] = Ee2(t2.rgb, e2.rgb, r2);
                return new Te2(n3, i2, s2, a2, false);
              }
              case "hcl": {
                const [n3, i2, s2, a2] = t2.hcl, [o2, l2, u2, c2] = e2.hcl;
                let h2, p2;
                if (isNaN(n3) || isNaN(o2)) isNaN(n3) ? isNaN(o2) ? h2 = NaN : (h2 = o2, 1 !== s2 && 0 !== s2 || (p2 = l2)) : (h2 = n3, 1 !== u2 && 0 !== u2 || (p2 = i2));
                else {
                  let t3 = o2 - n3;
                  o2 > n3 && t3 > 180 ? t3 -= 360 : o2 < n3 && n3 - o2 > 180 && (t3 += 360), h2 = n3 + r2 * t3;
                }
                const [f3, d2, y3, m2] = (function([t3, e3, r3, n4]) {
                  return t3 = isNaN(t3) ? 0 : t3 * ue2, ye2([r3, Math.cos(t3) * e3, Math.sin(t3) * e3, n4]);
                })([h2, null != p2 ? p2 : ke2(i2, l2, r2), ke2(s2, u2, r2), ke2(a2, c2, r2)]);
                return new Te2(f3, d2, y3, m2, false);
              }
              case "lab": {
                const [n3, i2, s2, a2] = ye2(Ee2(t2.lab, e2.lab, r2));
                return new Te2(n3, i2, s2, a2, false);
              }
            }
          }
        }
        Te2.black = new Te2(0, 0, 0, 1), Te2.white = new Te2(1, 1, 1, 1), Te2.transparent = new Te2(0, 0, 0, 0), Te2.red = new Te2(1, 0, 0, 1);
        class Ie2 {
          constructor(t2, e2, r2) {
            this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t2, e2) {
            return this.collator.compare(t2, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Me2 = ["bottom", "center", "top"];
        class Fe2 {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2, this.verticalAlign = s2;
          }
        }
        class De2 {
          constructor(t2) {
            this.sections = t2;
          }
          static fromString(t2) {
            return new De2([new Fe2(t2, null, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some(((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length));
          }
          static factory(t2) {
            return t2 instanceof De2 ? t2 : De2.fromString(t2);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map(((t2) => t2.text)).join("");
          }
        }
        class ze2 {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof ze2) return t2;
            if ("number" == typeof t2) return new ze2([t2, t2, t2, t2]);
            if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
              for (const e2 of t2) if ("number" != typeof e2) return;
              switch (t2.length) {
                case 1:
                  t2 = [t2[0], t2[0], t2[0], t2[0]];
                  break;
                case 2:
                  t2 = [t2[0], t2[1], t2[0], t2[1]];
                  break;
                case 3:
                  t2 = [t2[0], t2[1], t2[2], t2[1]];
              }
              return new ze2(t2);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t2, e2, r2) {
            return new ze2(Ee2(t2.values, e2.values, r2));
          }
        }
        class Pe2 {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof Pe2) return t2;
            if ("number" == typeof t2) return new Pe2([t2]);
            if (Array.isArray(t2)) {
              for (const e2 of t2) if ("number" != typeof e2) return;
              return new Pe2(t2);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t2, e2, r2) {
            return new Pe2(Ee2(t2.values, e2.values, r2));
          }
        }
        class Be2 {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof Be2) return t2;
            if ("string" == typeof t2) {
              const e3 = Te2.parse(t2);
              if (!e3) return;
              return new Be2([e3]);
            }
            if (!Array.isArray(t2)) return;
            const e2 = [];
            for (const r2 of t2) {
              if ("string" != typeof r2) return;
              const t3 = Te2.parse(r2);
              if (!t3) return;
              e2.push(t3);
            }
            return new Be2(e2);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t2, e2, r2, n2 = "rgb") {
            const i2 = [];
            if (t2.values.length != e2.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t2.values.length} vs. ${e2.values.length}), cannot interpolate.`);
            for (let s2 = 0; s2 < t2.values.length; s2++) i2.push(Te2.interpolate(t2.values[s2], e2.values[s2], r2, n2));
            return new Be2(i2);
          }
        }
        class Ve2 extends Error {
          constructor(t2) {
            super(t2), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const Ce2 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Le2 {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof Le2) return t2;
            if (Array.isArray(t2) && !(t2.length < 1) && t2.length % 2 == 0) {
              for (let e2 = 0; e2 < t2.length; e2 += 2) {
                const r2 = t2[e2], n2 = t2[e2 + 1];
                if ("string" != typeof r2 || !Ce2.has(r2)) return;
                if (!Array.isArray(n2) || 2 !== n2.length || "number" != typeof n2[0] || "number" != typeof n2[1]) return;
              }
              return new Le2(t2);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t2, e2, r2) {
            const n2 = t2.values, i2 = e2.values;
            if (n2.length !== i2.length) throw new Ve2(`Cannot interpolate values of different length. from: ${t2.toString()}, to: ${e2.toString()}`);
            const s2 = [];
            for (let t3 = 0; t3 < n2.length; t3 += 2) {
              if (n2[t3] !== i2[t3]) throw new Ve2(`Cannot interpolate values containing mismatched anchors. from[${t3}]: ${n2[t3]}, to[${t3}]: ${i2[t3]}`);
              s2.push(n2[t3]);
              const [e3, a2] = n2[t3 + 1], [o2, l2] = i2[t3 + 1];
              s2.push([ke2(e3, o2, r2), ke2(a2, l2, r2)]);
            }
            return new Le2(s2);
          }
        }
        class Oe2 {
          constructor(t2) {
            this.name = t2.name, this.available = t2.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t2) {
            return t2 ? new Oe2({ name: t2, available: false }) : null;
          }
        }
        class Re2 {
          constructor(t2, e2, r2) {
            this.from = t2, this.to = e2, this.transition = r2;
          }
          static interpolate(t2, e2, r2) {
            return new Re2(t2, e2, r2);
          }
          static parse(t2) {
            return t2 instanceof Re2 ? t2 : Array.isArray(t2) && 3 === t2.length && "string" == typeof t2[0] && "string" == typeof t2[1] && "number" == typeof t2[2] ? new Re2(t2[0], t2[1], t2[2]) : "object" == typeof t2 && "string" == typeof t2.from && "string" == typeof t2.to && "number" == typeof t2.transition ? new Re2(t2.from, t2.to, t2.transition) : "string" == typeof t2 ? new Re2(t2, t2, 1) : void 0;
          }
        }
        function Ne2(t2, e2, r2, n2) {
          return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function $e2(t2) {
          if (null === t2 || "string" == typeof t2 || "boolean" == typeof t2 || "number" == typeof t2 || t2 instanceof Re2 || t2 instanceof Te2 || t2 instanceof Ie2 || t2 instanceof De2 || t2 instanceof ze2 || t2 instanceof Pe2 || t2 instanceof Be2 || t2 instanceof Le2 || t2 instanceof Oe2) return true;
          if (Array.isArray(t2)) {
            for (const e2 of t2) if (!$e2(e2)) return false;
            return true;
          }
          if ("object" == typeof t2) {
            for (const e2 in t2) if (!$e2(t2[e2])) return false;
            return true;
          }
          return false;
        }
        function Ue2(t2) {
          if (null === t2) return Vt2;
          if ("string" == typeof t2) return Lt2;
          if ("boolean" == typeof t2) return Ot2;
          if ("number" == typeof t2) return Ct2;
          if (t2 instanceof Te2) return Rt2;
          if (t2 instanceof Re2) return Nt2;
          if (t2 instanceof Ie2) return qt2;
          if (t2 instanceof De2) return jt2;
          if (t2 instanceof ze2) return Gt2;
          if (t2 instanceof Pe2) return Yt2;
          if (t2 instanceof Be2) return Xt2;
          if (t2 instanceof Le2) return Ht2;
          if (t2 instanceof Oe2) return Zt2;
          if (Array.isArray(t2)) {
            const e2 = t2.length;
            let r2;
            for (const e3 of t2) {
              const t3 = Ue2(e3);
              if (r2) {
                if (r2 === t3) continue;
                r2 = Ut2;
                break;
              }
              r2 = t3;
            }
            return Kt2(r2 || Ut2, e2);
          }
          return $t2;
        }
        function qe2(t2) {
          const e2 = typeof t2;
          return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof Te2 || t2 instanceof Re2 || t2 instanceof De2 || t2 instanceof ze2 || t2 instanceof Pe2 || t2 instanceof Be2 || t2 instanceof Le2 || t2 instanceof Oe2 ? t2.toString() : JSON.stringify(t2);
        }
        class je2 {
          constructor(t2, e2) {
            this.type = t2, this.value = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (!$e2(t2[1])) return e2.error("invalid value");
            const r2 = t2[1];
            let n2 = Ue2(r2);
            const i2 = e2.expectedType;
            return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new je2(n2, r2);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Ge2 = { string: Lt2, number: Ct2, boolean: Ot2, object: $t2 };
        class Xe2 {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            let r2, n2 = 1;
            const i2 = t2[0];
            if ("array" === i2) {
              let i3, s3;
              if (t2.length > 2) {
                const r3 = t2[1];
                if ("string" != typeof r3 || !(r3 in Ge2) || "object" === r3) return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i3 = Ge2[r3], n2++;
              } else i3 = Ut2;
              if (t2.length > 3) {
                if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2]))) return e2.error('The length argument to "array" must be a positive integer literal', 2);
                s3 = t2[2], n2++;
              }
              r2 = Kt2(i3, s3);
            } else {
              if (!Ge2[i2]) throw new Error(`Types doesn't contain name = ${i2}`);
              r2 = Ge2[i2];
            }
            const s2 = [];
            for (; n2 < t2.length; n2++) {
              const r3 = e2.parse(t2[n2], n2, Ut2);
              if (!r3) return null;
              s2.push(r3);
            }
            return new Xe2(r2, s2);
          }
          evaluate(t2) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              const r2 = this.args[e2].evaluate(t2);
              if (!Qt2(this.type, Ue2(r2))) return r2;
              if (e2 === this.args.length - 1) throw new Ve2(`Expected value to be of type ${Wt2(this.type)}, but found ${Wt2(Ue2(r2))} instead.`);
            }
            throw new Error();
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every(((t2) => t2.outputDefined()));
          }
        }
        const Ye = { "to-boolean": Ot2, "to-color": Rt2, "to-number": Ct2, "to-string": Lt2 };
        class Ze2 {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            const r2 = t2[0];
            if (!Ye[r2]) throw new Error(`Can't parse ${r2} as it is not part of the known types`);
            if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length) return e2.error("Expected one argument.");
            const n2 = Ye[r2], i2 = [];
            for (let r3 = 1; r3 < t2.length; r3++) {
              const n3 = e2.parse(t2[r3], r3, Ut2);
              if (!n3) return null;
              i2.push(n3);
            }
            return new Ze2(n2, i2);
          }
          evaluate(t2) {
            switch (this.type.kind) {
              case "boolean":
                return Boolean(this.args[0].evaluate(t2));
              case "color": {
                let e2, r2;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Te2) return e2;
                  if ("string" == typeof e2) {
                    const r3 = t2.parseColor(e2);
                    if (r3) return r3;
                  } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rgba value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Ne2(e2[0], e2[1], e2[2], e2[3]), !r2)) return new Te2(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new Ve2(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "padding": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t2);
                  const n2 = ze2.parse(e2);
                  if (n2) return n2;
                }
                throw new Ve2(`Could not parse padding from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "numberArray": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t2);
                  const n2 = Pe2.parse(e2);
                  if (n2) return n2;
                }
                throw new Ve2(`Could not parse numberArray from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "colorArray": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t2);
                  const n2 = Be2.parse(e2);
                  if (n2) return n2;
                }
                throw new Ve2(`Could not parse colorArray from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t2);
                  const n2 = Le2.parse(e2);
                  if (n2) return n2;
                }
                throw new Ve2(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "number": {
                let e2 = null;
                for (const r2 of this.args) {
                  if (e2 = r2.evaluate(t2), null === e2) return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2)) return n2;
                }
                throw new Ve2(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              case "formatted":
                return De2.fromString(qe2(this.args[0].evaluate(t2)));
              case "resolvedImage":
                return Oe2.fromString(qe2(this.args[0].evaluate(t2)));
              case "projectionDefinition":
                return this.args[0].evaluate(t2);
              default:
                return qe2(this.args[0].evaluate(t2));
            }
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every(((t2) => t2.outputDefined()));
          }
        }
        const He2 = ["Unknown", "Point", "LineString", "Polygon"];
        class Ke2 {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? He2[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t2) {
            let e2 = this._parseColorCache.get(t2);
            return e2 || (e2 = Te2.parse(t2), this._parseColorCache.set(t2, e2)), e2;
          }
        }
        class We {
          constructor(t2, e2, r2 = [], n2, i2 = new Bt2(), s2 = []) {
            this.registry = t2, this.path = r2, this.key = r2.map(((t3) => `[${t3}]`)).join(""), this.scope = i2, this.errors = s2, this.expectedType = n2, this._isConstant = e2;
          }
          parse(t2, e2, r2, n2, i2 = {}) {
            return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
          }
          _parse(t2, e2) {
            function r2(t3, e3, r3) {
              return "assert" === r3 ? new Xe2(e3, [t3]) : "coerce" === r3 ? new Ze2(e3, [t3]) : t3;
            }
            if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (0 === t2.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n2 = t2[0];
              if ("string" != typeof n2) return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i2 = this.registry[n2];
              if (i2) {
                let n3 = i2.parse(t2, this);
                if (!n3) return null;
                if (this.expectedType) {
                  const t3 = this.expectedType, i3 = n3.type;
                  if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind) {
                    if ("projectionDefinition" === t3.kind && ["string", "array"].includes(i3.kind) || ["color", "formatted", "resolvedImage"].includes(t3.kind) && ["value", "string"].includes(i3.kind) || ["padding", "numberArray"].includes(t3.kind) && ["value", "number", "array"].includes(i3.kind) || "colorArray" === t3.kind && ["value", "string", "array"].includes(i3.kind) || "variableAnchorOffsetCollection" === t3.kind && ["value", "array"].includes(i3.kind)) n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                    else if (this.checkSubtype(t3, i3)) return null;
                  } else n3 = r2(n3, t3, e2.typeAnnotation || "assert");
                }
                if (!(n3 instanceof je2) && "resolvedImage" !== n3.type.kind && this._isConstant(n3)) {
                  const t3 = new Ke2();
                  try {
                    n3 = new je2(n3.type, n3.evaluate(t3));
                  } catch (t4) {
                    return this.error(t4.message), null;
                  }
                }
                return n3;
              }
              return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
          }
          concat(t2, e2, r2) {
            const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
            return new We(this.registry, this._isConstant, n2, e2 || null, i2, this.errors);
          }
          error(t2, ...e2) {
            const r2 = `${this.key}${e2.map(((t3) => `[${t3}]`)).join("")}`;
            this.errors.push(new Pt2(r2, t2));
          }
          checkSubtype(t2, e2) {
            const r2 = Qt2(t2, e2);
            return r2 && this.error(r2), r2;
          }
        }
        class Je {
          constructor(t2, e2) {
            this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
          }
          evaluate(t2) {
            return this.result.evaluate(t2);
          }
          eachChild(t2) {
            for (const e2 of this.bindings) t2(e2[1]);
            t2(this.result);
          }
          static parse(t2, e2) {
            if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
            const r2 = [];
            for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
              const i2 = t2[n3];
              if ("string" != typeof i2) return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
              if (/[^a-zA-Z0-9_]/.test(i2)) return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              const s2 = e2.parse(t2[n3 + 1], n3 + 1);
              if (!s2) return null;
              r2.push([i2, s2]);
            }
            const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
            return n2 ? new Je(r2, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Qe2 {
          constructor(t2, e2) {
            this.type = e2.type, this.name = t2, this.boundExpression = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length || "string" != typeof t2[1]) return e2.error("'var' expression requires exactly one string literal argument.");
            const r2 = t2[1];
            return e2.scope.has(r2) ? new Qe2(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t2) {
            return this.boundExpression.evaluate(t2);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class tr2 {
          constructor(t2, e2, r2) {
            this.type = t2, this.index = e2, this.input = r2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, Ct2), n2 = e2.parse(t2[2], 2, Kt2(e2.expectedType || Ut2));
            return r2 && n2 ? new tr2(n2.type.itemType, r2, n2) : null;
          }
          evaluate(t2) {
            const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e2 < 0) throw new Ve2(`Array index out of bounds: ${e2} < 0.`);
            if (e2 >= r2.length) throw new Ve2(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
            if (e2 !== Math.floor(e2)) throw new Ve2(`Array index must be an integer, but found ${e2} instead.`);
            return r2[e2];
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class er2 {
          constructor(t2, e2) {
            this.type = Ot2, this.needle = t2, this.haystack = e2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, Ut2), n2 = e2.parse(t2[2], 2, Ut2);
            return r2 && n2 ? te2(r2.type, [Ot2, Lt2, Ct2, Vt2, Ut2]) ? new er2(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Wt2(r2.type)} instead`) : null;
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!r2) return false;
            if (!ee2(e2, ["boolean", "string", "number", "null"])) throw new Ve2(`Expected first argument to be of type boolean, string, number or null, but found ${Wt2(Ue2(e2))} instead.`);
            if (!ee2(r2, ["string", "array"])) throw new Ve2(`Expected second argument to be of type array or string, but found ${Wt2(Ue2(r2))} instead.`);
            return r2.indexOf(e2) >= 0;
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class rr2 {
          constructor(t2, e2, r2) {
            this.type = Ct2, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 2 or 3 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, Ut2), n2 = e2.parse(t2[2], 2, Ut2);
            if (!r2 || !n2) return null;
            if (!te2(r2.type, [Ot2, Lt2, Ct2, Vt2, Ut2])) return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Wt2(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, Ct2);
              return i2 ? new rr2(r2, n2, i2) : null;
            }
            return new rr2(r2, n2);
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!ee2(e2, ["boolean", "string", "number", "null"])) throw new Ve2(`Expected first argument to be of type boolean, string, number or null, but found ${Wt2(Ue2(e2))} instead.`);
            let n2;
            if (this.fromIndex && (n2 = this.fromIndex.evaluate(t2)), ee2(r2, ["string"])) {
              const t3 = r2.indexOf(e2, n2);
              return -1 === t3 ? -1 : [...r2.slice(0, t3)].length;
            }
            if (ee2(r2, ["array"])) return r2.indexOf(e2, n2);
            throw new Ve2(`Expected second argument to be of type array or string, but found ${Wt2(Ue2(r2))} instead.`);
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class nr2 {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
          }
          static parse(t2, e2) {
            if (t2.length < 5) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 1) return e2.error("Expected an even number of arguments.");
            let r2, n2;
            e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
            const i2 = {}, s2 = [];
            for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
              let o3 = t2[a3];
              const l2 = t2[a3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u2 = e2.concat(a3);
              if (0 === o3.length) return u2.error("Expected at least one branch label.");
              for (const t3 of o3) {
                if ("number" != typeof t3 && "string" != typeof t3) return u2.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER) return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t3 && Math.floor(t3) !== t3) return u2.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (u2.checkSubtype(r2, Ue2(t3))) return null;
                } else r2 = Ue2(t3);
                if (void 0 !== i2[String(t3)]) return u2.error("Branch labels must be unique.");
                i2[String(t3)] = s2.length;
              }
              const c2 = e2.parse(l2, a3, n2);
              if (!c2) return null;
              n2 = n2 || c2.type, s2.push(c2);
            }
            const a2 = e2.parse(t2[1], 1, Ut2);
            if (!a2) return null;
            const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
            return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new nr2(r2, n2, a2, i2, s2, o2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            return (Ue2(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((t2) => t2.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class ir2 {
          constructor(t2, e2, r2) {
            this.type = t2, this.branches = e2, this.otherwise = r2;
          }
          static parse(t2, e2) {
            if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 0) return e2.error("Expected an odd number of arguments.");
            let r2;
            e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
            const n2 = [];
            for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
              const s2 = e2.parse(t2[i3], i3, Ot2);
              if (!s2) return null;
              const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
              if (!a2) return null;
              n2.push([s2, a2]), r2 = r2 || a2.type;
            }
            const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
            if (!i2) return null;
            if (!r2) throw new Error("Can't infer output type");
            return new ir2(r2, n2, i2);
          }
          evaluate(t2) {
            for (const [e2, r2] of this.branches) if (e2.evaluate(t2)) return r2.evaluate(t2);
            return this.otherwise.evaluate(t2);
          }
          eachChild(t2) {
            for (const [e2, r2] of this.branches) t2(e2), t2(r2);
            t2(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([t2, e2]) => e2.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class sr2 {
          constructor(t2, e2, r2, n2) {
            this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 2 or 3 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, Ut2), n2 = e2.parse(t2[2], 2, Ct2);
            if (!r2 || !n2) return null;
            if (!te2(r2.type, [Kt2(Ut2), Lt2, Ut2])) return e2.error(`Expected first argument to be of type array or string, but found ${Wt2(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, Ct2);
              return i2 ? new sr2(r2.type, r2, n2, i2) : null;
            }
            return new sr2(r2.type, r2, n2);
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
            let n2;
            if (this.endIndex && (n2 = this.endIndex.evaluate(t2)), ee2(e2, ["string"])) return [...e2].slice(r2, n2).join("");
            if (ee2(e2, ["array"])) return e2.slice(r2, n2);
            throw new Ve2(`Expected first argument to be of type array or string, but found ${Wt2(Ue2(e2))} instead.`);
          }
          eachChild(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function ar2(t2, e2) {
          const r2 = t2.length - 1;
          let n2, i2, s2 = 0, a2 = r2, o2 = 0;
          for (; s2 <= a2; ) if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r2 || e2 < i2) return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2)) throw new Ve2("Input is not a number.");
            a2 = o2 - 1;
          }
          return 0;
        }
        class or2 {
          constructor(t2, e2, r2) {
            this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of r2) this.labels.push(t3), this.outputs.push(e3);
          }
          static parse(t2, e2) {
            if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            const r2 = e2.parse(t2[1], 1, Ct2);
            if (!r2) return null;
            const n2 = [];
            let i2 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
            for (let r3 = 1; r3 < t2.length; r3 += 2) {
              const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
              if ("number" != typeof s2) return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= s2) return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u2 = e2.parse(a2, l2, i2);
              if (!u2) return null;
              i2 = i2 || u2.type, n2.push([s2, u2]);
            }
            return new or2(i2, r2, n2);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length) return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0]) return r2[0].evaluate(t2);
            const i2 = e2.length;
            return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[ar2(e2, n2)].evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs) t2(e2);
          }
          outputDefined() {
            return this.outputs.every(((t2) => t2.outputDefined()));
          }
        }
        function lr2(t2) {
          return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        var ur2, cr2, hr2 = (function() {
          if (cr2) return ur2;
          function t2(t3, e2, r2, n2) {
            this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
          }
          return cr2 = 1, ur2 = t2, t2.prototype = { sampleCurveX: function(t3) {
            return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
          }, sampleCurveY: function(t3) {
            return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
          }, sampleCurveDerivativeX: function(t3) {
            return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
          }, solveCurveX: function(t3, e2) {
            if (void 0 === e2 && (e2 = 1e-6), t3 < 0) return 0;
            if (t3 > 1) return 1;
            for (var r2 = t3, n2 = 0; n2 < 8; n2++) {
              var i2 = this.sampleCurveX(r2) - t3;
              if (Math.abs(i2) < e2) return r2;
              var s2 = this.sampleCurveDerivativeX(r2);
              if (Math.abs(s2) < 1e-6) break;
              r2 -= i2 / s2;
            }
            var a2 = 0, o2 = 1;
            for (r2 = t3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++) t3 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
            return r2;
          }, solve: function(t3, e2) {
            return this.sampleCurveY(this.solveCurveX(t3, e2));
          } }, ur2;
        })(), pr2 = lr2(hr2);
        class fr2 {
          constructor(t2, e2, r2, n2, i2) {
            this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of i2) this.labels.push(t3), this.outputs.push(e3);
          }
          static interpolationFactor(t2, e2, r2, n2) {
            let i2 = 0;
            if ("exponential" === t2.name) i2 = dr2(e2, t2.base, r2, n2);
            else if ("linear" === t2.name) i2 = dr2(e2, 1, r2, n2);
            else if ("cubic-bezier" === t2.name) {
              const s2 = t2.controlPoints;
              i2 = new pr2(s2[0], s2[1], s2[2], s2[3]).solve(dr2(e2, 1, r2, n2));
            }
            return i2;
          }
          static parse(t2, e2) {
            let [r2, n2, i2, ...s2] = t2;
            if (!Array.isArray(n2) || 0 === n2.length) return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n2[0]) n2 = { name: "linear" };
            else if ("exponential" === n2[0]) {
              const t3 = n2[1];
              if ("number" != typeof t3) return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t3 };
            } else {
              if ("cubic-bezier" !== n2[0]) return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
              {
                const t3 = n2.slice(1);
                if (4 !== t3.length || t3.some(((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))) return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t3 };
              }
            }
            if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            if (i2 = e2.parse(i2, 2, Ct2), !i2) return null;
            const a2 = [];
            let o2 = null;
            "interpolate-hcl" !== r2 && "interpolate-lab" !== r2 || e2.expectedType == Xt2 ? e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType) : o2 = Rt2;
            for (let t3 = 0; t3 < s2.length; t3 += 2) {
              const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
              if ("number" != typeof r3) return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
              if (a2.length && a2[a2.length - 1][0] >= r3) return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
              const u2 = e2.parse(n3, l2, o2);
              if (!u2) return null;
              o2 = o2 || u2.type, a2.push([r3, u2]);
            }
            return re2(o2, Ct2) || re2(o2, Nt2) || re2(o2, Rt2) || re2(o2, Gt2) || re2(o2, Yt2) || re2(o2, Xt2) || re2(o2, Ht2) || re2(o2, Kt2(Ct2)) ? new fr2(o2, r2, n2, i2, a2) : e2.error(`Type ${Wt2(o2)} is not interpolatable.`);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length) return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0]) return r2[0].evaluate(t2);
            const i2 = e2.length;
            if (n2 >= e2[i2 - 1]) return r2[i2 - 1].evaluate(t2);
            const s2 = ar2(e2, n2), a2 = fr2.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return ke2(o2, l2, a2);
                  case "color":
                    return Te2.interpolate(o2, l2, a2);
                  case "padding":
                    return ze2.interpolate(o2, l2, a2);
                  case "colorArray":
                    return Be2.interpolate(o2, l2, a2);
                  case "numberArray":
                    return Pe2.interpolate(o2, l2, a2);
                  case "variableAnchorOffsetCollection":
                    return Le2.interpolate(o2, l2, a2);
                  case "array":
                    return Ee2(o2, l2, a2);
                  case "projectionDefinition":
                    return Re2.interpolate(o2, l2, a2);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return Te2.interpolate(o2, l2, a2, "hcl");
                  case "colorArray":
                    return Be2.interpolate(o2, l2, a2, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return Te2.interpolate(o2, l2, a2, "lab");
                  case "colorArray":
                    return Be2.interpolate(o2, l2, a2, "lab");
                }
            }
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs) t2(e2);
          }
          outputDefined() {
            return this.outputs.every(((t2) => t2.outputDefined()));
          }
        }
        function dr2(t2, e2, r2, n2) {
          const i2 = n2 - r2, s2 = t2 - r2;
          return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
        }
        const yr2 = { color: Te2.interpolate, number: ke2, padding: ze2.interpolate, numberArray: Pe2.interpolate, colorArray: Be2.interpolate, variableAnchorOffsetCollection: Le2.interpolate, array: Ee2 };
        class mr2 {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            let r2 = null;
            const n2 = e2.expectedType;
            n2 && "value" !== n2.kind && (r2 = n2);
            const i2 = [];
            for (const n3 of t2.slice(1)) {
              const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
              if (!t3) return null;
              r2 = r2 || t3.type, i2.push(t3);
            }
            if (!r2) throw new Error("No output type");
            const s2 = n2 && i2.some(((t3) => Qt2(n2, t3.type)));
            return new mr2(s2 ? Ut2 : r2, i2);
          }
          evaluate(t2) {
            let e2, r2 = null, n2 = 0;
            for (const i2 of this.args) if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Oe2 && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null !== r2) break;
            return r2;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every(((t2) => t2.outputDefined()));
          }
        }
        function gr2(t2, e2) {
          return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function xr(t2, e2, r2, n2) {
          return 0 === n2.compare(e2, r2);
        }
        function vr2(t2, e2, r2) {
          const n2 = "==" !== t2 && "!=" !== t2;
          return class i2 {
            constructor(t3, e3, r3) {
              this.type = Ot2, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
            }
            static parse(t3, e3) {
              if (3 !== t3.length && 4 !== t3.length) return e3.error("Expected two or three arguments.");
              const r3 = t3[0];
              let s2 = e3.parse(t3[1], 1, Ut2);
              if (!s2) return null;
              if (!gr2(r3, s2.type)) return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${Wt2(s2.type)}'.`);
              let a2 = e3.parse(t3[2], 2, Ut2);
              if (!a2) return null;
              if (!gr2(r3, a2.type)) return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${Wt2(a2.type)}'.`);
              if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error(`Cannot compare types '${Wt2(s2.type)}' and '${Wt2(a2.type)}'.`);
              n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new Xe2(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new Xe2(s2.type, [a2])));
              let o2 = null;
              if (4 === t3.length) {
                if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error("Cannot use collator to compare non-string types.");
                if (o2 = e3.parse(t3[3], 3, qt2), !o2) return null;
              }
              return new i2(s2, a2, o2);
            }
            evaluate(i3) {
              const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
              if (n2 && this.hasUntypedArgument) {
                const e3 = Ue2(s2), r3 = Ue2(a2);
                if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind) throw new Ve2(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                const t3 = Ue2(s2), r3 = Ue2(a2);
                if ("string" !== t3.kind || "string" !== r3.kind) return e2(i3, s2, a2);
              }
              return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
            }
            eachChild(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const br2 = vr2("==", (function(t2, e2, r2) {
          return e2 === r2;
        }), xr), wr2 = vr2("!=", (function(t2, e2, r2) {
          return e2 !== r2;
        }), (function(t2, e2, r2, n2) {
          return !xr(0, e2, r2, n2);
        })), _r2 = vr2("<", (function(t2, e2, r2) {
          return e2 < r2;
        }), (function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) < 0;
        })), Sr2 = vr2(">", (function(t2, e2, r2) {
          return e2 > r2;
        }), (function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) > 0;
        })), Ar2 = vr2("<=", (function(t2, e2, r2) {
          return e2 <= r2;
        }), (function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) <= 0;
        })), kr = vr2(">=", (function(t2, e2, r2) {
          return e2 >= r2;
        }), (function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) >= 0;
        }));
        class Er2 {
          constructor(t2, e2, r2) {
            this.type = qt2, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("Expected one argument.");
            const r2 = t2[1];
            if ("object" != typeof r2 || Array.isArray(r2)) return e2.error("Collator options argument must be an object.");
            const n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, Ot2);
            if (!n2) return null;
            const i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, Ot2);
            if (!i2) return null;
            let s2 = null;
            return r2.locale && (s2 = e2.parse(r2.locale, 1, Lt2), !s2) ? null : new Er2(n2, i2, s2);
          }
          evaluate(t2) {
            return new Ie2(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }
          eachChild(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class Tr2 {
          constructor(t2, e2, r2, n2, i2) {
            this.type = Lt2, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, Ct2);
            if (!r2) return null;
            const n2 = t2[2];
            if ("object" != typeof n2 || Array.isArray(n2)) return e2.error("NumberFormat options argument must be an object.");
            let i2 = null;
            if (n2.locale && (i2 = e2.parse(n2.locale, 1, Lt2), !i2)) return null;
            let s2 = null;
            if (n2.currency && (s2 = e2.parse(n2.currency, 1, Lt2), !s2)) return null;
            let a2 = null;
            if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, Ct2), !a2)) return null;
            let o2 = null;
            return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, Ct2), !o2) ? null : new Tr2(r2, i2, s2, a2, o2);
          }
          evaluate(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }
          eachChild(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class Ir2 {
          constructor(t2) {
            this.type = jt2, this.sections = t2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            const r2 = t2[1];
            if (!Array.isArray(r2) && "object" == typeof r2) return e2.error("First argument must be an image or text section.");
            const n2 = [];
            let i2 = false;
            for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
              const s2 = t2[r3];
              if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                i2 = false;
                let t3 = null;
                if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, Ct2), !t3)) return null;
                let r4 = null;
                if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, Kt2(Lt2)), !r4)) return null;
                let a2 = null;
                if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, Rt2), !a2)) return null;
                let o2 = null;
                if (s2["vertical-align"]) {
                  if ("string" == typeof s2["vertical-align"] && !Me2.includes(s2["vertical-align"])) return e2.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s2["vertical-align"]}' instead.`);
                  if (o2 = e2.parse(s2["vertical-align"], 1, Lt2), !o2) return null;
                }
                const l2 = n2[n2.length - 1];
                l2.scale = t3, l2.font = r4, l2.textColor = a2, l2.verticalAlign = o2;
              } else {
                const s3 = e2.parse(t2[r3], 1, Ut2);
                if (!s3) return null;
                const a2 = s3.type.kind;
                if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2) return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Ir2(n2);
          }
          evaluate(t2) {
            return new De2(this.sections.map(((e2) => {
              const r2 = e2.content.evaluate(t2);
              return Ue2(r2) === Zt2 ? new Fe2("", r2, null, null, null, e2.verticalAlign ? e2.verticalAlign.evaluate(t2) : null) : new Fe2(qe2(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null, e2.verticalAlign ? e2.verticalAlign.evaluate(t2) : null);
            })));
          }
          eachChild(t2) {
            for (const e2 of this.sections) t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor), e2.verticalAlign && t2(e2.verticalAlign);
          }
          outputDefined() {
            return false;
          }
        }
        class Mr2 {
          constructor(t2) {
            this.type = Zt2, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, Lt2);
            return r2 ? new Mr2(r2) : e2.error("No image name provided.");
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = Oe2.fromString(e2);
            return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Fr2 {
          constructor(t2) {
            this.type = Ct2, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1);
            return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${Wt2(r2.type)} instead.`) : new Fr2(r2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            if ("string" == typeof e2) return [...e2].length;
            if (Array.isArray(e2)) return e2.length;
            throw new Ve2(`Expected value to be of type string or array, but found ${Wt2(Ue2(e2))} instead.`);
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const Dr2 = 8192;
        function zr2(t2, e2) {
          const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
          return [Math.round(r2 * i2 * Dr2), Math.round(n2 * i2 * Dr2)];
        }
        function Pr2(t2, e2) {
          const r2 = Math.pow(2, e2.z);
          return [(i2 = (t2[0] / Dr2 + e2.x) / r2, 360 * i2 - 180), (n2 = (t2[1] / Dr2 + e2.y) / r2, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n2) * Math.PI / 180)) - 90)];
          var n2, i2;
        }
        function Br2(t2, e2) {
          t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
        }
        function Vr2(t2, e2) {
          return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
        }
        function Cr2(t2, e2, r2) {
          const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
          return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
        }
        function Lr2(t2, e2, r2, n2) {
          return 0 != (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] && !(!qr2(t2, e2, r2, n2) || !qr2(r2, n2, t2, e2));
          var i2, s2;
        }
        function Or2(t2, e2, r2) {
          for (const n2 of r2) for (let r3 = 0; r3 < n2.length - 1; ++r3) if (Lr2(t2, e2, n2[r3], n2[r3 + 1])) return true;
          return false;
        }
        function Rr2(t2, e2, r2 = false) {
          let n2 = false;
          for (const o2 of e2) for (let e3 = 0; e3 < o2.length - 1; e3++) {
            if (Cr2(t2, o2[e3], o2[e3 + 1])) return r2;
            (s2 = o2[e3])[1] > (i2 = t2)[1] != (a2 = o2[e3 + 1])[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n2 = !n2);
          }
          var i2, s2, a2;
          return n2;
        }
        function Nr2(t2, e2) {
          for (const r2 of e2) if (Rr2(t2, r2)) return true;
          return false;
        }
        function $r2(t2, e2) {
          for (const r2 of t2) if (!Rr2(r2, e2)) return false;
          for (let r2 = 0; r2 < t2.length - 1; ++r2) if (Or2(t2[r2], t2[r2 + 1], e2)) return false;
          return true;
        }
        function Ur2(t2, e2) {
          for (const r2 of e2) if ($r2(t2, r2)) return true;
          return false;
        }
        function qr2(t2, e2, r2, n2) {
          const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
          return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function jr2(t2, e2, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = [];
            for (let n3 = 0; n3 < t2[i2].length; n3++) {
              const a2 = zr2(t2[i2][n3], r2);
              Br2(e2, a2), s2.push(a2);
            }
            n2.push(s2);
          }
          return n2;
        }
        function Gr2(t2, e2, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = jr2(t2[i2], e2, r2);
            n2.push(s2);
          }
          return n2;
        }
        function Xr2(t2, e2, r2, n2) {
          if (t2[0] < r2[0] || t2[0] > r2[2]) {
            const e3 = 0.5 * n2;
            let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
            0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
          }
          Br2(e2, t2);
        }
        function Yr2(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z) * Dr2, s2 = [n2.x * Dr2, n2.y * Dr2], a2 = [];
          for (const n3 of t2) for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            Xr2(n4, e2, r2, i2), a2.push(n4);
          }
          return a2;
        }
        function Zr2(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z) * Dr2, s2 = [n2.x * Dr2, n2.y * Dr2], a2 = [];
          for (const r3 of t2) {
            const t3 = [];
            for (const n3 of r3) {
              const r4 = [n3.x + s2[0], n3.y + s2[1]];
              Br2(e2, r4), t3.push(r4);
            }
            a2.push(t3);
          }
          if (e2[2] - e2[0] <= i2 / 2) {
            (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t3 of a2) for (const n3 of t3) Xr2(n3, e2, r2, i2);
          }
          var o2;
          return a2;
        }
        class Hr2 {
          constructor(t2, e2) {
            this.type = Ot2, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if ($e2(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type) {
                const t3 = [];
                for (const r2 of e3.features) {
                  const { type: e4, coordinates: n2 } = r2.geometry;
                  "Polygon" === e4 && t3.push(n2), "MultiPolygon" === e4 && t3.push(...n2);
                }
                if (t3.length) return new Hr2(e3, { type: "MultiPolygon", coordinates: t3 });
              } else if ("Feature" === e3.type) {
                const t3 = e3.geometry.type;
                if ("Polygon" === t3 || "MultiPolygon" === t3) return new Hr2(e3, e3.geometry);
              } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new Hr2(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType()) return (function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if ("Polygon" === e2.type) {
                  const s2 = jr2(e2.coordinates, n2, i2), a2 = Yr2(t3.geometry(), r2, n2, i2);
                  if (!Vr2(r2, n2)) return false;
                  for (const t4 of a2) if (!Rr2(t4, s2)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = Gr2(e2.coordinates, n2, i2), a2 = Yr2(t3.geometry(), r2, n2, i2);
                  if (!Vr2(r2, n2)) return false;
                  for (const t4 of a2) if (!Nr2(t4, s2)) return false;
                }
                return true;
              })(t2, this.geometries);
              if ("LineString" === t2.geometryType()) return (function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if ("Polygon" === e2.type) {
                  const s2 = jr2(e2.coordinates, n2, i2), a2 = Zr2(t3.geometry(), r2, n2, i2);
                  if (!Vr2(r2, n2)) return false;
                  for (const t4 of a2) if (!$r2(t4, s2)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = Gr2(e2.coordinates, n2, i2), a2 = Zr2(t3.geometry(), r2, n2, i2);
                  if (!Vr2(r2, n2)) return false;
                  for (const t4 of a2) if (!Ur2(t4, s2)) return false;
                }
                return true;
              })(t2, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let Kr2 = class {
          constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this._up(this.length++);
          }
          pop() {
            if (0 === this.length) return;
            const t2 = this.data[0], e2 = this.data.pop();
            return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e2, compare: r2 } = this, n2 = e2[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s2 = e2[i2];
              if (r2(n2, s2) >= 0) break;
              e2[t2] = s2, t2 = i2;
            }
            e2[t2] = n2;
          }
          _down(t2) {
            const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1);
              const s2 = n3 + 1;
              if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0) break;
              e2[t2] = e2[n3], t2 = n3;
            }
            e2[t2] = i2;
          }
        };
        function Wr2(t2, e2, r2 = 0, n2 = t2.length - 1, i2 = Qr2) {
          for (; n2 > r2; ) {
            if (n2 - r2 > 600) {
              const s3 = n2 - r2 + 1, a3 = e2 - r2 + 1, o3 = Math.log(s3), l2 = 0.5 * Math.exp(2 * o3 / 3), u2 = 0.5 * Math.sqrt(o3 * l2 * (s3 - l2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
              Wr2(t2, e2, Math.max(r2, Math.floor(e2 - a3 * l2 / s3 + u2)), Math.min(n2, Math.floor(e2 + (s3 - a3) * l2 / s3 + u2)), i2);
            }
            const s2 = t2[e2];
            let a2 = r2, o2 = n2;
            for (Jr2(t2, r2, e2), i2(t2[n2], s2) > 0 && Jr2(t2, r2, n2); a2 < o2; ) {
              for (Jr2(t2, a2, o2), a2++, o2--; i2(t2[a2], s2) < 0; ) a2++;
              for (; i2(t2[o2], s2) > 0; ) o2--;
            }
            0 === i2(t2[r2], s2) ? Jr2(t2, r2, o2) : (o2++, Jr2(t2, o2, n2)), o2 <= e2 && (r2 = o2 + 1), e2 <= o2 && (n2 = o2 - 1);
          }
        }
        function Jr2(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function Qr2(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function tn2(t2, e2) {
          if (t2.length <= 1) return [t2];
          const r2 = [];
          let n2, i2;
          for (const e3 of t2) {
            const t3 = rn2(e3);
            0 !== t3 && (e3.area = Math.abs(t3), void 0 === i2 && (i2 = t3 < 0), i2 === t3 < 0 ? (n2 && r2.push(n2), n2 = [e3]) : n2.push(e3));
          }
          if (n2 && r2.push(n2), e2 > 1) for (let t3 = 0; t3 < r2.length; t3++) r2[t3].length <= e2 || (Wr2(r2[t3], e2, 1, r2[t3].length - 1, en2), r2[t3] = r2[t3].slice(0, e2));
          return r2;
        }
        function en2(t2, e2) {
          return e2.area - t2.area;
        }
        function rn2(t2) {
          let e2 = 0;
          for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        const nn2 = 1 / 298.257223563, sn2 = nn2 * (2 - nn2), an2 = Math.PI / 180;
        class on2 {
          constructor(t2) {
            const e2 = 6378.137 * an2 * 1e3, r2 = Math.cos(t2 * an2), n2 = 1 / (1 - sn2 * (1 - r2 * r2)), i2 = Math.sqrt(n2);
            this.kx = e2 * i2 * r2, this.ky = e2 * i2 * n2 * (1 - sn2);
          }
          distance(t2, e2) {
            const r2 = this.wrap(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
            return Math.sqrt(r2 * r2 + n2 * n2);
          }
          pointOnLine(t2, e2) {
            let r2, n2, i2, s2, a2 = 1 / 0;
            for (let o2 = 0; o2 < t2.length - 1; o2++) {
              let l2 = t2[o2][0], u2 = t2[o2][1], c2 = this.wrap(t2[o2 + 1][0] - l2) * this.kx, h2 = (t2[o2 + 1][1] - u2) * this.ky, p2 = 0;
              0 === c2 && 0 === h2 || (p2 = (this.wrap(e2[0] - l2) * this.kx * c2 + (e2[1] - u2) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l2 = t2[o2 + 1][0], u2 = t2[o2 + 1][1]) : p2 > 0 && (l2 += c2 / this.kx * p2, u2 += h2 / this.ky * p2)), c2 = this.wrap(e2[0] - l2) * this.kx, h2 = (e2[1] - u2) * this.ky;
              const f3 = c2 * c2 + h2 * h2;
              f3 < a2 && (a2 = f3, r2 = l2, n2 = u2, i2 = o2, s2 = p2);
            }
            return { point: [r2, n2], index: i2, t: Math.max(0, Math.min(1, s2)) };
          }
          wrap(t2) {
            for (; t2 < -180; ) t2 += 360;
            for (; t2 > 180; ) t2 -= 360;
            return t2;
          }
        }
        function ln2(t2, e2) {
          return e2[0] - t2[0];
        }
        function un2(t2) {
          return t2[1] - t2[0] + 1;
        }
        function cn2(t2, e2) {
          return t2[1] >= t2[0] && t2[1] < e2;
        }
        function hn2(t2, e2) {
          if (t2[0] > t2[1]) return [null, null];
          const r2 = un2(t2);
          if (e2) {
            if (2 === r2) return [t2, null];
            const e3 = Math.floor(r2 / 2);
            return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
          }
          if (1 === r2) return [t2, null];
          const n2 = Math.floor(r2 / 2) - 1;
          return [[t2[0], t2[0] + n2], [t2[0] + n2 + 1, t2[1]]];
        }
        function pn2(t2, e2) {
          if (!cn2(e2, t2.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let n2 = e2[0]; n2 <= e2[1]; ++n2) Br2(r2, t2[n2]);
          return r2;
        }
        function fn2(t2) {
          const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r2 of t2) for (const t3 of r2) Br2(e2, t3);
          return e2;
        }
        function dn2(t2) {
          return t2[0] !== -1 / 0 && t2[1] !== -1 / 0 && t2[2] !== 1 / 0 && t2[3] !== 1 / 0;
        }
        function yn2(t2, e2, r2) {
          if (!dn2(t2) || !dn2(e2)) return NaN;
          let n2 = 0, i2 = 0;
          return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
        }
        function mn2(t2, e2, r2) {
          const n2 = r2.pointOnLine(e2, t2);
          return r2.distance(t2, n2.point);
        }
        function gn2(t2, e2, r2, n2, i2) {
          const s2 = Math.min(mn2(t2, [r2, n2], i2), mn2(e2, [r2, n2], i2)), a2 = Math.min(mn2(r2, [t2, e2], i2), mn2(n2, [t2, e2], i2));
          return Math.min(s2, a2);
        }
        function xn2(t2, e2, r2, n2, i2) {
          if (!cn2(e2, t2.length) || !cn2(n2, r2.length)) return 1 / 0;
          let s2 = 1 / 0;
          for (let a2 = e2[0]; a2 < e2[1]; ++a2) {
            const e3 = t2[a2], o2 = t2[a2 + 1];
            for (let t3 = n2[0]; t3 < n2[1]; ++t3) {
              const n3 = r2[t3], a3 = r2[t3 + 1];
              if (Lr2(e3, o2, n3, a3)) return 0;
              s2 = Math.min(s2, gn2(e3, o2, n3, a3, i2));
            }
          }
          return s2;
        }
        function vn2(t2, e2, r2, n2, i2) {
          if (!cn2(e2, t2.length) || !cn2(n2, r2.length)) return NaN;
          let s2 = 1 / 0;
          for (let a2 = e2[0]; a2 <= e2[1]; ++a2) for (let e3 = n2[0]; e3 <= n2[1]; ++e3) if (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3])), 0 === s2) return s2;
          return s2;
        }
        function bn2(t2, e2, r2) {
          if (Rr2(t2, e2, true)) return 0;
          let n2 = 1 / 0;
          for (const i2 of e2) {
            const e3 = i2[0], s2 = i2[i2.length - 1];
            if (e3 !== s2 && (n2 = Math.min(n2, mn2(t2, [s2, e3], r2)), 0 === n2)) return n2;
            const a2 = r2.pointOnLine(i2, t2);
            if (n2 = Math.min(n2, r2.distance(t2, a2.point)), 0 === n2) return n2;
          }
          return n2;
        }
        function wn2(t2, e2, r2, n2) {
          if (!cn2(e2, t2.length)) return NaN;
          for (let n3 = e2[0]; n3 <= e2[1]; ++n3) if (Rr2(t2[n3], r2, true)) return 0;
          let i2 = 1 / 0;
          for (let s2 = e2[0]; s2 < e2[1]; ++s2) {
            const e3 = t2[s2], a2 = t2[s2 + 1];
            for (const t3 of r2) for (let r3 = 0, s3 = t3.length, o2 = s3 - 1; r3 < s3; o2 = r3++) {
              const s4 = t3[o2], l2 = t3[r3];
              if (Lr2(e3, a2, s4, l2)) return 0;
              i2 = Math.min(i2, gn2(e3, a2, s4, l2, n2));
            }
          }
          return i2;
        }
        function _n2(t2, e2) {
          for (const r2 of t2) for (const t3 of r2) if (Rr2(t3, e2, true)) return true;
          return false;
        }
        function Sn2(t2, e2, r2, n2 = 1 / 0) {
          const i2 = fn2(t2), s2 = fn2(e2);
          if (n2 !== 1 / 0 && yn2(i2, s2, r2) >= n2) return n2;
          if (Vr2(i2, s2)) {
            if (_n2(t2, e2)) return 0;
          } else if (_n2(e2, t2)) return 0;
          let a2 = 1 / 0;
          for (const n3 of t2) for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++) {
            const i4 = n3[s3], o2 = n3[t3];
            for (const t4 of e2) for (let e3 = 0, n4 = t4.length, s4 = n4 - 1; e3 < n4; s4 = e3++) {
              const n5 = t4[s4], l2 = t4[e3];
              if (Lr2(i4, o2, n5, l2)) return 0;
              a2 = Math.min(a2, gn2(i4, o2, n5, l2, r2));
            }
          }
          return a2;
        }
        function An2(t2, e2, r2, n2, i2, s2) {
          if (!s2) return;
          const a2 = yn2(pn2(n2, s2), i2, r2);
          a2 < e2 && t2.push([a2, s2, [0, 0]]);
        }
        function kn2(t2, e2, r2, n2, i2, s2, a2) {
          if (!s2 || !a2) return;
          const o2 = yn2(pn2(n2, s2), pn2(i2, a2), r2);
          o2 < e2 && t2.push([o2, s2, a2]);
        }
        function En2(t2, e2, r2, n2, i2 = 1 / 0) {
          let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
          if (0 === s2) return s2;
          const a2 = new Kr2([[0, [0, t2.length - 1], [0, 0]]], ln2), o2 = fn2(r2);
          for (; a2.length > 0; ) {
            const i3 = a2.pop();
            if (i3[0] >= s2) continue;
            const l2 = i3[1], u2 = e2 ? 50 : 100;
            if (un2(l2) <= u2) {
              if (!cn2(l2, t2.length)) return NaN;
              if (e2) {
                const e3 = wn2(t2, l2, r2, n2);
                if (isNaN(e3) || 0 === e3) return e3;
                s2 = Math.min(s2, e3);
              } else for (let e3 = l2[0]; e3 <= l2[1]; ++e3) {
                const i4 = bn2(t2[e3], r2, n2);
                if (s2 = Math.min(s2, i4), 0 === s2) return 0;
              }
            } else {
              const r3 = hn2(l2, e2);
              An2(a2, s2, n2, t2, o2, r3[0]), An2(a2, s2, n2, t2, o2, r3[1]);
            }
          }
          return s2;
        }
        function Tn2(t2, e2, r2, n2, i2, s2 = 1 / 0) {
          let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
          if (0 === a2) return a2;
          const o2 = new Kr2([[0, [0, t2.length - 1], [0, r2.length - 1]]], ln2);
          for (; o2.length > 0; ) {
            const s3 = o2.pop();
            if (s3[0] >= a2) continue;
            const l2 = s3[1], u2 = s3[2], c2 = e2 ? 50 : 100, h2 = n2 ? 50 : 100;
            if (un2(l2) <= c2 && un2(u2) <= h2) {
              if (!cn2(l2, t2.length) && cn2(u2, r2.length)) return NaN;
              let s4;
              if (e2 && n2) s4 = xn2(t2, l2, r2, u2, i2), a2 = Math.min(a2, s4);
              else if (e2 && !n2) {
                const e3 = t2.slice(l2[0], l2[1] + 1);
                for (let t3 = u2[0]; t3 <= u2[1]; ++t3) if (s4 = mn2(r2[t3], e3, i2), a2 = Math.min(a2, s4), 0 === a2) return a2;
              } else if (!e2 && n2) {
                const e3 = r2.slice(u2[0], u2[1] + 1);
                for (let r3 = l2[0]; r3 <= l2[1]; ++r3) if (s4 = mn2(t2[r3], e3, i2), a2 = Math.min(a2, s4), 0 === a2) return a2;
              } else s4 = vn2(t2, l2, r2, u2, i2), a2 = Math.min(a2, s4);
            } else {
              const s4 = hn2(l2, e2), c3 = hn2(u2, n2);
              kn2(o2, a2, i2, t2, r2, s4[0], c3[0]), kn2(o2, a2, i2, t2, r2, s4[0], c3[1]), kn2(o2, a2, i2, t2, r2, s4[1], c3[0]), kn2(o2, a2, i2, t2, r2, s4[1], c3[1]);
            }
          }
          return a2;
        }
        function In2(t2) {
          return "MultiPolygon" === t2.type ? t2.coordinates.map(((t3) => ({ type: "Polygon", coordinates: t3 }))) : "MultiLineString" === t2.type ? t2.coordinates.map(((t3) => ({ type: "LineString", coordinates: t3 }))) : "MultiPoint" === t2.type ? t2.coordinates.map(((t3) => ({ type: "Point", coordinates: t3 }))) : [t2];
        }
        class Mn2 {
          constructor(t2, e2) {
            this.type = Ct2, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`'distance' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if ($e2(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type) return new Mn2(e3, e3.features.map(((t3) => In2(t3.geometry))).flat());
              if ("Feature" === e3.type) return new Mn2(e3, In2(e3.geometry));
              if ("type" in e3 && "coordinates" in e3) return new Mn2(e3, In2(e3));
            }
            return e2.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType()) return (function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map(((e3) => Pr2([e3.x, e3.y], t3.canonical)));
                if (0 === r2.length) return NaN;
                const i2 = new on2(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, Tn2(n2, false, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, Tn2(n2, false, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, En2(n2, false, t4.coordinates, i2, s2));
                  }
                  if (0 === s2) return s2;
                }
                return s2;
              })(t2, this.geometries);
              if ("LineString" === t2.geometryType()) return (function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map(((e3) => Pr2([e3.x, e3.y], t3.canonical)));
                if (0 === r2.length) return NaN;
                const i2 = new on2(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, Tn2(n2, true, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, Tn2(n2, true, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, En2(n2, true, t4.coordinates, i2, s2));
                  }
                  if (0 === s2) return s2;
                }
                return s2;
              })(t2, this.geometries);
              if ("Polygon" === t2.geometryType()) return (function(t3, e2) {
                const r2 = t3.geometry();
                if (0 === r2.length || 0 === r2[0].length) return NaN;
                const n2 = tn2(r2, 0).map(((e3) => e3.map(((e4) => e4.map(((e5) => Pr2([e5.x, e5.y], t3.canonical))))))), i2 = new on2(n2[0][0][0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) for (const e3 of n2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, En2([t4.coordinates], false, e3, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, En2(t4.coordinates, true, e3, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, Sn2(e3, t4.coordinates, i2, s2));
                  }
                  if (0 === s2) return s2;
                }
                return s2;
              })(t2, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class Fn2 {
          constructor(t2) {
            this.type = Ut2, this.key = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
            const r2 = t2[1];
            return null == r2 ? e2.error("Global state property must be defined.") : "string" != typeof r2 ? e2.error(`Global state property must be string, but found ${typeof t2[1]} instead.`) : new Fn2(r2);
          }
          evaluate(t2) {
            var e2;
            const r2 = null === (e2 = t2.globals) || void 0 === e2 ? void 0 : e2.globalState;
            return r2 && 0 !== Object.keys(r2).length ? ve2(r2, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        const Dn = { "==": br2, "!=": wr2, ">": Sr2, "<": _r2, ">=": kr, "<=": Ar2, array: Xe2, at: tr2, boolean: Xe2, case: ir2, coalesce: mr2, collator: Er2, format: Ir2, image: Mr2, in: er2, "index-of": rr2, interpolate: fr2, "interpolate-hcl": fr2, "interpolate-lab": fr2, length: Fr2, let: Je, literal: je2, match: nr2, number: Xe2, "number-format": Tr2, object: Xe2, slice: sr2, step: or2, string: Xe2, "to-boolean": Ze2, "to-color": Ze2, "to-number": Ze2, "to-string": Ze2, var: Qe2, within: Hr2, distance: Mn2, "global-state": Fn2 };
        class zn2 {
          constructor(t2, e2, r2, n2) {
            this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
          }
          evaluate(t2) {
            return this._evaluate(t2, this.args);
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return false;
          }
          static parse(t2, e2) {
            const r2 = t2[0], n2 = zn2.definitions[r2];
            if (!n2) return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter((([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1));
            let o2 = null;
            for (const [n3, s3] of a2) {
              o2 = new We(e2.registry, Ln2, e2.path, null, e2.scope);
              const a3 = [];
              let l2 = false;
              for (let e3 = 1; e3 < t2.length; e3++) {
                const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
                if (!s4) {
                  l2 = true;
                  break;
                }
                a3.push(s4);
              }
              if (!l2) if (Array.isArray(n3) && n3.length !== a3.length) o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
              else {
                for (let t3 = 0; t3 < a3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (0 === o2.errors.length) return new zn2(r2, i2, s3, a3);
              }
            }
            if (1 === a2.length) e2.errors.push(...o2.errors);
            else {
              const r3 = (a2.length ? a2 : s2).map((([t3]) => {
                return e3 = t3, Array.isArray(e3) ? `(${e3.map(Wt2).join(", ")})` : `(${Wt2(e3.type)}...)`;
                var e3;
              })).join(" | "), n3 = [];
              for (let r4 = 1; r4 < t2.length; r4++) {
                const i3 = e2.parse(t2[r4], 1 + n3.length);
                if (!i3) return null;
                n3.push(Wt2(i3.type));
              }
              e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t2, e2) {
            zn2.definitions = e2;
            for (const r2 in e2) t2[r2] = zn2;
          }
        }
        function Pn2(t2, [e2, r2, n2, i2]) {
          e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
          const s2 = i2 ? i2.evaluate(t2) : 1, a2 = Ne2(e2, r2, n2, s2);
          if (a2) throw new Ve2(a2);
          return new Te2(e2 / 255, r2 / 255, n2 / 255, s2, false);
        }
        function Bn2(t2, e2) {
          return t2 in e2;
        }
        function Vn2(t2, e2) {
          const r2 = e2[t2];
          return void 0 === r2 ? null : r2;
        }
        function Cn2(t2) {
          return { type: t2 };
        }
        function Ln2(t2) {
          if (t2 instanceof Qe2) return Ln2(t2.boundExpression);
          if (t2 instanceof zn2 && "error" === t2.name) return false;
          if (t2 instanceof Er2) return false;
          if (t2 instanceof Hr2) return false;
          if (t2 instanceof Mn2) return false;
          if (t2 instanceof Fn2) return false;
          const e2 = t2 instanceof Ze2 || t2 instanceof Xe2;
          let r2 = true;
          return t2.eachChild(((t3) => {
            r2 = e2 ? r2 && Ln2(t3) : r2 && t3 instanceof je2;
          })), !!r2 && On2(t2) && Nn2(t2, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function On2(t2) {
          if (t2 instanceof zn2) {
            if ("get" === t2.name && 1 === t2.args.length) return false;
            if ("feature-state" === t2.name) return false;
            if ("has" === t2.name && 1 === t2.args.length) return false;
            if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name) return false;
            if (/^filter-/.test(t2.name)) return false;
          }
          if (t2 instanceof Hr2) return false;
          if (t2 instanceof Mn2) return false;
          let e2 = true;
          return t2.eachChild(((t3) => {
            e2 && !On2(t3) && (e2 = false);
          })), e2;
        }
        function Rn2(t2) {
          if (t2 instanceof zn2 && "feature-state" === t2.name) return false;
          let e2 = true;
          return t2.eachChild(((t3) => {
            e2 && !Rn2(t3) && (e2 = false);
          })), e2;
        }
        function Nn2(t2, e2) {
          if (t2 instanceof zn2 && e2.indexOf(t2.name) >= 0) return false;
          let r2 = true;
          return t2.eachChild(((t3) => {
            r2 && !Nn2(t3, e2) && (r2 = false);
          })), r2;
        }
        function $n2(t2) {
          return { result: "success", value: t2 };
        }
        function Un(t2) {
          return { result: "error", value: t2 };
        }
        function qn2(t2) {
          return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
        }
        function jn(t2) {
          return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
        }
        function Gn2(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function Xn2(t2) {
          return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
        }
        function Yn2(t2) {
          return "object" == typeof t2 && null !== t2 && !Array.isArray(t2) && Ue2(t2) === $t2;
        }
        function Zn2(t2) {
          return t2;
        }
        function Hn2(t2, e2) {
          const r2 = t2.stops && "object" == typeof t2.stops[0][0], n2 = r2 || !(r2 || void 0 !== t2.property), i2 = t2.type || (Gn2(e2) ? "exponential" : "interval"), s2 = (function(t3) {
            switch (t3.type) {
              case "color":
                return Te2.parse;
              case "padding":
                return ze2.parse;
              case "numberArray":
                return Pe2.parse;
              case "colorArray":
                return Be2.parse;
              default:
                return null;
            }
          })(e2);
          if (s2 && ((t2 = zt2({}, t2)).stops && (t2.stops = t2.stops.map(((t3) => [t3[0], s2(t3[1])]))), t2.default = s2(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== (a2 = t2.colorSpace) && "hcl" !== a2 && "lab" !== a2) throw new Error(`Unknown color space: "${t2.colorSpace}"`);
          var a2;
          const o2 = (function(t3) {
            switch (t3) {
              case "exponential":
                return Qn2;
              case "interval":
                return Jn2;
              case "categorical":
                return Wn2;
              case "identity":
                return ti2;
              default:
                throw new Error(`Unknown function type "${t3}"`);
            }
          })(i2);
          let l2, u2;
          if ("categorical" === i2) {
            l2 = /* @__PURE__ */ Object.create(null);
            for (const e3 of t2.stops) l2[e3[0]] = e3[1];
            u2 = typeof t2.stops[0][0];
          }
          if (r2) {
            const r3 = {}, n3 = [];
            for (let e3 = 0; e3 < t2.stops.length; e3++) {
              const i4 = t2.stops[e3], s4 = i4[0].zoom;
              void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
            }
            const i3 = [];
            for (const t3 of n3) i3.push([r3[t3].zoom, Hn2(r3[t3], e2)]);
            const s3 = { name: "linear" };
            return { kind: "composite", interpolationType: s3, interpolationFactor: fr2.interpolationFactor.bind(void 0, s3), zoomStops: i3.map(((t3) => t3[0])), evaluate: ({ zoom: r4 }, n4) => Qn2({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
          }
          if (n2) {
            const r3 = "exponential" === i2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
            return { kind: "camera", interpolationType: r3, interpolationFactor: fr2.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map(((t3) => t3[0])), evaluate: ({ zoom: r4 }) => o2(t2, e2, r4, l2, u2) };
          }
          return { kind: "source", evaluate(r3, n3) {
            const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
            return void 0 === i3 ? Kn2(t2.default, e2.default) : o2(t2, e2, i3, l2, u2);
          } };
        }
        function Kn2(t2, e2, r2) {
          return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
        }
        function Wn2(t2, e2, r2, n2, i2) {
          return Kn2(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
        }
        function Jn2(t2, e2, r2) {
          if ("number" !== Xn2(r2)) return Kn2(t2.default, e2.default);
          const n2 = t2.stops.length;
          if (1 === n2) return t2.stops[0][1];
          if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
          if (r2 >= t2.stops[n2 - 1][0]) return t2.stops[n2 - 1][1];
          const i2 = ar2(t2.stops.map(((t3) => t3[0])), r2);
          return t2.stops[i2][1];
        }
        function Qn2(t2, e2, r2) {
          const n2 = void 0 !== t2.base ? t2.base : 1;
          if ("number" !== Xn2(r2)) return Kn2(t2.default, e2.default);
          const i2 = t2.stops.length;
          if (1 === i2) return t2.stops[0][1];
          if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
          if (r2 >= t2.stops[i2 - 1][0]) return t2.stops[i2 - 1][1];
          const s2 = ar2(t2.stops.map(((t3) => t3[0])), r2), a2 = (function(t3, e3, r3, n3) {
            const i3 = n3 - r3, s3 = t3 - r3;
            return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
          })(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1], u2 = yr2[e2.type] || Zn2;
          return "function" == typeof o2.evaluate ? { evaluate(...e3) {
            const r3 = o2.evaluate.apply(void 0, e3), n3 = l2.evaluate.apply(void 0, e3);
            if (void 0 !== r3 && void 0 !== n3) return u2(r3, n3, a2, t2.colorSpace);
          } } : u2(o2, l2, a2, t2.colorSpace);
        }
        function ti2(t2, e2, r2) {
          switch (e2.type) {
            case "color":
              r2 = Te2.parse(r2);
              break;
            case "formatted":
              r2 = De2.fromString(r2.toString());
              break;
            case "resolvedImage":
              r2 = Oe2.fromString(r2.toString());
              break;
            case "padding":
              r2 = ze2.parse(r2);
              break;
            case "colorArray":
              r2 = Be2.parse(r2);
              break;
            case "numberArray":
              r2 = Pe2.parse(r2);
              break;
            default:
              Xn2(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0);
          }
          return Kn2(r2, t2.default, e2.default);
        }
        zn2.register(Dn, { error: [{ kind: "error" }, [Lt2], (t2, [e2]) => {
          throw new Ve2(e2.evaluate(t2));
        }], typeof: [Lt2, [Ut2], (t2, [e2]) => Wt2(Ue2(e2.evaluate(t2)))], "to-rgba": [Kt2(Ct2, 4), [Rt2], (t2, [e2]) => {
          const [r2, n2, i2, s2] = e2.evaluate(t2).rgb;
          return [255 * r2, 255 * n2, 255 * i2, s2];
        }], rgb: [Rt2, [Ct2, Ct2, Ct2], Pn2], rgba: [Rt2, [Ct2, Ct2, Ct2, Ct2], Pn2], has: { type: Ot2, overloads: [[[Lt2], (t2, [e2]) => Bn2(e2.evaluate(t2), t2.properties())], [[Lt2, $t2], (t2, [e2, r2]) => Bn2(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: Ut2, overloads: [[[Lt2], (t2, [e2]) => Vn2(e2.evaluate(t2), t2.properties())], [[Lt2, $t2], (t2, [e2, r2]) => Vn2(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [Ut2, [Lt2], (t2, [e2]) => Vn2(e2.evaluate(t2), t2.featureState || {})], properties: [$t2, [], (t2) => t2.properties()], "geometry-type": [Lt2, [], (t2) => t2.geometryType()], id: [Ut2, [], (t2) => t2.id()], zoom: [Ct2, [], (t2) => t2.globals.zoom], "heatmap-density": [Ct2, [], (t2) => t2.globals.heatmapDensity || 0], elevation: [Ct2, [], (t2) => t2.globals.elevation || 0], "line-progress": [Ct2, [], (t2) => t2.globals.lineProgress || 0], accumulated: [Ut2, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [Ct2, Cn2(Ct2), (t2, e2) => {
          let r2 = 0;
          for (const n2 of e2) r2 += n2.evaluate(t2);
          return r2;
        }], "*": [Ct2, Cn2(Ct2), (t2, e2) => {
          let r2 = 1;
          for (const n2 of e2) r2 *= n2.evaluate(t2);
          return r2;
        }], "-": { type: Ct2, overloads: [[[Ct2, Ct2], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[Ct2], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [Ct2, [Ct2, Ct2], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [Ct2, [Ct2, Ct2], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [Ct2, [], () => Math.LN2], pi: [Ct2, [], () => Math.PI], e: [Ct2, [], () => Math.E], "^": [Ct2, [Ct2, Ct2], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [Ct2, [Ct2], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [Ct2, [Ct2], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [Ct2, [Ct2], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [Ct2, [Ct2], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [Ct2, [Ct2], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [Ct2, [Ct2], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [Ct2, [Ct2], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [Ct2, [Ct2], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [Ct2, [Ct2], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [Ct2, [Ct2], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [Ct2, Cn2(Ct2), (t2, e2) => Math.min(...e2.map(((e3) => e3.evaluate(t2))))], max: [Ct2, Cn2(Ct2), (t2, e2) => Math.max(...e2.map(((e3) => e3.evaluate(t2))))], abs: [Ct2, [Ct2], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [Ct2, [Ct2], (t2, [e2]) => {
          const r2 = e2.evaluate(t2);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [Ct2, [Ct2], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [Ct2, [Ct2], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [Ot2, [Lt2, Ut2], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [Ot2, [Ut2], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [Ot2, [Lt2], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [Ot2, [Lt2, Ut2], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 < i2;
        }], "filter-id-<": [Ot2, [Ut2], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 < n2;
        }], "filter->": [Ot2, [Lt2, Ut2], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 > i2;
        }], "filter-id->": [Ot2, [Ut2], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 > n2;
        }], "filter-<=": [Ot2, [Lt2, Ut2], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 <= i2;
        }], "filter-id-<=": [Ot2, [Ut2], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 <= n2;
        }], "filter->=": [Ot2, [Lt2, Ut2], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 >= i2;
        }], "filter-id->=": [Ot2, [Ut2], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 >= n2;
        }], "filter-has": [Ot2, [Ut2], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [Ot2, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [Ot2, [Kt2(Lt2)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [Ot2, [Kt2(Ut2)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [Ot2, [Lt2, Kt2(Ut2)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [Ot2, [Lt2, Kt2(Ut2)], (t2, [e2, r2]) => (function(t3, e3, r3, n2) {
          for (; r3 <= n2; ) {
            const i2 = r3 + n2 >> 1;
            if (e3[i2] === t3) return true;
            e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
          }
          return false;
        })(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: Ot2, overloads: [[[Ot2, Ot2], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Cn2(Ot2), (t2, e2) => {
          for (const r2 of e2) if (!r2.evaluate(t2)) return false;
          return true;
        }]] }, any: { type: Ot2, overloads: [[[Ot2, Ot2], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Cn2(Ot2), (t2, e2) => {
          for (const r2 of e2) if (r2.evaluate(t2)) return true;
          return false;
        }]] }, "!": [Ot2, [Ot2], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [Ot2, [Lt2], (t2, [e2]) => {
          const r2 = t2.globals && t2.globals.isSupportedScript;
          return !r2 || r2(e2.evaluate(t2));
        }], upcase: [Lt2, [Lt2], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [Lt2, [Lt2], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [Lt2, Cn2(Ut2), (t2, e2) => e2.map(((e3) => qe2(e3.evaluate(t2)))).join("")], "resolved-locale": [Lt2, [qt2], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
        class ei2 {
          constructor(t2, e2, r2) {
            this.expression = t2, this._warningHistory = {}, this._evaluator = new Ke2(), this._defaultValue = e2 ? (function(t3) {
              if ("color" === t3.type && Yn2(t3.default)) return new Te2(0, 0, 0, 0);
              switch (t3.type) {
                case "color":
                  return Te2.parse(t3.default) || null;
                case "padding":
                  return ze2.parse(t3.default) || null;
                case "numberArray":
                  return Pe2.parse(t3.default) || null;
                case "colorArray":
                  return Be2.parse(t3.default) || null;
                case "variableAnchorOffsetCollection":
                  return Le2.parse(t3.default) || null;
                case "projectionDefinition":
                  return Re2.parse(t3.default) || null;
                default:
                  return void 0 === t3.default ? null : t3.default;
              }
            })(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null, this._globalState = r2;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._globalState && (t2 = ci2(t2, this._globalState)), this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            this._globalState && (t2 = ci2(t2, this._globalState)), this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
            try {
              const t3 = this.expression.evaluate(this._evaluator);
              if (null == t3 || "number" == typeof t3 && t3 != t3) return this._defaultValue;
              if (this._enumValues && !(t3 in this._enumValues)) throw new Ve2(`Expected value to be one of ${Object.keys(this._enumValues).map(((t4) => JSON.stringify(t4))).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
              return t3;
            } catch (t3) {
              return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
            }
          }
        }
        function ri2(t2) {
          return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Dn;
        }
        function ni2(t2, e2, r2) {
          const n2 = new We(Dn, Ln2, [], e2 ? (function(t3) {
            const e3 = { color: Rt2, string: Lt2, number: Ct2, enum: Lt2, boolean: Ot2, formatted: jt2, padding: Gt2, numberArray: Yt2, colorArray: Xt2, projectionDefinition: Nt2, resolvedImage: Zt2, variableAnchorOffsetCollection: Ht2 };
            return "array" === t3.type ? Kt2(e3[t3.value] || Ut2, t3.length) : e3[t3.type];
          })(e2) : void 0), i2 = n2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return i2 ? $n2(new ei2(i2, e2, r2)) : Un(n2.errors);
        }
        class ii2 {
          constructor(t2, e2, r2) {
            this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !Rn2(e2.expression), this.globalStateRefs = ui2(e2.expression), this._globalState = r2;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._globalState && (t2 = ci2(t2, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return this._globalState && (t2 = ci2(t2, this._globalState)), this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
          }
        }
        class si2 {
          constructor(t2, e2, r2, n2, i2) {
            this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !Rn2(e2.expression), this.globalStateRefs = ui2(e2.expression), this.interpolationType = n2, this._globalState = i2;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._globalState && (t2 = ci2(t2, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return this._globalState && (t2 = ci2(t2, this._globalState)), this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
          }
          interpolationFactor(t2, e2, r2) {
            return this.interpolationType ? fr2.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
          }
        }
        function ai2(t2, e2, r2) {
          const n2 = ni2(t2, e2, r2);
          if ("error" === n2.result) return n2;
          const i2 = n2.value.expression, s2 = On2(i2);
          if (!s2 && !qn2(e2)) return Un([new Pt2("", "data expressions not supported")]);
          const a2 = Nn2(i2, ["zoom"]);
          if (!a2 && !jn(e2)) return Un([new Pt2("", "zoom expressions not supported")]);
          const o2 = li2(i2);
          return o2 || a2 ? o2 instanceof Pt2 ? Un([o2]) : o2 instanceof fr2 && !Gn2(e2) ? Un([new Pt2("", '"interpolate" expressions cannot be used with this property')]) : $n2(o2 ? new si2(s2 ? "camera" : "composite", n2.value, o2.labels, o2 instanceof fr2 ? o2.interpolation : void 0, r2) : new ii2(s2 ? "constant" : "source", n2.value, r2)) : Un([new Pt2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class oi2 {
          constructor(t2, e2) {
            this._parameters = t2, this._specification = e2, zt2(this, Hn2(this._parameters, this._specification));
          }
          static deserialize(t2) {
            return new oi2(t2._parameters, t2._specification);
          }
          static serialize(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          }
        }
        function li2(t2) {
          let e2 = null;
          if (t2 instanceof Je) e2 = li2(t2.result);
          else if (t2 instanceof mr2) {
            for (const r2 of t2.args) if (e2 = li2(r2), e2) break;
          } else (t2 instanceof or2 || t2 instanceof fr2) && t2.input instanceof zn2 && "zoom" === t2.input.name && (e2 = t2);
          return e2 instanceof Pt2 || t2.eachChild(((t3) => {
            const r2 = li2(t3);
            r2 instanceof Pt2 ? e2 = r2 : !e2 && r2 ? e2 = new Pt2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new Pt2("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), e2;
        }
        function ui2(t2, e2 = /* @__PURE__ */ new Set()) {
          return t2 instanceof Fn2 && e2.add(t2.key), t2.eachChild(((t3) => {
            ui2(t3, e2);
          })), e2;
        }
        function ci2(t2, e2) {
          const { zoom: r2, heatmapDensity: n2, elevation: i2, lineProgress: s2, isSupportedScript: a2, accumulated: o2 } = null != t2 ? t2 : {};
          return { zoom: r2, heatmapDensity: n2, elevation: i2, lineProgress: s2, isSupportedScript: a2, accumulated: o2, globalState: e2 };
        }
        function hi2(t2) {
          if (true === t2 || false === t2) return true;
          if (!Array.isArray(t2) || 0 === t2.length) return false;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
            case "in":
              return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (const e2 of t2.slice(1)) if (!hi2(e2) && "boolean" != typeof e2) return false;
              return true;
            default:
              return true;
          }
        }
        const pi2 = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function fi2(t2, e2) {
          if (null == t2) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          hi2(t2) || (t2 = mi2(t2));
          const r2 = ni2(t2, pi2, e2);
          if ("error" === r2.result) throw new Error(r2.value.map(((t3) => `${t3.key}: ${t3.message}`)).join(", "));
          return { filter: (t3, e3, n2) => r2.value.evaluate(t3, e3, {}, n2), needGeometry: yi2(t2), getGlobalStateRefs: () => ui2(r2.value.expression) };
        }
        function di2(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function yi2(t2) {
          if (!Array.isArray(t2)) return false;
          if ("within" === t2[0] || "distance" === t2[0]) return true;
          for (let e2 = 1; e2 < t2.length; e2++) if (yi2(t2[e2])) return true;
          return false;
        }
        function mi2(t2) {
          if (!t2) return true;
          const e2 = t2[0];
          return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? gi2(t2[1], t2[2], "==") : "!=" === e2 ? bi2(gi2(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? gi2(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(mi2))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(mi2)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(mi2).map(bi2)) : "in" === e2 ? xi(t2[1], t2.slice(2)) : "!in" === e2 ? bi2(xi(t2[1], t2.slice(2))) : "has" === e2 ? vi2(t2[1]) : "!has" !== e2 || bi2(vi2(t2[1]));
          var r2;
        }
        function gi2(t2, e2, r2) {
          switch (t2) {
            case "$type":
              return [`filter-type-${r2}`, e2];
            case "$id":
              return [`filter-id-${r2}`, e2];
            default:
              return [`filter-${r2}`, t2, e2];
          }
        }
        function xi(t2, e2) {
          if (0 === e2.length) return false;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some(((t3) => typeof t3 != typeof e2[0])) ? ["filter-in-large", t2, ["literal", e2.sort(di2)]] : ["filter-in-small", t2, ["literal", e2]];
          }
        }
        function vi2(t2) {
          switch (t2) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function bi2(t2) {
          return ["!", t2];
        }
        function wi2(t2) {
          const e2 = typeof t2;
          if ("number" === e2 || "boolean" === e2 || "string" === e2 || null == t2) return JSON.stringify(t2);
          if (Array.isArray(t2)) {
            let e3 = "[";
            for (const r3 of t2) e3 += `${wi2(r3)},`;
            return `${e3}]`;
          }
          const r2 = Object.keys(t2).sort();
          let n2 = "{";
          for (let e3 = 0; e3 < r2.length; e3++) n2 += `${JSON.stringify(r2[e3])}:${wi2(t2[r2[e3]])},`;
          return `${n2}}`;
        }
        function _i2(t2) {
          let e2 = "";
          for (const r2 of bt2) e2 += `/${wi2(t2[r2])}`;
          return e2;
        }
        function Si2(t2) {
          const e2 = t2.value;
          return e2 ? [new Dt2(t2.key, e2, "constants have been deprecated as of v8")] : [];
        }
        function Ai(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function ki(t2) {
          if (Array.isArray(t2)) return t2.map(ki);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            const e2 = {};
            for (const r2 in t2) e2[r2] = ki(t2[r2]);
            return e2;
          }
          return Ai(t2);
        }
        function Ei(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec, o2 = t2.validateSpec;
          let l2 = [];
          const u2 = Xn2(r2);
          if ("object" !== u2) return [new Dt2(e2, r2, `object expected, ${u2} found`)];
          for (const t3 in r2) {
            const u3 = t3.split(".")[0], c2 = ve2(n2, u3) || n2["*"];
            let h2;
            if (ve2(i2, u3)) h2 = i2[u3];
            else if (ve2(n2, u3)) {
              if (void 0 === r2[t3]) continue;
              h2 = o2;
            } else if (i2["*"]) h2 = i2["*"];
            else {
              if (!n2["*"]) {
                l2.push(new Dt2(e2, r2[t3], `unknown property "${t3}"`));
                continue;
              }
              h2 = o2;
            }
            l2 = l2.concat(h2({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: c2, style: s2, styleSpec: a2, object: r2, objectKey: t3, validateSpec: o2 }, r2));
          }
          for (const t3 in n2) i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && l2.push(new Dt2(e2, r2, `missing required property "${t3}"`));
          return l2;
        }
        function Ti(t2) {
          const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || t2.validateSpec;
          if ("array" !== Xn2(e2)) return [new Dt2(s2, e2, `array expected, ${Xn2(e2)} found`)];
          if (r2.length && e2.length !== r2.length) return [new Dt2(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
          let o2 = { type: r2.value, values: r2.values };
          i2.$version < 7 && (o2.function = r2.function), "object" === Xn2(r2.value) && (o2 = r2.value);
          let l2 = [];
          for (let r3 = 0; r3 < e2.length; r3++) l2 = l2.concat(a2({ array: e2, arrayIndex: r3, value: e2[r3], valueSpec: o2, validateSpec: t2.validateSpec, style: n2, styleSpec: i2, key: `${s2}[${r3}]` }));
          return l2;
        }
        function Ii2(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
          let i2 = Xn2(r2);
          return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new Dt2(e2, r2, `number expected, ${i2} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new Dt2(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new Dt2(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
        }
        function Mi(t2) {
          const e2 = t2.valueSpec, r2 = Ai(t2.value.type);
          let n2, i2, s2, a2 = {};
          const o2 = "categorical" !== r2 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === Xn2(t2.value.stops) && "array" === Xn2(t2.value.stops[0]) && "object" === Xn2(t2.value.stops[0][0]), c2 = Ei({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, validateSpec: t2.validateSpec, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if ("identity" === r2) return [new Dt2(t3.key, t3.value, 'identity function may not have a "stops" property')];
            let e3 = [];
            const n3 = t3.value;
            return e3 = e3.concat(Ti({ key: t3.key, value: n3, valueSpec: t3.valueSpec, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), "array" === Xn2(n3) && 0 === n3.length && e3.push(new Dt2(t3.key, n3, "array must have at least one stop")), e3;
          }, default: function(t3) {
            return t3.validateSpec({ key: t3.key, value: t3.value, valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec });
          } } });
          return "identity" === r2 && o2 && c2.push(new Dt2(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new Dt2(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !Gn2(t2.valueSpec) && c2.push(new Dt2(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !qn2(t2.valueSpec) ? c2.push(new Dt2(t2.key, t2.value, "property functions not supported")) : o2 && !jn(t2.valueSpec) && c2.push(new Dt2(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new Dt2(t2.key, t2.value, '"property" property is required')), c2;
          function h2(t3) {
            let r3 = [];
            const n3 = t3.value, o3 = t3.key;
            if ("array" !== Xn2(n3)) return [new Dt2(o3, n3, `array expected, ${Xn2(n3)} found`)];
            if (2 !== n3.length) return [new Dt2(o3, n3, `array length 2 expected, length ${n3.length} found`)];
            if (u2) {
              if ("object" !== Xn2(n3[0])) return [new Dt2(o3, n3, `object expected, ${Xn2(n3[0])} found`)];
              if (void 0 === n3[0].zoom) return [new Dt2(o3, n3, "object stop key must have zoom")];
              if (void 0 === n3[0].value) return [new Dt2(o3, n3, "object stop key must have value")];
              if (s2 && s2 > Ai(n3[0].zoom)) return [new Dt2(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
              Ai(n3[0].zoom) !== s2 && (s2 = Ai(n3[0].zoom), i2 = void 0, a2 = {}), r3 = r3.concat(Ei({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: Ii2, value: p2 } }));
            } else r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }, n3));
            return ri2(ki(n3[1])) ? r3.concat([new Dt2(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(t3.validateSpec({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function p2(t3, s3) {
            const o3 = Xn2(t3.value), l3 = Ai(t3.value), u3 = null !== t3.value ? t3.value : s3;
            if (n2) {
              if (o3 !== n2) return [new Dt2(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
            } else n2 = o3;
            if ("number" !== o3 && "string" !== o3 && "boolean" !== o3) return [new Dt2(t3.key, u3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o3 && "categorical" !== r2) {
              let n3 = `number expected, ${o3} found`;
              return qn2(e2) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Dt2(t3.key, u3, n3)];
            }
            return "categorical" !== r2 || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && void 0 !== i2 && l3 < i2 ? [new Dt2(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in a2 ? [new Dt2(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new Dt2(t3.key, u3, `integer expected, found ${l3}`)];
          }
        }
        function Fi(t2) {
          const e2 = ("property" === t2.expressionContext ? ai2 : ni2)(ki(t2.value), t2.valueSpec);
          if ("error" === e2.result) return e2.value.map(((e3) => new Dt2(`${t2.key}${e3.key}`, t2.value, e3.message)));
          const r2 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined()) return [new Dt2(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t2.expressionContext && "layout" === t2.propertyType && !Rn2(r2)) return [new Dt2(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t2.expressionContext && !Rn2(r2)) return [new Dt2(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
          if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
            if (!Nn2(r2, ["zoom", "feature-state"])) return [new Dt2(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t2.expressionContext && !On2(r2)) return [new Dt2(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function Di2(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = Xn2(r2);
          return "string" !== n2 ? [new Dt2(e2, r2, `color expected, ${n2} found`)] : Te2.parse(String(r2)) ? [] : [new Dt2(e2, r2, `color expected, "${r2}" found`)];
        }
        function zi(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
          return Array.isArray(n2.values) ? -1 === n2.values.indexOf(Ai(r2)) && i2.push(new Dt2(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(Ai(r2)) && i2.push(new Dt2(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
        }
        function Pi2(t2) {
          return hi2(ki(t2.value)) ? Fi(zt2({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Bi2(t2);
        }
        function Bi2(t2) {
          const e2 = t2.value, r2 = t2.key;
          if ("array" !== Xn2(e2)) return [new Dt2(r2, e2, `array expected, ${Xn2(e2)} found`)];
          const n2 = t2.styleSpec;
          let i2, s2 = [];
          if (e2.length < 1) return [new Dt2(r2, e2, "filter array must have at least 1 element")];
          switch (s2 = s2.concat(zi({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), Ai(e2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e2.length >= 2 && "$type" === Ai(e2[1]) && s2.push(new Dt2(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
            case "==":
            case "!=":
              3 !== e2.length && s2.push(new Dt2(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e2.length >= 2 && (i2 = Xn2(e2[1]), "string" !== i2 && s2.push(new Dt2(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
              for (let a2 = 2; a2 < e2.length; a2++) i2 = Xn2(e2[a2]), "$type" === Ai(e2[1]) ? s2 = s2.concat(zi({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new Dt2(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n3 = 1; n3 < e2.length; n3++) s2 = s2.concat(Bi2({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
              break;
            case "has":
            case "!has":
              i2 = Xn2(e2[1]), 2 !== e2.length ? s2.push(new Dt2(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new Dt2(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
          }
          return s2;
        }
        function Vi2(t2, e2) {
          const r2 = t2.key, n2 = t2.validateSpec, i2 = t2.style, s2 = t2.styleSpec, a2 = t2.value, o2 = t2.objectKey, l2 = s2[`${e2}_${t2.layerType}`];
          if (!l2) return [];
          const u2 = o2.match(/^(.*)-transition$/);
          if ("paint" === e2 && u2 && l2[u2[1]] && l2[u2[1]].transition) return n2({ key: r2, value: a2, valueSpec: s2.transition, style: i2, styleSpec: s2 });
          const c2 = t2.valueSpec || l2[o2];
          if (!c2) return [new Dt2(r2, a2, `unknown property "${o2}"`)];
          let h2;
          if ("string" === Xn2(a2) && qn2(c2) && !c2.tokens && (h2 = /^{([^}]+)}$/.exec(a2))) return [new Dt2(r2, a2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)];
          const p2 = [];
          return "symbol" === t2.layerType && "text-font" === o2 && Yn2(ki(a2)) && "identity" === Ai(a2.type) && p2.push(new Dt2(r2, a2, '"text-font" does not support identity functions')), p2.concat(n2({ key: t2.key, value: a2, valueSpec: c2, style: i2, styleSpec: s2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
        }
        function Ci(t2) {
          return Vi2(t2, "paint");
        }
        function Li(t2) {
          return Vi2(t2, "layout");
        }
        function Oi(t2) {
          let e2 = [];
          const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
          if ("object" !== Xn2(r2)) return [new Dt2(n2, r2, `object expected, ${Xn2(r2)} found`)];
          r2.type || r2.ref || e2.push(new Dt2(n2, r2, 'either "type" or "ref" is required'));
          let a2 = Ai(r2.type);
          const o2 = Ai(r2.ref);
          if (r2.id) {
            const s3 = Ai(r2.id);
            for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
              const t3 = i2.layers[a3];
              Ai(t3.id) === s3 && e2.push(new Dt2(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
            }
          }
          if ("ref" in r2) {
            let t3;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((t4) => {
              t4 in r2 && e2.push(new Dt2(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
            })), i2.layers.forEach(((e3) => {
              Ai(e3.id) === o2 && (t3 = e3);
            })), t3 ? t3.ref ? e2.push(new Dt2(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = Ai(t3.type) : e2.push(new Dt2(n2, r2.ref, `ref layer "${o2}" not found`));
          } else if ("background" !== a2) if (r2.source) {
            const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && Ai(t3.type);
            t3 ? "vector" === s3 && "raster" === a2 ? e2.push(new Dt2(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster-dem" !== s3 && "hillshade" === a2 || "raster-dem" !== s3 && "color-relief" === a2 ? e2.push(new Dt2(n2, r2.source, `layer "${r2.id}" requires a raster-dem source`)) : "raster" === s3 && "raster" !== a2 ? e2.push(new Dt2(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 && "color-relief" !== a2 ? e2.push(new Dt2(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === s3 && t3.lineMetrics || e2.push(new Dt2(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new Dt2(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new Dt2(n2, r2.source, `source "${r2.source}" not found`));
          } else e2.push(new Dt2(n2, r2, 'missing required property "source"'));
          return e2 = e2.concat(Ei({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, objectElementValidators: { "*": () => [], type: () => t2.validateSpec({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, object: r2, objectKey: "type" }), filter: Pi2, layout: (t3) => Ei({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Li(zt2({ layerType: a2 }, t4)) } }), paint: (t3) => Ei({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Ci(zt2({ layerType: a2 }, t4)) } }) } })), e2;
        }
        function Ri(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = Xn2(e2);
          return "string" !== n2 ? [new Dt2(r2, e2, `string expected, ${n2} found`)] : [];
        }
        const Ni2 = { promoteId: function({ key: t2, value: e2 }) {
          if ("string" === Xn2(e2)) return Ri({ key: t2, value: e2 });
          {
            const r2 = [];
            for (const n2 in e2) r2.push(...Ri({ key: `${t2}.${n2}`, value: e2[n2] }));
            return r2;
          }
        } };
        function $i(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style, s2 = t2.validateSpec;
          if (!e2.type) return [new Dt2(r2, e2, '"type" is required')];
          const a2 = Ai(e2.type);
          let o2;
          switch (a2) {
            case "vector":
            case "raster":
              return o2 = Ei({ key: r2, value: e2, valueSpec: n2[`source_${a2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: Ni2, validateSpec: s2 }), o2;
            case "raster-dem":
              return o2 = (function(t3) {
                var e3;
                const r3 = null !== (e3 = t3.sourceName) && void 0 !== e3 ? e3 : "", n3 = t3.value, i3 = t3.styleSpec, s3 = i3.source_raster_dem, a3 = t3.style;
                let o3 = [];
                const l2 = Xn2(n3);
                if (void 0 === n3) return o3;
                if ("object" !== l2) return o3.push(new Dt2("source_raster_dem", n3, `object expected, ${l2} found`)), o3;
                const u2 = "custom" === Ai(n3.encoding), c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = t3.value.encoding ? `"${t3.value.encoding}"` : "Default";
                for (const e4 in n3) !u2 && c2.includes(e4) ? o3.push(new Dt2(e4, n3[e4], `In "${r3}": "${e4}" is only valid when "encoding" is set to "custom". ${h2} encoding found`)) : s3[e4] ? o3 = o3.concat(t3.validateSpec({ key: e4, value: n3[e4], valueSpec: s3[e4], validateSpec: t3.validateSpec, style: a3, styleSpec: i3 })) : o3.push(new Dt2(e4, n3[e4], `unknown property "${e4}"`));
                return o3;
              })({ sourceName: r2, value: e2, style: t2.style, styleSpec: n2, validateSpec: s2 }), o2;
            case "geojson":
              if (o2 = Ei({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, validateSpec: s2, objectElementValidators: Ni2 }), e2.cluster) for (const t3 in e2.clusterProperties) {
                const [n3, i3] = e2.clusterProperties[t3], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                o2.push(...Fi({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), o2.push(...Fi({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
              }
              return o2;
            case "video":
              return Ei({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, validateSpec: s2, styleSpec: n2 });
            case "image":
              return Ei({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, validateSpec: s2, styleSpec: n2 });
            case "canvas":
              return [new Dt2(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return zi({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Ui2(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
          let s2 = [];
          const a2 = Xn2(e2);
          if (void 0 === e2) return s2;
          if ("object" !== a2) return s2 = s2.concat([new Dt2("light", e2, `object expected, ${a2} found`)]), s2;
          for (const a3 in e2) {
            const o2 = a3.match(/^(.*)-transition$/);
            s2 = s2.concat(o2 && n2[o2[1]] && n2[o2[1]].transition ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: r2.transition, validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new Dt2(a3, e2[a3], `unknown property "${a3}"`)]);
          }
          return s2;
        }
        function qi2(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.sky, i2 = t2.style, s2 = Xn2(e2);
          if (void 0 === e2) return [];
          if ("object" !== s2) return [new Dt2("sky", e2, `object expected, ${s2} found`)];
          let a2 = [];
          for (const s3 in e2) a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new Dt2(s3, e2[s3], `unknown property "${s3}"`)]);
          return a2;
        }
        function ji2(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.terrain, i2 = t2.style;
          let s2 = [];
          const a2 = Xn2(e2);
          if (void 0 === e2) return s2;
          if ("object" !== a2) return s2 = s2.concat([new Dt2("terrain", e2, `object expected, ${a2} found`)]), s2;
          for (const a3 in e2) s2 = s2.concat(n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new Dt2(a3, e2[a3], `unknown property "${a3}"`)]);
          return s2;
        }
        function Gi2(t2) {
          let e2 = [];
          const r2 = t2.value, n2 = t2.key;
          if (Array.isArray(r2)) {
            const i2 = [], s2 = [];
            for (const a2 in r2) r2[a2].id && i2.includes(r2[a2].id) && e2.push(new Dt2(n2, r2, `all the sprites' ids must be unique, but ${r2[a2].id} is duplicated`)), i2.push(r2[a2].id), r2[a2].url && s2.includes(r2[a2].url) && e2.push(new Dt2(n2, r2, `all the sprites' URLs must be unique, but ${r2[a2].url} is duplicated`)), s2.push(r2[a2].url), e2 = e2.concat(Ei({ key: `${n2}[${a2}]`, value: r2[a2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t2.validateSpec }));
            return e2;
          }
          return Ri({ key: n2, value: r2 });
        }
        function Xi2(t2) {
          return Boolean(t2) && t2.constructor === Object;
        }
        function Yi2(t2) {
          return Xi2(t2.value) ? [] : [new Dt2(t2.key, t2.value, `object expected, ${Xn2(t2.value)} found`)];
        }
        const Zi2 = { "*": () => [], array: Ti, boolean: function(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = Xn2(e2);
          return "boolean" !== n2 ? [new Dt2(r2, e2, `boolean expected, ${n2} found`)] : [];
        }, number: Ii2, color: Di2, constants: Si2, enum: zi, filter: Pi2, function: Mi, layer: Oi, object: Ei, source: $i, light: Ui2, sky: qi2, terrain: ji2, projection: function(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.projection, i2 = t2.style, s2 = Xn2(e2);
          if (void 0 === e2) return [];
          if ("object" !== s2) return [new Dt2("projection", e2, `object expected, ${s2} found`)];
          let a2 = [];
          for (const s3 in e2) a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new Dt2(s3, e2[s3], `unknown property "${s3}"`)]);
          return a2;
        }, projectionDefinition: function(t2) {
          const e2 = t2.key;
          let r2 = t2.value;
          r2 = r2 instanceof String ? r2.valueOf() : r2;
          const n2 = Xn2(r2);
          return "array" !== n2 || (function(t3) {
            return Array.isArray(t3) && 3 === t3.length && "string" == typeof t3[0] && "string" == typeof t3[1] && "number" == typeof t3[2];
          })(r2) || (function(t3) {
            return !!["interpolate", "step", "literal"].includes(t3[0]);
          })(r2) ? ["array", "string"].includes(n2) ? [] : [new Dt2(e2, r2, `projection expected, invalid type "${n2}" found`)] : [new Dt2(e2, r2, `projection expected, invalid array ${JSON.stringify(r2)} found`)];
        }, string: Ri, formatted: function(t2) {
          return 0 === Ri(t2).length ? [] : Fi(t2);
        }, resolvedImage: function(t2) {
          return 0 === Ri(t2).length ? [] : Fi(t2);
        }, padding: function(t2) {
          const e2 = t2.key, r2 = t2.value;
          if ("array" === Xn2(r2)) {
            if (r2.length < 1 || r2.length > 4) return [new Dt2(e2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
            const n2 = { type: "number" };
            let i2 = [];
            for (let s2 = 0; s2 < r2.length; s2++) i2 = i2.concat(t2.validateSpec({ key: `${e2}[${s2}]`, value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
            return i2;
          }
          return Ii2({ key: e2, value: r2, valueSpec: {} });
        }, numberArray: function(t2) {
          const e2 = t2.key, r2 = t2.value;
          if ("array" === Xn2(r2)) {
            const n2 = { type: "number" };
            if (r2.length < 1) return [new Dt2(e2, r2, "array length at least 1 expected, length 0 found")];
            let i2 = [];
            for (let s2 = 0; s2 < r2.length; s2++) i2 = i2.concat(t2.validateSpec({ key: `${e2}[${s2}]`, value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
            return i2;
          }
          return Ii2({ key: e2, value: r2, valueSpec: {} });
        }, colorArray: function(t2) {
          const e2 = t2.key, r2 = t2.value;
          if ("array" === Xn2(r2)) {
            if (r2.length < 1) return [new Dt2(e2, r2, "array length at least 1 expected, length 0 found")];
            let t3 = [];
            for (let n2 = 0; n2 < r2.length; n2++) t3 = t3.concat(Di2({ key: `${e2}[${n2}]`, value: r2[n2] }));
            return t3;
          }
          return Di2({ key: e2, value: r2 });
        }, variableAnchorOffsetCollection: function(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = Xn2(r2), i2 = t2.styleSpec;
          if ("array" !== n2 || r2.length < 1 || r2.length % 2 != 0) return [new Dt2(e2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let s2 = [];
          for (let n3 = 0; n3 < r2.length; n3 += 2) s2 = s2.concat(zi({ key: `${e2}[${n3}]`, value: r2[n3], valueSpec: i2.layout_symbol["text-anchor"] })), s2 = s2.concat(Ti({ key: `${e2}[${n3 + 1}]`, value: r2[n3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t2.validateSpec, style: t2.style, styleSpec: i2 }));
          return s2;
        }, sprite: Gi2, state: Yi2, fontFaces: function(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.validateSpec, i2 = t2.styleSpec, s2 = t2.style;
          if (!Xi2(r2)) return [new Dt2(e2, r2, `object expected, ${Xn2(r2)} found`)];
          const a2 = [];
          for (const t3 in r2) {
            const o2 = r2[t3], l2 = Xn2(o2);
            if ("string" === l2) a2.push(...Ri({ key: `${e2}.${t3}`, value: o2 }));
            else if ("array" === l2) {
              const r3 = { url: { type: "string", required: true }, "unicode-range": { type: "array", value: "string" } };
              for (const [l3, u2] of o2.entries()) a2.push(...Ei({ key: `${e2}.${t3}[${l3}]`, value: u2, valueSpec: r3, styleSpec: i2, style: s2, validateSpec: n2 }));
            } else a2.push(new Dt2(`${e2}.${t3}`, o2, `string or array expected, ${l2} found`));
          }
          return a2;
        } };
        function Hi2(t2) {
          const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
          return t2.validateSpec = Hi2, r2.expression && Yn2(Ai(e2)) ? Mi(t2) : r2.expression && ri2(ki(e2)) ? Fi(t2) : r2.type && Zi2[r2.type] ? Zi2[r2.type](t2) : Ei(zt2({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
        }
        function Ki2(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = Ri(t2);
          return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new Dt2(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new Dt2(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function Wi2(t2, e2 = vt2) {
          let r2 = [];
          return r2 = r2.concat(Hi2({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, validateSpec: Hi2, objectElementValidators: { glyphs: Ki2, "*": () => [] } })), t2.constants && (r2 = r2.concat(Si2({ key: "constants", value: t2.constants }))), Qi2(r2);
        }
        function Ji2(t2) {
          return function(e2) {
            return t2(Object.assign({}, e2, { validateSpec: Hi2 }));
          };
        }
        function Qi2(t2) {
          return [].concat(t2).sort(((t3, e2) => t3.line - e2.line));
        }
        function ts2(t2) {
          return function(...e2) {
            return Qi2(t2.apply(this, e2));
          };
        }
        Wi2.source = ts2(Ji2($i)), Wi2.sprite = ts2(Ji2(Gi2)), Wi2.glyphs = ts2(Ji2(Ki2)), Wi2.light = ts2(Ji2(Ui2)), Wi2.sky = ts2(Ji2(qi2)), Wi2.terrain = ts2(Ji2(ji2)), Wi2.state = ts2(Ji2(Yi2)), Wi2.layer = ts2(Ji2(Oi)), Wi2.filter = ts2(Ji2(Pi2)), Wi2.paintProperty = ts2(Ji2(Ci)), Wi2.layoutProperty = ts2(Ji2(Li));
        const es2 = { type: "enum", "property-type": "data-constant", expression: { interpolated: false, parameters: ["global-state"] }, values: { visible: {}, none: {} }, transition: false, default: "visible" };
        class rs2 {
          constructor(t2, e2) {
            this._globalState = e2, this.setValue(t2);
          }
          evaluate() {
            var t2;
            return null !== (t2 = this._literalValue) && void 0 !== t2 ? t2 : this._compiledValue.evaluate({});
          }
          setValue(t2) {
            if (null == t2 || "visible" === t2 || "none" === t2) return this._literalValue = "none" === t2 ? "none" : "visible", this._compiledValue = void 0, void (this._globalStateRefs = /* @__PURE__ */ new Set());
            const e2 = ni2(t2, es2, this._globalState);
            if ("error" === e2.result) throw this._literalValue = "visible", this._compiledValue = void 0, new Error(e2.value.map(((t3) => `${t3.key}: ${t3.message}`)).join(", "));
            this._literalValue = void 0, this._compiledValue = e2.value, this._globalStateRefs = ui2(e2.value.expression);
          }
          getGlobalStateRefs() {
            return this._globalStateRefs;
          }
        }
        const ns2 = vt2, is2 = Wi2, ss2 = is2.light, as2 = is2.sky, os2 = is2.paintProperty, ls2 = is2.layoutProperty;
        function us2(t2, e2) {
          let r2 = false;
          if (e2 && e2.length) for (const n2 of e2) t2.fire(new gt2(new Error(n2.message))), r2 = true;
          return r2;
        }
        class cs2 {
          constructor(t2, e2, r2) {
            const n2 = this.cells = [];
            if (t2 instanceof ArrayBuffer) {
              this.arrayBuffer = t2;
              const i3 = new Int32Array(this.arrayBuffer);
              t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
              for (let t3 = 0; t3 < this.d * this.d; t3++) {
                const e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
                n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
              }
              const s2 = i3[3 + n2.length + 1];
              this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r2;
              for (let t3 = 0; t3 < this.d * this.d; t3++) n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
            const i2 = r2 / e2 * t2;
            this.min = -i2, this.max = t2 + i2;
          }
          insert(t2, e2, r2, n2, i2) {
            this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t2, e2, r2, n2, i2, s2) {
            this.cells[i2].push(s2);
          }
          query(t2, e2, r2, n2, i2) {
            const s2 = this.min, a2 = this.max;
            if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2) return Array.prototype.slice.call(this.keys);
            {
              const s3 = [];
              return this._forEachCell(t2, e2, r2, n2, this._queryCell, s3, {}, i2), s3;
            }
          }
          _queryCell(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this.cells[i2];
            if (null !== l2) {
              const i3 = this.keys, u2 = this.bboxes;
              for (let c2 = 0; c2 < l2.length; c2++) {
                const h2 = l2[c2];
                if (void 0 === a2[h2]) {
                  const l3 = 4 * h2;
                  (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t2 <= u2[l3 + 2] && e2 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (a2[h2] = true, s2.push(i3[h2])) : a2[h2] = false;
                }
              }
            }
          }
          _forEachCell(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
            for (let p2 = l2; p2 <= c2; p2++) for (let l3 = u2; l3 <= h2; l3++) {
              const u3 = this.d * l3 + p2;
              if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e2, r2, n2, u3, s2, a2, o2)) return;
            }
          }
          _convertFromCellCoord(t2) {
            return (t2 - this.padding) / this.scale;
          }
          _convertToCellCoord(t2) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
            let r2 = 0;
            for (let t3 = 0; t3 < this.cells.length; t3++) r2 += this.cells[t3].length;
            const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
            n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
            let i2 = e2;
            for (let e3 = 0; e3 < t2.length; e3++) {
              const r3 = t2[e3];
              n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
            }
            return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
          }
          static serialize(t2, e2) {
            const r2 = t2.toArrayBuffer();
            return e2 && e2.push(r2), { buffer: r2 };
          }
          static deserialize(t2) {
            return new cs2(t2.buffer);
          }
        }
        const hs2 = {};
        function ps2(t2, e2, r2 = {}) {
          if (hs2[t2]) throw new Error(`${t2} is already registered.`);
          Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), hs2[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
        }
        ps2("Object", Object), ps2("Set", Set), ps2("TransferableGridIndex", cs2), ps2("Color", Te2), ps2("Error", Error), ps2("AJAXError", ct2), ps2("ResolvedImage", Oe2), ps2("StylePropertyFunction", oi2), ps2("StyleExpression", ei2, { omit: ["_evaluator"] }), ps2("ZoomDependentExpression", si2), ps2("ZoomConstantExpression", ii2), ps2("CompoundExpression", zn2, { omit: ["_evaluate"] });
        for (const t2 in Dn) Dn[t2]._classRegistryKey || ps2(`Expression_${t2}`, Dn[t2]);
        function fs2(t2) {
          return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
        }
        function ds2(t2) {
          return t2.$name || t2.constructor._classRegistryKey;
        }
        function ys2(t2) {
          return !(function(t3) {
            if (null === t3 || "object" != typeof t3) return false;
            const e2 = ds2(t3);
            return !(!e2 || "Object" === e2);
          })(t2) && (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || t2 instanceof Error || fs2(t2) || Z2(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData);
        }
        function ms2(t2, e2) {
          if (ys2(t2)) return (fs2(t2) || Z2(t2)) && e2 && e2.push(t2), ArrayBuffer.isView(t2) && e2 && e2.push(t2.buffer), t2 instanceof ImageData && e2 && e2.push(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            const r3 = [];
            for (const n3 of t2) r3.push(ms2(n3, e2));
            return r3;
          }
          if ("object" != typeof t2) throw new Error("can't serialize object of type " + typeof t2);
          const r2 = ds2(t2);
          if (!r2) throw new Error(`can't serialize object of unregistered class ${t2.constructor.name}`);
          if (!hs2[r2]) throw new Error(`${r2} is not registered.`);
          const { klass: n2 } = hs2[r2], i2 = n2.serialize ? n2.serialize(t2, e2) : {};
          if (n2.serialize) {
            if (e2 && i2 === e2[e2.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const n3 in t2) {
              if (!t2.hasOwnProperty(n3)) continue;
              if (hs2[r2].omit.indexOf(n3) >= 0) continue;
              const s2 = t2[n3];
              i2[n3] = hs2[r2].shallow.indexOf(n3) >= 0 ? s2 : ms2(s2, e2);
            }
            t2 instanceof Error && (i2.message = t2.message);
          }
          if (i2.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== r2 && (i2.$name = r2), i2;
        }
        function gs2(t2) {
          if (ys2(t2)) return t2;
          if (Array.isArray(t2)) return t2.map(gs2);
          if ("object" != typeof t2) throw new Error("can't deserialize object of type " + typeof t2);
          const e2 = ds2(t2) || "Object";
          if (!hs2[e2]) throw new Error(`can't deserialize unregistered class ${e2}`);
          const { klass: r2 } = hs2[e2];
          if (!r2) throw new Error(`can't deserialize unregistered class ${e2}`);
          if (r2.deserialize) return r2.deserialize(t2);
          const n2 = Object.create(r2.prototype);
          for (const r3 of Object.keys(t2)) {
            if ("$name" === r3) continue;
            const i2 = t2[r3];
            n2[r3] = hs2[e2].shallow.indexOf(r3) >= 0 ? i2 : gs2(i2);
          }
          return n2;
        }
        class xs2 {
          constructor() {
            this.first = true;
          }
          update(t2, e2) {
            const r2 = Math.floor(t2);
            return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
          }
        }
        function vs2(t2) {
          return /[\u02EA\u02EB\u2E80-\u2FDF\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t2));
        }
        function bs2(t2) {
          return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD83D\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD30-\uDEFB]|\uD833[\uDEC0-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDE00\uDF00-\uDFFF]|\uD83E[\uDD00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t2));
        }
        function ws2(t2) {
          return /\s/u.test(String.fromCodePoint(t2));
        }
        function _s2(t2) {
          for (const e2 of t2) if (bs2(e2.codePointAt(0))) return true;
          return false;
        }
        function Ss2(t2) {
          for (const e2 of t2) if (!Es2(e2.codePointAt(0))) return false;
          return true;
        }
        function As2(t2) {
          const e2 = t2.map(((t3) => {
            try {
              return new RegExp(`\\p{sc=${t3}}`, "u").source;
            } catch (t4) {
              return null;
            }
          })).filter(((t3) => t3));
          return new RegExp(e2.join("|"), "u");
        }
        const ks2 = As2(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Es2(t2) {
          return !ks2.test(String.fromCodePoint(t2));
        }
        function Ts2(t2) {
          return !(bs2(t2) || (e2 = t2, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]|[\uDB80-\uDBFF][\uDC00-\uDFFF]/gim.test(String.fromCodePoint(e2))));
          var e2;
        }
        const Is2 = As2(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function Ms2(t2) {
          return Is2.test(String.fromCodePoint(t2));
        }
        function Fs2(t2, e2) {
          return !(!e2 && Ms2(t2) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(t2)));
        }
        function Ds2(t2) {
          for (const e2 of t2) if (Ms2(e2.codePointAt(0))) return true;
          return false;
        }
        const zs2 = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(t2) {
            this.pluginStatus = t2.pluginStatus, this.pluginURL = t2.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(t2) {
            if (zs2.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = t2.applyArabicShaping, this.processBidirectionalText = t2.processBidirectionalText, this.processStyledBidirectionalText = t2.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(t2, r2) {
            return e(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if ("loading" !== t2.pluginStatus) return this.setState(t2), t2;
              const e2 = t2.pluginURL, n2 = new Promise(((t3) => {
                this.loadScriptResolve = t3;
              }));
              r2(e2);
              const i2 = new Promise(((t3) => setTimeout((() => t3()), this.TIMEOUT)));
              if (yield Promise.race([n2, i2]), this.isParsed()) {
                const t3 = { pluginStatus: "loaded", pluginURL: e2 };
                return this.setState(t3), t3;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${e2}`);
            }));
          }
        }();
        class Ps2 {
          constructor(t2, e2) {
            this.isSupportedScript = Bs2, this.zoom = t2, e2 ? (this.now = e2.now || 0, this.fadeDuration = e2.fadeDuration || 0, this.zoomHistory = e2.zoomHistory || new xs2(), this.transition = e2.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new xs2(), this.transition = {});
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
            return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
          }
        }
        function Bs2(t2) {
          return (function(t3, e2) {
            for (const r2 of t3) if (!Fs2(r2.codePointAt(0), e2)) return false;
            return true;
          })(t2, "loaded" === zs2.getRTLTextPluginStatus());
        }
        const Vs2 = "-transition";
        class Cs2 {
          constructor(t2, e2, r2) {
            this.property = t2, this.value = e2, this.expression = (function(t3, e3, r3) {
              if (Yn2(t3)) return new oi2(t3, e3);
              if (ri2(t3)) {
                const n2 = ai2(t3, e3, r3);
                if ("error" === n2.result) throw new Error(n2.value.map(((t4) => `${t4.key}: ${t4.message}`)).join(", "));
                return n2.value;
              }
              {
                let r4 = t3;
                return "color" === e3.type && "string" == typeof t3 ? r4 = Te2.parse(t3) : "padding" !== e3.type || "number" != typeof t3 && !Array.isArray(t3) ? "numberArray" !== e3.type || "number" != typeof t3 && !Array.isArray(t3) ? "colorArray" !== e3.type || "string" != typeof t3 && !Array.isArray(t3) ? "variableAnchorOffsetCollection" === e3.type && Array.isArray(t3) ? r4 = Le2.parse(t3) : "projectionDefinition" === e3.type && "string" == typeof t3 && (r4 = Re2.parse(t3)) : r4 = Be2.parse(t3) : r4 = Pe2.parse(t3) : r4 = ze2.parse(t3), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => r4 };
              }
            })(void 0 === e2 ? t2.specification.default : e2, t2.specification, r2);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t2, e2, r2) {
            return this.property.possiblyEvaluate(this, t2, e2, r2);
          }
        }
        class Ls2 {
          constructor(t2, e2) {
            this.property = t2, this.value = new Cs2(t2, void 0, e2);
          }
          transitioned(t2, e2) {
            return new Rs2(this.property, this.value, e2, O2({}, t2.transition, this.transition), t2.now);
          }
          untransitioned() {
            return new Rs2(this.property, this.value, null, {}, 0);
          }
        }
        class Os2 {
          constructor(t2, e2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues), this._globalState = e2;
          }
          getValue(t2) {
            return U2(this._values[t2].value.value);
          }
          setValue(t2, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Ls2(this._values[t2].property, this._globalState)), this._values[t2].value = new Cs2(this._values[t2].property, null === e2 ? void 0 : U2(e2), this._globalState);
          }
          getTransition(t2) {
            return U2(this._values[t2].transition);
          }
          setTransition(t2, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Ls2(this._values[t2].property, this._globalState)), this._values[t2].transition = U2(e2) || void 0;
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
              const n2 = this.getTransition(e2);
              void 0 !== n2 && (t2[`${e2}${Vs2}`] = n2);
            }
            return t2;
          }
          transitioned(t2, e2) {
            const r2 = new Ns2(this._properties);
            for (const n2 of Object.keys(this._values)) r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
            return r2;
          }
          untransitioned() {
            const t2 = new Ns2(this._properties);
            for (const e2 of Object.keys(this._values)) t2._values[e2] = this._values[e2].untransitioned();
            return t2;
          }
        }
        class Rs2 {
          constructor(t2, e2, r2, n2, i2) {
            this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
            if (s2) {
              if (n2 > this.end) return this.prior = null, i2;
              if (this.value.isDataDriven()) return this.prior = null, i2;
              if (n2 < this.begin) return s2.possiblyEvaluate(t2, e2, r2);
              {
                const a2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, P2(a2));
              }
            }
            return i2;
          }
        }
        class Ns2 {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = new qs2(this._properties);
            for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
          hasTransition() {
            for (const t2 of Object.keys(this._values)) if (this._values[t2].prior) return true;
            return false;
          }
        }
        class $s2 {
          constructor(t2, e2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues), this._globalState = e2;
          }
          hasValue(t2) {
            return void 0 !== this._values[t2].value;
          }
          getValue(t2) {
            return U2(this._values[t2].value);
          }
          setValue(t2, e2) {
            this._values[t2] = new Cs2(this._values[t2].property, null === e2 ? void 0 : U2(e2), this._globalState);
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
            }
            return t2;
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = new qs2(this._properties);
            for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
        }
        class Us2 {
          constructor(t2, e2, r2) {
            this.property = t2, this.value = e2, this.parameters = r2;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t2) {
            return "constant" === this.value.kind ? this.value.value : t2;
          }
          evaluate(t2, e2, r2, n2) {
            return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
          }
        }
        class qs2 {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          }
          get(t2) {
            return this._values[t2];
          }
        }
        class js2 {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            if (t2.isDataDriven()) throw new Error("Value should not be data driven");
            return t2.expression.evaluate(e2);
          }
          interpolate(t2, e2, r2) {
            const n2 = yr2[this.specification.type];
            return n2 ? n2(t2, e2, r2) : t2;
          }
        }
        class Gs2 {
          constructor(t2, e2) {
            this.specification = t2, this.overrides = e2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return new Us2(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
          }
          interpolate(t2, e2, r2) {
            if ("constant" !== t2.value.kind || "constant" !== e2.value.kind) return t2;
            if (void 0 === t2.value.value || void 0 === e2.value.value) return new Us2(this, { kind: "constant", value: void 0 }, t2.parameters);
            const n2 = yr2[this.specification.type];
            if (n2) {
              const i2 = n2(t2.value.value, e2.value.value, r2);
              return new Us2(this, { kind: "constant", value: i2 }, t2.parameters);
            }
            return t2;
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
          }
        }
        class Xs2 extends Gs2 {
          possiblyEvaluate(t2, e2, r2, n2) {
            if (void 0 === t2.value) return new Us2(this, { kind: "constant", value: void 0 }, e2);
            if ("constant" === t2.expression.kind) {
              const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = "resolvedImage" === t2.property.specification.type && "string" != typeof i2 ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
              return new Us2(this, { kind: "constant", value: a2 }, e2);
            }
            if ("camera" === t2.expression.kind) {
              const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
              return new Us2(this, { kind: "constant", value: r3 }, e2);
            }
            return new Us2(this, t2.expression, e2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            if ("source" === t2.kind) {
              const a2 = t2.evaluate(e2, r2, n2, i2, s2);
              return this._calculate(a2, a2, a2, e2);
            }
            return "composite" === t2.kind ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
          }
          _calculate(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class Ys2 {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            if (void 0 !== t2.value) {
              if ("constant" === t2.expression.kind) {
                const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
                return this._calculate(i2, i2, i2, e2);
              }
              return this._calculate(t2.expression.evaluate(new Ps2(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new Ps2(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new Ps2(Math.floor(e2.zoom + 1), e2)), e2);
            }
          }
          _calculate(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class Zs2 {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return !!t2.expression.evaluate(e2, null, {}, r2, n2);
          }
          interpolate() {
            return false;
          }
        }
        class Hs2 {
          constructor(t2) {
            this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e2 in t2) {
              const r2 = t2[e2];
              r2.specification.overridable && this.overridableProperties.push(e2);
              const n2 = this.defaultPropertyValues[e2] = new Cs2(r2, void 0, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new Ls2(r2, void 0);
              this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
            }
          }
        }
        ps2("DataDrivenProperty", Gs2), ps2("DataConstantProperty", js2), ps2("CrossFadedDataDrivenProperty", Xs2), ps2("CrossFadedProperty", Ys2), ps2("ColorRampProperty", Zs2);
        class Ks2 extends xt2 {
          constructor(t2, e2, r2) {
            if (super(), this.id = t2.id, this.type = t2.type, this._globalState = r2, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, this._visibilityExpression = (function(t3, e3) {
              return new rs2(t3, e3);
            })(this.visibility, r2), "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter, this._featureFilter = fi2(t2.filter, r2)), e2.layout && (this._unevaluatedLayout = new $s2(e2.layout, r2)), e2.paint)) {
              this._transitionablePaint = new Os2(e2.paint, r2);
              for (const e3 in t2.paint) this.setPaintProperty(e3, t2.paint[e3], { validate: false });
              for (const e3 in t2.layout) this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new qs2(e2.paint);
            }
          }
          setFilter(t2) {
            this.filter = t2, this._featureFilter = fi2(t2, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t2) {
            return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t2 = /* @__PURE__ */ new Set();
            for (const e2 of this._visibilityExpression.getGlobalStateRefs()) t2.add(e2);
            if (this._unevaluatedLayout) for (const e2 in this._unevaluatedLayout._values) {
              const r2 = this._unevaluatedLayout._values[e2];
              for (const e3 of r2.getGlobalStateRefs()) t2.add(e3);
            }
            for (const e2 of this._featureFilter.getGlobalStateRefs()) t2.add(e2);
            return t2;
          }
          getPaintAffectingGlobalStateRefs() {
            var t2;
            const e2 = new globalThis.Map();
            if (this._transitionablePaint) for (const r2 in this._transitionablePaint._values) {
              const n2 = this._transitionablePaint._values[r2].value;
              for (const i2 of n2.getGlobalStateRefs()) {
                const s2 = null !== (t2 = e2.get(i2)) && void 0 !== t2 ? t2 : [];
                s2.push({ name: r2, value: n2.value }), e2.set(i2, s2);
              }
            }
            return e2;
          }
          getVisibilityAffectingGlobalStateRefs() {
            return this._visibilityExpression.getGlobalStateRefs();
          }
          setLayoutProperty(t2, e2, r2 = {}) {
            if (null == e2 || !this._validate(ls2, `layers.${this.id}.layout.${t2}`, t2, e2, r2)) return "visibility" === t2 ? (this.visibility = e2, this._visibilityExpression.setValue(e2), void this.recalculateVisibility()) : void this._unevaluatedLayout.setValue(t2, e2);
          }
          getPaintProperty(t2) {
            return t2.endsWith(Vs2) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
          }
          setPaintProperty(t2, e2, r2 = {}) {
            if (null != e2 && this._validate(os2, `layers.${this.id}.paint.${t2}`, t2, e2, r2)) return false;
            if (t2.endsWith(Vs2)) return this._transitionablePaint.setTransition(t2.slice(0, -11), e2 || void 0), false;
            {
              const r3 = this._transitionablePaint._values[t2], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i2 = r3.value.isDataDriven(), s2 = r3.value;
              this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
              const a2 = this._transitionablePaint._values[t2].value;
              return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
            }
          }
          _handleSpecialPaintPropertyUpdate(t2) {
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return false;
          }
          isHidden(t2 = this.minzoom, e2 = false) {
            return !!(this.minzoom && t2 < (e2 ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this._evaluatedVisibility;
          }
          updateTransitions(t2) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculateVisibility() {
            this._evaluatedVisibility = this._visibilityExpression.evaluate();
          }
          recalculate(t2, e2) {
            t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
          }
          serialize() {
            const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), $2(t2, ((t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length)));
          }
          _validate(t2, e2, r2, n2, i2 = {}) {
            return (!i2 || false !== i2.validate) && us2(this, t2.call(is2, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: vt2, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t2 in this.paint._values) {
              const e2 = this.paint.get(t2);
              if (e2 instanceof Us2 && qn2(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent) return true;
            }
            return false;
          }
        }
        let Ws2;
        var Js2 = { get paint() {
          return Ws2 = Ws2 || new Hs2({ "raster-opacity": new js2(vt2.paint_raster["raster-opacity"]), "raster-hue-rotate": new js2(vt2.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new js2(vt2.paint_raster["raster-brightness-min"]), "raster-brightness-max": new js2(vt2.paint_raster["raster-brightness-max"]), "raster-saturation": new js2(vt2.paint_raster["raster-saturation"]), "raster-contrast": new js2(vt2.paint_raster["raster-contrast"]), "raster-resampling": new js2(vt2.paint_raster["raster-resampling"]), "raster-fade-duration": new js2(vt2.paint_raster["raster-fade-duration"]) });
        } };
        class Qs2 extends Ks2 {
          constructor(t2, e2) {
            super(t2, Js2, e2);
          }
        }
        const ta2 = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class ea2 {
          constructor(t2, e2) {
            this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class ra2 {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t2, e2) {
            return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }
          static deserialize(t2) {
            const e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t2) {
            this.reserve(t2), this.length = t2;
          }
          reserve(t2) {
            if (t2 > this.capacity) {
              this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function na2(t2, e2 = 1) {
          let r2 = 0, n2 = 0;
          return { members: t2.map(((t3) => {
            const i2 = ta2[t3.type].BYTES_PER_ELEMENT, s2 = r2 = ia2(r2, Math.max(e2, i2)), a2 = t3.components || 1;
            return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
          })), size: ia2(r2, Math.max(n2, e2)), alignment: e2 };
        }
        function ia2(t2, e2) {
          return Math.ceil(t2 / e2) * e2;
        }
        class sa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
          }
        }
        sa2.prototype.bytesPerElement = 4, ps2("StructArrayLayout2i4", sa2);
        class aa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
          }
        }
        aa2.prototype.bytesPerElement = 6, ps2("StructArrayLayout3i6", aa2);
        class oa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
          }
        }
        oa2.prototype.bytesPerElement = 8, ps2("StructArrayLayout4i8", oa2);
        class la2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        la2.prototype.bytesPerElement = 12, ps2("StructArrayLayout2i4i12", la2);
        class ua2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 4 * t2, l2 = 8 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = s2, this.uint8[l2 + 7] = a2, t2;
          }
        }
        ua2.prototype.bytesPerElement = 8, ps2("StructArrayLayout2i4ub8", ua2);
        class ca2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
          }
        }
        ca2.prototype.bytesPerElement = 8, ps2("StructArrayLayout2f8", ca2);
        class ha2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = this.length;
            return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = 10 * t2;
            return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
          }
        }
        ha2.prototype.bytesPerElement = 20, ps2("StructArrayLayout10ui20", ha2);
        class pa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this.length;
            return this.resize(l2 + 1), this.emplace(l2, t2, e2, r2, n2, i2, s2, a2, o2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = 8 * t2;
            return this.uint16[u2 + 0] = e2, this.uint16[u2 + 1] = r2, this.uint16[u2 + 2] = n2, this.uint16[u2 + 3] = i2, this.uint16[u2 + 4] = s2, this.uint16[u2 + 5] = a2, this.uint16[u2 + 6] = o2, this.uint16[u2 + 7] = l2, t2;
          }
        }
        pa2.prototype.bytesPerElement = 16, ps2("StructArrayLayout8ui16", pa2);
        class fa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
            const p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f3 = 12 * t2;
            return this.int16[f3 + 0] = e2, this.int16[f3 + 1] = r2, this.int16[f3 + 2] = n2, this.int16[f3 + 3] = i2, this.uint16[f3 + 4] = s2, this.uint16[f3 + 5] = a2, this.uint16[f3 + 6] = o2, this.uint16[f3 + 7] = l2, this.int16[f3 + 8] = u2, this.int16[f3 + 9] = c2, this.int16[f3 + 10] = h2, this.int16[f3 + 11] = p2, t2;
          }
        }
        fa2.prototype.bytesPerElement = 24, ps2("StructArrayLayout4i4ui4i24", fa2);
        class da2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        da2.prototype.bytesPerElement = 12, ps2("StructArrayLayout3f12", da2);
        class ya2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint32[1 * t2 + 0] = e2, t2;
          }
        }
        ya2.prototype.bytesPerElement = 4, ps2("StructArrayLayout1ul4", ya2);
        class ma2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = this.length;
            return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, s2, a2, o2, l2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = 10 * t2, h2 = 5 * t2;
            return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t2;
          }
        }
        ma2.prototype.bytesPerElement = 20, ps2("StructArrayLayout6i1ul2ui20", ma2);
        class ga2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        ga2.prototype.bytesPerElement = 12, ps2("StructArrayLayout2i2i2i12", ga2);
        class xa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
          }
          emplace(t2, e2, r2, n2, i2, s2) {
            const a2 = 4 * t2, o2 = 8 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
          }
        }
        xa2.prototype.bytesPerElement = 16, ps2("StructArrayLayout2f1f2i16", xa2);
        class va2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 16 * t2, l2 = 4 * t2, u2 = 8 * t2;
            return this.uint8[o2 + 0] = e2, this.uint8[o2 + 1] = r2, this.float32[l2 + 1] = n2, this.float32[l2 + 2] = i2, this.int16[u2 + 6] = s2, this.int16[u2 + 7] = a2, t2;
          }
        }
        va2.prototype.bytesPerElement = 16, ps2("StructArrayLayout2ub2f2i16", va2);
        class ba2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
          }
        }
        ba2.prototype.bytesPerElement = 6, ps2("StructArrayLayout3ui6", ba2);
        class wa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3, m2) {
            const g2 = this.length;
            return this.resize(g2 + 1), this.emplace(g2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3, m2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3, m2, g2) {
            const x2 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
            return this.int16[x2 + 0] = e2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = a2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f3, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y3, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, t2;
          }
        }
        wa2.prototype.bytesPerElement = 48, ps2("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", wa2);
        class _a2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3, m2, g2, x2, v2, b2, w3, _3, S3, A2, k3, E2, T3) {
            const I3 = this.length;
            return this.resize(I3 + 1), this.emplace(I3, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3, m2, g2, x2, v2, b2, w3, _3, S3, A2, k3, E2, T3);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3, m2, g2, x2, v2, b2, w3, _3, S3, A2, k3, E2, T3, I3) {
            const M3 = 32 * t2, F3 = 16 * t2;
            return this.int16[M3 + 0] = e2, this.int16[M3 + 1] = r2, this.int16[M3 + 2] = n2, this.int16[M3 + 3] = i2, this.int16[M3 + 4] = s2, this.int16[M3 + 5] = a2, this.int16[M3 + 6] = o2, this.int16[M3 + 7] = l2, this.uint16[M3 + 8] = u2, this.uint16[M3 + 9] = c2, this.uint16[M3 + 10] = h2, this.uint16[M3 + 11] = p2, this.uint16[M3 + 12] = f3, this.uint16[M3 + 13] = d2, this.uint16[M3 + 14] = y3, this.uint16[M3 + 15] = m2, this.uint16[M3 + 16] = g2, this.uint16[M3 + 17] = x2, this.uint16[M3 + 18] = v2, this.uint16[M3 + 19] = b2, this.uint16[M3 + 20] = w3, this.uint16[M3 + 21] = _3, this.uint16[M3 + 22] = S3, this.uint32[F3 + 12] = A2, this.float32[F3 + 13] = k3, this.float32[F3 + 14] = E2, this.uint16[M3 + 30] = T3, this.uint16[M3 + 31] = I3, t2;
          }
        }
        _a2.prototype.bytesPerElement = 64, ps2("StructArrayLayout8i15ui1ul2f2ui64", _a2);
        class Sa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.float32[1 * t2 + 0] = e2, t2;
          }
        }
        Sa2.prototype.bytesPerElement = 4, ps2("StructArrayLayout1f4", Sa2);
        class Aa2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.uint16[6 * t2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        Aa2.prototype.bytesPerElement = 12, ps2("StructArrayLayout1ui2f12", Aa2);
        class ka2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 4 * t2;
            return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
          }
        }
        ka2.prototype.bytesPerElement = 8, ps2("StructArrayLayout1ul2ui8", ka2);
        class Ea2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
          }
        }
        Ea2.prototype.bytesPerElement = 4, ps2("StructArrayLayout2ui4", Ea2);
        class Ta2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint16[1 * t2 + 0] = e2, t2;
          }
        }
        Ta2.prototype.bytesPerElement = 2, ps2("StructArrayLayout1ui2", Ta2);
        class Ia2 extends ra2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
          }
        }
        Ia2.prototype.bytesPerElement = 16, ps2("StructArrayLayout4f16", Ia2);
        class Ma2 extends ea2 {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new r(this.anchorPointX, this.anchorPointY);
          }
        }
        Ma2.prototype.size = 20;
        class Fa2 extends ma2 {
          get(t2) {
            return new Ma2(this, t2);
          }
        }
        ps2("CollisionBoxArray", Fa2);
        class Da2 extends ea2 {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t2) {
            this._structArray.uint8[this._pos1 + 37] = t2;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t2) {
            this._structArray.uint8[this._pos1 + 38] = t2;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 10] = t2;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        Da2.prototype.size = 48;
        class za2 extends wa2 {
          get(t2) {
            return new Da2(this, t2);
          }
        }
        ps2("PlacedSymbolArray", za2);
        class Pa2 extends ea2 {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 12] = t2;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        Pa2.prototype.size = 64;
        class Ba2 extends _a2 {
          get(t2) {
            return new Pa2(this, t2);
          }
        }
        ps2("SymbolInstanceArray", Ba2);
        class Va2 extends Sa2 {
          getoffsetX(t2) {
            return this.float32[1 * t2 + 0];
          }
        }
        ps2("GlyphOffsetArray", Va2);
        class Ca2 extends aa2 {
          getx(t2) {
            return this.int16[3 * t2 + 0];
          }
          gety(t2) {
            return this.int16[3 * t2 + 1];
          }
          gettileUnitDistanceFromAnchor(t2) {
            return this.int16[3 * t2 + 2];
          }
        }
        ps2("SymbolLineVertexArray", Ca2);
        class La2 extends ea2 {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        La2.prototype.size = 12;
        class Oa2 extends Aa2 {
          get(t2) {
            return new La2(this, t2);
          }
        }
        ps2("TextAnchorOffsetArray", Oa2);
        class Ra2 extends ea2 {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        Ra2.prototype.size = 8;
        class Na2 extends ka2 {
          get(t2) {
            return new Ra2(this, t2);
          }
        }
        ps2("FeatureIndexArray", Na2);
        class $a2 extends sa2 {
        }
        class Ua2 extends sa2 {
        }
        class qa2 extends sa2 {
        }
        class ja2 extends la2 {
        }
        class Ga2 extends ua2 {
        }
        class Xa extends ca2 {
        }
        class Ya2 extends ha2 {
        }
        class Za2 extends pa2 {
        }
        class Ha2 extends fa2 {
        }
        class Ka2 extends da2 {
        }
        class Wa2 extends ya2 {
        }
        class Ja2 extends ga2 {
        }
        class Qa2 extends va2 {
        }
        class to2 extends ba2 {
        }
        class eo2 extends Ea2 {
        }
        const ro2 = na2([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: no2 } = ro2;
        class io2 {
          constructor(t2 = []) {
            this._forceNewSegmentOnNextPrepare = false, this.segments = t2;
          }
          prepareSegment(t2, e2, r2, n2) {
            const i2 = this.segments[this.segments.length - 1];
            return t2 > io2.MAX_VERTEX_ARRAY_LENGTH && j2(`Max vertices per segment is ${io2.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${io2.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i2 || i2.vertexLength + t2 > io2.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2 ? this.createNewSegment(e2, r2, n2) : i2;
          }
          createNewSegment(t2, e2, r2) {
            const n2 = { vertexOffset: t2.length, primitiveOffset: e2.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return void 0 !== r2 && (n2.sortKey = r2), this._forceNewSegmentOnNextPrepare = false, this.segments.push(n2), n2;
          }
          getOrCreateLatestSegment(t2, e2, r2) {
            return this.prepareSegment(0, t2, e2, r2);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = true;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t2 of this.segments) for (const e2 in t2.vaos) t2.vaos[e2].destroy();
          }
          static simpleSegment(t2, e2, r2, n2) {
            return new io2([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        function so2(t2, e2) {
          return 256 * (t2 = C(Math.floor(t2), 0, 255)) + C(Math.floor(e2), 0, 255);
        }
        io2.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ps2("SegmentVector", io2);
        const ao2 = na2([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), oo2 = na2([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
        var lo2, uo2, co2, ho2 = { exports: {} }, po = { exports: {} }, fo2 = { exports: {} }, yo2 = (function() {
          if (co2) return ho2.exports;
          co2 = 1;
          var t2 = (lo2 || (lo2 = 1, po.exports = function(t3, e3) {
            var r2, n2, i2, s2, a2, o2, l2, u2;
            for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e3, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; ) l2 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
            switch (l2 = 0, r2) {
              case 3:
                l2 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
              case 2:
                l2 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
              case 1:
                i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
            }
            return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
          }), po.exports), e2 = (uo2 || (uo2 = 1, fo2.exports = function(t3, e3) {
            for (var r2, n2 = t3.length, i2 = e3 ^ n2, s2 = 0; n2 >= 4; ) r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
            switch (n2) {
              case 3:
                i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
              case 2:
                i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
              case 1:
                i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
            }
            return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
          }), fo2.exports);
          return ho2.exports = t2, ho2.exports.murmur3 = t2, ho2.exports.murmur2 = e2, ho2.exports;
        })(), mo2 = n(yo2);
        class go2 {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t2, e2, r2, n2) {
            this.ids.push(xo2(t2)), this.positions.push(e2, r2, n2);
          }
          getPositions(t2) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const e2 = xo2(t2);
            let r2 = 0, n2 = this.ids.length - 1;
            for (; r2 < n2; ) {
              const t3 = r2 + n2 >> 1;
              this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
            }
            const i2 = [];
            for (; this.ids[r2] === e2; ) i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
            return i2;
          }
          static serialize(t2, e2) {
            const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
            return vo2(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
          }
          static deserialize(t2) {
            const e2 = new go2();
            return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
          }
        }
        function xo2(t2) {
          const e2 = +t2;
          return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : mo2(String(t2));
        }
        function vo2(t2, e2, r2, n2) {
          for (; r2 < n2; ) {
            const i2 = t2[r2 + n2 >> 1];
            let s2 = r2 - 1, a2 = n2 + 1;
            for (; ; ) {
              do {
                s2++;
              } while (t2[s2] < i2);
              do {
                a2--;
              } while (t2[a2] > i2);
              if (s2 >= a2) break;
              bo2(t2, s2, a2), bo2(e2, 3 * s2, 3 * a2), bo2(e2, 3 * s2 + 1, 3 * a2 + 1), bo2(e2, 3 * s2 + 2, 3 * a2 + 2);
            }
            a2 - r2 < n2 - a2 ? (vo2(t2, e2, r2, a2), r2 = a2 + 1) : (vo2(t2, e2, a2 + 1, n2), n2 = a2);
          }
        }
        function bo2(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        ps2("FeaturePositionMap", go2);
        class wo2 {
          constructor(t2, e2) {
            this.gl = t2.gl, this.location = e2;
          }
        }
        class _o2 extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
          }
        }
        class So2 extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
          }
        }
        class Ao2 extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = Te2.transparent;
          }
          set(t2) {
            t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
          }
        }
        const ko2 = new Float32Array(16);
        function Eo2(t2) {
          return [so2(255 * t2.r, 255 * t2.g), so2(255 * t2.b, 255 * t2.a)];
        }
        class To2 {
          constructor(t2, e2, r2) {
            this.value = t2, this.uniformNames = e2.map(((t3) => `u_${t3}`)), this.type = r2;
          }
          setUniform(t2, e2, r2) {
            t2.set(r2.constantOr(this.value));
          }
          getBinding(t2, e2, r2) {
            return "color" === this.type ? new Ao2(t2, e2) : new _o2(t2, e2);
          }
        }
        class Io2 {
          constructor(t2, e2) {
            this.uniformNames = e2.map(((t3) => `u_${t3}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t2, e2) {
            this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
          }
          setConstantDashPositions(t2, e2) {
            this.dashTo = [0, t2.y, t2.height, t2.width], this.dashFrom = [0, e2.y, e2.height, e2.width];
          }
          setUniform(t2, e2, r2, n2) {
            let i2 = null;
            "u_pattern_to" === n2 ? i2 = this.patternTo : "u_pattern_from" === n2 ? i2 = this.patternFrom : "u_dasharray_to" === n2 ? i2 = this.dashTo : "u_dasharray_from" === n2 ? i2 = this.dashFrom : "u_pixel_ratio_to" === n2 ? i2 = this.pixelRatioTo : "u_pixel_ratio_from" === n2 && (i2 = this.pixelRatioFrom), null !== i2 && t2.set(i2);
          }
          getBinding(t2, e2, r2) {
            return "u_pattern" === r2.substr(0, 9) || "u_dasharray_" === r2.substr(0, 12) ? new So2(t2, e2) : new _o2(t2, e2);
          }
        }
        class Mo2 {
          constructor(t2, e2, r2, n2) {
            this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map(((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 }))), this.paintVertexArray = new n2();
          }
          populatePaintArray(t2, e2, r2) {
            const n2 = this.paintVertexArray.length, i2 = this.expression.evaluate(new Ps2(0, r2), e2, {}, r2.canonical, [], r2.formattedSection);
            this.paintVertexArray.resize(t2), this._setPaintValue(n2, t2, i2);
          }
          updatePaintArray(t2, e2, r2, n2, i2) {
            const s2 = this.expression.evaluate(new Ps2(0, i2), r2, n2);
            this._setPaintValue(t2, e2, s2);
          }
          _setPaintValue(t2, e2, r2) {
            if ("color" === this.type) {
              const n2 = Eo2(r2);
              for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, n2[0], n2[1]);
            } else {
              for (let n2 = t2; n2 < e2; n2++) this.paintVertexArray.emplace(n2, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Fo2 {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.expression = t2, this.uniformNames = e2.map(((t3) => `u_${t3}_t`)), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map(((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 }))), this.paintVertexArray = new s2();
          }
          populatePaintArray(t2, e2, r2) {
            const n2 = this.expression.evaluate(new Ps2(this.zoom, r2), e2, {}, r2.canonical, [], r2.formattedSection), i2 = this.expression.evaluate(new Ps2(this.zoom + 1, r2), e2, {}, r2.canonical, [], r2.formattedSection), s2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, n2, i2);
          }
          updatePaintArray(t2, e2, r2, n2, i2) {
            const s2 = this.expression.evaluate(new Ps2(this.zoom, i2), r2, n2), a2 = this.expression.evaluate(new Ps2(this.zoom + 1, i2), r2, n2);
            this._setPaintValue(t2, e2, s2, a2);
          }
          _setPaintValue(t2, e2, r2, n2) {
            if ("color" === this.type) {
              const i2 = Eo2(r2), s2 = Eo2(n2);
              for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
            } else {
              for (let i2 = t2; i2 < e2; i2++) this.paintVertexArray.emplace(i2, r2, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t2, e2) {
            const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = C(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
            t2.set(n2);
          }
          getBinding(t2, e2, r2) {
            return new _o2(t2, e2);
          }
        }
        class Do2 {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
          }
          populatePaintArray(t2, e2, r2) {
            const n2 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, this.getPositionIds(e2), r2);
          }
          updatePaintArray(t2, e2, r2, n2, i2) {
            this._setPaintValues(t2, e2, this.getPositionIds(r2), i2);
          }
          _setPaintValues(t2, e2, r2, n2) {
            const i2 = this.getPositions(n2);
            if (!i2 || !r2) return;
            const s2 = i2[r2.min], a2 = i2[r2.mid], o2 = i2[r2.max];
            if (s2 && a2 && o2) for (let r3 = t2; r3 < e2; r3++) this.emplace(this.zoomInPaintVertexArray, r3, a2, s2), this.emplace(this.zoomOutPaintVertexArray, r3, a2, o2);
          }
          upload(t2) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const e2 = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, e2, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, e2, this.expression.isStateDependent);
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class zo2 extends Do2 {
          getPositions(t2) {
            return t2.imagePositions;
          }
          getPositionIds(t2) {
            return t2.patterns && t2.patterns[this.layerId];
          }
          getVertexAttributes() {
            return ao2.members;
          }
          emplace(t2, e2, r2, n2) {
            t2.emplace(e2, r2.tlbr[0], r2.tlbr[1], r2.tlbr[2], r2.tlbr[3], n2.tlbr[0], n2.tlbr[1], n2.tlbr[2], n2.tlbr[3], r2.pixelRatio, n2.pixelRatio);
          }
        }
        class Po2 extends Do2 {
          getPositions(t2) {
            return t2.dashPositions;
          }
          getPositionIds(t2) {
            return t2.dashes && t2.dashes[this.layerId];
          }
          getVertexAttributes() {
            return oo2.members;
          }
          emplace(t2, e2, r2, n2) {
            t2.emplace(e2, 0, r2.y, r2.height, r2.width, 0, n2.y, n2.height, n2.width);
          }
        }
        class Bo2 {
          constructor(t2, e2, r2) {
            this.binders = {}, this._buffers = [];
            const n2 = [];
            for (const i2 in t2.paint._values) {
              if (!r2(i2)) continue;
              const s2 = t2.paint.get(i2);
              if (!(s2 instanceof Us2 && qn2(s2.property.specification))) continue;
              const a2 = Co2(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = "cross-faded" === c2 || "cross-faded-data-driven" === c2;
              if ("constant" === o2.kind) this.binders[i2] = h2 ? new Io2(o2.value, a2) : new To2(o2.value, a2, l2), n2.push(`/u_${i2}`);
              else if ("source" === o2.kind || h2) {
                const r3 = Lo2(i2, l2, "source");
                this.binders[i2] = h2 ? "line-dasharray" === i2 ? new Po2(o2, l2, u2, e2, r3, t2.id) : new zo2(o2, l2, u2, e2, r3, t2.id) : new Mo2(o2, a2, l2, r3), n2.push(`/a_${i2}`);
              } else {
                const t3 = Lo2(i2, l2, "composite");
                this.binders[i2] = new Fo2(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
              }
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t2) {
            const e2 = this.binders[t2];
            return e2 instanceof Mo2 || e2 instanceof Fo2 ? e2.maxValue : 0;
          }
          populatePaintArrays(t2, e2, r2) {
            for (const n2 in this.binders) {
              const i2 = this.binders[n2];
              (i2 instanceof Mo2 || i2 instanceof Fo2 || i2 instanceof Do2) && i2.populatePaintArray(t2, e2, r2);
            }
          }
          setConstantPatternPositions(t2, e2) {
            for (const r2 in this.binders) {
              const n2 = this.binders[r2];
              n2 instanceof Io2 && n2.setConstantPatternPositions(t2, e2);
            }
          }
          setConstantDashPositions(t2, e2) {
            for (const r2 in this.binders) {
              const n2 = this.binders[r2];
              n2 instanceof Io2 && n2.setConstantDashPositions(t2, e2);
            }
          }
          updatePaintArrays(t2, e2, r2, n2, i2) {
            let s2 = false;
            for (const a2 in t2) {
              const o2 = e2.getPositions(a2);
              for (const e3 of o2) {
                const o3 = r2.feature(e3.index);
                for (const r3 in this.binders) {
                  const l2 = this.binders[r3];
                  if ((l2 instanceof Mo2 || l2 instanceof Fo2 || l2 instanceof Do2) && true === l2.expression.isStateDependent) {
                    const u2 = n2.paint.get(r3);
                    l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                  }
                }
              }
            }
            return s2;
          }
          defines() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof To2 || r2 instanceof Io2) && t2.push(...r2.uniformNames.map(((t3) => `#define HAS_UNIFORM_${t3}`)));
            }
            return t2;
          }
          getBinderAttributes() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof Mo2 || r2 instanceof Fo2) for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++) t2.push(r2.paintVertexAttributes[e3].name);
              else if (r2 instanceof Do2) {
                const e3 = r2.getVertexAttributes();
                for (const r3 of e3) t2.push(r3.name);
              }
            }
            return t2;
          }
          getBinderUniforms() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof To2 || r2 instanceof Io2 || r2 instanceof Fo2) for (const e3 of r2.uniformNames) t2.push(e3);
            }
            return t2;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t2, e2) {
            const r2 = [];
            for (const n2 in this.binders) {
              const i2 = this.binders[n2];
              if (i2 instanceof To2 || i2 instanceof Io2 || i2 instanceof Fo2) {
                for (const s2 of i2.uniformNames) if (e2[s2]) {
                  const a2 = i2.getBinding(t2, e2[s2], s2);
                  r2.push({ name: s2, property: n2, binding: a2 });
                }
              }
            }
            return r2;
          }
          setUniforms(t2, e2, r2, n2) {
            for (const { name: t3, property: i2, binding: s2 } of e2) this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
          }
          updatePaintBuffers(t2) {
            this._buffers = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (t2 && r2 instanceof Do2) {
                const e3 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                e3 && this._buffers.push(e3);
              } else (r2 instanceof Mo2 || r2 instanceof Fo2) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
            }
          }
          upload(t2) {
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof Mo2 || r2 instanceof Fo2 || r2 instanceof Do2) && r2.upload(t2);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof Mo2 || e2 instanceof Fo2 || e2 instanceof Do2) && e2.destroy();
            }
          }
        }
        class Vo2 {
          constructor(t2, e2, r2 = () => true) {
            this.programConfigurations = {};
            for (const n2 of t2) this.programConfigurations[n2.id] = new Bo2(n2, e2, r2);
            this.needsUpload = false, this._featureMap = new go2(), this._bufferOffset = 0;
          }
          populatePaintArrays(t2, e2, r2, n2) {
            for (const r3 in this.programConfigurations) this.programConfigurations[r3].populatePaintArrays(t2, e2, n2);
            void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
          }
          updatePaintArrays(t2, e2, r2, n2) {
            for (const i2 of r2) this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
          }
          get(t2) {
            return this.programConfigurations[t2];
          }
          upload(t2) {
            if (this.needsUpload) {
              for (const e2 in this.programConfigurations) this.programConfigurations[e2].upload(t2);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t2 in this.programConfigurations) this.programConfigurations[t2].destroy();
          }
        }
        function Co2(t2, e2) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
        }
        function Lo2(t2, e2, r2) {
          const n2 = { color: { source: ca2, composite: Ia2 }, number: { source: Sa2, composite: ca2 } }, i2 = (function(t3) {
            return { "line-pattern": { source: Ya2, composite: Ya2 }, "fill-pattern": { source: Ya2, composite: Ya2 }, "fill-extrusion-pattern": { source: Ya2, composite: Ya2 }, "line-dasharray": { source: Za2, composite: Za2 } }[t3];
          })(t2);
          return i2 && i2[r2] || n2[e2][r2];
        }
        ps2("ConstantBinder", To2), ps2("CrossFadedConstantBinder", Io2), ps2("SourceExpressionBinder", Mo2), ps2("CrossFadedPatternBinder", zo2), ps2("CrossFadedDasharrayBinder", Po2), ps2("CompositeExpressionBinder", Fo2), ps2("ProgramConfiguration", Bo2, { omit: ["_buffers"] }), ps2("ProgramConfigurationSet", Vo2);
        const Oo2 = Math.pow(2, 14) - 1, Ro2 = -Oo2 - 1;
        function No2(t2) {
          const e2 = M2 / t2.extent, r2 = t2.loadGeometry();
          for (let t3 = 0; t3 < r2.length; t3++) {
            const n2 = r2[t3];
            for (let t4 = 0; t4 < n2.length; t4++) {
              const r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
              r3.x = C(i2, Ro2, Oo2), r3.y = C(s2, Ro2, Oo2), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && j2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r2;
        }
        function $o2(t2, e2) {
          return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? No2(t2) : [] };
        }
        const Uo2 = -32768;
        function qo2(t2, e2, r2, n2, i2) {
          t2.emplaceBack(Uo2 + 8 * e2 + n2, Uo2 + 8 * r2 + i2);
        }
        class jo2 {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(((t3) => t3.id)), this.index = t2.index, this.hasDependencies = false, this.layoutVertexArray = new Ua2(), this.indexArray = new to2(), this.segments = new io2(), this.programConfigurations = new Vo2(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter(((t3) => t3.isStateDependent())).map(((t3) => t3.id));
          }
          populate(t2, e2, r2) {
            const n2 = this.layers[0], i2 = [];
            let s2 = null, a2 = false, o2 = "heatmap" === n2.type;
            if ("circle" === n2.type) {
              const t3 = n2;
              s2 = t3.layout.get("circle-sort-key"), a2 = !s2.isConstant(), o2 = o2 || "map" === t3.paint.get("circle-pitch-alignment");
            }
            const l2 = o2 ? e2.subdivisionGranularity.circle : 1;
            for (const { feature: e3, id: n3, index: o3, sourceLayerIndex: l3 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = $o2(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new Ps2(this.zoom), u2, r2)) continue;
              const c2 = a2 ? s2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u2.geometry : No2(e3), patterns: {}, sortKey: c2 };
              i2.push(h2);
            }
            a2 && i2.sort(((t3, e3) => t3.sortKey - e3.sortKey));
            for (const n3 of i2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o3 = t2[s3].feature;
              this.addFeature(n3, i3, s3, r2, l2), e2.featureIndex.insert(o3, i3, s3, a3, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, { imagePositions: r2 });
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, no2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e2, r2, n2, i2 = 1) {
            let s2;
            switch (i2) {
              case 1:
                s2 = [0, 7];
                break;
              case 3:
                s2 = [0, 2, 5, 7];
                break;
              case 5:
                s2 = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                s2 = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${i2}; valid values are 1, 3, 5, 7.`);
            }
            const a2 = s2.length;
            for (const r3 of e2) for (const e3 of r3) {
              const r4 = e3.x, n3 = e3.y;
              if (r4 < 0 || r4 >= M2 || n3 < 0 || n3 >= M2) continue;
              const i3 = this.segments.prepareSegment(a2 * a2, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = i3.vertexLength;
              for (let t3 = 0; t3 < a2; t3++) for (let e4 = 0; e4 < a2; e4++) qo2(this.layoutVertexArray, r4, n3, s2[e4], s2[t3]);
              for (let t3 = 0; t3 < a2 - 1; t3++) for (let e4 = 0; e4 < a2 - 1; e4++) {
                const r5 = o2 + t3 * a2 + e4, n4 = o2 + (t3 + 1) * a2 + e4;
                this.indexArray.emplaceBack(r5, n4 + 1, r5 + 1), this.indexArray.emplaceBack(r5, n4, n4 + 1);
              }
              i3.vertexLength += a2 * a2, i3.primitiveLength += (a2 - 1) * (a2 - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, { imagePositions: {}, canonical: n2 });
          }
        }
        function Go2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) if (tl2(e2, t2[r2])) return true;
          for (let r2 = 0; r2 < e2.length; r2++) if (tl2(t2, e2[r2])) return true;
          return !!Ho2(t2, e2);
        }
        function Xo2(t2, e2, r2) {
          return !!tl2(t2, e2) || !!Wo2(e2, t2, r2);
        }
        function Yo2(t2, e2) {
          if (1 === t2.length) return Qo2(e2, t2[0]);
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n2 = e2[r2];
            for (let e3 = 0; e3 < n2.length; e3++) if (tl2(t2, n2[e3])) return true;
          }
          for (let r2 = 0; r2 < t2.length; r2++) if (Qo2(e2, t2[r2])) return true;
          for (let r2 = 0; r2 < e2.length; r2++) if (Ho2(t2, e2[r2])) return true;
          return false;
        }
        function Zo2(t2, e2, r2) {
          if (t2.length > 1) {
            if (Ho2(t2, e2)) return true;
            for (let n2 = 0; n2 < e2.length; n2++) if (Wo2(e2[n2], t2, r2)) return true;
          }
          for (let n2 = 0; n2 < t2.length; n2++) if (Wo2(t2[n2], e2, r2)) return true;
          return false;
        }
        function Ho2(t2, e2) {
          if (0 === t2.length || 0 === e2.length) return false;
          for (let r2 = 0; r2 < t2.length - 1; r2++) {
            const n2 = t2[r2], i2 = t2[r2 + 1];
            for (let t3 = 0; t3 < e2.length - 1; t3++) if (Ko2(n2, i2, e2[t3], e2[t3 + 1])) return true;
          }
          return false;
        }
        function Ko2(t2, e2, r2, n2) {
          return G2(t2, r2, n2) !== G2(e2, r2, n2) && G2(t2, e2, r2) !== G2(t2, e2, n2);
        }
        function Wo2(t2, e2, r2) {
          const n2 = r2 * r2;
          if (1 === e2.length) return t2.distSqr(e2[0]) < n2;
          for (let r3 = 1; r3 < e2.length; r3++) if (Jo2(t2, e2[r3 - 1], e2[r3]) < n2) return true;
          return false;
        }
        function Jo2(t2, e2, r2) {
          const n2 = e2.distSqr(r2);
          if (0 === n2) return t2.distSqr(e2);
          const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
          return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
        }
        function Qo2(t2, e2) {
          let r2, n2, i2, s2 = false;
          for (let a2 = 0; a2 < t2.length; a2++) {
            r2 = t2[a2];
            for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++) n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
          }
          return s2;
        }
        function tl2(t2, e2) {
          let r2 = false;
          for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
            const s2 = t2[n2], a2 = t2[i2];
            s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
          }
          return r2;
        }
        function el2(t2, e2, r2) {
          const n2 = r2[0], i2 = r2[2];
          if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y) return false;
          const s2 = G2(t2, e2, r2[0]);
          return s2 !== G2(t2, e2, r2[1]) || s2 !== G2(t2, e2, r2[2]) || s2 !== G2(t2, e2, r2[3]);
        }
        function rl2(t2, e2, r2) {
          const n2 = e2.paint.get(t2).value;
          return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
        }
        function nl2(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function il2(t2, e2, n2, i2, s2) {
          if (!e2[0] && !e2[1]) return t2;
          const a2 = r.convert(e2)._mult(s2);
          "viewport" === n2 && a2._rotate(-i2);
          const o2 = [];
          for (let e3 = 0; e3 < t2.length; e3++) o2.push(t2[e3].sub(a2));
          return o2;
        }
        function sl2(t2) {
          const e2 = [];
          for (let r2 = 0; r2 < t2.length; r2++) {
            const n2 = t2[r2], i2 = e2.at(-1);
            (0 === r2 || i2 && !n2.equals(i2)) && e2.push(n2);
          }
          return e2;
        }
        function al2({ queryGeometry: t2, size: e2 }, r2) {
          return Xo2(t2, r2, e2);
        }
        function ol2({ queryGeometry: t2, size: e2, transform: r2, unwrappedTileID: n2, getElevation: i2 }, s2) {
          return Xo2(t2, s2, e2 * (r2.projectTileCoordinates(s2.x, s2.y, n2, i2).signedDistanceFromCamera / r2.cameraToCenterDistance));
        }
        function ll2({ queryGeometry: t2, size: e2, transform: r2, unwrappedTileID: n2, getElevation: i2 }, s2) {
          const a2 = r2.projectTileCoordinates(s2.x, s2.y, n2, i2).signedDistanceFromCamera, o2 = e2 * (r2.cameraToCenterDistance / a2);
          return Xo2(t2, hl2(s2, r2, n2, i2), o2);
        }
        function ul2({ queryGeometry: t2, size: e2, transform: r2, unwrappedTileID: n2, getElevation: i2 }, s2) {
          return Xo2(t2, hl2(s2, r2, n2, i2), e2);
        }
        function cl2({ queryGeometry: t2, size: e2, transform: r2, unwrappedTileID: n2, getElevation: i2, pitchAlignment: s2 = "map", pitchScale: a2 = "map" }, o2) {
          const l2 = "map" === s2 ? "map" === a2 ? al2 : ol2 : "map" === a2 ? ll2 : ul2, u2 = { queryGeometry: t2, size: e2, transform: r2, unwrappedTileID: n2, getElevation: i2 };
          for (const t3 of o2) for (const e3 of t3) if (l2(u2, e3)) return true;
          return false;
        }
        function hl2(t2, e2, n2, i2) {
          const s2 = e2.projectTileCoordinates(t2.x, t2.y, n2, i2).point;
          return new r((0.5 * s2.x + 0.5) * e2.width, (0.5 * -s2.y + 0.5) * e2.height);
        }
        let pl2, fl2;
        ps2("CircleBucket", jo2, { omit: ["layers"] });
        var dl2 = { get paint() {
          return fl2 = fl2 || new Hs2({ "circle-radius": new Gs2(vt2.paint_circle["circle-radius"]), "circle-color": new Gs2(vt2.paint_circle["circle-color"]), "circle-blur": new Gs2(vt2.paint_circle["circle-blur"]), "circle-opacity": new Gs2(vt2.paint_circle["circle-opacity"]), "circle-translate": new js2(vt2.paint_circle["circle-translate"]), "circle-translate-anchor": new js2(vt2.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new js2(vt2.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new js2(vt2.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Gs2(vt2.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Gs2(vt2.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Gs2(vt2.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return pl2 = pl2 || new Hs2({ "circle-sort-key": new Gs2(vt2.layout_circle["circle-sort-key"]) });
        } };
        class yl2 extends Ks2 {
          constructor(t2, e2) {
            super(t2, dl2, e2);
          }
          createBucket(t2) {
            return new jo2(t2);
          }
          queryRadius(t2) {
            const e2 = t2;
            return rl2("circle-radius", this, e2) + rl2("circle-stroke-width", this, e2) + nl2(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2, unwrappedTileID: a2, getElevation: o2 }) {
            const l2 = il2(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i2.bearingInRadians, s2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = this.paint.get("circle-pitch-scale"), h2 = this.paint.get("circle-pitch-alignment");
            let p2, f3;
            return "map" === h2 ? (p2 = l2, f3 = u2 * s2) : (p2 = (function(t3, e3, r3, n3) {
              return t3.map(((t4) => hl2(t4, e3, r3, n3)));
            })(l2, i2, a2, o2), f3 = u2), cl2({ queryGeometry: p2, size: f3, transform: i2, unwrappedTileID: a2, getElevation: o2, pitchAlignment: h2, pitchScale: c2 }, n2);
          }
        }
        class ml2 extends jo2 {
        }
        let gl2;
        ps2("HeatmapBucket", ml2, { omit: ["layers"] });
        var xl2 = { get paint() {
          return gl2 = gl2 || new Hs2({ "heatmap-radius": new Gs2(vt2.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Gs2(vt2.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new js2(vt2.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Zs2(vt2.paint_heatmap["heatmap-color"]), "heatmap-opacity": new js2(vt2.paint_heatmap["heatmap-opacity"]) });
        } };
        function vl2(t2, { width: e2, height: r2 }, n2, i2) {
          if (i2) {
            if (i2 instanceof Uint8ClampedArray) i2 = new Uint8Array(i2.buffer);
            else if (i2.length !== e2 * r2 * n2) throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e2 * r2 * n2}`);
          } else i2 = new Uint8Array(e2 * r2 * n2);
          return t2.width = e2, t2.height = r2, t2.data = i2, t2;
        }
        function bl2(t2, { width: e2, height: r2 }, n2) {
          if (e2 === t2.width && r2 === t2.height) return;
          const i2 = vl2({}, { width: e2, height: r2 }, n2);
          wl2(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
        }
        function wl2(t2, e2, r2, n2, i2, s2) {
          if (0 === i2.width || 0 === i2.height) return e2;
          if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height) throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height) throw new RangeError("out of range destination coordinates for image copy");
          const a2 = t2.data, o2 = e2.data;
          if (a2 === o2) throw new Error("srcData equals dstData, so image is already copied");
          for (let l2 = 0; l2 < i2.height; l2++) {
            const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
            for (let t3 = 0; t3 < i2.width * s2; t3++) o2[c2 + t3] = a2[u2 + t3];
          }
          return e2;
        }
        class _l2 {
          constructor(t2, e2) {
            vl2(this, t2, 1, e2);
          }
          resize(t2) {
            bl2(this, t2, 1);
          }
          clone() {
            return new _l2({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            wl2(t2, e2, r2, n2, i2, 1);
          }
        }
        class Sl2 {
          constructor(t2, e2) {
            vl2(this, t2, 4, e2);
          }
          resize(t2) {
            bl2(this, t2, 4);
          }
          replace(t2, e2) {
            e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }
          clone() {
            return new Sl2({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            wl2(t2, e2, r2, n2, i2, 4);
          }
          setPixel(t2, e2, r2) {
            const n2 = 4 * (t2 * this.width + e2);
            this.data[n2 + 0] = Math.round(255 * r2.r / r2.a), this.data[n2 + 1] = Math.round(255 * r2.g / r2.a), this.data[n2 + 2] = Math.round(255 * r2.b / r2.a), this.data[n2 + 3] = Math.round(255 * r2.a);
          }
        }
        function Al2(t2) {
          const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Sl2({ width: r2, height: n2 });
          if (Math.log(r2) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r2}`);
          const s2 = (n3, s3, a2) => {
            e2[t2.evaluationKey] = a2;
            const o2 = t2.expression.evaluate(e2);
            i2.setPixel(n3 / 4 / r2, s3 / 4, o2);
          };
          if (t2.clips) for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2) for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
            const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
            s2(i3, a2, l2 * (1 - o2) + u2 * o2);
          }
          else for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4) s2(0, e3, t3 / (r2 - 1));
          return i2;
        }
        ps2("AlphaImage", _l2), ps2("RGBAImage", Sl2);
        const kl2 = "big-fb";
        class El2 extends Ks2 {
          createBucket(t2) {
            return new ml2(t2);
          }
          constructor(t2, e2) {
            super(t2, xl2, e2), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "heatmap-color" === t2 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Al2({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(kl2) && this.heatmapFbos.delete(kl2);
          }
          queryRadius(t2) {
            return rl2("heatmap-radius", this, t2);
          }
          queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2, unwrappedTileID: a2, getElevation: o2 }) {
            return cl2({ queryGeometry: t2, size: this.paint.get("heatmap-radius").evaluate(e2, r2) * s2, transform: i2, unwrappedTileID: a2, getElevation: o2 }, n2);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && !this.isHidden();
          }
        }
        let Tl2;
        var Il2 = { get paint() {
          return Tl2 = Tl2 || new Hs2({ "hillshade-illumination-direction": new js2(vt2.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new js2(vt2.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new js2(vt2.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new js2(vt2.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new js2(vt2.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new js2(vt2.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new js2(vt2.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new js2(vt2.paint_hillshade["hillshade-method"]) });
        } };
        class Ml2 extends Ks2 {
          constructor(t2, e2) {
            super(t2, Il2, e2), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t2 = this.paint.get("hillshade-illumination-direction").values, e2 = this.paint.get("hillshade-illumination-altitude").values, r2 = this.paint.get("hillshade-highlight-color").values, n2 = this.paint.get("hillshade-shadow-color").values;
            const i2 = Math.max(t2.length, e2.length, r2.length, n2.length);
            t2 = t2.concat(Array(i2 - t2.length).fill(t2.at(-1))), e2 = e2.concat(Array(i2 - e2.length).fill(e2.at(-1))), r2 = r2.concat(Array(i2 - r2.length).fill(r2.at(-1))), n2 = n2.concat(Array(i2 - n2.length).fill(n2.at(-1)));
            const s2 = e2.map(tt2);
            return { directionRadians: t2.map(tt2), altitudeRadians: s2, shadowColor: n2, highlightColor: r2 };
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && !this.isHidden();
          }
        }
        let Fl2;
        var Dl2 = { get paint() {
          return Fl2 = Fl2 || new Hs2({ "color-relief-opacity": new js2(vt2["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new Zs2(vt2["paint_color-relief"]["color-relief-color"]) });
        } };
        class zl2 {
          constructor(t2, e2, r2, n2) {
            this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e2, n2);
          }
          update(t2, e2, r2) {
            const { width: n2, height: i2 } = t2, s2 = !(this.size && this.size[0] === n2 && this.size[1] === i2 || r2), { context: a2 } = this, { gl: o2 } = a2;
            if (this.useMipmap = Boolean(e2 && e2.useMipmap), o2.bindTexture(o2.TEXTURE_2D, this.texture), a2.pixelStoreUnpackFlipY.set(false), a2.pixelStoreUnpack.set(1), a2.pixelStoreUnpackPremultiplyAlpha.set(this.format === o2.RGBA && (!e2 || false !== e2.premultiply)), s2) this.size = [n2, i2], t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || Z2(t2) ? o2.texImage2D(o2.TEXTURE_2D, 0, this.format, this.format, o2.UNSIGNED_BYTE, t2) : o2.texImage2D(o2.TEXTURE_2D, 0, this.format, n2, i2, 0, this.format, o2.UNSIGNED_BYTE, t2.data);
            else {
              const { x: e3, y: s3 } = r2 || { x: 0, y: 0 };
              t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || Z2(t2) ? o2.texSubImage2D(o2.TEXTURE_2D, 0, e3, s3, o2.RGBA, o2.UNSIGNED_BYTE, t2) : o2.texSubImage2D(o2.TEXTURE_2D, 0, e3, s3, n2, i2, o2.RGBA, o2.UNSIGNED_BYTE, t2.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && o2.generateMipmap(o2.TEXTURE_2D), a2.pixelStoreUnpackFlipY.setDefault(), a2.pixelStoreUnpack.setDefault(), a2.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t2, e2, r2) {
            const { context: n2 } = this, { gl: i2 } = n2;
            i2.bindTexture(i2.TEXTURE_2D, this.texture), r2 !== i2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r2 = i2.LINEAR), t2 !== this.filter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, t2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, r2 || t2), this.filter = t2), e2 !== this.wrap && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, e2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }
        class Pl2 {
          constructor(t2, e2, r2, n2 = 1, i2 = 1, s2 = 1, a2 = 0) {
            if (this.uid = t2, e2.height !== e2.width) throw new RangeError("DEM tiles must be square");
            if (r2 && !["mapbox", "terrarium", "custom"].includes(r2)) return void j2(`"${r2}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = e2.height;
            const o2 = this.dim = e2.height - 2;
            switch (this.data = new Uint32Array(e2.data.buffer), r2) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = n2, this.greenFactor = i2, this.blueFactor = s2, this.baseShift = a2;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let t3 = 0; t3 < o2; t3++) this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(o2, t3)] = this.data[this._idx(o2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, o2)] = this.data[this._idx(t3, o2 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o2, -1)] = this.data[this._idx(o2 - 1, 0)], this.data[this._idx(-1, o2)] = this.data[this._idx(0, o2 - 1)], this.data[this._idx(o2, o2)] = this.data[this._idx(o2 - 1, o2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let t3 = 0; t3 < o2; t3++) for (let e3 = 0; e3 < o2; e3++) {
              const r3 = this.get(t3, e3);
              r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
            }
          }
          get(t2, e2) {
            const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
            return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t2, e2) {
            if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1) throw new RangeError(`Out of range source coordinates for DEM data. x: ${t2}, y: ${e2}, dim: ${this.dim}`);
            return (e2 + 1) * this.stride + (t2 + 1);
          }
          unpack(t2, e2, r2) {
            return t2 * this.redFactor + e2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
          }
          pack(t2) {
            return Bl2(t2, this.getUnpackVector());
          }
          getPixels() {
            return new Sl2({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t2, e2, r2) {
            if (this.dim !== t2.dim) throw new Error("dem dimension mismatch");
            let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n2 = i2 - 1;
                break;
              case 1:
                i2 = n2 + 1;
            }
            switch (r2) {
              case -1:
                s2 = a2 - 1;
                break;
              case 1:
                a2 = s2 + 1;
            }
            const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
            for (let e3 = s2; e3 < a2; e3++) for (let r3 = n2; r3 < i2; r3++) this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l2)];
          }
        }
        function Bl2(t2, e2) {
          const r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = Math.min(r2, n2, i2), o2 = Math.round((t2 + s2) / a2);
          return { r: Math.floor(o2 * a2 / r2) % 256, g: Math.floor(o2 * a2 / n2) % 256, b: Math.floor(o2 * a2 / i2) % 256 };
        }
        ps2("DEMData", Pl2);
        class Vl2 extends Ks2 {
          constructor(t2, e2) {
            super(t2, Dl2, e2);
          }
          _createColorRamp(t2) {
            const e2 = { elevationStops: [], colorStops: [] }, r2 = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (r2 instanceof ii2 && r2._styleExpression.expression instanceof fr2) {
              this.colorRampExpression = r2;
              const t3 = r2._styleExpression.expression;
              e2.elevationStops = t3.labels, e2.colorStops = [];
              for (const r3 of e2.elevationStops) e2.colorStops.push(t3.evaluate({ globals: { elevation: r3 } }));
            }
            if (e2.elevationStops.length < 1 && (e2.elevationStops = [0], e2.colorStops = [Te2.transparent]), e2.elevationStops.length < 2 && (e2.elevationStops.push(e2.elevationStops[0] + 1), e2.colorStops.push(e2.colorStops[0])), e2.elevationStops.length <= t2) return e2;
            const n2 = { elevationStops: [], colorStops: [] }, i2 = (e2.elevationStops.length - 1) / (t2 - 1);
            for (let t3 = 0; t3 < e2.elevationStops.length - 0.5; t3 += i2) n2.elevationStops.push(e2.elevationStops[Math.round(t3)]), n2.colorStops.push(e2.colorStops[Math.round(t3)]);
            return j2(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t2}, provided: ${e2.elevationStops.length}`), n2;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t2, e2, r2) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const n2 = this._createColorRamp(e2), i2 = new Sl2({ width: n2.colorStops.length, height: 1 }), s2 = new Sl2({ width: n2.colorStops.length, height: 1 });
            for (let t3 = 0; t3 < n2.elevationStops.length; t3++) {
              const e3 = Bl2(n2.elevationStops[t3], r2);
              s2.setPixel(0, t3, new Te2(e3.r / 255, e3.g / 255, e3.b / 255, 1)), i2.setPixel(0, t3, n2.colorStops[t3]);
            }
            return this.colorRampTextures = { elevationTexture: new zl2(t2, s2, t2.gl.RGBA), colorTexture: new zl2(t2, i2, t2.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return !this.isHidden() && !!this.colorRampTextures;
          }
        }
        const Cl2 = na2([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ll2 } = Cl2;
        function Ol2(t2, e2, r2) {
          const n2 = r2.patternDependencies;
          let i2 = false;
          for (const r3 of e2) {
            const e3 = r3.paint.get(`${t2}-pattern`);
            e3.isConstant() || (i2 = true);
            const s2 = e3.constantOr(null);
            s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
          }
          return i2;
        }
        function Rl2(t2, e2, r2, n2, i2) {
          const { zoom: s2 } = n2, a2 = i2.patternDependencies;
          for (const n3 of e2) {
            const e3 = n3.paint.get(`${t2}-pattern`).value;
            if ("constant" !== e3.kind) {
              let t3 = e3.evaluate({ zoom: s2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: s2 }, r2, {}, i2.availableImages), l2 = e3.evaluate({ zoom: s2 + 1 }, r2, {}, i2.availableImages);
              t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, a2[t3] = true, a2[o2] = true, a2[l2] = true, r2.patterns[n3.id] = { min: t3, mid: o2, max: l2 };
            }
          }
          return r2;
        }
        function Nl2(t2, e2, r2, n2, i2) {
          let s2;
          if (i2 === (function(t3, e3, r3, n3) {
            let i3 = 0;
            for (let s3 = e3, a2 = r3 - n3; s3 < r3; s3 += n3) i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
            return i3;
          })(t2, e2, r2, n2) > 0) for (let i3 = e2; i3 < r2; i3 += n2) s2 = lu2(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
          else for (let i3 = r2 - n2; i3 >= e2; i3 -= n2) s2 = lu2(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
          return s2 && ru2(s2, s2.next) && (uu2(s2), s2 = s2.next), s2;
        }
        function $l2(t2, e2) {
          if (!t2) return t2;
          e2 || (e2 = t2);
          let r2, n2 = t2;
          do {
            if (r2 = false, n2.steiner || !ru2(n2, n2.next) && 0 !== eu2(n2.prev, n2, n2.next)) n2 = n2.next;
            else {
              if (uu2(n2), n2 = e2 = n2.prev, n2 === n2.next) break;
              r2 = true;
            }
          } while (r2 || n2 !== e2);
          return e2;
        }
        function Ul2(t2, e2, r2, n2, i2, s2, a2) {
          if (!t2) return;
          !a2 && s2 && (function(t3, e3, r3, n3) {
            let i3 = t3;
            do {
              0 === i3.z && (i3.z = Kl2(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
            } while (i3 !== t3);
            i3.prevZ.nextZ = null, i3.prevZ = null, (function(t4) {
              let e4, r4 = 1;
              do {
                let n4, i4 = t4;
                t4 = null;
                let s3 = null;
                for (e4 = 0; i4; ) {
                  e4++;
                  let a3 = i4, o3 = 0;
                  for (let t5 = 0; t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++) ;
                  let l2 = r4;
                  for (; o3 > 0 || l2 > 0 && a3; ) 0 !== o3 && (0 === l2 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l2--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                  i4 = a3;
                }
                s3.nextZ = null, r4 *= 2;
              } while (e4 > 1);
            })(i3);
          })(t2, n2, i2, s2);
          let o2 = t2;
          for (; t2.prev !== t2.next; ) {
            const l2 = t2.prev, u2 = t2.next;
            if (s2 ? jl2(t2, n2, i2, s2) : ql2(t2)) e2.push(l2.i, t2.i, u2.i), uu2(t2), t2 = u2.next, o2 = u2.next;
            else if ((t2 = u2) === o2) {
              a2 ? 1 === a2 ? Ul2(t2 = Gl2($l2(t2), e2), e2, r2, n2, i2, s2, 2) : 2 === a2 && Xl2(t2, e2, r2, n2, i2, s2) : Ul2($l2(t2), e2, r2, n2, i2, s2, 1);
              break;
            }
          }
        }
        function ql2(t2) {
          const e2 = t2.prev, r2 = t2, n2 = t2.next;
          if (eu2(e2, r2, n2) >= 0) return false;
          const i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = Math.min(i2, s2, a2), h2 = Math.min(o2, l2, u2), p2 = Math.max(i2, s2, a2), f3 = Math.max(o2, l2, u2);
          let d2 = n2.next;
          for (; d2 !== e2; ) {
            if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f3 && Ql2(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && eu2(d2.prev, d2, d2.next) >= 0) return false;
            d2 = d2.next;
          }
          return true;
        }
        function jl2(t2, e2, r2, n2) {
          const i2 = t2.prev, s2 = t2, a2 = t2.next;
          if (eu2(i2, s2, a2) >= 0) return false;
          const o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f3 = Math.min(o2, l2, u2), d2 = Math.min(c2, h2, p2), y3 = Math.max(o2, l2, u2), m2 = Math.max(c2, h2, p2), g2 = Kl2(f3, d2, e2, r2, n2), x2 = Kl2(y3, m2, e2, r2, n2);
          let v2 = t2.prevZ, b2 = t2.nextZ;
          for (; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
            if (v2.x >= f3 && v2.x <= y3 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Ql2(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && eu2(v2.prev, v2, v2.next) >= 0) return false;
            if (v2 = v2.prevZ, b2.x >= f3 && b2.x <= y3 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Ql2(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && eu2(b2.prev, b2, b2.next) >= 0) return false;
            b2 = b2.nextZ;
          }
          for (; v2 && v2.z >= g2; ) {
            if (v2.x >= f3 && v2.x <= y3 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Ql2(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && eu2(v2.prev, v2, v2.next) >= 0) return false;
            v2 = v2.prevZ;
          }
          for (; b2 && b2.z <= x2; ) {
            if (b2.x >= f3 && b2.x <= y3 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Ql2(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && eu2(b2.prev, b2, b2.next) >= 0) return false;
            b2 = b2.nextZ;
          }
          return true;
        }
        function Gl2(t2, e2) {
          let r2 = t2;
          do {
            const n2 = r2.prev, i2 = r2.next.next;
            !ru2(n2, i2) && nu2(n2, r2, r2.next, i2) && au2(n2, i2) && au2(i2, n2) && (e2.push(n2.i, r2.i, i2.i), uu2(r2), uu2(r2.next), r2 = t2 = i2), r2 = r2.next;
          } while (r2 !== t2);
          return $l2(r2);
        }
        function Xl2(t2, e2, r2, n2, i2, s2) {
          let a2 = t2;
          do {
            let t3 = a2.next.next;
            for (; t3 !== a2.prev; ) {
              if (a2.i !== t3.i && tu2(a2, t3)) {
                let o2 = ou2(a2, t3);
                return a2 = $l2(a2, a2.next), o2 = $l2(o2, o2.next), Ul2(a2, e2, r2, n2, i2, s2, 0), void Ul2(o2, e2, r2, n2, i2, s2, 0);
              }
              t3 = t3.next;
            }
            a2 = a2.next;
          } while (a2 !== t2);
        }
        function Yl2(t2, e2) {
          let r2 = t2.x - e2.x;
          return 0 === r2 && (r2 = t2.y - e2.y, 0 === r2) && (r2 = (t2.next.y - t2.y) / (t2.next.x - t2.x) - (e2.next.y - e2.y) / (e2.next.x - e2.x)), r2;
        }
        function Zl2(t2, e2) {
          const r2 = (function(t3, e3) {
            let r3 = e3;
            const n3 = t3.x, i2 = t3.y;
            let s2, a2 = -1 / 0;
            if (ru2(t3, r3)) return r3;
            do {
              if (ru2(t3, r3.next)) return r3.next;
              if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
                const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
                if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3)) return s2;
              }
              r3 = r3.next;
            } while (r3 !== e3);
            if (!s2) return null;
            const o2 = s2, l2 = s2.x, u2 = s2.y;
            let c2 = 1 / 0;
            r3 = s2;
            do {
              if (n3 >= r3.x && r3.x >= l2 && n3 !== r3.x && Jl2(i2 < u2 ? n3 : a2, i2, l2, u2, i2 < u2 ? a2 : n3, i2, r3.x, r3.y)) {
                const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
                au2(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && Hl2(s2, r3))) && (s2 = r3, c2 = e4);
              }
              r3 = r3.next;
            } while (r3 !== o2);
            return s2;
          })(t2, e2);
          if (!r2) return e2;
          const n2 = ou2(r2, t2);
          return $l2(n2, n2.next), $l2(r2, r2.next);
        }
        function Hl2(t2, e2) {
          return eu2(t2.prev, t2, e2.prev) < 0 && eu2(e2.next, t2, t2.next) < 0;
        }
        function Kl2(t2, e2, r2, n2, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function Wl2(t2) {
          let e2 = t2, r2 = t2;
          do {
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          } while (e2 !== t2);
          return r2;
        }
        function Jl2(t2, e2, r2, n2, i2, s2, a2, o2) {
          return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
        }
        function Ql2(t2, e2, r2, n2, i2, s2, a2, o2) {
          return !(t2 === a2 && e2 === o2) && Jl2(t2, e2, r2, n2, i2, s2, a2, o2);
        }
        function tu2(t2, e2) {
          return t2.next.i !== e2.i && t2.prev.i !== e2.i && !(function(t3, e3) {
            let r2 = t3;
            do {
              if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && nu2(r2, r2.next, t3, e3)) return true;
              r2 = r2.next;
            } while (r2 !== t3);
            return false;
          })(t2, e2) && (au2(t2, e2) && au2(e2, t2) && (function(t3, e3) {
            let r2 = t3, n2 = false;
            const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
            do {
              r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            } while (r2 !== t3);
            return n2;
          })(t2, e2) && (eu2(t2.prev, t2, e2.prev) || eu2(t2, e2.prev, e2)) || ru2(t2, e2) && eu2(t2.prev, t2, t2.next) > 0 && eu2(e2.prev, e2, e2.next) > 0);
        }
        function eu2(t2, e2, r2) {
          return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
        }
        function ru2(t2, e2) {
          return t2.x === e2.x && t2.y === e2.y;
        }
        function nu2(t2, e2, r2, n2) {
          const i2 = su2(eu2(t2, e2, r2)), s2 = su2(eu2(t2, e2, n2)), a2 = su2(eu2(r2, n2, t2)), o2 = su2(eu2(r2, n2, e2));
          return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !iu2(t2, r2, e2)) || !(0 !== s2 || !iu2(t2, n2, e2)) || !(0 !== a2 || !iu2(r2, t2, n2)) || !(0 !== o2 || !iu2(r2, e2, n2));
        }
        function iu2(t2, e2, r2) {
          return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
        }
        function su2(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function au2(t2, e2) {
          return eu2(t2.prev, t2, t2.next) < 0 ? eu2(t2, e2, t2.next) >= 0 && eu2(t2, t2.prev, e2) >= 0 : eu2(t2, e2, t2.prev) < 0 || eu2(t2, t2.next, e2) < 0;
        }
        function ou2(t2, e2) {
          const r2 = cu2(t2.i, t2.x, t2.y), n2 = cu2(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
          return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
        }
        function lu2(t2, e2, r2, n2) {
          const i2 = cu2(t2, e2, r2);
          return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function uu2(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function cu2(t2, e2, r2) {
          return { i: t2, x: e2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        class hu2 {
          constructor(t2, e2) {
            if (e2 > t2) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t2, this._minGranularity = e2;
          }
          getGranularityForZoomLevel(t2) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t2)), this._minGranularity, 1);
          }
        }
        class pu2 {
          constructor(t2) {
            this.fill = t2.fill, this.line = t2.line, this.tile = t2.tile, this.stencil = t2.stencil, this.circle = t2.circle;
          }
        }
        pu2.noSubdivision = new pu2({ fill: new hu2(0, 0), line: new hu2(0, 0), tile: new hu2(0, 0), stencil: new hu2(0, 0), circle: 1 }), ps2("SubdivisionGranularityExpression", hu2), ps2("SubdivisionGranularitySetting", pu2);
        const fu2 = -32768, du2 = 32767;
        class yu2 {
          constructor(t2, e2) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t2, this._granularityCellSize = M2 / t2, this._canonical = e2;
          }
          _getKey(t2, e2) {
            return (t2 += 32768) << 16 | e2 + 32768;
          }
          _vertexToIndex(t2, e2) {
            if (t2 < -32768 || e2 < -32768 || t2 > 32767 || e2 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const r2 = 0 | Math.round(t2), n2 = 0 | Math.round(e2), i2 = this._getKey(r2, n2);
            if (this._vertexDictionary.has(i2)) return this._vertexDictionary.get(i2);
            const s2 = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(i2, s2), this._vertexBuffer.push(r2, n2), s2;
          }
          _subdivideTrianglesScanline(t2) {
            if (this._granularity < 2) return (function(t3, e3) {
              const r3 = [];
              for (let n2 = 0; n2 < e3.length; n2 += 3) {
                const i2 = e3[n2], s2 = e3[n2 + 1], a2 = e3[n2 + 2], o2 = t3[2 * i2], l2 = t3[2 * i2 + 1];
                (t3[2 * s2] - o2) * (t3[2 * a2 + 1] - l2) - (t3[2 * s2 + 1] - l2) * (t3[2 * a2] - o2) > 0 ? (r3.push(i2), r3.push(a2), r3.push(s2)) : (r3.push(i2), r3.push(s2), r3.push(a2));
              }
              return r3;
            })(this._vertexBuffer, t2);
            const e2 = [], r2 = t2.length;
            for (let n2 = 0; n2 < r2; n2 += 3) {
              const r3 = [t2[n2 + 0], t2[n2 + 1], t2[n2 + 2]], i2 = [this._vertexBuffer[2 * t2[n2 + 0] + 0], this._vertexBuffer[2 * t2[n2 + 0] + 1], this._vertexBuffer[2 * t2[n2 + 1] + 0], this._vertexBuffer[2 * t2[n2 + 1] + 1], this._vertexBuffer[2 * t2[n2 + 2] + 0], this._vertexBuffer[2 * t2[n2 + 2] + 1]];
              let s2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, l2 = -1 / 0;
              for (let t3 = 0; t3 < 3; t3++) {
                const e3 = i2[2 * t3], r4 = i2[2 * t3 + 1];
                s2 = Math.min(s2, e3), o2 = Math.max(o2, e3), a2 = Math.min(a2, r4), l2 = Math.max(l2, r4);
              }
              if (s2 === o2 || a2 === l2) continue;
              const u2 = Math.floor(s2 / this._granularityCellSize), c2 = Math.ceil(o2 / this._granularityCellSize), h2 = Math.floor(a2 / this._granularityCellSize), p2 = Math.ceil(l2 / this._granularityCellSize);
              if (u2 !== c2 || h2 !== p2) for (let t3 = h2; t3 < p2; t3++) {
                const n3 = this._scanlineGenerateVertexRingForCellRow(t3, i2, r3);
                xu2(this._vertexBuffer, n3, e2);
              }
              else e2.push(...r3);
            }
            return e2;
          }
          _scanlineGenerateVertexRingForCellRow(t2, e2, r2) {
            const n2 = t2 * this._granularityCellSize, i2 = n2 + this._granularityCellSize, s2 = [];
            for (let t3 = 0; t3 < 3; t3++) {
              const a2 = e2[2 * t3], o2 = e2[2 * t3 + 1], l2 = e2[2 * (t3 + 1) % 6], u2 = e2[(2 * (t3 + 1) + 1) % 6], c2 = e2[2 * (t3 + 2) % 6], h2 = e2[(2 * (t3 + 2) + 1) % 6], p2 = l2 - a2, f3 = u2 - o2, d2 = 0 === p2, y3 = 0 === f3, m2 = (n2 - o2) / f3, g2 = (i2 - o2) / f3, x2 = Math.min(m2, g2), v2 = Math.max(m2, g2);
              if (!y3 && (x2 >= 1 || v2 <= 0) || y3 && (o2 < n2 || o2 > i2)) {
                u2 >= n2 && u2 <= i2 && s2.push(r2[(t3 + 1) % 3]);
                continue;
              }
              !y3 && x2 > 0 && s2.push(this._vertexToIndex(a2 + p2 * x2, o2 + f3 * x2));
              const b2 = a2 + p2 * Math.max(x2, 0), w3 = a2 + p2 * Math.min(v2, 1);
              d2 || this._generateIntraEdgeVertices(s2, a2, o2, l2, u2, b2, w3), !y3 && v2 < 1 && s2.push(this._vertexToIndex(a2 + p2 * v2, o2 + f3 * v2)), (y3 || u2 >= n2 && u2 <= i2) && s2.push(r2[(t3 + 1) % 3]), !y3 && (u2 <= n2 || u2 >= i2) && this._generateInterEdgeVertices(s2, a2, o2, l2, u2, c2, h2, w3, n2, i2);
            }
            return s2;
          }
          _generateIntraEdgeVertices(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = n2 - e2, l2 = i2 - r2, u2 = 0 === l2, c2 = u2 ? Math.min(e2, n2) : Math.min(s2, a2), h2 = u2 ? Math.max(e2, n2) : Math.max(s2, a2), p2 = Math.floor(c2 / this._granularityCellSize) + 1, f3 = Math.ceil(h2 / this._granularityCellSize) - 1;
            if (u2 ? e2 < n2 : s2 < a2) for (let n3 = p2; n3 <= f3; n3++) {
              const i3 = n3 * this._granularityCellSize;
              t2.push(this._vertexToIndex(i3, r2 + l2 * (i3 - e2) / o2));
            }
            else for (let n3 = f3; n3 >= p2; n3--) {
              const i3 = n3 * this._granularityCellSize;
              t2.push(this._vertexToIndex(i3, r2 + l2 * (i3 - e2) / o2));
            }
          }
          _generateInterEdgeVertices(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = i2 - r2, h2 = s2 - n2, p2 = a2 - i2, f3 = (l2 - i2) / p2, d2 = (u2 - i2) / p2, y3 = Math.min(f3, d2), m2 = Math.max(f3, d2), g2 = n2 + h2 * y3;
            let x2 = Math.floor(Math.min(g2, o2) / this._granularityCellSize) + 1, v2 = Math.ceil(Math.max(g2, o2) / this._granularityCellSize) - 1, b2 = o2 < g2;
            const w3 = 0 === p2;
            if (w3 && (a2 === l2 || a2 === u2)) return;
            if (w3 || y3 >= 1 || m2 <= 0) {
              const t3 = r2 - a2, n3 = s2 + (e2 - s2) * Math.min((l2 - a2) / t3, (u2 - a2) / t3);
              x2 = Math.floor(Math.min(n3, o2) / this._granularityCellSize) + 1, v2 = Math.ceil(Math.max(n3, o2) / this._granularityCellSize) - 1, b2 = o2 < n3;
            }
            const _3 = c2 > 0 ? u2 : l2;
            if (b2) for (let e3 = x2; e3 <= v2; e3++) t2.push(this._vertexToIndex(e3 * this._granularityCellSize, _3));
            else for (let e3 = v2; e3 >= x2; e3--) t2.push(this._vertexToIndex(e3 * this._granularityCellSize, _3));
          }
          _generateOutline(t2) {
            const e2 = [];
            for (const r2 of t2) {
              const t3 = gu2(r2, this._granularity, true), n2 = this._pointArrayToIndices(t3), i2 = [];
              for (let t4 = 1; t4 < n2.length; t4++) i2.push(n2[t4 - 1]), i2.push(n2[t4]);
              e2.push(i2);
            }
            return e2;
          }
          _handlePoles(t2) {
            let e2 = false, r2 = false;
            this._canonical && (0 === this._canonical.y && (e2 = true), this._canonical.y === (1 << this._canonical.z) - 1 && (r2 = true)), (e2 || r2) && this._fillPoles(t2, e2, r2);
          }
          _ensureNoPoleVertices() {
            const t2 = this._vertexBuffer;
            for (let e2 = 0; e2 < t2.length; e2 += 2) {
              const r2 = t2[e2 + 1];
              r2 === fu2 && (t2[e2 + 1] = -32767), r2 === du2 && (t2[e2 + 1] = 32766);
            }
          }
          _generatePoleQuad(t2, e2, r2, n2, i2, s2) {
            n2 > i2 != (s2 === fu2) ? (t2.push(e2), t2.push(r2), t2.push(this._vertexToIndex(n2, s2)), t2.push(r2), t2.push(this._vertexToIndex(i2, s2)), t2.push(this._vertexToIndex(n2, s2))) : (t2.push(r2), t2.push(e2), t2.push(this._vertexToIndex(n2, s2)), t2.push(this._vertexToIndex(i2, s2)), t2.push(r2), t2.push(this._vertexToIndex(n2, s2)));
          }
          _fillPoles(t2, e2, r2) {
            const n2 = this._vertexBuffer, i2 = M2, s2 = t2.length;
            for (let a2 = 2; a2 < s2; a2 += 3) {
              const s3 = t2[a2 - 2], o2 = t2[a2 - 1], l2 = t2[a2], u2 = n2[2 * s3], c2 = n2[2 * s3 + 1], h2 = n2[2 * o2], p2 = n2[2 * o2 + 1], f3 = n2[2 * l2], d2 = n2[2 * l2 + 1];
              e2 && (0 === c2 && 0 === p2 && this._generatePoleQuad(t2, s3, o2, u2, h2, fu2), 0 === p2 && 0 === d2 && this._generatePoleQuad(t2, o2, l2, h2, f3, fu2), 0 === d2 && 0 === c2 && this._generatePoleQuad(t2, l2, s3, f3, u2, fu2)), r2 && (c2 === i2 && p2 === i2 && this._generatePoleQuad(t2, s3, o2, u2, h2, du2), p2 === i2 && d2 === i2 && this._generatePoleQuad(t2, o2, l2, h2, f3, du2), d2 === i2 && c2 === i2 && this._generatePoleQuad(t2, l2, s3, f3, u2, du2));
            }
          }
          _initializeVertices(t2) {
            for (let e2 = 0; e2 < t2.length; e2 += 2) this._vertexToIndex(t2[e2], t2[e2 + 1]);
          }
          subdividePolygonInternal(t2, e2) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = true;
            const { flattened: r2, holeIndices: n2 } = (function(t3) {
              const e3 = [], r3 = [];
              for (const n3 of t3) if (0 !== n3.length) {
                n3 !== t3[0] && e3.push(r3.length / 2);
                for (let t4 = 0; t4 < n3.length; t4++) r3.push(n3[t4].x), r3.push(n3[t4].y);
              }
              return { flattened: r3, holeIndices: e3 };
            })(t2);
            let i2;
            this._initializeVertices(r2);
            try {
              const t3 = (function(t4, e4, r3 = 2) {
                const n3 = e4 && e4.length, i3 = n3 ? e4[0] * r3 : t4.length;
                let s3 = Nl2(t4, 0, i3, r3, true);
                const a2 = [];
                if (!s3 || s3.next === s3.prev) return a2;
                let o2, l2, u2;
                if (n3 && (s3 = (function(t5, e5, r4, n4) {
                  const i4 = [];
                  for (let r5 = 0, s4 = e5.length; r5 < s4; r5++) {
                    const a3 = Nl2(t5, e5[r5] * n4, r5 < s4 - 1 ? e5[r5 + 1] * n4 : t5.length, n4, false);
                    a3 === a3.next && (a3.steiner = true), i4.push(Wl2(a3));
                  }
                  i4.sort(Yl2);
                  for (let t6 = 0; t6 < i4.length; t6++) r4 = Zl2(i4[t6], r4);
                  return r4;
                })(t4, e4, s3, r3)), t4.length > 80 * r3) {
                  o2 = t4[0], l2 = t4[1];
                  let e5 = o2, n4 = l2;
                  for (let s4 = r3; s4 < i3; s4 += r3) {
                    const r4 = t4[s4], i4 = t4[s4 + 1];
                    r4 < o2 && (o2 = r4), i4 < l2 && (l2 = i4), r4 > e5 && (e5 = r4), i4 > n4 && (n4 = i4);
                  }
                  u2 = Math.max(e5 - o2, n4 - l2), u2 = 0 !== u2 ? 32767 / u2 : 0;
                }
                return Ul2(s3, a2, r3, o2, l2, u2, 0), a2;
              })(r2, n2), e3 = this._convertIndices(r2, t3);
              i2 = this._subdivideTrianglesScanline(e3);
            } catch (t3) {
              console.error(t3);
            }
            let s2 = [];
            return e2 && (s2 = this._generateOutline(t2)), this._ensureNoPoleVertices(), this._handlePoles(i2), { verticesFlattened: this._vertexBuffer, indicesTriangles: i2, indicesLineList: s2 };
          }
          _convertIndices(t2, e2) {
            const r2 = [];
            for (let n2 = 0; n2 < e2.length; n2++) r2.push(this._vertexToIndex(t2[2 * e2[n2]], t2[2 * e2[n2] + 1]));
            return r2;
          }
          _pointArrayToIndices(t2) {
            const e2 = [];
            for (let r2 = 0; r2 < t2.length; r2++) {
              const n2 = t2[r2];
              e2.push(this._vertexToIndex(n2.x, n2.y));
            }
            return e2;
          }
        }
        function mu2(t2, e2, r2, n2 = true) {
          return new yu2(r2, e2).subdividePolygonInternal(t2, n2);
        }
        function gu2(t2, e2, n2 = false) {
          if (!t2 || t2.length < 1) return [];
          if (t2.length < 2) return [];
          const i2 = t2[0], s2 = t2[t2.length - 1], a2 = n2 && (i2.x !== s2.x || i2.y !== s2.y);
          if (e2 < 2) return a2 ? [...t2, t2[0]] : [...t2];
          const o2 = Math.floor(M2 / e2), l2 = [];
          l2.push(new r(t2[0].x, t2[0].y));
          const u2 = t2.length, c2 = a2 ? u2 : u2 - 1;
          for (let e3 = 0; e3 < c2; e3++) {
            const n3 = t2[e3], i3 = e3 < u2 - 1 ? t2[e3 + 1] : t2[0], s3 = n3.x, a3 = n3.y, c3 = i3.x, h2 = i3.y, p2 = s3 !== c3, f3 = a3 !== h2;
            if (!p2 && !f3) continue;
            const d2 = c3 - s3, y3 = h2 - a3, m2 = Math.abs(d2), g2 = Math.abs(y3);
            let x2 = s3, v2 = a3;
            for (; ; ) {
              const t3 = d2 > 0 ? (Math.floor(x2 / o2) + 1) * o2 : (Math.ceil(x2 / o2) - 1) * o2, e4 = y3 > 0 ? (Math.floor(v2 / o2) + 1) * o2 : (Math.ceil(v2 / o2) - 1) * o2, n4 = Math.abs(x2 - t3), i4 = Math.abs(v2 - e4), s4 = Math.abs(x2 - c3), a4 = Math.abs(v2 - h2), u3 = p2 ? n4 / m2 : Number.POSITIVE_INFINITY, b3 = f3 ? i4 / g2 : Number.POSITIVE_INFINITY;
              if ((s4 <= n4 || !p2) && (a4 <= i4 || !f3)) break;
              if (u3 < b3 && p2 || !f3) {
                x2 = t3, v2 += y3 * u3;
                const e5 = new r(x2, Math.round(v2));
                l2[l2.length - 1].x === e5.x && l2[l2.length - 1].y === e5.y || l2.push(e5);
              } else {
                x2 += d2 * b3, v2 = e4;
                const t4 = new r(Math.round(x2), v2);
                l2[l2.length - 1].x === t4.x && l2[l2.length - 1].y === t4.y || l2.push(t4);
              }
            }
            const b2 = new r(c3, h2);
            l2[l2.length - 1].x === b2.x && l2[l2.length - 1].y === b2.y || l2.push(b2);
          }
          return l2;
        }
        function xu2(t2, e2, r2) {
          if (0 === e2.length) throw new Error("Subdivision vertex ring is empty.");
          let n2 = 0, i2 = t2[2 * e2[0]];
          for (let r3 = 1; r3 < e2.length; r3++) {
            const s3 = t2[2 * e2[r3]];
            s3 < i2 && (i2 = s3, n2 = r3);
          }
          const s2 = e2.length;
          let a2 = n2, o2 = (a2 + 1) % s2;
          for (; ; ) {
            const n3 = a2 - 1 >= 0 ? a2 - 1 : s2 - 1, i3 = (o2 + 1) % s2, l2 = t2[2 * e2[n3]], u2 = t2[2 * e2[i3]], c2 = t2[2 * e2[a2]], h2 = t2[2 * e2[a2] + 1], p2 = t2[2 * e2[o2] + 1];
            let f3 = false;
            if (l2 < u2) f3 = true;
            else if (l2 > u2) f3 = false;
            else {
              const r3 = p2 - h2, s3 = -(t2[2 * e2[o2]] - c2), a3 = h2 < p2 ? 1 : -1;
              ((l2 - c2) * r3 + (t2[2 * e2[n3] + 1] - h2) * s3) * a3 > ((u2 - c2) * r3 + (t2[2 * e2[i3] + 1] - h2) * s3) * a3 && (f3 = true);
            }
            if (f3) {
              const t3 = e2[n3], i4 = e2[a2], l3 = e2[o2];
              t3 !== i4 && t3 !== l3 && i4 !== l3 && r2.push(l3, i4, t3), a2--, a2 < 0 && (a2 = s2 - 1);
            } else {
              const t3 = e2[i3], n4 = e2[a2], l3 = e2[o2];
              t3 !== n4 && t3 !== l3 && n4 !== l3 && r2.push(l3, n4, t3), o2++, o2 >= s2 && (o2 = 0);
            }
            if (n3 === i3) break;
          }
        }
        function vu2(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = i2.length / 2, c2 = a2 && o2 && l2;
          if (u2 < io2.MAX_VERTEX_ARRAY_LENGTH) {
            const h2 = e2.prepareSegment(u2, r2, n2), p2 = h2.vertexLength;
            for (let t3 = 0; t3 < s2.length; t3 += 3) n2.emplaceBack(p2 + s2[t3], p2 + s2[t3 + 1], p2 + s2[t3 + 2]);
            let f3, d2;
            h2.vertexLength += u2, h2.primitiveLength += s2.length / 3, c2 && (d2 = a2.prepareSegment(u2, r2, o2), f3 = d2.vertexLength, d2.vertexLength += u2);
            for (let e3 = 0; e3 < i2.length; e3 += 2) t2(i2[e3], i2[e3 + 1]);
            if (c2) for (let t3 = 0; t3 < l2.length; t3++) {
              const e3 = l2[t3];
              for (let t4 = 1; t4 < e3.length; t4 += 2) o2.emplaceBack(f3 + e3[t4 - 1], f3 + e3[t4]);
              d2.primitiveLength += e3.length / 2;
            }
          } else !(function(t3, e3, r3, n3, i3, s3) {
            const a3 = [];
            for (let t4 = 0; t4 < n3.length / 2; t4++) a3.push(-1);
            const o3 = { count: 0 };
            let l3 = 0, u3 = t3.getOrCreateLatestSegment(e3, r3), c3 = u3.vertexLength;
            for (let h2 = 2; h2 < i3.length; h2 += 3) {
              const p2 = i3[h2 - 2], f3 = i3[h2 - 1], d2 = i3[h2];
              let y3 = a3[p2] < l3, m2 = a3[f3] < l3, g2 = a3[d2] < l3;
              u3.vertexLength + ((y3 ? 1 : 0) + (m2 ? 1 : 0) + (g2 ? 1 : 0)) > io2.MAX_VERTEX_ARRAY_LENGTH && (u3 = t3.createNewSegment(e3, r3), l3 = o3.count, y3 = true, m2 = true, g2 = true, c3 = 0);
              const x2 = bu2(a3, n3, s3, o3, p2, y3, u3), v2 = bu2(a3, n3, s3, o3, f3, m2, u3), b2 = bu2(a3, n3, s3, o3, d2, g2, u3);
              r3.emplaceBack(c3 + x2 - l3, c3 + v2 - l3, c3 + b2 - l3), u3.primitiveLength++;
            }
          })(e2, r2, n2, i2, s2, t2), c2 && (function(t3, e3, r3, n3, i3, s3) {
            const a3 = [];
            for (let t4 = 0; t4 < n3.length / 2; t4++) a3.push(-1);
            const o3 = { count: 0 };
            let l3 = 0, u3 = t3.getOrCreateLatestSegment(e3, r3), c3 = u3.vertexLength;
            for (let h2 = 0; h2 < i3.length; h2++) {
              const p2 = i3[h2];
              for (let f3 = 1; f3 < i3[h2].length; f3 += 2) {
                const i4 = p2[f3 - 1], h3 = p2[f3];
                let d2 = a3[i4] < l3, y3 = a3[h3] < l3;
                u3.vertexLength + ((d2 ? 1 : 0) + (y3 ? 1 : 0)) > io2.MAX_VERTEX_ARRAY_LENGTH && (u3 = t3.createNewSegment(e3, r3), l3 = o3.count, d2 = true, y3 = true, c3 = 0);
                const m2 = bu2(a3, n3, s3, o3, i4, d2, u3), g2 = bu2(a3, n3, s3, o3, h3, y3, u3);
                r3.emplaceBack(c3 + m2 - l3, c3 + g2 - l3), u3.primitiveLength++;
              }
            }
          })(a2, r2, o2, i2, l2, t2), e2.forceNewSegmentOnNextPrepare(), null == a2 || a2.forceNewSegmentOnNextPrepare();
        }
        function bu2(t2, e2, r2, n2, i2, s2, a2) {
          if (s2) {
            const s3 = n2.count;
            return r2(e2[2 * i2], e2[2 * i2 + 1]), t2[i2] = n2.count, n2.count++, a2.vertexLength++, s3;
          }
          return t2[i2];
        }
        class wu2 {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(((t3) => t3.id)), this.index = t2.index, this.hasDependencies = false, this.patternFeatures = [], this.layoutVertexArray = new qa2(), this.indexArray = new to2(), this.indexArray2 = new eo2(), this.programConfigurations = new Vo2(t2.layers, t2.zoom), this.segments = new io2(), this.segments2 = new io2(), this.stateDependentLayerIds = this.layers.filter(((t3) => t3.isStateDependent())).map(((t3) => t3.id));
          }
          populate(t2, e2, r2) {
            this.hasDependencies = Ol2("fill", this.layers, e2);
            const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
            for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c2 = $o2(a2, t3);
              if (!this.layers[0]._featureFilter.filter(new Ps2(this.zoom), c2, r2)) continue;
              const h2 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : No2(a2), patterns: {}, sortKey: h2 };
              s2.push(p2);
            }
            i2 && s2.sort(((t3, e3) => t3.sortKey - e3.sortKey));
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasDependencies) {
                const t3 = Rl2("fill", this.layers, n3, { zoom: this.zoom }, e2);
                this.patternFeatures.push(t3);
              } else this.addFeature(n3, i3, s3, r2, {}, e2.subdivisionGranularity);
              e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, { imagePositions: r2 });
          }
          addFeatures(t2, e2, r2) {
            for (const n2 of this.patternFeatures) this.addFeature(n2, n2.geometry, n2.index, e2, r2, t2.subdivisionGranularity);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ll2), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t2, e2, r2, n2, i2, s2) {
            for (const t3 of tn2(e2, 500)) {
              const e3 = mu2(t3, n2, s2.fill.getGranularityForZoomLevel(n2.z)), r3 = this.layoutVertexArray;
              vu2(((t4, e4) => {
                r3.emplaceBack(t4, e4);
              }), this.segments, this.layoutVertexArray, this.indexArray, e3.verticesFlattened, e3.indicesTriangles, this.segments2, this.indexArray2, e3.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, { imagePositions: i2, canonical: n2 });
          }
        }
        let _u2, Su2;
        ps2("FillBucket", wu2, { omit: ["layers", "patternFeatures"] });
        var Au2 = { get paint() {
          return Su2 = Su2 || new Hs2({ "fill-antialias": new js2(vt2.paint_fill["fill-antialias"]), "fill-opacity": new Gs2(vt2.paint_fill["fill-opacity"]), "fill-color": new Gs2(vt2.paint_fill["fill-color"]), "fill-outline-color": new Gs2(vt2.paint_fill["fill-outline-color"]), "fill-translate": new js2(vt2.paint_fill["fill-translate"]), "fill-translate-anchor": new js2(vt2.paint_fill["fill-translate-anchor"]), "fill-pattern": new Xs2(vt2.paint_fill["fill-pattern"]) });
        }, get layout() {
          return _u2 = _u2 || new Hs2({ "fill-sort-key": new Gs2(vt2.layout_fill["fill-sort-key"]) });
        } };
        class ku2 extends Ks2 {
          constructor(t2, e2) {
            super(t2, Au2, e2);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2);
            const r2 = this.paint._values["fill-outline-color"];
            "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t2) {
            return new wu2(t2);
          }
          queryRadius() {
            return nl2(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t2, geometry: e2, transform: r2, pixelsToTileUnits: n2 }) {
            return Yo2(il2(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r2.bearingInRadians, n2), e2);
          }
          isTileClipped() {
            return true;
          }
        }
        const Eu2 = na2([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Tu2 = na2([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Iu2 } = Eu2;
        class Mu2 {
          constructor(t2, e2, r2, n2, i2) {
            this.properties = {}, this.extent = r2, this.type = 0, this.id = void 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Fu2, this, e2);
          }
          loadGeometry() {
            const t2 = this._pbf;
            t2.pos = this._geometry;
            const e2 = t2.readVarint() + t2.pos, n2 = [];
            let i2, s2 = 1, a2 = 0, o2 = 0, l2 = 0;
            for (; t2.pos < e2; ) {
              if (a2 <= 0) {
                const e3 = t2.readVarint();
                s2 = 7 & e3, a2 = e3 >> 3;
              }
              if (a2--, 1 === s2 || 2 === s2) o2 += t2.readSVarint(), l2 += t2.readSVarint(), 1 === s2 && (i2 && n2.push(i2), i2 = []), i2 && i2.push(new r(o2, l2));
              else {
                if (7 !== s2) throw new Error(`unknown command ${s2}`);
                i2 && i2.push(i2[0].clone());
              }
            }
            return i2 && n2.push(i2), n2;
          }
          bbox() {
            const t2 = this._pbf;
            t2.pos = this._geometry;
            const e2 = t2.readVarint() + t2.pos;
            let r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0;
            for (; t2.pos < e2; ) {
              if (n2 <= 0) {
                const e3 = t2.readVarint();
                r2 = 7 & e3, n2 = e3 >> 3;
              }
              if (n2--, 1 === r2 || 2 === r2) i2 += t2.readSVarint(), s2 += t2.readSVarint(), i2 < a2 && (a2 = i2), i2 > o2 && (o2 = i2), s2 < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
              else if (7 !== r2) throw new Error(`unknown command ${r2}`);
            }
            return [a2, l2, o2, u2];
          }
          toGeoJSON(t2, e2, r2) {
            const n2 = this.extent * Math.pow(2, r2), i2 = this.extent * t2, s2 = this.extent * e2, a2 = this.loadGeometry();
            function o2(t3) {
              return [360 * (t3.x + i2) / n2 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t3.y + s2) / n2) * Math.PI)) - 90];
            }
            function l2(t3) {
              return t3.map(o2);
            }
            let u2;
            if (1 === this.type) {
              const t3 = [];
              for (const e4 of a2) t3.push(e4[0]);
              const e3 = l2(t3);
              u2 = 1 === t3.length ? { type: "Point", coordinates: e3[0] } : { type: "MultiPoint", coordinates: e3 };
            } else if (2 === this.type) {
              const t3 = a2.map(l2);
              u2 = 1 === t3.length ? { type: "LineString", coordinates: t3[0] } : { type: "MultiLineString", coordinates: t3 };
            } else {
              if (3 !== this.type) throw new Error("unknown feature type");
              {
                const t3 = Du2(a2), e3 = [];
                for (const r3 of t3) e3.push(r3.map(l2));
                u2 = 1 === e3.length ? { type: "Polygon", coordinates: e3[0] } : { type: "MultiPolygon", coordinates: e3 };
              }
            }
            const c2 = { type: "Feature", geometry: u2, properties: this.properties };
            return null != this.id && (c2.id = this.id), c2;
          }
        }
        function Fu2(t2, e2, r2) {
          1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? (function(t3, e3) {
            const r3 = t3.readVarint() + t3.pos;
            for (; t3.pos < r3; ) {
              const r4 = e3._keys[t3.readVarint()], n2 = e3._values[t3.readVarint()];
              e3.properties[r4] = n2;
            }
          })(r2, e2) : 3 === t2 ? e2.type = r2.readVarint() : 4 === t2 && (e2._geometry = r2.pos);
        }
        function Du2(t2) {
          const e2 = t2.length;
          if (e2 <= 1) return [t2];
          const r2 = [];
          let n2, i2;
          for (let s2 = 0; s2 < e2; s2++) {
            const e3 = zu2(t2[s2]);
            0 !== e3 && (void 0 === i2 && (i2 = e3 < 0), i2 === e3 < 0 ? (n2 && r2.push(n2), n2 = [t2[s2]]) : n2 && n2.push(t2[s2]));
          }
          return n2 && r2.push(n2), r2;
        }
        function zu2(t2) {
          let e2 = 0;
          for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        Mu2.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Pu2 {
          constructor(t2, e2) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(Bu2, this, e2), this.length = this._features.length;
          }
          feature(t2) {
            if (t2 < 0 || t2 >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t2];
            const e2 = this._pbf.readVarint() + this._pbf.pos;
            return new Mu2(this._pbf, e2, this.extent, this._keys, this._values);
          }
        }
        function Bu2(t2, e2, r2) {
          15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push((function(t3) {
            let e3 = null;
            const r3 = t3.readVarint() + t3.pos;
            for (; t3.pos < r3; ) {
              const r4 = t3.readVarint() >> 3;
              e3 = 1 === r4 ? t3.readString() : 2 === r4 ? t3.readFloat() : 3 === r4 ? t3.readDouble() : 4 === r4 ? t3.readVarint64() : 5 === r4 ? t3.readVarint() : 6 === r4 ? t3.readSVarint() : 7 === r4 ? t3.readBoolean() : null;
            }
            if (null == e3) throw new Error("unknown feature value");
            return e3;
          })(r2));
        }
        class Vu2 {
          constructor(t2, e2) {
            this.layers = t2.readFields(Cu2, {}, e2);
          }
        }
        function Cu2(t2, e2, r2) {
          if (3 === t2) {
            const t3 = new Pu2(r2, r2.readVarint() + r2.pos);
            t3.length && (e2[t3.name] = t3);
          }
        }
        const Lu2 = Math.pow(2, 13);
        function Ou2(t2, e2, r2, n2, i2, s2, a2, o2) {
          t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * Lu2) + a2, i2 * Lu2 * 2, s2 * Lu2 * 2, Math.round(o2));
        }
        class Ru2 {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(((t3) => t3.id)), this.index = t2.index, this.hasDependencies = false, this.layoutVertexArray = new ja2(), this.centroidVertexArray = new $a2(), this.indexArray = new to2(), this.programConfigurations = new Vo2(t2.layers, t2.zoom), this.segments = new io2(), this.stateDependentLayerIds = this.layers.filter(((t3) => t3.isStateDependent())).map(((t3) => t3.id));
          }
          populate(t2, e2, r2) {
            this.features = [], this.hasDependencies = Ol2("fill-extrusion", this.layers, e2);
            for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, o2 = $o2(n2, t3);
              if (!this.layers[0]._featureFilter.filter(new Ps2(this.zoom), o2, r2)) continue;
              const l2 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : No2(n2), properties: n2.properties, type: n2.type, patterns: {} };
              this.hasDependencies ? this.features.push(Rl2("fill-extrusion", this.layers, l2, { zoom: this.zoom }, e2)) : this.addFeature(l2, l2.geometry, s2, r2, {}, e2.subdivisionGranularity), e2.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, true);
            }
          }
          addFeatures(t2, e2, r2) {
            for (const n2 of this.features) {
              const { geometry: i2 } = n2;
              this.addFeature(n2, i2, n2.index, e2, r2, t2.subdivisionGranularity);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, { imagePositions: r2 });
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Iu2), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Tu2.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t2, e2, r2, n2, i2, s2) {
            for (const r3 of tn2(e2, 500)) {
              const e3 = { x: 0, y: 0, sampleCount: 0 }, i3 = this.layoutVertexArray.length;
              this.processPolygon(e3, n2, t2, r3, s2);
              const a2 = this.layoutVertexArray.length - i3, o2 = Math.floor(e3.x / e3.sampleCount), l2 = Math.floor(e3.y / e3.sampleCount);
              for (let t3 = 0; t3 < a2; t3++) this.centroidVertexArray.emplaceBack(o2, l2);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, { imagePositions: i2, canonical: n2 });
          }
          processPolygon(t2, e2, r2, n2, i2) {
            if (n2.length < 1) return;
            if (Uu2(n2[0])) return;
            for (const e3 of n2) 0 !== e3.length && Nu2(t2, e3);
            const s2 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a2 = i2.fill.getGranularityForZoomLevel(e2.z), o2 = "Polygon" === Mu2.types[r2.type];
            for (const t3 of n2) {
              if (0 === t3.length) continue;
              if (Uu2(t3)) continue;
              const e3 = gu2(t3, a2, o2);
              this._generateSideFaces(e3, s2);
            }
            if (!o2) return;
            const l2 = mu2(n2, e2, a2, false), u2 = this.layoutVertexArray;
            vu2(((t3, e3) => {
              Ou2(u2, t3, e3, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, l2.verticesFlattened, l2.indicesTriangles);
          }
          _generateSideFaces(t2, e2) {
            let r2 = 0;
            for (let n2 = 1; n2 < t2.length; n2++) {
              const i2 = t2[n2], s2 = t2[n2 - 1];
              if ($u2(i2, s2)) continue;
              e2.segment.vertexLength + 4 > io2.MAX_VERTEX_ARRAY_LENGTH && (e2.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const a2 = i2.sub(s2)._perp()._unit(), o2 = s2.dist(i2);
              r2 + o2 > 32768 && (r2 = 0), Ou2(this.layoutVertexArray, i2.x, i2.y, a2.x, a2.y, 0, 0, r2), Ou2(this.layoutVertexArray, i2.x, i2.y, a2.x, a2.y, 0, 1, r2), r2 += o2, Ou2(this.layoutVertexArray, s2.x, s2.y, a2.x, a2.y, 0, 0, r2), Ou2(this.layoutVertexArray, s2.x, s2.y, a2.x, a2.y, 0, 1, r2);
              const l2 = e2.segment.vertexLength;
              this.indexArray.emplaceBack(l2, l2 + 2, l2 + 1), this.indexArray.emplaceBack(l2 + 1, l2 + 2, l2 + 3), e2.segment.vertexLength += 4, e2.segment.primitiveLength += 2;
            }
          }
        }
        function Nu2(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n2 = e2[r2];
            r2 === e2.length - 1 && e2[0].x === n2.x && e2[0].y === n2.y || (t2.x += n2.x, t2.y += n2.y, t2.sampleCount++);
          }
        }
        function $u2(t2, e2) {
          return t2.x === e2.x && (t2.x < 0 || t2.x > M2) || t2.y === e2.y && (t2.y < 0 || t2.y > M2);
        }
        function Uu2(t2) {
          return t2.every(((t3) => t3.x < 0)) || t2.every(((t3) => t3.x > M2)) || t2.every(((t3) => t3.y < 0)) || t2.every(((t3) => t3.y > M2));
        }
        let qu2;
        ps2("FillExtrusionBucket", Ru2, { omit: ["layers", "features"] });
        var ju2 = { get paint() {
          return qu2 = qu2 || new Hs2({ "fill-extrusion-opacity": new js2(vt2["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Gs2(vt2["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new js2(vt2["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new js2(vt2["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Xs2(vt2["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Gs2(vt2["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Gs2(vt2["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new js2(vt2["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class Gu2 extends Ks2 {
          constructor(t2, e2) {
            super(t2, ju2, e2);
          }
          createBucket(t2) {
            return new Ru2(t2);
          }
          queryRadius() {
            return nl2(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: n2, geometry: i2, transform: s2, pixelsToTileUnits: a2, pixelPosMatrix: o2 }) {
            const l2 = il2(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -s2.bearingInRadians, a2), u2 = this.paint.get("fill-extrusion-height").evaluate(e2, n2), c2 = this.paint.get("fill-extrusion-base").evaluate(e2, n2), h2 = (function(t3, e3) {
              const n3 = [];
              for (const i3 of t3) {
                const t4 = [i3.x, i3.y, 0, 1];
                A(t4, t4, e3), n3.push(new r(t4[0] / t4[3], t4[1] / t4[3]));
              }
              return n3;
            })(l2, o2), p2 = (function(t3, e3, n3, i3) {
              const s3 = [], a3 = [], o3 = i3[8] * e3, l3 = i3[9] * e3, u3 = i3[10] * e3, c3 = i3[11] * e3, h3 = i3[8] * n3, p3 = i3[9] * n3, f3 = i3[10] * n3, d2 = i3[11] * n3;
              for (const e4 of t3) {
                const t4 = [], n4 = [];
                for (const s4 of e4) {
                  const e5 = s4.x, a4 = s4.y, y3 = i3[0] * e5 + i3[4] * a4 + i3[12], m2 = i3[1] * e5 + i3[5] * a4 + i3[13], g2 = i3[2] * e5 + i3[6] * a4 + i3[14], x2 = i3[3] * e5 + i3[7] * a4 + i3[15], v2 = g2 + u3, b2 = x2 + c3, w3 = y3 + h3, _3 = m2 + p3, S3 = g2 + f3, A2 = x2 + d2, k3 = new r((y3 + o3) / b2, (m2 + l3) / b2);
                  k3.z = v2 / b2, t4.push(k3);
                  const E2 = new r(w3 / A2, _3 / A2);
                  E2.z = S3 / A2, n4.push(E2);
                }
                s3.push(t4), a3.push(n4);
              }
              return [s3, a3];
            })(i2, c2, u2, o2);
            return (function(t3, e3, r2) {
              let n3 = 1 / 0;
              Yo2(r2, e3) && (n3 = Yu2(r2, e3[0]));
              for (let i3 = 0; i3 < e3.length; i3++) {
                const s3 = e3[i3], a3 = t3[i3];
                for (let t4 = 0; t4 < s3.length - 1; t4++) {
                  const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                  Go2(r2, i4) && (n3 = Math.min(n3, Yu2(r2, i4)));
                }
              }
              return n3 !== 1 / 0 && n3;
            })(p2[0], p2[1], h2);
          }
        }
        function Xu2(t2, e2) {
          return t2.x * e2.x + t2.y * e2.y;
        }
        function Yu2(t2, e2) {
          if (1 === t2.length) {
            let r2 = 0;
            const n2 = e2[r2++];
            let i2;
            for (; !i2 || n2.equals(i2); ) if (i2 = e2[r2++], !i2) return 1 / 0;
            for (; r2 < e2.length; r2++) {
              const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Xu2(o2, o2), h2 = Xu2(o2, l2), p2 = Xu2(l2, l2), f3 = Xu2(u2, o2), d2 = Xu2(u2, l2), y3 = c2 * p2 - h2 * h2, m2 = (p2 * f3 - h2 * d2) / y3, g2 = (c2 * d2 - h2 * f3) / y3, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
              if (isFinite(x2)) return x2;
            }
            return 1 / 0;
          }
          {
            let t3 = 1 / 0;
            for (const r2 of e2) t3 = Math.min(t3, r2.z);
            return t3;
          }
        }
        const Zu2 = na2([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Hu2 } = Zu2, Ku2 = na2([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Wu2 } = Ku2, Ju2 = Math.cos(Math.PI / 180 * 37.5), Qu2 = Math.pow(2, 14) / 0.5;
        class tc2 {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(((t3) => t3.id)), this.index = t2.index, this.hasDependencies = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((t3) => {
              this.gradients[t3.id] = {};
            })), this.layoutVertexArray = new Ga2(), this.layoutVertexArray2 = new Xa(), this.indexArray = new to2(), this.programConfigurations = new Vo2(t2.layers, t2.zoom), this.segments = new io2(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((t3) => t3.isStateDependent())).map(((t3) => t3.id));
          }
          populate(t2, e2, r2) {
            this.hasDependencies = Ol2("line", this.layers, e2) || this.hasLineDasharray(this.layers);
            const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
            for (const { feature: e3, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = $o2(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new Ps2(this.zoom), u2, r2)) continue;
              const c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: a2, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : No2(e3), patterns: {}, dashes: {}, sortKey: c2 };
              s2.push(h2);
            }
            i2 && s2.sort(((t3, e3) => t3.sortKey - e3.sortKey));
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              this.hasDependencies ? (Ol2("line", this.layers, e2) ? Rl2("line", this.layers, n3, { zoom: this.zoom }, e2) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, n3, this.zoom, e2), this.patternFeatures.push(n3)) : this.addFeature(n3, i3, s3, r2, {}, {}, e2.subdivisionGranularity), e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e2, r2, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, { imagePositions: r2, dashPositions: n2 });
          }
          addFeatures(t2, e2, r2, n2) {
            for (const i2 of this.patternFeatures) this.addFeature(i2, i2.geometry, i2.index, e2, r2, n2, t2.subdivisionGranularity);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Wu2)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Hu2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t2) {
            if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end")) return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
          }
          addFeature(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = this.layers[0].layout, l2 = o2.get("line-join").evaluate(t2, {}), u2 = o2.get("line-cap"), c2 = o2.get("line-miter-limit"), h2 = o2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2);
            for (const r3 of e2) this.addLine(r3, t2, l2, u2, c2, h2, n2, a2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, { imagePositions: i2, dashPositions: s2, canonical: n2 });
          }
          addLine(t2, e2, r2, n2, i2, s2, a2, o2) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t2 = gu2(t2, a2 ? o2.line.getGranularityForZoomLevel(a2.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e3 = 0; e3 < t2.length - 1; e3++) this.totalDistance += t2[e3].dist(t2[e3 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const l2 = "Polygon" === Mu2.types[e2.type];
            let u2 = t2.length;
            for (; u2 >= 2 && t2[u2 - 1].equals(t2[u2 - 2]); ) u2--;
            let c2 = 0;
            for (; c2 < u2 - 1 && t2[c2].equals(t2[c2 + 1]); ) c2++;
            if (u2 < (l2 ? 3 : 2)) return;
            "bevel" === r2 && (i2 = 1.05);
            const h2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, p2 = this.segments.prepareSegment(10 * u2, this.layoutVertexArray, this.indexArray);
            let f3, d2, y3, m2, g2;
            this.e1 = this.e2 = -1, l2 && (f3 = t2[u2 - 2], g2 = t2[c2].sub(f3)._unit()._perp());
            for (let e3 = c2; e3 < u2; e3++) {
              if (y3 = e3 === u2 - 1 ? l2 ? t2[c2 + 1] : void 0 : t2[e3 + 1], y3 && t2[e3].equals(y3)) continue;
              g2 && (m2 = g2), f3 && (d2 = f3), f3 = t2[e3], g2 = y3 ? y3.sub(f3)._unit()._perp() : m2, m2 = m2 || g2;
              let a3 = m2.add(g2);
              0 === a3.x && 0 === a3.y || a3._unit();
              const o3 = m2.x * g2.x + m2.y * g2.y, x2 = a3.x * g2.x + a3.y * g2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w3 = x2 < Ju2 && d2 && y3, _3 = m2.x * g2.y - m2.y * g2.x > 0;
              if (w3 && e3 > c2) {
                const t3 = f3.dist(d2);
                if (t3 > 2 * h2) {
                  const e4 = f3.sub(f3.sub(d2)._mult(h2 / t3)._round());
                  this.updateDistance(d2, e4), this.addCurrentVertex(e4, m2, 0, 0, p2), d2 = e4;
                }
              }
              const S3 = d2 && y3;
              let A2 = S3 ? r2 : l2 ? "butt" : n2;
              if (S3 && "round" === A2 && (v2 < s2 ? A2 = "miter" : v2 <= 2 && (A2 = "fakeround")), "miter" === A2 && v2 > i2 && (A2 = "bevel"), "bevel" === A2 && (v2 > 2 && (A2 = "flipbevel"), v2 < i2 && (A2 = "miter")), d2 && this.updateDistance(d2, f3), "miter" === A2) a3._mult(v2), this.addCurrentVertex(f3, a3, 0, 0, p2);
              else if ("flipbevel" === A2) {
                if (v2 > 100) a3 = g2.mult(-1);
                else {
                  const t3 = v2 * m2.add(g2).mag() / m2.sub(g2).mag();
                  a3._perp()._mult(t3 * (_3 ? -1 : 1));
                }
                this.addCurrentVertex(f3, a3, 0, 0, p2), this.addCurrentVertex(f3, a3.mult(-1), 0, 0, p2);
              } else if ("bevel" === A2 || "fakeround" === A2) {
                const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _3 ? t3 : 0, r3 = _3 ? 0 : t3;
                if (d2 && this.addCurrentVertex(f3, m2, e4, r3, p2), "fakeround" === A2) {
                  const t4 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e5 = 1; e5 < t4; e5++) {
                    let r4 = e5 / t4;
                    if (0.5 !== r4) {
                      const t5 = r4 - 0.5;
                      r4 += r4 * t5 * (r4 - 1) * ((1.0904 + o3 * (o3 * (3.55645 - 1.43519 * o3) - 3.2452)) * t5 * t5 + (0.848013 + o3 * (0.215638 * o3 - 1.06021)));
                    }
                    const n3 = g2.sub(m2)._mult(r4)._add(m2)._unit()._mult(_3 ? -1 : 1);
                    this.addHalfVertex(f3, n3.x, n3.y, false, _3, 0, p2);
                  }
                }
                y3 && this.addCurrentVertex(f3, g2, -e4, -r3, p2);
              } else if ("butt" === A2) this.addCurrentVertex(f3, a3, 0, 0, p2);
              else if ("square" === A2) {
                const t3 = d2 ? 1 : -1;
                this.addCurrentVertex(f3, a3, t3, t3, p2);
              } else "round" === A2 && (d2 && (this.addCurrentVertex(f3, m2, 0, 0, p2), this.addCurrentVertex(f3, m2, 1, 1, p2, true)), y3 && (this.addCurrentVertex(f3, g2, -1, -1, p2, true), this.addCurrentVertex(f3, g2, 0, 0, p2)));
              if (w3 && e3 < u2 - 1) {
                const t3 = f3.dist(y3);
                if (t3 > 2 * h2) {
                  const e4 = f3.add(y3.sub(f3)._mult(h2 / t3)._round());
                  this.updateDistance(f3, e4), this.addCurrentVertex(e4, g2, 0, 0, p2), f3 = e4;
                }
              }
            }
          }
          addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
            const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
            this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > Qu2 / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t2, e2, r2, n2, i2, s2));
          }
          addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
            const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Qu2 - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const u2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u2, this.e2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t2, e2) {
            this.distance += t2.dist(e2), this.updateScaledDistance();
          }
          hasLineDasharray(t2) {
            for (const e2 of t2) {
              const t3 = e2.paint.get("line-dasharray");
              if (t3 && !t3.isConstant()) return true;
            }
            return false;
          }
          addLineDashDependencies(t2, e2, r2, n2) {
            for (const i2 of t2) {
              const t3 = i2.paint.get("line-dasharray");
              if (!t3 || "constant" === t3.value.kind) continue;
              const s2 = "round" === i2.layout.get("line-cap"), a2 = { dasharray: t3.value.evaluate({ zoom: r2 - 1 }, e2, {}), round: s2 }, o2 = { dasharray: t3.value.evaluate({ zoom: r2 }, e2, {}), round: s2 }, l2 = { dasharray: t3.value.evaluate({ zoom: r2 + 1 }, e2, {}), round: s2 }, u2 = `${a2.dasharray.join(",")},${a2.round}`, c2 = `${o2.dasharray.join(",")},${o2.round}`, h2 = `${l2.dasharray.join(",")},${l2.round}`;
              n2.dashDependencies[u2] = a2, n2.dashDependencies[c2] = o2, n2.dashDependencies[h2] = l2, e2.dashes[i2.id] = { min: u2, mid: c2, max: h2 };
            }
          }
        }
        let ec2, rc2;
        ps2("LineBucket", tc2, { omit: ["layers", "patternFeatures"] });
        var nc2 = { get paint() {
          return rc2 = rc2 || new Hs2({ "line-opacity": new Gs2(vt2.paint_line["line-opacity"]), "line-color": new Gs2(vt2.paint_line["line-color"]), "line-translate": new js2(vt2.paint_line["line-translate"]), "line-translate-anchor": new js2(vt2.paint_line["line-translate-anchor"]), "line-width": new Gs2(vt2.paint_line["line-width"]), "line-gap-width": new Gs2(vt2.paint_line["line-gap-width"]), "line-offset": new Gs2(vt2.paint_line["line-offset"]), "line-blur": new Gs2(vt2.paint_line["line-blur"]), "line-dasharray": new Xs2(vt2.paint_line["line-dasharray"]), "line-pattern": new Xs2(vt2.paint_line["line-pattern"]), "line-gradient": new Zs2(vt2.paint_line["line-gradient"]) });
        }, get layout() {
          return ec2 = ec2 || new Hs2({ "line-cap": new js2(vt2.layout_line["line-cap"]), "line-join": new Gs2(vt2.layout_line["line-join"]), "line-miter-limit": new js2(vt2.layout_line["line-miter-limit"]), "line-round-limit": new js2(vt2.layout_line["line-round-limit"]), "line-sort-key": new Gs2(vt2.layout_line["line-sort-key"]) });
        } };
        class ic2 extends Gs2 {
          possiblyEvaluate(t2, e2) {
            return e2 = new Ps2(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
          }
          evaluate(t2, e2, r2, n2) {
            return e2 = O2({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
          }
        }
        let sc2;
        class ac2 extends Ks2 {
          constructor(t2, e2) {
            super(t2, nc2, e2), this.gradientVersion = 0, sc2 || (sc2 = new ic2(nc2.paint.properties["line-width"].specification), sc2.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            if ("line-gradient" === t2) {
              const t3 = this.gradientExpression();
              this.stepInterpolant = !!(function(t4) {
                return void 0 !== t4._styleExpression;
              })(t3) && t3._styleExpression.expression instanceof or2, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = sc2.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
          }
          createBucket(t2) {
            return new tc2(t2);
          }
          queryRadius(t2) {
            const e2 = t2, r2 = oc2(rl2("line-width", this, e2), rl2("line-gap-width", this, e2)), n2 = rl2("line-offset", this, e2);
            return r2 / 2 + Math.abs(n2) + nl2(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: n2, geometry: i2, transform: s2, pixelsToTileUnits: a2 }) {
            const o2 = il2(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -s2.bearingInRadians, a2), l2 = a2 / 2 * oc2(this.paint.get("line-width").evaluate(e2, n2), this.paint.get("line-gap-width").evaluate(e2, n2)), u2 = this.paint.get("line-offset").evaluate(e2, n2);
            return u2 && (i2 = (function(t3, e3) {
              const n3 = [];
              for (let i3 = 0; i3 < t3.length; i3++) {
                const s3 = sl2(t3[i3]), a3 = [];
                for (let t4 = 0; t4 < s3.length; t4++) {
                  const n4 = s3[t4], i4 = s3[t4 - 1], o3 = s3[t4 + 1], l3 = 0 === t4 ? new r(0, 0) : n4.sub(i4)._unit()._perp(), u3 = t4 === s3.length - 1 ? new r(0, 0) : o3.sub(n4)._unit()._perp(), c2 = l3._add(u3)._unit(), h2 = c2.x * u3.x + c2.y * u3.y;
                  0 !== h2 && c2._mult(1 / h2), a3.push(c2._mult(e3)._add(n4));
                }
                n3.push(a3);
              }
              return n3;
            })(i2, u2 * a2)), (function(t3, e3, r2) {
              for (let n3 = 0; n3 < e3.length; n3++) {
                const i3 = e3[n3];
                if (t3.length >= 3) {
                  for (let e4 = 0; e4 < i3.length; e4++) if (tl2(t3, i3[e4])) return true;
                }
                if (Zo2(t3, i3, r2)) return true;
              }
              return false;
            })(o2, i2, l2);
          }
          isTileClipped() {
            return true;
          }
        }
        function oc2(t2, e2) {
          return e2 > 0 ? e2 + 2 * t2 : t2;
        }
        const lc2 = na2([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), uc2 = na2([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        na2([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const cc2 = na2([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        na2([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const hc2 = na2([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), pc2 = na2([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function fc2(t2, e2, r2) {
          return t2.sections.forEach(((t3) => {
            t3.text = (function(t4, e3, r3) {
              const n2 = e3.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), zs2.applyArabicShaping && (t4 = zs2.applyArabicShaping(t4)), t4;
            })(t3.text, e2, r2);
          })), t2;
        }
        na2([{ name: "triangle", components: 3, type: "Uint16" }]), na2([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), na2([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), na2([{ type: "Float32", name: "offsetX" }]), na2([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), na2([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        var dc2 = 24;
        const yc2 = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" }, mc2 = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, gc2 = { 40: true };
        function xc2(t2, e2, r2, n2, i2, s2) {
          if ("fontStack" in e2) {
            const n3 = r2[e2.fontStack], s3 = n3 && n3[t2];
            return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
          }
          {
            const t3 = n2[e2.imageName];
            return t3 ? t3.displaySize[0] * e2.scale * dc2 / s2 + i2 : 0;
          }
        }
        function vc2(t2, e2, r2, n2) {
          const i2 = Math.pow(t2 - e2, 2);
          return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
        }
        function bc2(t2, e2, r2) {
          let n2 = 0;
          return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
        }
        function wc2(t2, e2, r2, n2, i2, s2) {
          let a2 = null, o2 = vc2(e2, r2, i2, s2);
          for (const t3 of n2) {
            const n3 = vc2(e2 - t3.x, r2, i2, s2) + t3.badness;
            n3 <= o2 && (a2 = t3, o2 = n3);
          }
          return { index: t2, x: e2, priorBreak: a2, badness: o2 };
        }
        function _c2(t2) {
          return t2 ? _c2(t2.priorBreak).concat(t2.index) : [];
        }
        class Sc2 {
          constructor(t2 = "", e2 = [], r2 = []) {
            this.text = t2, this.sections = e2, this.sectionIndex = r2, this.imageSectionID = null;
          }
          static fromFeature(t2, e2) {
            const r2 = new Sc2();
            for (let n2 = 0; n2 < t2.sections.length; n2++) {
              const i2 = t2.sections[n2];
              i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
            }
            return r2;
          }
          length() {
            return [...this.text].length;
          }
          getSection(t2) {
            return this.sections[this.sectionIndex[t2]];
          }
          getSectionIndex(t2) {
            return this.sectionIndex[t2];
          }
          verticalizePunctuation() {
            this.text = (function(t2) {
              let e2 = "", r2 = { premature: true, value: void 0 };
              const n2 = t2[Symbol.iterator]();
              let i2 = n2.next();
              const s2 = t2[Symbol.iterator]();
              s2.next();
              let a2 = s2.next();
              for (; !i2.done; ) e2 += !a2.done && Ts2(a2.value.codePointAt(0)) && !yc2[a2.value] || !r2.premature && Ts2(r2.value.codePointAt(0)) && !yc2[r2.value] || !yc2[i2.value] ? i2.value : yc2[i2.value], r2 = { value: i2.value, premature: false }, i2 = n2.next(), a2 = s2.next();
              return e2;
            })(this.text);
          }
          hasZeroWidthSpaces() {
            return this.text.includes("");
          }
          trim() {
            const t2 = this.text.match(/^\s*/), e2 = t2 ? t2[0].length : 0, r2 = this.text.match(/\S\s*$/), n2 = r2 ? r2[0].length - 1 : 0;
            this.text = this.text.substring(e2, this.text.length - n2), this.sectionIndex = this.sectionIndex.slice(e2, this.sectionIndex.length - n2);
          }
          substring(t2, e2) {
            const r2 = [...this.text].slice(t2, e2).join(""), n2 = this.sectionIndex.slice(t2, e2);
            return new Sc2(r2, this.sections, n2);
          }
          toCodeUnitIndex(t2) {
            return [...this.text].slice(0, t2).join("").length;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t2, e2) => Math.max(t2, this.sections[e2].scale)), 0);
          }
          getMaxImageSize(t2) {
            let e2 = 0, r2 = 0;
            for (let n2 = 0; n2 < this.length(); n2++) {
              const i2 = this.getSection(n2);
              if ("imageName" in i2) {
                const n3 = t2[i2.imageName];
                if (!n3) continue;
                const s2 = n3.displaySize;
                e2 = Math.max(e2, s2[0]), r2 = Math.max(r2, s2[1]);
              }
            }
            return { maxImageWidth: e2, maxImageHeight: r2 };
          }
          addTextSection(t2, e2) {
            this.text += t2.text, this.sections.push({ scale: t2.scale || 1, verticalAlign: t2.verticalAlign || "bottom", fontStack: t2.fontStack || e2 });
            const r2 = this.sections.length - 1;
            this.sectionIndex.push(...[...t2.text].map((() => r2)));
          }
          addImageSection(t2) {
            const e2 = t2.image ? t2.image.name : "";
            if (0 === e2.length) return void j2("Can't add FormattedSection with an empty image.");
            const r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push({ scale: 1, verticalAlign: t2.verticalAlign || "bottom", imageName: e2 }), this.sectionIndex.push(this.sections.length - 1)) : j2("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
          determineLineBreaks(t2, e2, r2, n2, i2) {
            const s2 = [], a2 = this.determineAverageLineWidth(t2, e2, r2, n2, i2), o2 = this.hasZeroWidthSpaces();
            let l2 = 0, u2 = 0;
            const c2 = this.text[Symbol.iterator]();
            let h2 = c2.next();
            const p2 = this.text[Symbol.iterator]();
            p2.next();
            let f3 = p2.next();
            const d2 = this.text[Symbol.iterator]();
            d2.next(), d2.next();
            let y3 = d2.next();
            for (; !h2.done; ) {
              const e3 = this.getSection(u2), m2 = h2.value.codePointAt(0);
              if (ws2(m2) || (l2 += xc2(m2, e3, r2, n2, t2, i2)), !f3.done) {
                const t3 = vs2(m2), r3 = f3.value.codePointAt(0);
                (mc2[m2] || t3 || "imageName" in e3 || !y3.done && gc2[r3]) && s2.push(wc2(u2 + 1, l2, a2, s2, bc2(m2, r3, t3 && o2), false));
              }
              u2++, h2 = c2.next(), f3 = p2.next(), y3 = d2.next();
            }
            return _c2(wc2(this.length(), l2, a2, s2, 0, true));
          }
          determineAverageLineWidth(t2, e2, r2, n2, i2) {
            let s2 = 0, a2 = 0;
            for (const e3 of this.text) {
              const o2 = this.getSection(a2);
              s2 += xc2(e3.codePointAt(0), o2, r2, n2, t2, i2), a2++;
            }
            return s2 / Math.max(1, Math.ceil(s2 / e2));
          }
        }
        const Ac2 = 4294967296, kc2 = 1 / Ac2, Ec2 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
        class Tc2 {
          constructor(t2 = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t2, e2, r2 = this.length) {
            for (; this.pos < r2; ) {
              const r3 = this.readVarint(), n2 = r3 >> 3, i2 = this.pos;
              this.type = 7 & r3, t2(n2, e2, this), this.pos === i2 && this.skip(r3);
            }
            return e2;
          }
          readMessage(t2, e2) {
            return this.readFields(t2, e2, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t2 = this.dataView.getUint32(this.pos, true);
            return this.pos += 4, t2;
          }
          readSFixed32() {
            const t2 = this.dataView.getInt32(this.pos, true);
            return this.pos += 4, t2;
          }
          readFixed64() {
            const t2 = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * Ac2;
            return this.pos += 8, t2;
          }
          readSFixed64() {
            const t2 = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * Ac2;
            return this.pos += 8, t2;
          }
          readFloat() {
            const t2 = this.dataView.getFloat32(this.pos, true);
            return this.pos += 4, t2;
          }
          readDouble() {
            const t2 = this.dataView.getFloat64(this.pos, true);
            return this.pos += 8, t2;
          }
          readVarint(t2) {
            const e2 = this.buf;
            let r2, n2;
            return n2 = e2[this.pos++], r2 = 127 & n2, n2 < 128 ? r2 : (n2 = e2[this.pos++], r2 |= (127 & n2) << 7, n2 < 128 ? r2 : (n2 = e2[this.pos++], r2 |= (127 & n2) << 14, n2 < 128 ? r2 : (n2 = e2[this.pos++], r2 |= (127 & n2) << 21, n2 < 128 ? r2 : (n2 = e2[this.pos], r2 |= (15 & n2) << 28, (function(t3, e3, r3) {
              const n3 = r3.buf;
              let i2, s2;
              if (s2 = n3[r3.pos++], i2 = (112 & s2) >> 4, s2 < 128) return Ic2(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 3, s2 < 128) return Ic2(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 10, s2 < 128) return Ic2(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 17, s2 < 128) return Ic2(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 24, s2 < 128) return Ic2(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (1 & s2) << 31, s2 < 128) return Ic2(t3, i2, e3);
              throw new Error("Expected varint not more than 10 bytes");
            })(r2, t2, this)))));
          }
          readVarint64() {
            return this.readVarint(true);
          }
          readSVarint() {
            const t2 = this.readVarint();
            return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
          }
          readBoolean() {
            return Boolean(this.readVarint());
          }
          readString() {
            const t2 = this.readVarint() + this.pos, e2 = this.pos;
            return this.pos = t2, t2 - e2 >= 12 && Ec2 ? Ec2.decode(this.buf.subarray(e2, t2)) : (function(t3, e3, r2) {
              let n2 = "", i2 = e3;
              for (; i2 < r2; ) {
                const e4 = t3[i2];
                let s2, a2, o2, l2 = null, u2 = e4 > 239 ? 4 : e4 > 223 ? 3 : e4 > 191 ? 2 : 1;
                if (i2 + u2 > r2) break;
                1 === u2 ? e4 < 128 && (l2 = e4) : 2 === u2 ? (s2 = t3[i2 + 1], 128 == (192 & s2) && (l2 = (31 & e4) << 6 | 63 & s2, l2 <= 127 && (l2 = null))) : 3 === u2 ? (s2 = t3[i2 + 1], a2 = t3[i2 + 2], 128 == (192 & s2) && 128 == (192 & a2) && (l2 = (15 & e4) << 12 | (63 & s2) << 6 | 63 & a2, (l2 <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null))) : 4 === u2 && (s2 = t3[i2 + 1], a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & s2) && 128 == (192 & a2) && 128 == (192 & o2) && (l2 = (15 & e4) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2, (l2 <= 65535 || l2 >= 1114112) && (l2 = null))), null === l2 ? (l2 = 65533, u2 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i2 += u2;
              }
              return n2;
            })(this.buf, e2, t2);
          }
          readBytes() {
            const t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
            return this.pos = t2, e2;
          }
          readPackedVarint(t2 = [], e2) {
            const r2 = this.readPackedEnd();
            for (; this.pos < r2; ) t2.push(this.readVarint(e2));
            return t2;
          }
          readPackedSVarint(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readSVarint());
            return t2;
          }
          readPackedBoolean(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readBoolean());
            return t2;
          }
          readPackedFloat(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readFloat());
            return t2;
          }
          readPackedDouble(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readDouble());
            return t2;
          }
          readPackedFixed32(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readFixed32());
            return t2;
          }
          readPackedSFixed32(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readSFixed32());
            return t2;
          }
          readPackedFixed64(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readFixed64());
            return t2;
          }
          readPackedSFixed64(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readSFixed64());
            return t2;
          }
          readPackedEnd() {
            return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t2) {
            const e2 = 7 & t2;
            if (0 === e2) for (; this.buf[this.pos++] > 127; ) ;
            else if (2 === e2) this.pos = this.readVarint() + this.pos;
            else if (5 === e2) this.pos += 4;
            else {
              if (1 !== e2) throw new Error(`Unimplemented type: ${e2}`);
              this.pos += 8;
            }
          }
          writeTag(t2, e2) {
            this.writeVarint(t2 << 3 | e2);
          }
          realloc(t2) {
            let e2 = this.length || 16;
            for (; e2 < this.pos + t2; ) e2 *= 2;
            if (e2 !== this.length) {
              const t3 = new Uint8Array(e2);
              t3.set(this.buf), this.buf = t3, this.dataView = new DataView(t3.buffer), this.length = e2;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t2) {
            this.realloc(4), this.dataView.setInt32(this.pos, t2, true), this.pos += 4;
          }
          writeSFixed32(t2) {
            this.realloc(4), this.dataView.setInt32(this.pos, t2, true), this.pos += 4;
          }
          writeFixed64(t2) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t2, true), this.dataView.setInt32(this.pos + 4, Math.floor(t2 * kc2), true), this.pos += 8;
          }
          writeSFixed64(t2) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t2, true), this.dataView.setInt32(this.pos + 4, Math.floor(t2 * kc2), true), this.pos += 8;
          }
          writeVarint(t2) {
            (t2 = +t2 || 0) > 268435455 || t2 < 0 ? (function(t3, e2) {
              let r2, n2;
              if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (r2 = ~(-t3 % 4294967296), n2 = ~(-t3 / 4294967296), 4294967295 ^ r2 ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              e2.realloc(10), (function(t4, e3, r3) {
                r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
              })(r2, 0, e2), (function(t4, e3) {
                const r3 = (7 & t4) << 4;
                e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
              })(n2, e2);
            })(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
          }
          writeSVarint(t2) {
            this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
          }
          writeBoolean(t2) {
            this.writeVarint(+t2);
          }
          writeString(t2) {
            t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
            const e2 = this.pos;
            this.pos = (function(t3, e3, r3) {
              for (let n2, i2, s2 = 0; s2 < e3.length; s2++) {
                if (n2 = e3.charCodeAt(s2), n2 > 55295 && n2 < 57344) {
                  if (!i2) {
                    n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                    continue;
                  }
                  if (n2 < 56320) {
                    t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                    continue;
                  }
                  n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
                } else i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
                n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
              }
              return r3;
            })(this.buf, t2, this.pos);
            const r2 = this.pos - e2;
            r2 >= 128 && Mc2(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
          }
          writeFloat(t2) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t2, true), this.pos += 4;
          }
          writeDouble(t2) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t2, true), this.pos += 8;
          }
          writeBytes(t2) {
            const e2 = t2.length;
            this.writeVarint(e2), this.realloc(e2);
            for (let r2 = 0; r2 < e2; r2++) this.buf[this.pos++] = t2[r2];
          }
          writeRawMessage(t2, e2) {
            this.pos++;
            const r2 = this.pos;
            t2(e2, this);
            const n2 = this.pos - r2;
            n2 >= 128 && Mc2(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
          }
          writeMessage(t2, e2, r2) {
            this.writeTag(t2, 2), this.writeRawMessage(e2, r2);
          }
          writePackedVarint(t2, e2) {
            e2.length && this.writeMessage(t2, Fc2, e2);
          }
          writePackedSVarint(t2, e2) {
            e2.length && this.writeMessage(t2, Dc2, e2);
          }
          writePackedBoolean(t2, e2) {
            e2.length && this.writeMessage(t2, Bc2, e2);
          }
          writePackedFloat(t2, e2) {
            e2.length && this.writeMessage(t2, zc2, e2);
          }
          writePackedDouble(t2, e2) {
            e2.length && this.writeMessage(t2, Pc2, e2);
          }
          writePackedFixed32(t2, e2) {
            e2.length && this.writeMessage(t2, Vc2, e2);
          }
          writePackedSFixed32(t2, e2) {
            e2.length && this.writeMessage(t2, Cc2, e2);
          }
          writePackedFixed64(t2, e2) {
            e2.length && this.writeMessage(t2, Lc2, e2);
          }
          writePackedSFixed64(t2, e2) {
            e2.length && this.writeMessage(t2, Oc2, e2);
          }
          writeBytesField(t2, e2) {
            this.writeTag(t2, 2), this.writeBytes(e2);
          }
          writeFixed32Field(t2, e2) {
            this.writeTag(t2, 5), this.writeFixed32(e2);
          }
          writeSFixed32Field(t2, e2) {
            this.writeTag(t2, 5), this.writeSFixed32(e2);
          }
          writeFixed64Field(t2, e2) {
            this.writeTag(t2, 1), this.writeFixed64(e2);
          }
          writeSFixed64Field(t2, e2) {
            this.writeTag(t2, 1), this.writeSFixed64(e2);
          }
          writeVarintField(t2, e2) {
            this.writeTag(t2, 0), this.writeVarint(e2);
          }
          writeSVarintField(t2, e2) {
            this.writeTag(t2, 0), this.writeSVarint(e2);
          }
          writeStringField(t2, e2) {
            this.writeTag(t2, 2), this.writeString(e2);
          }
          writeFloatField(t2, e2) {
            this.writeTag(t2, 5), this.writeFloat(e2);
          }
          writeDoubleField(t2, e2) {
            this.writeTag(t2, 1), this.writeDouble(e2);
          }
          writeBooleanField(t2, e2) {
            this.writeVarintField(t2, +e2);
          }
        }
        function Ic2(t2, e2, r2) {
          return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
        }
        function Mc2(t2, e2, r2) {
          const n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n2);
          for (let e3 = r2.pos - 1; e3 >= t2; e3--) r2.buf[e3 + n2] = r2.buf[e3];
        }
        function Fc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeVarint(t2[r2]);
        }
        function Dc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeSVarint(t2[r2]);
        }
        function zc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeFloat(t2[r2]);
        }
        function Pc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeDouble(t2[r2]);
        }
        function Bc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeBoolean(t2[r2]);
        }
        function Vc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeFixed32(t2[r2]);
        }
        function Cc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeSFixed32(t2[r2]);
        }
        function Lc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeFixed64(t2[r2]);
        }
        function Oc2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeSFixed64(t2[r2]);
        }
        function Rc2(t2, e2, r2) {
          1 === t2 && r2.readMessage(Nc2, e2);
        }
        function Nc2(t2, e2, r2) {
          if (3 === t2) {
            const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage($c2, {});
            e2.push({ id: t3, bitmap: new _l2({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
          }
        }
        function $c2(t2, e2, r2) {
          1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
        }
        function Uc2(t2) {
          let e2 = 0, r2 = 0;
          for (const n3 of t2) e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
          t2.sort(((t3, e3) => e3.h - t3.h));
          const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
          let i2 = 0, s2 = 0;
          for (const e3 of t2) for (let t3 = n2.length - 1; t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                e4 && t3 < n2.length && (n2[t3] = e4);
              } else e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
          return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
        }
        class qc2 {
          constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2, textFitWidth: a2, textFitHeight: o2 }) {
            this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2, this.textFitWidth = a2, this.textFitHeight = o2;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class jc2 {
          constructor(t2, e2) {
            const r2 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            const i2 = [];
            this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
            const { w: s2, h: a2 } = Uc2(i2), o2 = new Sl2({ width: s2 || 1, height: a2 || 1 });
            for (const e3 in t2) {
              const n3 = t2[e3], i3 = r2[e3].paddedRect;
              Sl2.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
            }
            for (const t3 in e2) {
              const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
              Sl2.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Sl2.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Sl2.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), Sl2.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Sl2.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
            }
            this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
          }
          addImages(t2, e2, r2) {
            for (const n2 in t2) {
              const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
              r2.push(s2), e2[n2] = new qc2(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }
          patchUpdatedImages(t2, e2) {
            t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r2 in t2.updatedImages) this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
          }
          patchUpdatedImage(t2, e2, r2) {
            if (!t2 || !e2) return;
            if (t2.version === e2.version) return;
            t2.version = e2.version;
            const [n2, i2] = t2.tl;
            r2.update(e2.data, void 0, { x: n2, y: i2 });
          }
        }
        var Gc2;
        function Xc2(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3) {
          const m2 = Sc2.fromFeature(e2, s2);
          let g2;
          p2 === t.az.vertical && m2.verticalizePunctuation();
          let x2 = m2.determineLineBreaks(c2, a2, r2, i2, d2);
          const { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = zs2;
          if (v2 && 1 === m2.sections.length) {
            g2 = [], x2 = x2.map(((t3) => m2.toCodeUnitIndex(t3)));
            const t2 = v2(m2.toString(), x2);
            for (const e3 of t2) {
              const t3 = [...e3].map((() => 0));
              g2.push(new Sc2(e3, m2.sections, t3));
            }
          } else if (b2) {
            g2 = [], x2 = x2.map(((t3) => m2.toCodeUnitIndex(t3)));
            let t2 = 0;
            const e3 = [];
            for (const r4 of m2.text) e3.push(...Array(r4.length).fill(m2.sectionIndex[t2])), t2++;
            const r3 = b2(m2.text, e3, x2);
            for (const t3 of r3) {
              const e4 = [];
              let r4 = "";
              for (const n3 of t3[0]) e4.push(t3[1][r4.length]), r4 += n3;
              g2.push(new Sc2(t3[0], m2.sections, e4));
            }
          } else g2 = (function(t2, e3) {
            const r3 = [];
            let n3 = 0;
            for (const i3 of e3) r3.push(t2.substring(n3, i3)), n3 = i3;
            return n3 < t2.length() && r3.push(t2.substring(n3, t2.length())), r3;
          })(m2, x2);
          const w3 = [], _3 = { positionedLines: w3, text: m2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
          return (function(t2, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
            let p3 = 0, f4 = 0, d3 = 0, y4 = 0;
            const m3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5, g3 = dc2 / h3;
            let x3 = 0;
            for (const a4 of i3) {
              a4.trim();
              const i4 = a4.getMaxScale(), o4 = { positionedGlyphs: [], lineOffset: 0 };
              t2.positionedLines[x3] = o4;
              const h4 = o4.positionedGlyphs;
              let v7 = 0;
              if (!a4.length()) {
                f4 += s3, ++x3;
                continue;
              }
              const b4 = Zc2(n3, a4, g3);
              let w4 = 0;
              for (const s4 of a4.text) {
                const o5 = a4.getSection(w4), d4 = s4.codePointAt(0), y5 = Kc2(l3, c3, d4), m4 = { glyph: d4, imageName: null, x: p3, y: f4 + -17, vertical: y5, scale: 1, fontStack: "", sectionIndex: a4.getSectionIndex(w4), metrics: null, rect: null };
                let x4;
                if ("fontStack" in o5) {
                  if (x4 = Wc2(o5, d4, y5, b4, e3, r3), !x4) continue;
                  m4.fontStack = o5.fontStack;
                } else {
                  if (t2.iconsInText = true, o5.scale *= g3, x4 = Jc2(o5, y5, i4, b4, n3), !x4) continue;
                  v7 = Math.max(v7, x4.imageOffset), m4.imageName = o5.imageName;
                }
                const { rect: _5, metrics: S3, baselineOffset: A2 } = x4;
                m4.y += A2, m4.scale = o5.scale, m4.metrics = S3, m4.rect = _5, h4.push(m4), y5 ? (t2.verticalizable = true, p3 += ("imageName" in o5 ? S3.advance : dc2) * o5.scale + u3) : p3 += S3.advance * o5.scale + u3, w4++;
              }
              0 !== h4.length && (d3 = Math.max(p3 - u3, d3), Qc2(h4, 0, h4.length - 1, m3)), p3 = 0, o4.lineOffset = Math.max(v7, (i4 - 1) * dc2);
              const _4 = s3 * i4 + v7;
              f4 += _4, y4 = Math.max(_4, y4), ++x3;
            }
            const { horizontalAlign: v6, verticalAlign: b3 } = Yc2(a3);
            (function(t3, e4, r4, n4, i4, s4, a4, o4, l4) {
              const u4 = (e4 - r4) * i4;
              let c4 = 0;
              c4 = s4 !== a4 ? -o4 * n4 - -17 : -n4 * l4 * a4 + 0.5 * a4;
              for (const e5 of t3) for (const t4 of e5.positionedGlyphs) t4.x += u4, t4.y += c4;
            })(t2.positionedLines, m3, v6, b3, d3, y4, s3, f4, i3.length), t2.top += -b3 * f4, t2.bottom = t2.top + f4, t2.left += -v6 * d3, t2.right = t2.left + d3;
          })(_3, r2, n2, i2, g2, o2, l2, u2, p2, c2, f3, y3), !(function(t2) {
            for (const e3 of t2) if (0 !== e3.positionedGlyphs.length) return false;
            return true;
          })(w3) && _3;
        }
        function Yc2(t2) {
          let e2 = 0.5, r2 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function Zc2(t2, e2, r2) {
          const n2 = e2.getMaxScale() * dc2, { maxImageWidth: i2, maxImageHeight: s2 } = e2.getMaxImageSize(t2), a2 = Math.max(n2, s2 * r2);
          return { verticalLineContentWidth: Math.max(n2, i2 * r2), horizontalLineContentHeight: a2 };
        }
        function Hc2(t2) {
          switch (t2) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function Kc2(e2, r2, n2) {
          return !(e2 === t.az.horizontal || !r2 && !bs2(n2) || r2 && (ws2(n2) || (i2 = n2, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(i2)))));
          var i2;
        }
        function Wc2(t2, e2, r2, n2, i2, s2) {
          const a2 = s2[t2.fontStack], o2 = (function(t3, e3, r3, n3) {
            if (t3 && t3.rect) return t3;
            const i3 = e3[r3.fontStack], s3 = i3 && i3[n3];
            return s3 ? { rect: null, metrics: s3.metrics } : null;
          })(a2 && a2[e2], i2, t2, e2);
          if (null === o2) return null;
          let l2;
          if (r2) l2 = n2.verticalLineContentWidth - t2.scale * dc2;
          else {
            const e3 = Hc2(t2.verticalAlign);
            l2 = (n2.horizontalLineContentHeight - t2.scale * dc2) * e3;
          }
          return { rect: o2.rect, metrics: o2.metrics, baselineOffset: l2 };
        }
        function Jc2(t2, e2, r2, n2, i2) {
          const s2 = i2[t2.imageName];
          if (!s2) return null;
          const a2 = s2.paddedRect, o2 = s2.displaySize, l2 = { width: o2[0], height: o2[1], left: 1, top: -3, advance: e2 ? o2[1] : o2[0] };
          let u2;
          if (e2) u2 = n2.verticalLineContentWidth - o2[1] * t2.scale;
          else {
            const e3 = Hc2(t2.verticalAlign);
            u2 = (n2.horizontalLineContentHeight - o2[1] * t2.scale) * e3;
          }
          return { rect: a2, metrics: l2, baselineOffset: u2, imageOffset: (e2 ? o2[0] : o2[1]) * t2.scale - dc2 * r2 };
        }
        function Qc2(t2, e2, r2, n2) {
          if (0 === n2) return;
          const i2 = t2[r2], s2 = (t2[r2].x + i2.metrics.advance * i2.scale) * n2;
          for (let n3 = e2; n3 <= r2; n3++) t2[n3].x -= s2;
        }
        function th(t2, e2, r2) {
          const { horizontalAlign: n2, verticalAlign: i2 } = Yc2(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
          return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
        }
        function eh(t2) {
          var e2, r2;
          let n2 = t2.left, i2 = t2.top, s2 = t2.right - n2, a2 = t2.bottom - i2;
          const o2 = null !== (e2 = t2.image.textFitWidth) && void 0 !== e2 ? e2 : "stretchOrShrink", l2 = null !== (r2 = t2.image.textFitHeight) && void 0 !== r2 ? r2 : "stretchOrShrink", u2 = (t2.image.content[2] - t2.image.content[0]) / (t2.image.content[3] - t2.image.content[1]);
          if ("proportional" === l2) {
            if ("stretchOnly" === o2 && s2 / a2 < u2 || "proportional" === o2) {
              const t3 = Math.ceil(a2 * u2);
              n2 *= t3 / s2, s2 = t3;
            }
          } else if ("proportional" === o2 && "stretchOnly" === l2 && 0 !== u2 && s2 / a2 > u2) {
            const t3 = Math.ceil(s2 / u2);
            i2 *= t3 / a2, a2 = t3;
          }
          return { x1: n2, y1: i2, x2: n2 + s2, y2: i2 + a2 };
        }
        function rh(t2, e2, r2, n2, i2, s2) {
          const a2 = t2.image;
          let o2;
          if (a2.content) {
            const t3 = a2.content, e3 = a2.pixelRatio || 1;
            o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
          }
          const l2 = e2.left * s2, u2 = e2.right * s2;
          let c2, h2, p2, f3;
          "width" === r2 || "both" === r2 ? (f3 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f3 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = f3 + a2.displaySize[0]);
          const d2 = e2.top * s2, y3 = e2.bottom * s2;
          return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y3 + n2[2]) : (c2 = i2[1] + (d2 + y3 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f3, collisionPadding: o2 };
        }
        ps2("ImagePosition", qc2), ps2("ImageAtlas", jc2), t.az = void 0, (Gc2 = t.az || (t.az = {}))[Gc2.none = 0] = "none", Gc2[Gc2.horizontal = 1] = "horizontal", Gc2[Gc2.vertical = 2] = "vertical", Gc2[Gc2.horizontalOnly = 3] = "horizontalOnly";
        const nh = 128, ih = 32640;
        function sh(t2, e2) {
          const { expression: r2 } = e2;
          if ("constant" === r2.kind) return { kind: "constant", layoutSize: r2.evaluate(new Ps2(t2 + 1)) };
          if ("source" === r2.kind) return { kind: "source" };
          {
            const { zoomStops: e3, interpolationType: n2 } = r2;
            let i2 = 0;
            for (; i2 < e3.length && e3[i2] <= t2; ) i2++;
            i2 = Math.max(0, i2 - 1);
            let s2 = i2;
            for (; s2 < e3.length && e3[s2] < t2 + 1; ) s2++;
            s2 = Math.min(e3.length - 1, s2);
            const a2 = e3[i2], o2 = e3[s2];
            return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new Ps2(a2)), maxSize: r2.evaluate(new Ps2(o2)), interpolationType: n2 };
          }
        }
        function ah(t2, e2, r2) {
          let n2 = "never";
          const i2 = t2.get(e2);
          return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
        }
        const oh = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function lh(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const f3 = o2 ? Math.min(ih, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(ih, Math.round(o2[1])) : 0;
          t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f3 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
        }
        function uh(t2, e2, r2) {
          t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
        }
        function ch(t2) {
          for (const e2 of t2.sections) if (Ds2(e2.text)) return true;
          return false;
        }
        class hh {
          constructor(t2) {
            this.layoutVertexArray = new Ha2(), this.indexArray = new to2(), this.programConfigurations = t2, this.segments = new io2(), this.dynamicLayoutVertexArray = new Ka2(), this.opacityVertexArray = new Wa2(), this.hasVisibleVertices = false, this.placedSymbolArray = new za2();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t2, e2, r2, n2) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, lc2.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, uc2.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, oh, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        ps2("SymbolBuffers", hh);
        class ph {
          constructor(t2, e2, r2) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new io2(), this.collisionVertexArray = new Qa2();
          }
          upload(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, cc2.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        ps2("CollisionBuffers", ph);
        class fh {
          constructor(e2) {
            this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map(((t2) => t2.id)), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasDependencies = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = sh(this.zoom, r2["text-size"]), this.iconSizeData = sh(this.zoom, r2["icon-size"]);
            const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
            this.canOverlap = "never" !== ah(n2, "text-overlap", "text-allow-overlap") || "never" !== ah(n2, "icon-overlap", "icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s2 && !i2.isConstant(), this.sortFeaturesByY = ("viewport-y" === s2 || "auto" === s2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n2.get("symbol-placement") && (this.writingModes = n2.get("text-writing-mode").map(((e3) => t.az[e3]))), this.stateDependentLayerIds = this.layers.filter(((t2) => t2.isStateDependent())).map(((t2) => t2.id)), this.sourceID = e2.sourceID;
          }
          createArrays() {
            this.text = new hh(new Vo2(this.layers, this.zoom, ((t2) => /^text/.test(t2)))), this.icon = new hh(new Vo2(this.layers, this.zoom, ((t2) => /^icon/.test(t2)))), this.glyphOffsetArray = new Va2(), this.lineVertexArray = new Ca2(), this.symbolInstances = new Ba2(), this.textAnchorOffsets = new Oa2();
          }
          calculateGlyphDependencies(t2, e2, r2, n2, i2) {
            for (const s2 of t2) if (e2[s2.codePointAt(0)] = true, (r2 || n2) && i2) {
              const t3 = yc2[s2];
              t3 && (e2[t3.codePointAt(0)] = true);
            }
          }
          populate(e2, r2, n2) {
            const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l2 = s2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof De2 && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), c2 = "constant" !== l2.value.kind || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = s2.get("symbol-sort-key");
            if (this.features = [], !u2 && !c2) return;
            const p2 = r2.iconDependencies, f3 = r2.glyphDependencies, d2 = r2.availableImages, y3 = new Ps2(this.zoom);
            for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e2) {
              const e3 = i2._featureFilter.needGeometry, g2 = $o2(r3, e3);
              if (!i2._featureFilter.filter(y3, g2, n2)) continue;
              let x2, v2;
              if (e3 || (g2.geometry = No2(r3)), u2) {
                const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = De2.factory(t2), r4 = this.hasRTLText = this.hasRTLText || ch(e4);
                (!r4 || "unavailable" === zs2.getRTLTextPluginStatus() || r4 && zs2.isParsed()) && (x2 = fc2(e4, i2, g2));
              }
              if (c2) {
                const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
                v2 = t2 instanceof Oe2 ? t2 : Oe2.fromString(t2);
              }
              if (!x2 && !v2) continue;
              const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
              if (this.features.push({ id: o3, text: x2, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: Mu2.types[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x2) {
                const e4 = a2.evaluate(g2, {}, n2).join(","), r4 = "viewport" !== s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.az.vertical) >= 0;
                for (const t2 of x2.sections) if (t2.image) p2[t2.image.name] = true;
                else {
                  const n3 = _s2(x2.toString()), i3 = t2.fontStack || e4, s3 = f3[i3] = f3[i3] || {};
                  this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                }
              }
            }
            "line" === s2.get("symbol-placement") && (this.features = (function(t2) {
              const e3 = {}, r3 = {}, n3 = [];
              let i3 = 0;
              function s3(e4) {
                n3.push(t2[e4]), i3++;
              }
              function a3(t3, e4, i4) {
                const s4 = r3[t3];
                return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
              }
              function o3(t3, r4, i4) {
                const s4 = e3[r4];
                return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
              }
              function l3(t3, e4, r4) {
                const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return `${t3}:${n4.x}:${n4.y}`;
              }
              for (let u3 = 0; u3 < t2.length; u3++) {
                const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  s3(u3);
                  continue;
                }
                const f4 = l3(p3, h3), d3 = l3(p3, h3, true);
                if (f4 in r3 && d3 in e3 && r3[f4] !== e3[d3]) {
                  const t3 = o3(f4, d3, h3), i4 = a3(f4, d3, n3[t3].geometry);
                  delete e3[f4], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
                } else f4 in r3 ? a3(f4, d3, h3) : d3 in e3 ? o3(f4, d3, h3) : (s3(u3), e3[f4] = i3 - 1, r3[d3] = i3 - 1);
              }
              return n3.filter(((t3) => t3.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((t2, e3) => t2.sortKey - e3.sortKey));
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, { imagePositions: r2 }), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, { imagePositions: r2 }));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t2, e2) {
            const r2 = this.lineVertexArray.length;
            if (void 0 !== t2.segment) {
              let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
              const i2 = {};
              for (let n3 = t2.segment + 1; n3 < e2.length; n3++) i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
              for (let r4 = t2.segment || 0; r4 >= 0; r4--) i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
              for (let t3 = 0; t3 < e2.length; t3++) {
                const e3 = i2[t3];
                this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }
          addSymbols(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f3 = e2.indexArray, d2 = e2.layoutVertexArray, y3 = e2.segments.prepareSegment(4 * r2.length, d2, f3, this.canOverlap ? a2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y3.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.az.vertical ? Math.PI / 2 : 0, v2 = a2.text && a2.text.sections;
            for (let t2 = 0; t2 < r2.length; t2++) {
              const { tl: i3, tr: s3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w3, isSDF: _3, sectionIndex: S3 } = r2[t2], A2 = y3.vertexLength, k3 = w3[1];
              lh(d2, l2.x, l2.y, i3.x, k3 + i3.y, c3.x, c3.y, n2, _3, h3.x, h3.y, g3, b2), lh(d2, l2.x, l2.y, s3.x, k3 + s3.y, c3.x + c3.w, c3.y, n2, _3, m3.x, h3.y, g3, b2), lh(d2, l2.x, l2.y, o3.x, k3 + o3.y, c3.x, c3.y + c3.h, n2, _3, h3.x, m3.y, g3, b2), lh(d2, l2.x, l2.y, u3.x, k3 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _3, m3.x, m3.y, g3, b2), uh(e2.dynamicLayoutVertexArray, l2, x2), f3.emplaceBack(A2, A2 + 2, A2 + 1), f3.emplaceBack(A2 + 1, A2 + 2, A2 + 3), y3.vertexLength += 4, y3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w3[0]), t2 !== r2.length - 1 && S3 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, { imagePositions: {}, canonical: p2, formattedSection: v2 && v2[S3] });
            }
            e2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
          }
          _addCollisionDebugVertex(t2, e2, r2, n2, i2, s2) {
            return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
          }
          addCollisionDebugVertices(t2, e2, n2, i2, s2, a2, o2) {
            const l2 = s2.segments.prepareSegment(4, s2.layoutVertexArray, s2.indexArray), u2 = l2.vertexLength, c2 = s2.layoutVertexArray, h2 = s2.collisionVertexArray, p2 = o2.anchorX, f3 = o2.anchorY;
            this._addCollisionDebugVertex(c2, h2, a2, p2, f3, new r(t2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f3, new r(n2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f3, new r(n2, i2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f3, new r(t2, i2)), l2.vertexLength += 4;
            const d2 = s2.indexArray;
            d2.emplaceBack(u2, u2 + 1), d2.emplaceBack(u2 + 1, u2 + 2), d2.emplaceBack(u2 + 2, u2 + 3), d2.emplaceBack(u2 + 3, u2), l2.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t2, e2, r2, n2) {
            for (let i2 = t2; i2 < e2; i2++) {
              const t3 = this.collisionBoxArray.get(i2);
              this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ph(Ja2, hc2.members, eo2), this.iconCollisionBox = new ph(Ja2, hc2.members, eo2);
            for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
              const e2 = this.symbolInstances.get(t2);
              this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = {};
            for (let n3 = e2; n3 < r2; n3++) {
              const e3 = t2.get(n3);
              u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
              break;
            }
            for (let e3 = n2; e3 < i2; e3++) {
              const r3 = t2.get(e3);
              u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = s2; e3 < a2; e3++) {
              const r3 = t2.get(e3);
              u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = o2; e3 < l2; e3++) {
              const r3 = t2.get(e3);
              u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
              break;
            }
            return u2;
          }
          deserializeCollisionBoxes(t2) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              const r2 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t2, e2) {
            const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
            for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4) t2.indexArray.emplaceBack(e3, e3 + 2, e3 + 1), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t2) {
            if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
            const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
            for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
              s2.push(t3);
              const a2 = this.symbolInstances.get(t3);
              n2.push(0 | Math.round(e2 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
            }
            return s2.sort(((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3])), s2;
          }
          addToSortKeyRanges(t2, e2) {
            const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }
          sortFeatures(t2) {
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t3 of this.symbolInstanceIndexes) {
                const e2 = this.symbolInstances.get(t3);
                this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach(((t4, e3, r2) => {
                  t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
                })), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let dh, yh;
        ps2("SymbolBucket", fh, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), fh.MAX_GLYPHS = 65535, fh.addDynamicAttributes = uh;
        var mh = { get paint() {
          return yh = yh || new Hs2({ "icon-opacity": new Gs2(vt2.paint_symbol["icon-opacity"]), "icon-color": new Gs2(vt2.paint_symbol["icon-color"]), "icon-halo-color": new Gs2(vt2.paint_symbol["icon-halo-color"]), "icon-halo-width": new Gs2(vt2.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Gs2(vt2.paint_symbol["icon-halo-blur"]), "icon-translate": new js2(vt2.paint_symbol["icon-translate"]), "icon-translate-anchor": new js2(vt2.paint_symbol["icon-translate-anchor"]), "text-opacity": new Gs2(vt2.paint_symbol["text-opacity"]), "text-color": new Gs2(vt2.paint_symbol["text-color"], { runtimeType: Rt2, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Gs2(vt2.paint_symbol["text-halo-color"]), "text-halo-width": new Gs2(vt2.paint_symbol["text-halo-width"]), "text-halo-blur": new Gs2(vt2.paint_symbol["text-halo-blur"]), "text-translate": new js2(vt2.paint_symbol["text-translate"]), "text-translate-anchor": new js2(vt2.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return dh = dh || new Hs2({ "symbol-placement": new js2(vt2.layout_symbol["symbol-placement"]), "symbol-spacing": new js2(vt2.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new js2(vt2.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Gs2(vt2.layout_symbol["symbol-sort-key"]), "symbol-z-order": new js2(vt2.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new js2(vt2.layout_symbol["icon-allow-overlap"]), "icon-overlap": new js2(vt2.layout_symbol["icon-overlap"]), "icon-ignore-placement": new js2(vt2.layout_symbol["icon-ignore-placement"]), "icon-optional": new js2(vt2.layout_symbol["icon-optional"]), "icon-rotation-alignment": new js2(vt2.layout_symbol["icon-rotation-alignment"]), "icon-size": new Gs2(vt2.layout_symbol["icon-size"]), "icon-text-fit": new js2(vt2.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new js2(vt2.layout_symbol["icon-text-fit-padding"]), "icon-image": new Gs2(vt2.layout_symbol["icon-image"]), "icon-rotate": new Gs2(vt2.layout_symbol["icon-rotate"]), "icon-padding": new Gs2(vt2.layout_symbol["icon-padding"]), "icon-keep-upright": new js2(vt2.layout_symbol["icon-keep-upright"]), "icon-offset": new Gs2(vt2.layout_symbol["icon-offset"]), "icon-anchor": new Gs2(vt2.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new js2(vt2.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new js2(vt2.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new js2(vt2.layout_symbol["text-rotation-alignment"]), "text-field": new Gs2(vt2.layout_symbol["text-field"]), "text-font": new Gs2(vt2.layout_symbol["text-font"]), "text-size": new Gs2(vt2.layout_symbol["text-size"]), "text-max-width": new Gs2(vt2.layout_symbol["text-max-width"]), "text-line-height": new js2(vt2.layout_symbol["text-line-height"]), "text-letter-spacing": new Gs2(vt2.layout_symbol["text-letter-spacing"]), "text-justify": new Gs2(vt2.layout_symbol["text-justify"]), "text-radial-offset": new Gs2(vt2.layout_symbol["text-radial-offset"]), "text-variable-anchor": new js2(vt2.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Gs2(vt2.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Gs2(vt2.layout_symbol["text-anchor"]), "text-max-angle": new js2(vt2.layout_symbol["text-max-angle"]), "text-writing-mode": new js2(vt2.layout_symbol["text-writing-mode"]), "text-rotate": new Gs2(vt2.layout_symbol["text-rotate"]), "text-padding": new js2(vt2.layout_symbol["text-padding"]), "text-keep-upright": new js2(vt2.layout_symbol["text-keep-upright"]), "text-transform": new Gs2(vt2.layout_symbol["text-transform"]), "text-offset": new Gs2(vt2.layout_symbol["text-offset"]), "text-allow-overlap": new js2(vt2.layout_symbol["text-allow-overlap"]), "text-overlap": new js2(vt2.layout_symbol["text-overlap"]), "text-ignore-placement": new js2(vt2.layout_symbol["text-ignore-placement"]), "text-optional": new js2(vt2.layout_symbol["text-optional"]) });
        } };
        class gh {
          constructor(t2) {
            if (void 0 === t2.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Vt2, this.defaultValue = t2;
          }
          evaluate(t2) {
            if (t2.formattedSection) {
              const e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t2.formattedSection)) return e2.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        ps2("FormatSectionOverride", gh, { omit: ["defaultValue"] });
        class xh extends Ks2 {
          constructor(t2, e2) {
            super(t2, mh, e2);
          }
          recalculate(t2, e2) {
            if (super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              const t3 = this.layout.get("text-writing-mode");
              if (t3) {
                const e3 = [];
                for (const r2 of t3) e3.indexOf(r2) < 0 && e3.push(r2);
                this.layout._values["text-writing-mode"] = e3;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t2, e2, r2, n2) {
            const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
            return s2.isDataDriven() || ri2(s2.value) || !i2 ? i2 : (function(t3, e3) {
              return e3.replace(/{([^{}]+)}/g, ((e4, r3) => t3 && r3 in t3 ? String(t3[r3]) : ""));
            })(e2.properties, i2);
          }
          createBucket(t2) {
            return new fh(t2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t2 of mh.paint.overridableProperties) {
              if (!xh.hasPaintOverride(this.layout, t2)) continue;
              const e2 = this.paint.get(t2), r2 = new gh(e2), n2 = new ei2(r2, e2.property.specification);
              let i2 = null;
              i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new ii2("source", n2) : new si2("composite", n2, e2.value.zoomStops), this.paint._values[t2] = new Us2(e2.property, i2, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && xh.hasPaintOverride(this.layout, t2);
          }
          static hasPaintOverride(t2, e2) {
            const r2 = t2.get("text-field"), n2 = mh.paint.properties[e2];
            let i2 = false;
            const s2 = (t3) => {
              for (const e3 of t3) if (n2.overrides && n2.overrides.hasOverride(e3)) return void (i2 = true);
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof De2) s2(r2.value.value.sections);
            else if ("source" === r2.value.kind || "composite" === r2.value.kind) {
              const t3 = (e4) => {
                i2 || (e4 instanceof je2 && Ue2(e4.value) === jt2 ? s2(e4.value.sections) : e4 instanceof Ir2 ? s2(e4.sections) : e4.eachChild(t3));
              }, e3 = r2.value;
              e3._styleExpression && t3(e3._styleExpression.expression);
            }
            return i2;
          }
        }
        let vh;
        var bh = { get paint() {
          return vh = vh || new Hs2({ "background-color": new js2(vt2.paint_background["background-color"]), "background-pattern": new Ys2(vt2.paint_background["background-pattern"]), "background-opacity": new js2(vt2.paint_background["background-opacity"]) });
        } };
        class wh extends Ks2 {
          constructor(t2, e2) {
            super(t2, bh, e2);
          }
        }
        class _h extends Ks2 {
          constructor(t2, e2) {
            super(t2, {}, e2), this.onAdd = (t3) => {
              this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
            }, this.onRemove = (t3) => {
              this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
            }, this.implementation = t2;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Sh {
          constructor(t2) {
            this._methodToThrottle = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout((() => {
              this._triggered = false, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const Ah = { once: true }, kh = 63710088e-1;
        class Eh {
          constructor(t2, e2) {
            if (isNaN(t2) || isNaN(e2)) throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
            if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Eh(L2(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t2) {
            const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
            return kh * Math.acos(Math.min(i2, 1));
          }
          static convert(t2) {
            if (t2 instanceof Eh) return t2;
            if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length)) return new Eh(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2) return new Eh(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Th = 2 * Math.PI * kh;
        function Ih(t2) {
          return Th * Math.cos(t2 * Math.PI / 180);
        }
        function Mh(t2) {
          return (180 + t2) / 360;
        }
        function Fh(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function Dh(t2, e2) {
          return t2 / Ih(e2);
        }
        function zh(t2) {
          return 360 * t2 - 180;
        }
        function Ph(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        function Bh(t2, e2) {
          return t2 * Ih(Ph(e2));
        }
        class Vh {
          constructor(t2, e2, r2 = 0) {
            this.x = +t2, this.y = +e2, this.z = +r2;
          }
          static fromLngLat(t2, e2 = 0) {
            const r2 = Eh.convert(t2);
            return new Vh(Mh(r2.lng), Fh(r2.lat), Dh(e2, r2.lat));
          }
          toLngLat() {
            return new Eh(zh(this.x), Ph(this.y));
          }
          toAltitude() {
            return Bh(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Th * (t2 = Ph(this.y), 1 / Math.cos(t2 * Math.PI / 180));
            var t2;
          }
        }
        function Ch(t2, e2, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        class Lh {
          constructor(t2, e2, r2) {
            if (!(function(t3, e3, r3) {
              return !(t3 < 0 || t3 > 25 || r3 < 0 || r3 >= Math.pow(2, t3) || e3 < 0 || e3 >= Math.pow(2, t3));
            })(t2, e2, r2)) throw new Error(`x=${e2}, y=${r2}, z=${t2} outside of bounds. 0<=x<${Math.pow(2, t2)}, 0<=y<${Math.pow(2, t2)} 0<=z<=25 `);
            this.z = t2, this.x = e2, this.y = r2, this.key = Nh(0, t2, t2, e2, r2);
          }
          equals(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }
          url(t2, e2, r2) {
            const n2 = (function(t3, e3, r3) {
              var n3 = Ch(256 * t3, 256 * (e3 = Math.pow(2, r3) - e3 - 1), r3), i3 = Ch(256 * (t3 + 1), 256 * (e3 + 1), r3);
              return n3[0] + "," + n3[1] + "," + i3[0] + "," + i3[1];
            })(this.x, this.y, this.z), i2 = (function(t3, e3, r3) {
              let n3, i3 = "";
              for (let s2 = t3; s2 > 0; s2--) n3 = 1 << s2 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
              return i3;
            })(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, i2).replace(/{bbox-epsg-3857}/g, n2);
          }
          isChildOf(t2) {
            const e2 = this.z - t2.z;
            return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
          }
          getTilePoint(t2) {
            const e2 = Math.pow(2, this.z);
            return new r((t2.x * e2 - this.x) * M2, (t2.y * e2 - this.y) * M2);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Oh {
          constructor(t2, e2) {
            this.wrap = t2, this.canonical = e2, this.key = Nh(t2, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class Rh {
          constructor(t2, e2, r2, n2, i2) {
            if (this.terrainRttPosMatrix32f = null, t2 < r2) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t2}; z = ${r2}`);
            this.overscaledZ = t2, this.wrap = e2, this.canonical = new Lh(r2, +n2, +i2), this.key = Nh(e2, t2, r2, n2, i2);
          }
          clone() {
            return new Rh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }
          scaledTo(t2) {
            if (t2 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
            const e2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new Rh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Rh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z;
          }
          calculateScaledKey(t2, e2) {
            if (t2 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
            const r2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? Nh(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : Nh(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }
          isChildOf(t2) {
            if (t2.wrap !== this.wrap) return false;
            if (this.overscaledZ - t2.overscaledZ <= 0) return false;
            if (0 === t2.overscaledZ) return this.overscaledZ > 0;
            const e2 = this.canonical.z - t2.canonical.z;
            return !(e2 < 0) && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
          }
          children(t2) {
            if (this.overscaledZ >= t2) return [new Rh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new Rh(e2, this.wrap, e2, r2, n2), new Rh(e2, this.wrap, e2, r2 + 1, n2), new Rh(e2, this.wrap, e2, r2, n2 + 1), new Rh(e2, this.wrap, e2, r2 + 1, n2 + 1)];
          }
          isLessThan(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }
          wrapped() {
            return new Rh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t2) {
            return new Rh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Oh(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t2) {
            return this.canonical.getTilePoint(new Vh(t2.x - this.wrap, t2.y));
          }
        }
        function Nh(t2, e2, r2, n2, i2) {
          (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
          const s2 = 1 << r2;
          return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
        }
        function $h(t2, e2) {
          return e2 ? t2.properties[e2] : t2.id;
        }
        function Uh(t2, e2) {
          const r2 = { id: t2.id };
          if (e2.removeAllProperties && (delete t2.removeProperties, delete t2.addOrUpdateProperties, delete e2.removeProperties), e2.removeProperties) for (const r3 of e2.removeProperties) {
            const e3 = t2.addOrUpdateProperties.findIndex(((t3) => t3.key === r3));
            e3 > -1 && t2.addOrUpdateProperties.splice(e3, 1);
          }
          return (t2.removeAllProperties || e2.removeAllProperties) && (r2.removeAllProperties = true), (t2.removeProperties || e2.removeProperties) && (r2.removeProperties = [...t2.removeProperties || [], ...e2.removeProperties || []]), (t2.addOrUpdateProperties || e2.addOrUpdateProperties) && (r2.addOrUpdateProperties = [...t2.addOrUpdateProperties || [], ...e2.addOrUpdateProperties || []]), (t2.newGeometry || e2.newGeometry) && (r2.newGeometry = e2.newGeometry || t2.newGeometry), r2;
        }
        function qh(t2) {
          var e2, r2;
          if (!t2) return {};
          const n2 = {};
          return n2.removeAll = t2.removeAll, n2.remove = new Set(t2.remove || []), n2.add = new Map(null === (e2 = t2.add) || void 0 === e2 ? void 0 : e2.map(((t3) => [t3.id, t3]))), n2.update = new Map(null === (r2 = t2.update) || void 0 === r2 ? void 0 : r2.map(((t3) => [t3.id, t3]))), n2;
        }
        ps2("CanonicalTileID", Lh), ps2("OverscaledTileID", Rh, { omit: ["terrainRttPosMatrix32f"] });
        class jh {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t2) {
            return this.minX = Math.min(this.minX, t2.x), this.minY = Math.min(this.minY, t2.y), this.maxX = Math.max(this.maxX, t2.x), this.maxY = Math.max(this.maxY, t2.y), this;
          }
          expandBy(t2) {
            return this.minX -= t2, this.minY -= t2, this.maxX += t2, this.maxY += t2, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t2) {
            return this.expandBy(-t2);
          }
          map(t2) {
            const e2 = new jh();
            return e2.extend(t2(new r(this.minX, this.minY))), e2.extend(t2(new r(this.maxX, this.minY))), e2.extend(t2(new r(this.minX, this.maxY))), e2.extend(t2(new r(this.maxX, this.maxY))), e2;
          }
          static fromPoints(t2) {
            const e2 = new jh();
            for (const r2 of t2) e2.extend(r2);
            return e2;
          }
          contains(t2) {
            return t2.x >= this.minX && t2.x <= this.maxX && t2.y >= this.minY && t2.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t2) {
            return !this.empty() && !t2.empty() && t2.minX >= this.minX && t2.maxX <= this.maxX && t2.minY >= this.minY && t2.maxY <= this.maxY;
          }
          intersects(t2) {
            return !this.empty() && !t2.empty() && t2.minX <= this.maxX && t2.maxX >= this.minX && t2.minY <= this.maxY && t2.maxY >= this.minY;
          }
        }
        class Gh {
          constructor(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t2.length; e2++) {
              const r2 = t2[e2];
              this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
            }
          }
          encode(t2) {
            return this._stringToNumber[t2];
          }
          decode(t2) {
            if (t2 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t2} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t2];
          }
        }
        class Xh {
          constructor(t2, e2, r2, n2, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, this._x = r2, this._y = n2, this._z = e2, this.properties = t2.properties, this.id = i2;
          }
          projectPoint(t2, e2, r2, n2) {
            return [360 * (t2.x + e2) / n2 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t2.y + r2) / n2) * Math.PI)) - 90];
          }
          projectLine(t2, e2, r2, n2) {
            return t2.map(((t3) => this.projectPoint(t3, e2, r2, n2)));
          }
          get geometry() {
            if (this._geometry) return this._geometry;
            const t2 = this._vectorTileFeature, e2 = t2.extent * Math.pow(2, this._z), r2 = t2.extent * this._x, n2 = t2.extent * this._y, i2 = t2.loadGeometry();
            switch (t2.type) {
              case 1: {
                const t3 = [];
                for (const e3 of i2) t3.push(e3[0]);
                const s2 = this.projectLine(t3, r2, n2, e2);
                this._geometry = 1 === t3.length ? { type: "Point", coordinates: s2[0] } : { type: "MultiPoint", coordinates: s2 };
                break;
              }
              case 2: {
                const t3 = i2.map(((t4) => this.projectLine(t4, r2, n2, e2)));
                this._geometry = 1 === t3.length ? { type: "LineString", coordinates: t3[0] } : { type: "MultiLineString", coordinates: t3 };
                break;
              }
              case 3: {
                const t3 = Du2(i2), s2 = [];
                for (const i3 of t3) s2.push(i3.map(((t4) => this.projectLine(t4, r2, n2, e2))));
                this._geometry = 1 === s2.length ? { type: "Polygon", coordinates: s2[0] } : { type: "MultiPolygon", coordinates: s2 };
                break;
              }
              default:
                throw new Error(`unknown feature type: ${t2.type}`);
            }
            return this._geometry;
          }
          set geometry(t2) {
            this._geometry = t2;
          }
          toJSON() {
            const t2 = { geometry: this.geometry };
            for (const e2 in this) "_geometry" !== e2 && "_vectorTileFeature" !== e2 && "_x" !== e2 && "_y" !== e2 && "_z" !== e2 && (t2[e2] = this[e2]);
            return t2;
          }
        }
        class Yh {
          _name;
          dataBuffer;
          nullabilityBuffer;
          _size;
          constructor(t2, e2, r2) {
            this._name = t2, this.dataBuffer = e2, "number" == typeof r2 ? this._size = r2 : (this.nullabilityBuffer = r2, this._size = r2.size());
          }
          getValue(t2) {
            return this.nullabilityBuffer && !this.nullabilityBuffer.get(t2) ? null : this.getValueFromBuffer(t2);
          }
          has(t2) {
            return this.nullabilityBuffer && this.nullabilityBuffer.get(t2) || !this.nullabilityBuffer;
          }
          get name() {
            return this._name;
          }
          get size() {
            return this._size;
          }
        }
        class Zh extends Yh {
        }
        class Hh extends Zh {
          getValueFromBuffer(t2) {
            return this.dataBuffer[t2];
          }
        }
        class Kh extends Zh {
          getValueFromBuffer(t2) {
            return this.dataBuffer[t2];
          }
        }
        class Wh extends Yh {
          delta;
          constructor(t2, e2, r2, n2) {
            super(t2, e2, n2), this.delta = r2;
          }
        }
        class Jh extends Wh {
          constructor(t2, e2, r2, n2) {
            super(t2, Int32Array.of(e2), r2, n2);
          }
          getValueFromBuffer(t2) {
            return this.dataBuffer[0] + t2 * this.delta;
          }
        }
        class Qh extends Yh {
          constructor(t2, e2, r2) {
            super(t2, Int32Array.of(e2), r2);
          }
          getValueFromBuffer(t2) {
            return this.dataBuffer[0];
          }
        }
        class tp2 {
          _name;
          _geometryVector;
          _idVector;
          _propertyVectors;
          _extent;
          propertyVectorsMap;
          constructor(t2, e2, r2, n2, i2 = 4096) {
            this._name = t2, this._geometryVector = e2, this._idVector = r2, this._propertyVectors = n2, this._extent = i2;
          }
          get name() {
            return this._name;
          }
          get idVector() {
            return this._idVector;
          }
          get geometryVector() {
            return this._geometryVector;
          }
          get propertyVectors() {
            return this._propertyVectors;
          }
          getPropertyVector(t2) {
            return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map(((t3) => [t3.name, t3])))), this.propertyVectorsMap.get(t2);
          }
          *[Symbol.iterator]() {
            const t2 = this.geometryVector[Symbol.iterator]();
            let e2 = 0;
            for (; e2 < this.numFeatures; ) {
              let r2;
              this.idVector && (r2 = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(e2)) : this.idVector.getValue(e2));
              const n2 = t2?.next().value, i2 = {};
              for (const t3 of this.propertyVectors) {
                if (!t3) continue;
                const r3 = t3.name, n3 = t3.getValue(e2);
                null !== n3 && (i2[r3] = n3);
              }
              e2++, yield { id: r2, geometry: n2, properties: i2 };
            }
          }
          get numFeatures() {
            return this.geometryVector.numGeometries;
          }
          get extent() {
            return this._extent;
          }
          getFeatures() {
            const t2 = [], e2 = this.geometryVector.getGeometries();
            for (let r2 = 0; r2 < this.numFeatures; r2++) {
              let n2;
              this.idVector && (n2 = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(r2)) : this.idVector.getValue(r2));
              const i2 = { coordinates: e2[r2], type: this.geometryVector.geometryType(r2) }, s2 = {};
              for (const t3 of this.propertyVectors) {
                if (!t3) continue;
                const e3 = t3.name, n3 = t3.getValue(r2);
                null !== n3 && (s2[e3] = n3);
              }
              t2.push({ id: n2, geometry: i2, properties: s2 });
            }
            return t2;
          }
          containsMaxSaveIntegerValues(t2) {
            return t2 instanceof Hh || t2 instanceof Qh && t2 instanceof Jh || t2 instanceof Kh;
          }
        }
        class ep2 {
          value;
          constructor(t2) {
            this.value = t2;
          }
          get() {
            return this.value;
          }
          set(t2) {
            this.value = t2;
          }
          increment() {
            return this.value++;
          }
          add(t2) {
            this.value += t2;
          }
        }
        var rp2, np2, ip2, sp2, ap2, op2, lp2, up2, cp2, hp2;
        function pp2(t2, e2, r2) {
          const n2 = new Int32Array(r2);
          let i2 = 0, s2 = e2.get();
          for (let e3 = 0; e3 < n2.length; e3++) {
            let e4 = t2[s2++], r3 = 127 & e4;
            e4 < 128 || (e4 = t2[s2++], r3 |= (127 & e4) << 7, e4 < 128 || (e4 = t2[s2++], r3 |= (127 & e4) << 14, e4 < 128 || (e4 = t2[s2++], r3 |= (127 & e4) << 21, e4 < 128 || (e4 = t2[s2++], r3 |= (15 & e4) << 28)))), n2[i2++] = r3;
          }
          return e2.set(s2), n2;
        }
        function fp2(t2, e2, r2) {
          const n2 = new BigInt64Array(r2);
          for (let r3 = 0; r3 < n2.length; r3++) n2[r3] = xp2(t2, e2);
          return n2;
        }
        function dp2(t2, e2) {
          let r2, n2;
          return n2 = t2[e2.get()], e2.increment(), r2 = 127 & n2, n2 < 128 ? r2 : (n2 = t2[e2.get()], e2.increment(), r2 |= (127 & n2) << 7, n2 < 128 ? r2 : (n2 = t2[e2.get()], e2.increment(), r2 |= (127 & n2) << 14, n2 < 128 ? r2 : (n2 = t2[e2.get()], e2.increment(), r2 |= (127 & n2) << 21, n2 < 128 ? r2 : (n2 = t2[e2.get()], r2 |= (15 & n2) << 28, (function(t3, e3, r3) {
            let n3, i2;
            if (i2 = e3[r3.get()], r3.increment(), n3 = (112 & i2) >> 4, i2 < 128) return 4294967296 * n3 + (t3 >>> 0);
            if (i2 = e3[r3.get()], r3.increment(), n3 |= (127 & i2) << 3, i2 < 128) return 4294967296 * n3 + (t3 >>> 0);
            if (i2 = e3[r3.get()], r3.increment(), n3 |= (127 & i2) << 10, i2 < 128) return 4294967296 * n3 + (t3 >>> 0);
            if (i2 = e3[r3.get()], r3.increment(), n3 |= (127 & i2) << 17, i2 < 128) return 4294967296 * n3 + (t3 >>> 0);
            if (i2 = e3[r3.get()], r3.increment(), n3 |= (127 & i2) << 24, i2 < 128) return 4294967296 * n3 + (t3 >>> 0);
            if (i2 = e3[r3.get()], r3.increment(), n3 |= (1 & i2) << 31, i2 < 128) return 4294967296 * n3 + (t3 >>> 0);
            throw new Error("Expected varint not more than 10 bytes");
          })(r2, t2, e2)))));
        }
        function yp2(t2, e2, r2, n2) {
          throw new Error("FastPFor is not implemented yet.");
        }
        function mp2(t2) {
          return t2 >>> 1 ^ -(1 & t2);
        }
        function gp2(t2) {
          return t2 >> 1n ^ -(1n & t2);
        }
        function xp2(t2, e2) {
          let r2 = 0n, n2 = 0, i2 = e2.get();
          for (; i2 < t2.length; ) {
            const e3 = t2[i2++];
            if (r2 |= BigInt(127 & e3) << BigInt(n2), !(128 & e3)) break;
            if (n2 += 7, n2 >= 64) throw new Error("Varint too long");
          }
          return e2.set(i2), r2;
        }
        function vp2(t2, e2, r2) {
          const n2 = new Int32Array(r2);
          let i2 = 0;
          for (let r3 = 0; r3 < e2; r3++) {
            const s2 = t2[r3];
            n2.fill(t2[r3 + e2], i2, i2 + s2), i2 += s2;
          }
          return n2;
        }
        function bp2(t2, e2, r2) {
          const n2 = new BigInt64Array(r2);
          let i2 = 0;
          for (let r3 = 0; r3 < e2; r3++) {
            const s2 = Number(t2[r3]);
            n2.fill(t2[r3 + e2], i2, i2 + s2), i2 += s2;
          }
          return n2;
        }
        function wp2(t2, e2, r2) {
          const n2 = new Float64Array(r2);
          let i2 = 0;
          for (let r3 = 0; r3 < e2; r3++) {
            const s2 = t2[r3];
            n2.fill(t2[r3 + e2], i2, i2 + s2), i2 += s2;
          }
          return n2;
        }
        function _p2(t2) {
          const e2 = t2.length / 4 * 4;
          let r2 = 1;
          if (e2 >= 4) for (let n2 = t2[0]; r2 < e2 - 4; r2 += 4) n2 = t2[r2] += n2, n2 = t2[r2 + 1] += n2, n2 = t2[r2 + 2] += n2, n2 = t2[r2 + 3] += n2;
          for (; r2 != t2.length; ) t2[r2] += t2[r2 - 1], ++r2;
        }
        function Sp2(t2) {
          t2[0] = t2[0] >>> 1 ^ -(1 & t2[0]), t2[1] = t2[1] >>> 1 ^ -(1 & t2[1]);
          const e2 = t2.length / 4 * 4;
          let r2 = 2;
          if (e2 >= 4) for (; r2 < e2 - 4; r2 += 4) {
            const e3 = t2[r2], n2 = t2[r2 + 1], i2 = t2[r2 + 2], s2 = t2[r2 + 3];
            t2[r2] = (e3 >>> 1 ^ -(1 & e3)) + t2[r2 - 2], t2[r2 + 1] = (n2 >>> 1 ^ -(1 & n2)) + t2[r2 - 1], t2[r2 + 2] = (i2 >>> 1 ^ -(1 & i2)) + t2[r2], t2[r2 + 3] = (s2 >>> 1 ^ -(1 & s2)) + t2[r2 + 1];
          }
          for (; r2 != t2.length; r2 += 2) t2[r2] = (t2[r2] >>> 1 ^ -(1 & t2[r2])) + t2[r2 - 2], t2[r2 + 1] = (t2[r2 + 1] >>> 1 ^ -(1 & t2[r2 + 1])) + t2[r2 - 1];
        }
        !(function(t2) {
          t2.NONE = "NONE", t2.DELTA = "DELTA", t2.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", t2.RLE = "RLE", t2.MORTON = "MORTON", t2.PDE = "PDE";
        })(rp2 || (rp2 = {})), (function(t2) {
          t2.NONE = "NONE", t2.FAST_PFOR = "FAST_PFOR", t2.VARINT = "VARINT", t2.ALP = "ALP";
        })(np2 || (np2 = {})), (function(t2) {
          t2.PRESENT = "PRESENT", t2.DATA = "DATA", t2.OFFSET = "OFFSET", t2.LENGTH = "LENGTH";
        })(ip2 || (ip2 = {}));
        class Ap2 {
          _dictionaryType;
          _offsetType;
          _lengthType;
          constructor(t2, e2, r2) {
            this._dictionaryType = t2, this._offsetType = e2, this._lengthType = r2;
          }
          get dictionaryType() {
            return this._dictionaryType;
          }
          get offsetType() {
            return this._offsetType;
          }
          get lengthType() {
            return this._lengthType;
          }
        }
        function kp2(t2, e2) {
          const r2 = (function(t3, e3) {
            const r3 = t3[e3.get()], n2 = Object.values(ip2)[r3 >> 4];
            let i2 = null;
            switch (n2) {
              case ip2.DATA:
                i2 = new Ap2(Object.values(sp2)[15 & r3]);
                break;
              case ip2.OFFSET:
                i2 = new Ap2(null, Object.values(ap2)[15 & r3]);
                break;
              case ip2.LENGTH:
                i2 = new Ap2(null, null, Object.values(op2)[15 & r3]);
            }
            e3.increment();
            const s2 = t3[e3.get()], a2 = Object.values(rp2)[s2 >> 5], o2 = Object.values(rp2)[s2 >> 2 & 7], l2 = Object.values(np2)[3 & s2];
            e3.increment();
            const u2 = pp2(t3, e3, 2), c2 = u2[0];
            return { physicalStreamType: n2, logicalStreamType: i2, logicalLevelTechnique1: a2, logicalLevelTechnique2: o2, physicalLevelTechnique: l2, numValues: c2, byteLength: u2[1], decompressedCount: c2 };
          })(t2, e2);
          return r2.logicalLevelTechnique1 === rp2.MORTON ? (function(t3, e3, r3) {
            const n2 = pp2(e3, r3, 2);
            return { physicalStreamType: t3.physicalStreamType, logicalStreamType: t3.logicalStreamType, logicalLevelTechnique1: t3.logicalLevelTechnique1, logicalLevelTechnique2: t3.logicalLevelTechnique2, physicalLevelTechnique: t3.physicalLevelTechnique, numValues: t3.numValues, byteLength: t3.byteLength, decompressedCount: t3.decompressedCount, numBits: n2[0], coordinateShift: n2[1] };
          })(r2, t2, e2) : rp2.RLE !== r2.logicalLevelTechnique1 && rp2.RLE !== r2.logicalLevelTechnique2 || np2.NONE === r2.physicalLevelTechnique ? r2 : (function(t3, e3, r3) {
            const n2 = pp2(e3, r3, 2);
            return { physicalStreamType: t3.physicalStreamType, logicalStreamType: t3.logicalStreamType, logicalLevelTechnique1: t3.logicalLevelTechnique1, logicalLevelTechnique2: t3.logicalLevelTechnique2, physicalLevelTechnique: t3.physicalLevelTechnique, numValues: t3.numValues, byteLength: t3.byteLength, decompressedCount: n2[1], runs: n2[0], numRleValues: n2[1] };
          })(r2, t2, e2);
        }
        !(function(t2) {
          t2.NONE = "NONE", t2.SINGLE = "SINGLE", t2.SHARED = "SHARED", t2.VERTEX = "VERTEX", t2.MORTON = "MORTON", t2.FSST = "FSST";
        })(sp2 || (sp2 = {})), (function(t2) {
          t2.VERTEX = "VERTEX", t2.INDEX = "INDEX", t2.STRING = "STRING", t2.KEY = "KEY";
        })(ap2 || (ap2 = {})), (function(t2) {
          t2.VAR_BINARY = "VAR_BINARY", t2.GEOMETRIES = "GEOMETRIES", t2.PARTS = "PARTS", t2.RINGS = "RINGS", t2.TRIANGLES = "TRIANGLES", t2.SYMBOL = "SYMBOL", t2.DICTIONARY = "DICTIONARY";
        })(op2 || (op2 = {})), (function(t2) {
          t2[t2.FLAT = 0] = "FLAT", t2[t2.CONST = 1] = "CONST", t2[t2.SEQUENCE = 2] = "SEQUENCE", t2[t2.DICTIONARY = 3] = "DICTIONARY", t2[t2.FSST_DICTIONARY = 4] = "FSST_DICTIONARY";
        })(lp2 || (lp2 = {}));
        class Ep2 {
          values;
          _size;
          constructor(t2, e2) {
            this.values = t2, this._size = e2;
          }
          get(t2) {
            const e2 = Math.floor(t2 / 8);
            return 1 == (this.values[e2] >> t2 % 8 & 1);
          }
          set(t2, e2) {
            const r2 = Math.floor(t2 / 8);
            this.values[r2] = this.values[r2] | (e2 ? 1 : 0) << t2 % 8;
          }
          getInt(t2) {
            const e2 = Math.floor(t2 / 8);
            return this.values[e2] >> t2 % 8 & 1;
          }
          size() {
            return this._size;
          }
          getBuffer() {
            return this.values;
          }
        }
        function Tp2(t2, e2, r2, n2, i2) {
          return (function(t3, e3, r3) {
            switch (e3.logicalLevelTechnique1) {
              case rp2.DELTA:
                return e3.logicalLevelTechnique2 === rp2.RLE ? (function(t4, e4, r4) {
                  const n3 = new Int32Array(r4);
                  let i3 = 0, s2 = 0;
                  for (let r5 = 0; r5 < e4; r5++) {
                    const a2 = t4[r5], o2 = mp2(t4[r5 + e4]);
                    for (let t5 = 0; t5 < a2; t5++) s2 += o2, n3[i3++] = s2;
                  }
                  return n3;
                })(t3, e3.runs, e3.numRleValues) : ((function(t4) {
                  t4[0] = t4[0] >>> 1 ^ -(1 & t4[0]);
                  const e4 = t4.length / 4 * 4;
                  let r4 = 1;
                  if (e4 >= 4) for (; r4 < e4 - 4; r4 += 4) {
                    const e5 = t4[r4], n3 = t4[r4 + 1], i3 = t4[r4 + 2], s2 = t4[r4 + 3];
                    t4[r4] = (e5 >>> 1 ^ -(1 & e5)) + t4[r4 - 1], t4[r4 + 1] = (n3 >>> 1 ^ -(1 & n3)) + t4[r4], t4[r4 + 2] = (i3 >>> 1 ^ -(1 & i3)) + t4[r4 + 1], t4[r4 + 3] = (s2 >>> 1 ^ -(1 & s2)) + t4[r4 + 2];
                  }
                  for (; r4 != t4.length; ++r4) t4[r4] = (t4[r4] >>> 1 ^ -(1 & t4[r4])) + t4[r4 - 1];
                })(t3), t3);
              case rp2.RLE:
                return (function(t4, e4, r4) {
                  return r4 ? (function(t5, e5, r5) {
                    const n3 = new Int32Array(r5);
                    let i3 = 0;
                    for (let r6 = 0; r6 < e5; r6++) {
                      const s2 = t5[r6];
                      let a2 = t5[r6 + e5];
                      a2 = a2 >>> 1 ^ -(1 & a2), n3.fill(a2, i3, i3 + s2), i3 += s2;
                    }
                    return n3;
                  })(t4, e4.runs, e4.numRleValues) : vp2(t4, e4.runs, e4.numRleValues);
                })(t3, e3, r3);
              case rp2.MORTON:
                return _p2(t3), t3;
              case rp2.COMPONENTWISE_DELTA:
                return Sp2(t3), t3;
              case rp2.NONE:
                return r3 && (function(t4) {
                  for (let e4 = 0; e4 < t4.length; e4++) {
                    const r4 = t4[e4];
                    t4[e4] = r4 >>> 1 ^ -(1 & r4);
                  }
                })(t3), t3;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${e3.logicalLevelTechnique1}`);
            }
          })(Mp2(t2, e2, r2), r2, n2);
        }
        function Ip2(t2, e2, r2) {
          return (function(t3, e3) {
            if (e3.logicalLevelTechnique1 === rp2.DELTA && e3.logicalLevelTechnique2 === rp2.NONE) {
              const e4 = (function(t4) {
                const e5 = new Int32Array(t4.length + 1);
                e5[0] = 0, e5[1] = mp2(t4[0]);
                let r3 = e5[1], n2 = 2;
                for (; n2 != e5.length; ++n2) {
                  const i2 = t4[n2 - 1];
                  r3 += i2 >>> 1 ^ -(1 & i2), e5[n2] = e5[n2 - 1] + r3;
                }
                return e5;
              })(t3);
              return e4;
            }
            if (e3.logicalLevelTechnique1 === rp2.RLE && e3.logicalLevelTechnique2 === rp2.NONE) {
              const r3 = (function(t4, e4, r4) {
                const n2 = new Int32Array(r4 + 1);
                n2[0] = 0;
                let i2 = 1, s2 = n2[0];
                for (let r5 = 0; r5 < e4; r5++) {
                  const a2 = t4[r5], o2 = t4[r5 + e4];
                  for (let t5 = i2; t5 < i2 + a2; t5++) n2[t5] = o2 + s2, s2 = n2[t5];
                  i2 += a2;
                }
                return n2;
              })(t3, e3.runs, e3.numRleValues);
              return r3;
            }
            if (e3.logicalLevelTechnique1 === rp2.NONE && e3.logicalLevelTechnique2 === rp2.NONE) {
              !(function(t4) {
                let e4 = 0;
                for (let r4 = 0; r4 < t4.length; r4++) t4[r4] += e4, e4 = t4[r4];
              })(t3);
              const r3 = new Int32Array(e3.numValues + 1);
              return r3[0] = 0, r3.set(t3, 1), r3;
            }
            if (e3.logicalLevelTechnique1 === rp2.DELTA && e3.logicalLevelTechnique2 === rp2.RLE) {
              const r3 = (function(t4, e4, r4) {
                const n2 = new Int32Array(r4 + 1);
                n2[0] = 0;
                let i2 = 1, s2 = n2[0];
                for (let r5 = 0; r5 < e4; r5++) {
                  const a2 = t4[r5];
                  let o2 = t4[r5 + e4];
                  o2 = o2 >>> 1 ^ -(1 & o2);
                  for (let t5 = i2; t5 < i2 + a2; t5++) n2[t5] = o2 + s2, s2 = n2[t5];
                  i2 += a2;
                }
                return n2;
              })(t3, e3.runs, e3.numRleValues);
              return _p2(r3), r3;
            }
            throw new Error("Only delta encoding is supported for transforming length to offset streams yet.");
          })(Mp2(t2, e2, r2), r2);
        }
        function Mp2(t2, e2, r2) {
          const n2 = r2.physicalLevelTechnique;
          if (n2 === np2.FAST_PFOR) return yp2();
          if (n2 === np2.VARINT) return pp2(t2, e2, r2.numValues);
          if (n2 === np2.NONE) {
            const n3 = e2.get();
            e2.add(r2.byteLength);
            const i2 = t2.subarray(n3, e2.get());
            return new Int32Array(i2);
          }
          throw new Error("Specified physicalLevelTechnique is not supported (yet).");
        }
        function Fp(t2, e2, r2, n2) {
          const i2 = Mp2(t2, e2, r2);
          if (1 === i2.length) {
            const t3 = i2[0];
            return n2 ? mp2(t3) : t3;
          }
          return n2 ? (function(t3) {
            return mp2(t3[1]);
          })(i2) : (function(t3) {
            return t3[1];
          })(i2);
        }
        function Dp2(t2, e2, r2) {
          return (function(t3) {
            if (2 == t3.length) {
              const e3 = mp2(t3[1]);
              return [e3, e3];
            }
            return [mp2(t3[2]), mp2(t3[3])];
          })(Mp2(t2, e2, r2));
        }
        function zp(t2, e2, r2) {
          return (function(t3) {
            if (2 == t3.length) {
              const e3 = gp2(t3[1]);
              return [e3, e3];
            }
            return [gp2(t3[2]), gp2(t3[3])];
          })(fp2(t2, e2, r2.numValues));
        }
        function Pp2(t2, e2, r2, n2) {
          return (function(t3, e3, r3) {
            switch (e3.logicalLevelTechnique1) {
              case rp2.DELTA:
                return e3.logicalLevelTechnique2 === rp2.RLE ? (function(t4, e4, r4) {
                  const n3 = new BigInt64Array(r4);
                  let i2 = 0, s2 = 0n;
                  for (let r5 = 0; r5 < e4; r5++) {
                    const a2 = Number(t4[r5]), o2 = gp2(t4[r5 + e4]);
                    for (let t5 = 0; t5 < a2; t5++) s2 += o2, n3[i2++] = s2;
                  }
                  return n3;
                })(t3, e3.runs, e3.numRleValues) : ((function(t4) {
                  t4[0] = t4[0] >> 1n ^ -(1n & t4[0]);
                  const e4 = t4.length / 4 * 4;
                  let r4 = 1;
                  if (e4 >= 4) for (; r4 < e4 - 4; r4 += 4) {
                    const e5 = t4[r4], n3 = t4[r4 + 1], i2 = t4[r4 + 2], s2 = t4[r4 + 3];
                    t4[r4] = (e5 >> 1n ^ -(1n & e5)) + t4[r4 - 1], t4[r4 + 1] = (n3 >> 1n ^ -(1n & n3)) + t4[r4], t4[r4 + 2] = (i2 >> 1n ^ -(1n & i2)) + t4[r4 + 1], t4[r4 + 3] = (s2 >> 1n ^ -(1n & s2)) + t4[r4 + 2];
                  }
                  for (; r4 != t4.length; ++r4) t4[r4] = (t4[r4] >> 1n ^ -(1n & t4[r4])) + t4[r4 - 1];
                })(t3), t3);
              case rp2.RLE:
                return (function(t4, e4, r4) {
                  return r4 ? (function(t5, e5, r5) {
                    const n3 = new BigInt64Array(r5);
                    let i2 = 0;
                    for (let r6 = 0; r6 < e5; r6++) {
                      const s2 = Number(t5[r6]);
                      let a2 = t5[r6 + e5];
                      a2 = a2 >> 1n ^ -(1n & a2), n3.fill(a2, i2, i2 + s2), i2 += s2;
                    }
                    return n3;
                  })(t4, e4.runs, e4.numRleValues) : bp2(t4, e4.runs, e4.numRleValues);
                })(t3, e3, r3);
              case rp2.NONE:
                return r3 && (function(t4) {
                  for (let e4 = 0; e4 < t4.length; e4++) {
                    const r4 = t4[e4];
                    t4[e4] = r4 >> 1n ^ -(1n & r4);
                  }
                })(t3), t3;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${e3.logicalLevelTechnique1}`);
            }
          })(fp2(t2, e2, r2.numValues), r2, n2);
        }
        function Bp2(t2, e2, r2, n2) {
          const i2 = fp2(t2, e2, r2.numValues);
          if (1 === i2.length) {
            const t3 = i2[0];
            return n2 ? gp2(t3) : t3;
          }
          return n2 ? (function(t3) {
            return gp2(t3[1]);
          })(i2) : (function(t3) {
            return t3[1];
          })(i2);
        }
        function Vp2(t2, e2, r2, n2, i2) {
          return (function(t3, e3, r3, n3) {
            switch (e3.logicalLevelTechnique1) {
              case rp2.DELTA:
                return e3.logicalLevelTechnique2 === rp2.RLE && (t3 = vp2(t3, e3.runs, e3.numRleValues)), (function(t4, e4) {
                  const r4 = new Int32Array(t4.size());
                  let n4 = 0;
                  t4.get(0) ? (r4[0] = t4.get(0) ? e4[0] >>> 1 ^ -(1 & e4[0]) : 0, n4 = 1) : r4[0] = 0;
                  let i3 = 1;
                  for (; i3 != r4.length; ++i3) r4[i3] = t4.get(i3) ? r4[i3 - 1] + (e4[n4] >>> 1 ^ -(1 & e4[n4++])) : r4[i3 - 1];
                  return r4;
                })(n3, t3);
              case rp2.RLE:
                return (function(t4, e4, r4, n4) {
                  const i3 = e4;
                  return r4 ? (function(t5, e5, r5) {
                    const n5 = new Int32Array(t5.size());
                    let i4 = 0;
                    for (let s2 = 0; s2 < r5; s2++) {
                      const a2 = e5[s2];
                      let o2 = e5[s2 + r5];
                      o2 = o2 >>> 1 ^ -(1 & o2);
                      for (let e6 = i4; e6 < i4 + a2; e6++) t5.get(e6) ? n5[e6] = o2 : (n5[e6] = 0, i4++);
                      i4 += a2;
                    }
                    return n5;
                  })(n4, t4, i3.runs) : (function(t5, e5, r5) {
                    const n5 = new Int32Array(t5.size());
                    let i4 = 0;
                    for (let s2 = 0; s2 < r5; s2++) {
                      const a2 = e5[s2], o2 = e5[s2 + r5];
                      for (let e6 = i4; e6 < i4 + a2; e6++) t5.get(e6) ? n5[e6] = o2 : (n5[e6] = 0, i4++);
                      i4 += a2;
                    }
                    return n5;
                  })(n4, t4, i3.runs);
                })(t3, e3, r3, n3);
              case rp2.MORTON:
                return _p2(t3), t3;
              case rp2.COMPONENTWISE_DELTA:
                return Sp2(t3), t3;
              case rp2.NONE:
                return t3 = r3 ? (function(t4, e4) {
                  const r4 = new Int32Array(t4.size());
                  let n4 = 0, i3 = 0;
                  for (; i3 != r4.length; ++i3) if (t4.get(i3)) {
                    const t5 = e4[n4++];
                    r4[i3] = t5 >>> 1 ^ -(1 & t5);
                  } else r4[i3] = 0;
                  return r4;
                })(n3, t3) : (function(t4, e4) {
                  const r4 = new Int32Array(t4.size());
                  let n4 = 0, i3 = 0;
                  for (; i3 != r4.length; ++i3) r4[i3] = t4.get(i3) ? e4[n4++] : 0;
                  return r4;
                })(n3, t3), t3;
              default:
                throw new Error("The specified Logical level technique is not supported");
            }
          })(r2.physicalLevelTechnique === np2.FAST_PFOR ? yp2() : pp2(t2, e2, r2.numValues), r2, n2, i2);
        }
        function Cp2(t2, e2, r2, n2) {
          const i2 = t2.logicalLevelTechnique1;
          if (i2 === rp2.RLE) return 1 === t2.runs ? lp2.CONST : lp2.FLAT;
          const s2 = e2 instanceof Ep2 ? e2.size() : e2;
          if (i2 === rp2.DELTA && t2.logicalLevelTechnique2 === rp2.RLE) {
            const e3 = t2.runs, i3 = 2;
            if (t2.numRleValues !== s2) return lp2.FLAT;
            if (1 === e3) return lp2.SEQUENCE;
            if (2 === e3) {
              const e4 = n2.get();
              let s3;
              if (t2.physicalLevelTechnique === np2.VARINT) s3 = pp2(r2, n2, 4);
              else {
                const t3 = n2.get();
                s3 = new Int32Array(r2.buffer, r2.byteOffset + t3, 4);
              }
              if (n2.set(e4), s3[2] === i3 && s3[3] === i3) return lp2.SEQUENCE;
            }
          }
          return 1 === t2.numValues ? lp2.CONST : lp2.FLAT;
        }
        class Lp2 extends Zh {
          getValueFromBuffer(t2) {
            return this.dataBuffer[t2];
          }
        }
        class Op extends Wh {
          constructor(t2, e2, r2, n2) {
            super(t2, BigInt64Array.of(e2), r2, n2);
          }
          getValueFromBuffer(t2) {
            return this.dataBuffer[0] + BigInt(t2) * this.delta;
          }
        }
        class Rp {
          _geometryOffsets;
          _partOffsets;
          _ringOffsets;
          constructor(t2, e2, r2) {
            this._geometryOffsets = t2, this._partOffsets = e2, this._ringOffsets = r2;
          }
          get geometryOffsets() {
            return this._geometryOffsets;
          }
          get partOffsets() {
            return this._partOffsets;
          }
          get ringOffsets() {
            return this._ringOffsets;
          }
        }
        function Np(t2, e2, r2) {
          return { x: $p(t2, e2) - r2, y: $p(t2 >> 1, e2) - r2 };
        }
        function $p(t2, e2) {
          let r2 = 0;
          for (let n2 = 0; n2 < e2; n2++) r2 |= (t2 & 1 << 2 * n2) >> n2;
          return r2;
        }
        !(function(t2) {
          t2[t2.POINT = 0] = "POINT", t2[t2.LINESTRING = 1] = "LINESTRING", t2[t2.POLYGON = 2] = "POLYGON", t2[t2.MULTIPOINT = 3] = "MULTIPOINT", t2[t2.MULTILINESTRING = 4] = "MULTILINESTRING", t2[t2.MULTIPOLYGON = 5] = "MULTIPOLYGON";
        })(up2 || (up2 = {})), (function(t2) {
          t2[t2.POINT = 0] = "POINT", t2[t2.LINESTRING = 1] = "LINESTRING", t2[t2.POLYGON = 2] = "POLYGON";
        })(cp2 || (cp2 = {})), (function(t2) {
          t2[t2.MORTON = 0] = "MORTON", t2[t2.VEC_2 = 1] = "VEC_2", t2[t2.VEC_3 = 2] = "VEC_3";
        })(hp2 || (hp2 = {}));
        class Up2 {
          createPoint(t2) {
            return [[t2]];
          }
          createMultiPoint(t2) {
            return t2.map(((t3) => [t3]));
          }
          createLineString(t2) {
            return [t2];
          }
          createMultiLineString(t2) {
            return t2;
          }
          createPolygon(t2, e2) {
            return [t2].concat(e2);
          }
          createMultiPolygon(t2) {
            return t2.flat();
          }
        }
        function qp2(t2) {
          const e2 = new Array(t2.numGeometries);
          let n2 = 1, i2 = 1, s2 = 1, a2 = 0;
          const o2 = new Up2();
          let l2 = 0, u2 = 0;
          const c2 = t2.mortonSettings, h2 = t2.topologyVector, p2 = h2.geometryOffsets, f3 = h2.partOffsets, d2 = h2.ringOffsets, y3 = t2.vertexOffsets, m2 = t2.containsPolygonGeometry(), g2 = t2.vertexBuffer;
          for (let h3 = 0; h3 < t2.numGeometries; h3++) {
            const x2 = t2.geometryType(h3);
            if (x2 === up2.POINT) {
              if (y3 && 0 !== y3.length) if (t2.vertexBufferType === hp2.VEC_2) {
                const t3 = 2 * y3[u2++], n3 = new r(g2[t3], g2[t3 + 1]);
                e2[a2++] = o2.createPoint(n3);
              } else {
                const t3 = Np(g2[y3[u2++]], c2.numBits, c2.coordinateShift), n3 = new r(t3.x, t3.y);
                e2[a2++] = o2.createPoint(n3);
              }
              else {
                const t3 = new r(g2[l2++], g2[l2++]);
                e2[a2++] = o2.createPoint(t3);
              }
              p2 && s2++, f3 && n2++, d2 && i2++;
            } else if (x2 === up2.MULTIPOINT) {
              const t3 = p2[s2] - p2[s2 - 1];
              s2++;
              const n3 = new Array(t3);
              if (y3 && 0 !== y3.length) {
                for (let e3 = 0; e3 < t3; e3++) {
                  const t4 = 2 * y3[u2++];
                  n3[e3] = new r(g2[t4], g2[t4 + 1]);
                }
                e2[a2++] = o2.createMultiPoint(n3);
              } else {
                for (let e3 = 0; e3 < t3; e3++) {
                  const t4 = g2[l2++], i3 = g2[l2++];
                  n3[e3] = new r(t4, i3);
                }
                e2[a2++] = o2.createMultiPoint(n3);
              }
            } else if (x2 === up2.LINESTRING) {
              let r2, h4 = 0;
              m2 ? (h4 = d2[i2] - d2[i2 - 1], i2++) : h4 = f3[n2] - f3[n2 - 1], n2++, y3 && 0 !== y3.length ? (r2 = t2.vertexBufferType === hp2.VEC_2 ? Zp2(g2, y3, u2, h4, false) : Hp2(g2, y3, u2, h4, false, c2), u2 += h4) : (r2 = Yp2(g2, l2, h4, false), l2 += 2 * h4), e2[a2++] = o2.createLineString(r2), p2 && s2++;
            } else if (x2 === up2.POLYGON) {
              const r2 = f3[n2] - f3[n2 - 1];
              n2++;
              const h4 = new Array(r2 - 1);
              let m3 = d2[i2] - d2[i2 - 1];
              if (i2++, y3 && 0 !== y3.length) {
                const r3 = t2.vertexBufferType === hp2.VEC_2 ? Gp2(g2, y3, u2, m3) : Xp2(g2, y3, u2, m3, 0, c2);
                u2 += m3;
                for (let e3 = 0; e3 < h4.length; e3++) m3 = d2[i2] - d2[i2 - 1], i2++, h4[e3] = t2.vertexBufferType === hp2.VEC_2 ? Gp2(g2, y3, u2, m3) : Xp2(g2, y3, u2, m3, 0, c2), u2 += m3;
                e2[a2++] = o2.createPolygon(r3, h4);
              } else {
                const t3 = jp(g2, l2, m3);
                l2 += 2 * m3;
                for (let t4 = 0; t4 < h4.length; t4++) m3 = d2[i2] - d2[i2 - 1], i2++, h4[t4] = jp(g2, l2, m3), l2 += 2 * m3;
                e2[a2++] = o2.createPolygon(t3, h4);
              }
              p2 && s2++;
            } else if (x2 === up2.MULTILINESTRING) {
              const r2 = p2[s2] - p2[s2 - 1];
              s2++;
              const h4 = new Array(r2);
              if (y3 && 0 !== y3.length) {
                for (let e3 = 0; e3 < r2; e3++) {
                  let r3 = 0;
                  m2 ? (r3 = d2[i2] - d2[i2 - 1], i2++) : r3 = f3[n2] - f3[n2 - 1], n2++;
                  const s3 = t2.vertexBufferType === hp2.VEC_2 ? Zp2(g2, y3, u2, r3, false) : Hp2(g2, y3, u2, r3, false, c2);
                  h4[e3] = s3, u2 += r3;
                }
                e2[a2++] = o2.createMultiLineString(h4);
              } else {
                for (let t3 = 0; t3 < r2; t3++) {
                  let e3 = 0;
                  m2 ? (e3 = d2[i2] - d2[i2 - 1], i2++) : e3 = f3[n2] - f3[n2 - 1], n2++, h4[t3] = Yp2(g2, l2, e3, false), l2 += 2 * e3;
                }
                e2[a2++] = o2.createMultiLineString(h4);
              }
            } else {
              if (x2 !== up2.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported.");
              {
                const r2 = p2[s2] - p2[s2 - 1];
                s2++;
                const h4 = new Array(r2);
                let m3 = 0;
                if (y3 && 0 !== y3.length) {
                  for (let e3 = 0; e3 < r2; e3++) {
                    const r3 = f3[n2] - f3[n2 - 1];
                    n2++;
                    const s3 = new Array(r3 - 1);
                    m3 = d2[i2] - d2[i2 - 1], i2++;
                    const a3 = t2.vertexBufferType === hp2.VEC_2 ? Gp2(g2, y3, u2, m3) : Xp2(g2, y3, u2, m3, 0, c2);
                    u2 += m3;
                    for (let e4 = 0; e4 < s3.length; e4++) m3 = d2[i2] - d2[i2 - 1], i2++, s3[e4] = t2.vertexBufferType === hp2.VEC_2 ? Gp2(g2, y3, u2, m3) : Xp2(g2, y3, u2, m3, 0, c2), u2 += m3;
                    h4[e3] = o2.createPolygon(a3, s3);
                  }
                  e2[a2++] = o2.createMultiPolygon(h4);
                } else {
                  for (let t3 = 0; t3 < r2; t3++) {
                    const e3 = f3[n2] - f3[n2 - 1];
                    n2++;
                    const r3 = new Array(e3 - 1);
                    m3 = d2[i2] - d2[i2 - 1], i2++;
                    const s3 = jp(g2, l2, m3);
                    l2 += 2 * m3;
                    for (let t4 = 0; t4 < r3.length; t4++) {
                      const e4 = d2[i2] - d2[i2 - 1];
                      i2++, r3[t4] = jp(g2, l2, e4), l2 += 2 * e4;
                    }
                    h4[t3] = o2.createPolygon(s3, r3);
                  }
                  e2[a2++] = o2.createMultiPolygon(h4);
                }
              }
            }
          }
          return e2;
        }
        function jp(t2, e2, r2) {
          return Yp2(t2, e2, r2, true);
        }
        function Gp2(t2, e2, r2, n2) {
          return Zp2(t2, e2, r2, n2, true);
        }
        function Xp2(t2, e2, r2, n2, i2, s2) {
          return Hp2(t2, e2, r2, n2, true, s2);
        }
        function Yp2(t2, e2, n2, i2) {
          const s2 = new Array(i2 ? n2 + 1 : n2);
          for (let i3 = 0; i3 < 2 * n2; i3 += 2) s2[i3 / 2] = new r(t2[e2 + i3], t2[e2 + i3 + 1]);
          return i2 && (s2[s2.length - 1] = s2[0]), s2;
        }
        function Zp2(t2, e2, n2, i2, s2) {
          const a2 = new Array(s2 ? i2 + 1 : i2);
          for (let s3 = 0; s3 < 2 * i2; s3 += 2) {
            const i3 = 2 * e2[n2 + s3 / 2];
            a2[s3 / 2] = new r(t2[i3], t2[i3 + 1]);
          }
          return s2 && (a2[a2.length - 1] = a2[0]), a2;
        }
        function Hp2(t2, e2, n2, i2, s2, a2) {
          const o2 = new Array(s2 ? i2 + 1 : i2);
          for (let s3 = 0; s3 < i2; s3++) {
            const i3 = Np(t2[e2[n2 + s3]], a2.numBits, a2.coordinateShift);
            o2[s3] = new r(i3.x, i3.y);
          }
          return s2 && (o2[o2.length - 1] = o2[0]), o2;
        }
        class Kp2 {
          _vertexBufferType;
          _topologyVector;
          _vertexOffsets;
          _vertexBuffer;
          _mortonSettings;
          constructor(t2, e2, r2, n2, i2) {
            this._vertexBufferType = t2, this._topologyVector = e2, this._vertexOffsets = r2, this._vertexBuffer = n2, this._mortonSettings = i2;
          }
          get vertexBufferType() {
            return this._vertexBufferType;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          get vertexOffsets() {
            return this._vertexOffsets;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          *[Symbol.iterator]() {
            const t2 = qp2(this);
            let e2 = 0;
            for (; e2 < this.numGeometries; ) yield { coordinates: t2[e2], type: this.geometryType(e2) }, e2++;
          }
          getSimpleEncodedVertex(t2) {
            const e2 = this.vertexOffsets ? 2 * this.vertexOffsets[t2] : 2 * t2;
            return [this.vertexBuffer[e2], this.vertexBuffer[e2 + 1]];
          }
          getVertex(t2) {
            if (this.vertexOffsets && this.mortonSettings) {
              const e3 = Np(this.vertexBuffer[this.vertexOffsets[t2]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift);
              return [e3.x, e3.y];
            }
            const e2 = this.vertexOffsets ? 2 * this.vertexOffsets[t2] : 2 * t2;
            return [this.vertexBuffer[e2], this.vertexBuffer[e2 + 1]];
          }
          getGeometries() {
            return qp2(this);
          }
          get mortonSettings() {
            return this._mortonSettings;
          }
        }
        class Wp2 extends Kp2 {
          _numGeometries;
          _geometryType;
          constructor(t2, e2, r2, n2, i2, s2, a2) {
            super(r2, n2, i2, s2, a2), this._numGeometries = t2, this._geometryType = e2;
          }
          geometryType(t2) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsPolygonGeometry() {
            return this._geometryType === up2.POLYGON || this._geometryType === up2.MULTIPOLYGON;
          }
          containsSingleGeometryType() {
            return true;
          }
        }
        class Jp2 extends Kp2 {
          _geometryTypes;
          constructor(t2, e2, r2, n2, i2, s2) {
            super(t2, r2, n2, i2, s2), this._geometryTypes = e2;
          }
          geometryType(t2) {
            return this._geometryTypes[t2];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsPolygonGeometry() {
            for (let t2 = 0; t2 < this.numGeometries; t2++) if (this.geometryType(t2) === up2.POLYGON || this.geometryType(t2) === up2.MULTIPOLYGON) return true;
            return false;
          }
          containsSingleGeometryType() {
            return false;
          }
        }
        class Qp2 {
          _triangleOffsets;
          _indexBuffer;
          _vertexBuffer;
          _topologyVector;
          constructor(t2, e2, r2, n2) {
            this._triangleOffsets = t2, this._indexBuffer = e2, this._vertexBuffer = r2, this._topologyVector = n2;
          }
          get triangleOffsets() {
            return this._triangleOffsets;
          }
          get indexBuffer() {
            return this._indexBuffer;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          getGeometries() {
            if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information");
            const t2 = new Array(this.numGeometries), e2 = this._topologyVector, n2 = e2.partOffsets, i2 = e2.ringOffsets, s2 = e2.geometryOffsets;
            let a2 = 0, o2 = 1, l2 = 1, u2 = 1;
            for (let e3 = 0; e3 < this.numGeometries; e3++) switch (this.geometryType(e3)) {
              case up2.POLYGON:
                {
                  const c2 = n2[o2] - n2[o2 - 1];
                  o2++;
                  const h2 = [];
                  for (let t3 = 0; t3 < c2; t3++) {
                    const t4 = i2[l2] - i2[l2 - 1];
                    l2++;
                    const e4 = [];
                    for (let n3 = 0; n3 < t4; n3++) {
                      const t5 = this._vertexBuffer[a2++], n4 = this._vertexBuffer[a2++];
                      e4.push(new r(t5, n4));
                    }
                    e4.length > 0 && e4.push(e4[0]), h2.push(e4);
                  }
                  t2[e3] = h2, s2 && u2++;
                }
                break;
              case up2.MULTIPOLYGON: {
                const c2 = s2[u2] - s2[u2 - 1];
                u2++;
                const h2 = [];
                for (let t3 = 0; t3 < c2; t3++) {
                  const t4 = n2[o2] - n2[o2 - 1];
                  o2++;
                  for (let e4 = 0; e4 < t4; e4++) {
                    const t5 = i2[l2] - i2[l2 - 1];
                    l2++;
                    const e5 = [];
                    for (let n3 = 0; n3 < t5; n3++) {
                      const t6 = this._vertexBuffer[a2++], n4 = this._vertexBuffer[a2++];
                      e5.push(new r(t6, n4));
                    }
                    e5.length > 0 && e5.push(e5[0]), h2.push(e5);
                  }
                }
                t2[e3] = h2;
              }
            }
            return t2;
          }
          [Symbol.iterator]() {
            return null;
          }
        }
        function tf2(t2, e2, r2, n2, i2, s2) {
          return new ef2(t2, e2, r2, n2, i2, s2);
        }
        class ef2 extends Qp2 {
          _numGeometries;
          _geometryType;
          constructor(t2, e2, r2, n2, i2, s2) {
            super(r2, n2, i2, s2), this._numGeometries = t2, this._geometryType = e2;
          }
          geometryType(t2) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsSingleGeometryType() {
            return true;
          }
        }
        function rf2(t2, e2, r2, n2, i2) {
          return new nf2(t2, e2, r2, n2, i2);
        }
        class nf2 extends Qp2 {
          _geometryTypes;
          constructor(t2, e2, r2, n2, i2) {
            super(e2, r2, n2, i2), this._geometryTypes = t2;
          }
          geometryType(t2) {
            return this._geometryTypes[t2];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsSingleGeometryType() {
            return false;
          }
        }
        function sf2(t2, e2, r2, n2, i2) {
          const s2 = kp2(t2, r2);
          let a2 = null, o2 = null, l2 = null, u2 = null, c2 = null, h2 = null, p2 = null, f3 = null;
          if (Cp2(s2, n2, t2, r2) === lp2.CONST) {
            const i3 = Fp(t2, r2, s2, false);
            for (let n3 = 0; n3 < e2 - 1; n3++) {
              const e3 = kp2(t2, r2);
              switch (e3.physicalStreamType) {
                case ip2.LENGTH:
                  switch (e3.logicalStreamType.lengthType) {
                    case op2.GEOMETRIES:
                      a2 = Ip2(t2, r2, e3);
                      break;
                    case op2.PARTS:
                      o2 = Ip2(t2, r2, e3);
                      break;
                    case op2.RINGS:
                      l2 = Ip2(t2, r2, e3);
                      break;
                    case op2.TRIANGLES:
                      p2 = Ip2(t2, r2, e3);
                  }
                  break;
                case ip2.OFFSET:
                  switch (e3.logicalStreamType.offsetType) {
                    case ap2.VERTEX:
                      u2 = Tp2(t2, r2, e3, false);
                      break;
                    case ap2.INDEX:
                      f3 = Tp2(t2, r2, e3, false);
                  }
                  break;
                case ip2.DATA:
                  sp2.VERTEX === e3.logicalStreamType.dictionaryType ? c2 = Tp2(t2, r2, e3, true) : (h2 = { numBits: e3.numBits, coordinateShift: e3.coordinateShift }, c2 = Tp2(t2, r2, e3, false));
              }
            }
            return null !== f3 ? null != a2 || null != o2 ? tf2(n2, i3, p2, f3, c2, new Rp(a2, o2, l2)) : tf2(n2, i3, p2, f3, c2) : null === h2 ? (function(t3, e3, r3, n3, i4) {
              return new Wp2(t3, e3, hp2.VEC_2, r3, n3, i4);
            })(n2, i3, new Rp(a2, o2, l2), u2, c2) : (function(t3, e3, r3, n3, i4, s3) {
              return new Wp2(t3, e3, hp2.MORTON, r3, n3, i4, s3);
            })(n2, i3, new Rp(a2, o2, l2), u2, c2, h2);
          }
          const d2 = Tp2(t2, r2, s2, false);
          for (let n3 = 0; n3 < e2 - 1; n3++) {
            const e3 = kp2(t2, r2);
            switch (e3.physicalStreamType) {
              case ip2.LENGTH:
                switch (e3.logicalStreamType.lengthType) {
                  case op2.GEOMETRIES:
                    a2 = Tp2(t2, r2, e3, false);
                    break;
                  case op2.PARTS:
                    o2 = Tp2(t2, r2, e3, false);
                    break;
                  case op2.RINGS:
                    l2 = Tp2(t2, r2, e3, false);
                    break;
                  case op2.TRIANGLES:
                    p2 = Ip2(t2, r2, e3);
                }
                break;
              case ip2.OFFSET:
                switch (e3.logicalStreamType.offsetType) {
                  case ap2.VERTEX:
                    u2 = Tp2(t2, r2, e3, false);
                    break;
                  case ap2.INDEX:
                    f3 = Tp2(t2, r2, e3, false);
                }
                break;
              case ip2.DATA:
                sp2.VERTEX === e3.logicalStreamType.dictionaryType ? c2 = Tp2(t2, r2, e3, true) : (h2 = { numBits: e3.numBits, coordinateShift: e3.coordinateShift }, c2 = Tp2(t2, r2, e3, false));
            }
          }
          return null !== f3 && null === o2 ? rf2(d2, p2, f3, c2) : (null !== a2 ? (a2 = af2(d2, a2, 2), null !== o2 && null !== l2 ? (o2 = of2(d2, a2, o2, false), l2 = (function(t3, e3, r3, n3) {
            const i3 = new Int32Array(r3[r3.length - 1] + 1);
            let s3 = 0;
            i3[0] = s3;
            let a3 = 1, o3 = 1, l3 = 0;
            for (let u3 = 0; u3 < t3.length; u3++) {
              const c3 = t3[u3], h3 = e3[u3 + 1] - e3[u3];
              if (0 !== c3 && 3 !== c3) for (let t4 = 0; t4 < h3; t4++) {
                const t5 = r3[a3] - r3[a3 - 1];
                a3++;
                for (let e4 = 0; e4 < t5; e4++) s3 = i3[o3++] = s3 + n3[l3++];
              }
              else for (let t4 = 0; t4 < h3; t4++) i3[o3++] = ++s3, a3++;
            }
            return i3;
          })(d2, a2, o2, l2)) : null !== o2 && (o2 = (function(t3, e3, r3) {
            const n3 = new Int32Array(e3[e3.length - 1] + 1);
            let i3 = 0;
            n3[0] = i3;
            let s3 = 1, a3 = 0;
            for (let o3 = 0; o3 < t3.length; o3++) {
              const l3 = t3[o3], u3 = e3[o3 + 1] - e3[o3];
              if (4 === l3 || 1 === l3) for (let t4 = 0; t4 < u3; t4++) i3 = n3[s3++] = i3 + r3[a3++];
              else for (let t4 = 0; t4 < u3; t4++) n3[s3++] = ++i3;
            }
            return n3;
          })(d2, a2, o2))) : null !== o2 && null !== l2 ? (o2 = af2(d2, o2, 1), l2 = of2(d2, o2, l2, true)) : null !== o2 && (o2 = af2(d2, o2, 0)), null !== f3 ? rf2(d2, p2, f3, c2, new Rp(a2, o2, l2)) : null === h2 ? (function(t3, e3, r3, n3) {
            return new Jp2(hp2.VEC_2, t3, e3, r3, n3);
          })(d2, new Rp(a2, o2, l2), u2, c2) : (function(t3, e3, r3, n3, i3) {
            return new Jp2(hp2.MORTON, t3, e3, r3, n3, i3);
          })(d2, new Rp(a2, o2, l2), u2, c2, h2));
        }
        function af2(t2, e2, r2) {
          const n2 = new Int32Array(t2.length + 1);
          let i2 = 0;
          n2[0] = i2;
          let s2 = 0;
          for (let a2 = 0; a2 < t2.length; a2++) i2 = n2[a2 + 1] = i2 + (t2[a2] > r2 ? e2[s2++] : 1);
          return n2;
        }
        function of2(t2, e2, r2, n2) {
          const i2 = new Int32Array(e2[e2.length - 1] + 1);
          let s2 = 0;
          i2[0] = s2;
          let a2 = 1, o2 = 0;
          for (let l2 = 0; l2 < t2.length; l2++) {
            const u2 = t2[l2], c2 = e2[l2 + 1] - e2[l2];
            if (5 === u2 || 2 === u2 || n2 && (4 === u2 || 1 === u2)) for (let t3 = 0; t3 < c2; t3++) s2 = i2[a2++] = s2 + r2[o2++];
            else for (let t3 = 0; t3 < c2; t3++) i2[a2++] = ++s2;
          }
          return i2;
        }
        class lf2 extends Yh {
          dataVector;
          constructor(t2, e2, r2) {
            super(t2, e2.getBuffer(), r2), this.dataVector = e2;
          }
          getValueFromBuffer(t2) {
            return this.dataVector.get(t2);
          }
        }
        class uf2 extends Zh {
          getValueFromBuffer(t2) {
            return this.dataBuffer[t2];
          }
        }
        class cf2 extends Yh {
          constructor(t2, e2, r2) {
            super(t2, BigInt64Array.of(e2), r2);
          }
          getValueFromBuffer(t2) {
            return this.dataBuffer[0];
          }
        }
        function hf2(t2, e2, r2) {
          return pf2(t2, Math.ceil(e2 / 8), r2);
        }
        function pf2(t2, e2, r2) {
          const n2 = new Uint8Array(e2);
          let i2 = 0;
          for (; i2 < e2; ) {
            const e3 = t2[r2.increment()];
            if (e3 <= 127) {
              const s2 = e3 + 3, a2 = t2[r2.increment()], o2 = i2 + s2;
              n2.fill(a2, i2, o2), i2 = o2;
            } else {
              const s2 = 256 - e3;
              for (let e4 = 0; e4 < s2; e4++) n2[i2++] = t2[r2.increment()];
            }
          }
          return n2;
        }
        const ff2 = new TextDecoder();
        function df2(t2, e2, r2) {
          return r2 - e2 >= 12 ? ff2.decode(t2.subarray(e2, r2)) : (function(t3, e3, r3) {
            let n2 = "", i2 = e3;
            for (; i2 < r3; ) {
              const e4 = t3[i2];
              let s2, a2, o2, l2 = null, u2 = e4 > 239 ? 4 : e4 > 223 ? 3 : e4 > 191 ? 2 : 1;
              if (i2 + u2 > r3) break;
              1 === u2 ? e4 < 128 && (l2 = e4) : 2 === u2 ? (s2 = t3[i2 + 1], 128 == (192 & s2) && (l2 = (31 & e4) << 6 | 63 & s2, l2 <= 127 && (l2 = null))) : 3 === u2 ? (s2 = t3[i2 + 1], a2 = t3[i2 + 2], 128 == (192 & s2) && 128 == (192 & a2) && (l2 = (15 & e4) << 12 | (63 & s2) << 6 | 63 & a2, (l2 <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null))) : 4 === u2 && (s2 = t3[i2 + 1], a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & s2) && 128 == (192 & a2) && 128 == (192 & o2) && (l2 = (15 & e4) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2, (l2 <= 65535 || l2 >= 1114112) && (l2 = null))), null === l2 ? (l2 = 65533, u2 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i2 += u2;
            }
            return n2;
          })(t2, e2, r2);
        }
        class yf2 extends Yh {
          offsetBuffer;
          constructor(t2, e2, r2, n2) {
            super(t2, r2, n2), this.offsetBuffer = e2;
          }
        }
        class mf2 extends yf2 {
          textEncoder;
          constructor(t2, e2, r2, n2) {
            super(t2, e2, r2, n2 ?? e2.length - 1), this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(t2) {
            return df2(this.dataBuffer, this.offsetBuffer[t2], this.offsetBuffer[t2 + 1]);
          }
        }
        class gf2 extends yf2 {
          indexBuffer;
          textEncoder;
          constructor(t2, e2, r2, n2, i2) {
            super(t2, r2, n2, i2 ?? e2.length), this.indexBuffer = e2, this.indexBuffer = e2, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(t2) {
            const e2 = this.indexBuffer[t2];
            return df2(this.dataBuffer, this.offsetBuffer[e2], this.offsetBuffer[e2 + 1]);
          }
        }
        class xf2 extends yf2 {
          indexBuffer;
          symbolOffsetBuffer;
          symbolTableBuffer;
          textEncoder;
          symbolLengthBuffer;
          lengthBuffer;
          decodedDictionary;
          constructor(t2, e2, r2, n2, i2, s2, a2) {
            super(t2, r2, n2, a2), this.indexBuffer = e2, this.symbolOffsetBuffer = i2, this.symbolTableBuffer = s2, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(t2) {
            null == this.decodedDictionary && (null == this.symbolLengthBuffer && (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = (function(t3, e3, r2) {
              const n2 = [], i2 = new Array(e3.length).fill(0);
              for (let t4 = 1; t4 < e3.length; t4++) i2[t4] = i2[t4 - 1] + e3[t4 - 1];
              for (let s2 = 0; s2 < r2.length; s2++) if (255 === r2[s2]) n2.push(r2[++s2]);
              else {
                const a2 = e3[r2[s2]], o2 = i2[r2[s2]];
                for (let e4 = 0; e4 < a2; e4++) n2.push(t3[o2 + e4]);
              }
              return new Uint8Array(n2);
            })(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer));
            const e2 = this.indexBuffer[t2];
            return df2(this.decodedDictionary, this.offsetBuffer[e2], this.offsetBuffer[e2 + 1]);
          }
          offsetToLengthBuffer(t2) {
            const e2 = new Uint32Array(t2.length - 1);
            let r2 = t2[0];
            for (let n2 = 1; n2 < t2.length; n2++) {
              const i2 = t2[n2];
              e2[n2 - 1] = i2 - r2, r2 = i2;
            }
            return e2;
          }
        }
        function vf2(t2, e2, r2, n2, i2, s2) {
          return "scalarType" === r2.type ? (function(t3, e3, r3, n3, i3, s3) {
            let a2 = null, o2 = 0;
            if (0 === t3) return null;
            if (s3.nullable) {
              const t4 = kp2(e3, r3);
              o2 = t4.numValues;
              const n4 = r3.get(), i4 = hf2(e3, o2, r3);
              r3.set(n4 + t4.byteLength), a2 = new Ep2(i4, t4.numValues);
            }
            const l2 = a2 ?? n3;
            switch (i3.physicalType) {
              case 4:
              case 3:
                return (function(t4, e4, r4, n4, i4) {
                  const s4 = kp2(t4, e4), a3 = Cp2(s4, i4, t4, e4), o3 = 3 === n4.physicalType;
                  if (a3 === lp2.FLAT) {
                    const n5 = bf2(i4) ? Vp2(t4, e4, s4, o3, i4) : Tp2(t4, e4, s4, o3);
                    return new Hh(r4.name, n5, i4);
                  }
                  if (a3 === lp2.SEQUENCE) {
                    const n5 = Dp2(t4, e4, s4);
                    return new Jh(r4.name, n5[0], n5[1], s4.numRleValues);
                  }
                  {
                    const n5 = Fp(t4, e4, s4, o3);
                    return new Qh(r4.name, n5, i4);
                  }
                })(e3, r3, s3, i3, l2);
              case 9:
                return (function(t4, e4, r4, n4, i4) {
                  let s4 = null, a3 = null, o3 = null, l3 = null, u2 = null, c2 = null, h2 = null, p2 = null;
                  for (let t5 = 0; t5 < n4; t5++) {
                    const t6 = kp2(e4, r4);
                    if (0 !== t6.byteLength) switch (t6.physicalStreamType) {
                      case ip2.PRESENT: {
                        const n5 = hf2(e4, t6.numValues, r4);
                        c2 = new Ep2(n5, t6.numValues);
                        break;
                      }
                      case ip2.OFFSET:
                        a3 = null != i4 || null != c2 ? Vp2(e4, r4, t6, false, i4 ?? c2) : Tp2(e4, r4, t6, false);
                        break;
                      case ip2.LENGTH: {
                        const n5 = Ip2(e4, r4, t6);
                        op2.DICTIONARY === t6.logicalStreamType.lengthType ? s4 = n5 : op2.SYMBOL === t6.logicalStreamType.lengthType ? l3 = n5 : h2 = n5;
                        break;
                      }
                      case ip2.DATA: {
                        const n5 = e4.subarray(r4.get(), r4.get() + t6.byteLength);
                        r4.add(t6.byteLength);
                        const i5 = t6.logicalStreamType.dictionaryType;
                        sp2.FSST === i5 ? u2 = n5 : sp2.SINGLE === i5 || sp2.SHARED === i5 ? o3 = n5 : sp2.NONE === i5 && (p2 = n5);
                        break;
                      }
                    }
                  }
                  return (function(t5, e5, r5, n5, i5, s5, a4) {
                    return e5 ? new xf2(t5, r5, n5, i5, s5, e5, a4) : null;
                  })(t4, u2, a3, s4, o3, l3, i4 ?? c2) ?? (function(t5, e5, r5, n5, i5) {
                    return e5 ? i5 ? new gf2(t5, r5, n5, e5, i5) : new gf2(t5, r5, n5, e5) : null;
                  })(t4, o3, a3, s4, i4 ?? c2) ?? (function(t5, e5, r5, n5, i5) {
                    if (!e5 || !r5) return null;
                    if (n5) return i5 ? new gf2(t5, n5, e5, r5, i5) : new gf2(t5, n5, e5, r5);
                    if (i5 && i5.size() !== e5.length - 1) {
                      const n6 = new Int32Array(i5.size());
                      let s5 = 0;
                      for (let t6 = 0; t6 < i5.size(); t6++) n6[t6] = i5.get(t6) ? s5++ : 0;
                      return new gf2(t5, n6, e5, r5, i5);
                    }
                    return i5 ? new mf2(t5, e5, r5, i5) : new mf2(t5, e5, r5);
                  })(t4, h2, p2, a3, i4 ?? c2);
                })(s3.name, e3, r3, s3.nullable ? t3 - 1 : t3, a2);
              case 0:
                return (function(t4, e4, r4, n4, i4) {
                  const s4 = kp2(t4, e4), a3 = s4.numValues, o3 = e4.get(), l3 = bf2(i4) ? (function(t5, e5, r5, n5) {
                    const i5 = pf2(t5, Math.ceil(e5 / 8), r5), s5 = new Ep2(i5, e5), a4 = n5.size(), o4 = new Ep2(new Uint8Array(a4), a4);
                    let l4 = 0;
                    for (let t6 = 0; t6 < n5.size(); t6++) {
                      const e6 = !!n5.get(t6) && s5.get(l4++);
                      o4.set(t6, e6);
                    }
                    return o4.getBuffer();
                  })(t4, a3, e4, i4) : hf2(t4, a3, e4);
                  e4.set(o3 + s4.byteLength);
                  const u2 = new Ep2(l3, a3);
                  return new lf2(r4.name, u2, i4);
                })(e3, r3, s3, 0, l2);
              case 6:
              case 5:
                return (function(t4, e4, r4, n4, i4) {
                  const s4 = kp2(t4, e4), a3 = Cp2(s4, n4, t4, e4), o3 = 5 === i4.physicalType;
                  if (a3 === lp2.FLAT) {
                    const i5 = bf2(n4) ? (function(t5, e5, r5, n5, i6) {
                      return (function(t6, e6, r6, n6) {
                        switch (e6.logicalLevelTechnique1) {
                          case rp2.DELTA:
                            return e6.logicalLevelTechnique2 === rp2.RLE && (t6 = bp2(t6, e6.runs, e6.numRleValues)), (function(t7, e7) {
                              const r7 = new BigInt64Array(t7.size());
                              let n7 = 0;
                              t7.get(0) ? (r7[0] = t7.get(0) ? e7[0] >> 1n ^ -(1n & e7[0]) : 0n, n7 = 1) : r7[0] = 0n;
                              let i7 = 1;
                              for (; i7 != r7.length; ++i7) r7[i7] = t7.get(i7) ? r7[i7 - 1] + (e7[n7] >> 1n ^ -(1n & e7[n7++])) : r7[i7 - 1];
                              return r7;
                            })(n6, t6);
                          case rp2.RLE:
                            return (function(t7, e7, r7, n7) {
                              const i7 = e7;
                              return r7 ? (function(t8, e8, r8) {
                                const n8 = new BigInt64Array(t8.size());
                                let i8 = 0;
                                for (let s5 = 0; s5 < r8; s5++) {
                                  const a4 = Number(e8[s5]);
                                  let o4 = e8[s5 + r8];
                                  o4 = o4 >> 1n ^ -(1n & o4);
                                  for (let e9 = i8; e9 < i8 + a4; e9++) t8.get(e9) ? n8[e9] = o4 : (n8[e9] = 0n, i8++);
                                  i8 += a4;
                                }
                                return n8;
                              })(n7, t7, i7.runs) : (function(t8, e8, r8) {
                                const n8 = new BigInt64Array(t8.size());
                                let i8 = 0;
                                for (let s5 = 0; s5 < r8; s5++) {
                                  const a4 = Number(e8[s5]), o4 = e8[s5 + r8];
                                  for (let e9 = i8; e9 < i8 + a4; e9++) t8.get(e9) ? n8[e9] = o4 : (n8[e9] = 0n, i8++);
                                  i8 += a4;
                                }
                                return n8;
                              })(n7, t7, i7.runs);
                            })(t6, e6, r6, n6);
                          case rp2.NONE:
                            return t6 = r6 ? (function(t7, e7) {
                              const r7 = new BigInt64Array(t7.size());
                              let n7 = 0, i7 = 0;
                              for (; i7 != r7.length; ++i7) if (t7.get(i7)) {
                                const t8 = e7[n7++];
                                r7[i7] = t8 >> 1n ^ -(1n & t8);
                              } else r7[i7] = 0n;
                              return r7;
                            })(n6, t6) : (function(t7, e7) {
                              const r7 = new BigInt64Array(t7.size());
                              let n7 = 0, i7 = 0;
                              for (; i7 != r7.length; ++i7) r7[i7] = t7.get(i7) ? e7[n7++] : 0n;
                              return r7;
                            })(n6, t6), t6;
                          default:
                            throw new Error("The specified Logical level technique is not supported");
                        }
                      })(fp2(t5, e5, r5.numValues), r5, n5, i6);
                    })(t4, e4, s4, o3, n4) : Pp2(t4, e4, s4, o3);
                    return new Lp2(r4.name, i5, n4);
                  }
                  if (a3 === lp2.SEQUENCE) {
                    const n5 = zp(t4, e4, s4);
                    return new Op(r4.name, n5[0], n5[1], s4.numRleValues);
                  }
                  {
                    const i5 = Bp2(t4, e4, s4, o3);
                    return new cf2(r4.name, i5, n4);
                  }
                })(e3, r3, s3, l2, i3);
              case 7:
                return (function(t4, e4, r4, n4) {
                  const i4 = kp2(t4, e4), s4 = bf2(n4) ? (function(t5, e5, r5, n5) {
                    const i5 = e5.get(), s5 = i5 + n5 * Float32Array.BYTES_PER_ELEMENT, a3 = new Uint8Array(t5.subarray(i5, s5)).buffer, o3 = new Float32Array(a3);
                    e5.set(s5);
                    const l3 = r5.size(), u2 = new Float32Array(l3);
                    let c2 = 0;
                    for (let t6 = 0; t6 < l3; t6++) u2[t6] = r5.get(t6) ? o3[c2++] : 0;
                    return u2;
                  })(t4, e4, n4, i4.numValues) : (function(t5, e5, r5) {
                    const n5 = e5.get(), i5 = n5 + r5 * Float32Array.BYTES_PER_ELEMENT, s5 = new Uint8Array(t5.subarray(n5, i5)).buffer, a3 = new Float32Array(s5);
                    return e5.set(i5), a3;
                  })(t4, e4, i4.numValues);
                  return new uf2(r4.name, s4, n4);
                })(e3, r3, s3, l2);
              case 8:
                return (function(t4, e4, r4, n4) {
                  const i4 = kp2(t4, e4), s4 = bf2(n4) ? (function(t5, e5, r5, n5) {
                    const i5 = e5.get(), s5 = i5 + n5 * Float64Array.BYTES_PER_ELEMENT, a3 = new Uint8Array(t5.subarray(i5, s5)).buffer, o3 = new Float64Array(a3);
                    e5.set(s5);
                    const l3 = r5.size(), u2 = new Float64Array(l3);
                    let c2 = 0;
                    for (let t6 = 0; t6 < l3; t6++) u2[t6] = r5.get(t6) ? o3[c2++] : 0;
                    return u2;
                  })(t4, e4, n4, i4.numValues) : (function(t5, e5, r5) {
                    const n5 = e5.get(), i5 = n5 + r5 * Float64Array.BYTES_PER_ELEMENT, s5 = new Uint8Array(t5.subarray(n5, i5)).buffer, a3 = new Float64Array(s5);
                    return e5.set(i5), a3;
                  })(t4, e4, i4.numValues);
                  return new Kh(r4.name, s4, n4);
                })(e3, r3, s3, l2);
              default:
                throw new Error(`The specified data type for the field is currently not supported: ${i3}`);
            }
          })(n2, t2, e2, i2, r2.scalarType, r2) : 1 != n2 ? null : (function(t3, e3, r3, n3) {
            let i3 = null, s3 = null, a2 = null, o2 = null, l2 = false;
            for (; !l2; ) {
              const r4 = kp2(t3, e3);
              switch (r4.physicalStreamType) {
                case ip2.LENGTH:
                  op2.DICTIONARY === r4.logicalStreamType.lengthType ? i3 = Ip2(t3, e3, r4) : a2 = Ip2(t3, e3, r4);
                  break;
                case ip2.DATA:
                  sp2.SINGLE === r4.logicalStreamType.dictionaryType || sp2.SHARED === r4.logicalStreamType.dictionaryType ? (s3 = t3.subarray(e3.get(), e3.get() + r4.byteLength), l2 = true) : o2 = t3.subarray(e3.get(), e3.get() + r4.byteLength), e3.add(r4.byteLength);
              }
            }
            const u2 = r3.complexType.children, c2 = [];
            let h2 = 0;
            for (const l3 of u2) {
              const u3 = pp2(t3, e3, 1)[0];
              if (0 == u3) continue;
              const p2 = `${r3.name}${"default" === l3.name ? "" : ":" + l3.name}`;
              if (2 !== u3 || "scalarField" !== l3.type || 9 !== l3.scalarField.physicalType) throw new Error("Currently only optional string fields are implemented for a struct.");
              const f3 = kp2(t3, e3), d2 = hf2(t3, f3.numValues, e3), y3 = kp2(t3, e3), m2 = y3.decompressedCount !== n3 ? Vp2(t3, e3, y3, false, new Ep2(d2, f3.numValues)) : Tp2(t3, e3, y3, false);
              c2[h2++] = o2 ? new xf2(p2, m2, i3, s3, a2, o2, new Ep2(d2, f3.numValues)) : new gf2(p2, m2, i3, s3, new Ep2(d2, f3.numValues));
            }
            return c2;
          })(t2, e2, r2, i2);
        }
        function bf2(t2) {
          return t2 instanceof Ep2;
        }
        function wf2(t2) {
          if ("id" === t2.name) return false;
          if ("scalarType" === t2.type) {
            const e2 = t2.scalarType;
            if ("physicalType" === e2.type) switch (e2.physicalType) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              default:
                return false;
              case 9:
                return true;
            }
            else if ("logicalType" === e2.type) return false;
          } else if ("complexType" === t2.type) {
            const e2 = t2.complexType;
            if ("physicalType" === e2.type) switch (e2.physicalType) {
              case 0:
              case 1:
                return true;
              default:
                return false;
            }
          }
          return console.warn("Unexpected column type in hasStreamCount", t2), false;
        }
        const _f2 = new TextDecoder();
        function Sf2(t2, e2) {
          const r2 = pp2(t2, e2, 1)[0];
          if (0 === r2) return "";
          const n2 = e2.get(), i2 = t2.subarray(n2, n2 + r2);
          return e2.add(r2), _f2.decode(i2);
        }
        function Af2(t2, e2) {
          const r2 = pp2(t2, e2, 1)[0] >>> 0, n2 = !!(4 & r2), i2 = !!(2 & r2), s2 = pp2(t2, e2, 1)[0] >>> 0, a2 = {};
          if (1 & r2 && (a2.nullable = true), i2) {
            const i3 = {};
            if (n2 ? (i3.type = "logicalType", i3.logicalType = s2) : (i3.type = "physicalType", i3.physicalType = s2), 8 & r2) {
              const r3 = pp2(t2, e2, 1)[0] >>> 0;
              i3.children = new Array(r3);
              for (let n3 = 0; n3 < r3; n3++) i3.children[n3] = Af2(t2, e2);
            }
            a2.type = "complexField", a2.complexField = i3;
          } else {
            const t3 = {};
            n2 ? (t3.type = "logicalType", t3.logicalType = s2) : (t3.type = "physicalType", t3.physicalType = s2), a2.type = "scalarField", a2.scalarField = t3;
          }
          return a2;
        }
        function kf2(t2, e2) {
          const r2 = pp2(t2, e2, 1)[0] >>> 0, n2 = (function(t3) {
            switch (t3) {
              case 0:
              case 1:
              case 2:
              case 3: {
                const e3 = {};
                e3.nullable = !!(1 & t3), e3.columnScope = 0;
                const r3 = {};
                return r3.physicalType = t3 > 1 ? 6 : 4, r3.type = "physicalType", e3.scalarType = r3, e3.type = "scalarType", e3;
              }
              case 4: {
                const t4 = { nullable: false, columnScope: 0 }, e3 = { type: "physicalType", physicalType: 0 };
                return t4.type = "complexType", t4.complexType = e3, t4;
              }
              case 30: {
                const t4 = { nullable: false, columnScope: 0 }, e3 = { type: "physicalType", physicalType: 1 };
                return t4.type = "complexType", t4.complexType = e3, t4;
              }
              default:
                return (function(t4) {
                  let e3 = null;
                  switch (t4) {
                    case 10:
                    case 11:
                      e3 = 0;
                      break;
                    case 12:
                    case 13:
                      e3 = 1;
                      break;
                    case 14:
                    case 15:
                      e3 = 2;
                      break;
                    case 16:
                    case 17:
                      e3 = 3;
                      break;
                    case 18:
                    case 19:
                      e3 = 4;
                      break;
                    case 20:
                    case 21:
                      e3 = 5;
                      break;
                    case 22:
                    case 23:
                      e3 = 6;
                      break;
                    case 24:
                    case 25:
                      e3 = 7;
                      break;
                    case 26:
                    case 27:
                      e3 = 8;
                      break;
                    case 28:
                    case 29:
                      e3 = 9;
                      break;
                    default:
                      return null;
                  }
                  const r3 = {};
                  r3.nullable = !!(1 & t4), r3.columnScope = 0;
                  const n3 = { type: "physicalType" };
                  return n3.physicalType = e3, r3.type = "scalarType", r3.scalarType = n3, r3;
                })(t3);
            }
          })(r2);
          if (!n2) throw new Error(`Unsupported column type code: ${r2}`);
          if ((function(t3) {
            return t3 >= 10;
          })(r2) ? n2.name = Sf2(t2, e2) : r2 >= 0 && r2 <= 3 ? n2.name = "id" : 4 === r2 && (n2.name = "geometry"), /* @__PURE__ */ (function(t3) {
            return 30 === t3;
          })(r2)) {
            const r3 = pp2(t2, e2, 1)[0] >>> 0, i2 = n2.complexType;
            i2.children = new Array(r3);
            for (let n3 = 0; n3 < r3; n3++) i2.children[n3] = Af2(t2, e2);
          }
          return n2;
        }
        function Ef2(t2, e2) {
          const r2 = { featureTables: [] }, n2 = {};
          n2.name = Sf2(t2, e2);
          const i2 = pp2(t2, e2, 1)[0] >>> 0, s2 = pp2(t2, e2, 1)[0] >>> 0;
          n2.columns = new Array(s2);
          for (let r3 = 0; r3 < s2; r3++) n2.columns[r3] = kf2(t2, e2);
          return r2.featureTables.push(n2), [r2, i2];
        }
        function Tf2(t2, e2, r2, n2, i2, s2, a2 = false) {
          const o2 = e2.scalarType.physicalType, l2 = Cp2(i2, s2, t2, r2);
          if (4 === o2) switch (l2) {
            case lp2.FLAT: {
              const e3 = Tp2(t2, r2, i2, false);
              return new Hh(n2, e3, s2);
            }
            case lp2.SEQUENCE: {
              const e3 = Dp2(t2, r2, i2);
              return new Jh(n2, e3[0], e3[1], i2.numRleValues);
            }
            case lp2.CONST: {
              const e3 = Fp(t2, r2, i2, false);
              return new Qh(n2, e3, s2);
            }
          }
          else switch (l2) {
            case lp2.FLAT: {
              if (a2) {
                const e4 = (function(t3, e5, r3, n3) {
                  const i3 = (function(t4, e6, r4) {
                    const n4 = new Float64Array(e6);
                    for (let i4 = 0; i4 < e6; i4++) n4[i4] = dp2(t4, r4);
                    return n4;
                  })(t3, r3.numValues, e5);
                  return (function(t4, e6, r4) {
                    switch (e6.logicalLevelTechnique1) {
                      case rp2.DELTA:
                        return e6.logicalLevelTechnique2 === rp2.RLE && (t4 = wp2(t4, e6.runs, e6.numRleValues)), (function(t5) {
                          t5[0] = t5[0] % 2 == 1 ? (t5[0] + 1) / -2 : t5[0] / 2;
                          const e7 = t5.length / 4 * 4;
                          let r5 = 1;
                          if (e7 >= 4) for (; r5 < e7 - 4; r5 += 4) {
                            const e8 = t5[r5], n4 = t5[r5 + 1], i4 = t5[r5 + 2], s3 = t5[r5 + 3];
                            t5[r5] = (e8 % 2 == 1 ? (e8 + 1) / -2 : e8 / 2) + t5[r5 - 1], t5[r5 + 1] = (n4 % 2 == 1 ? (n4 + 1) / -2 : n4 / 2) + t5[r5], t5[r5 + 2] = (i4 % 2 == 1 ? (i4 + 1) / -2 : i4 / 2) + t5[r5 + 1], t5[r5 + 3] = (s3 % 2 == 1 ? (s3 + 1) / -2 : s3 / 2) + t5[r5 + 2];
                          }
                          for (; r5 != t5.length; ++r5) t5[r5] = (t5[r5] % 2 == 1 ? (t5[r5] + 1) / -2 : t5[r5] / 2) + t5[r5 - 1];
                        })(t4), t4;
                      case rp2.RLE:
                        return (function(t5, e7, r5) {
                          return r5 ? (function(t6, e8, r6) {
                            const n4 = new Float64Array(r6);
                            let i4 = 0;
                            for (let r7 = 0; r7 < e8; r7++) {
                              const s3 = t6[r7];
                              let a3 = t6[r7 + e8];
                              a3 = a3 % 2 == 1 ? (a3 + 1) / -2 : a3 / 2, n4.fill(a3, i4, i4 + s3), i4 += s3;
                            }
                            return n4;
                          })(t5, e7.runs, e7.numRleValues) : wp2(t5, e7.runs, e7.numRleValues);
                        })(t4, e6, r4);
                      case rp2.NONE:
                        return t4;
                      default:
                        throw new Error(`The specified Logical level technique is not supported: ${e6.logicalLevelTechnique1}`);
                    }
                  })(i3, r3, n3);
                })(t2, r2, i2, false);
                return new Kh(n2, e4, s2);
              }
              const e3 = Pp2(t2, r2, i2, false);
              return new Lp2(n2, e3, s2);
            }
            case lp2.SEQUENCE: {
              const e3 = zp(t2, r2, i2);
              return new Op(n2, e3[0], e3[1], i2.numRleValues);
            }
            case lp2.CONST: {
              const e3 = Bp2(t2, r2, i2, false);
              return new cf2(n2, e3, s2);
            }
          }
          throw new Error("Vector type not supported for id column.");
        }
        class If2 {
          constructor(t2, e2) {
            var r2;
            switch (this._featureData = t2, this.properties = this._featureData.properties || {}, null === (r2 = this._featureData.geometry) || void 0 === r2 ? void 0 : r2.type) {
              case up2.POINT:
              case up2.MULTIPOINT:
                this.type = 1;
                break;
              case up2.LINESTRING:
              case up2.MULTILINESTRING:
                this.type = 2;
                break;
              case up2.POLYGON:
              case up2.MULTIPOLYGON:
                this.type = 3;
                break;
              default:
                this.type = 0;
            }
            this.extent = e2, this.id = Number(this._featureData.id);
          }
          loadGeometry() {
            const t2 = [];
            for (const e2 of this._featureData.geometry.coordinates) {
              const n2 = [];
              for (const t3 of e2) n2.push(new r(t3.x, t3.y));
              t2.push(n2);
            }
            return t2;
          }
        }
        class Mf2 {
          constructor(t2) {
            this.features = [], this.featureTable = t2, this.name = t2.name, this.extent = t2.extent, this.version = 2, this.features = t2.getFeatures(), this.length = this.features.length;
          }
          feature(t2) {
            return new If2(this.features[t2], this.extent);
          }
        }
        class Ff2 {
          constructor(t2) {
            this.layers = {};
            const e2 = (function(t3, e3, r2 = true) {
              const n2 = new ep2(0), i2 = [];
              for (; n2.get() < t3.length; ) {
                const e4 = pp2(t3, n2, 1)[0] >>> 0, s2 = n2.get() + e4;
                if (s2 > t3.length) throw new Error(`Block overruns tile: ${s2} > ${t3.length}`);
                if (1 != pp2(t3, n2, 1)[0] >>> 0) {
                  n2.set(s2);
                  continue;
                }
                const a2 = Ef2(t3, n2), o2 = a2[1], l2 = a2[0].featureTables[0];
                let u2 = null, c2 = null;
                const h2 = [];
                let p2 = 0;
                for (const e5 of l2.columns) {
                  const i3 = e5.name;
                  if ("id" === i3) {
                    let s3 = null;
                    if (e5.nullable) {
                      const e6 = kp2(t3, n2), r3 = n2.get(), i4 = hf2(t3, e6.numValues, n2);
                      n2.set(r3 + e6.byteLength), s3 = new Ep2(i4, e6.numValues);
                    }
                    const a3 = kp2(t3, n2);
                    p2 = a3.decompressedCount, u2 = Tf2(t3, e5, n2, i3, a3, s3 ?? p2, r2);
                  } else if ("geometry" === i3) {
                    const e6 = pp2(t3, n2, 1)[0];
                    if (0 === p2) {
                      const e7 = n2.get();
                      p2 = kp2(t3, n2).decompressedCount, n2.set(e7);
                    }
                    c2 = sf2(t3, e6, n2, p2);
                  } else {
                    const r3 = wf2(e5) ? pp2(t3, n2, 1)[0] : 1;
                    if (0 === r3 && "scalarType" === e5.type) continue;
                    const i4 = vf2(t3, n2, e5, r3, p2);
                    if (i4) if (Array.isArray(i4)) for (const t4 of i4) h2.push(t4);
                    else h2.push(i4);
                  }
                }
                const f3 = new tp2(l2.name, c2, u2, h2, o2);
                i2.push(f3), n2.set(s2);
              }
              return i2;
            })(new Uint8Array(t2));
            this.layers = e2.reduce(((t3, e3) => Object.assign(Object.assign({}, t3), { [e3.name]: new Mf2(e3) })), {});
          }
        }
        class Df2 {
          constructor(t2, e2) {
            this.feature = t2, this.type = t2.type, this.properties = t2.tags ? t2.tags : {}, this.extent = e2, "id" in t2 && ("string" == typeof t2.id ? this.id = parseInt(t2.id, 10) : "number" != typeof t2.id || isNaN(t2.id) || (this.id = t2.id));
          }
          loadGeometry() {
            const t2 = [], e2 = 1 === this.feature.type ? [this.feature.geometry] : this.feature.geometry;
            for (const n2 of e2) {
              const e3 = [];
              for (const t3 of n2) e3.push(new r(t3[0], t3[1]));
              t2.push(e3);
            }
            return t2;
          }
        }
        const zf2 = "_geojsonTileLayer";
        function Pf2(t2, e2) {
          e2.writeVarintField(15, t2.version || 1), e2.writeStringField(1, t2.name || ""), e2.writeVarintField(5, t2.extent || 4096);
          const r2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let n3 = 0; n3 < t2.length; n3++) r2.feature = t2.feature(n3), e2.writeMessage(2, Bf2, r2);
          const n2 = r2.keys;
          for (const t3 of n2) e2.writeStringField(3, t3);
          const i2 = r2.values;
          for (const t3 of i2) e2.writeMessage(4, Rf2, t3);
        }
        function Bf2(t2, e2) {
          if (!t2.feature) return;
          const r2 = t2.feature;
          void 0 !== r2.id && e2.writeVarintField(1, r2.id), e2.writeMessage(2, Vf2, t2), e2.writeVarintField(3, r2.type), e2.writeMessage(4, Of2, r2);
        }
        function Vf2(t2, e2) {
          for (const r2 in t2.feature?.properties) {
            let n2 = t2.feature.properties[r2], i2 = t2.keycache[r2];
            if (null == n2) continue;
            void 0 === i2 && (t2.keys.push(r2), i2 = t2.keys.length - 1, t2.keycache[r2] = i2), e2.writeVarint(i2), "string" != typeof n2 && "boolean" != typeof n2 && "number" != typeof n2 && (n2 = JSON.stringify(n2));
            const s2 = typeof n2 + ":" + n2;
            let a2 = t2.valuecache[s2];
            void 0 === a2 && (t2.values.push(n2), a2 = t2.values.length - 1, t2.valuecache[s2] = a2), e2.writeVarint(a2);
          }
        }
        function Cf2(t2, e2) {
          return (e2 << 3) + (7 & t2);
        }
        function Lf2(t2) {
          return t2 << 1 ^ t2 >> 31;
        }
        function Of2(t2, e2) {
          const r2 = t2.loadGeometry(), n2 = t2.type;
          let i2 = 0, s2 = 0;
          for (const a2 of r2) {
            let r3 = 1;
            1 === n2 && (r3 = a2.length), e2.writeVarint(Cf2(1, r3));
            const o2 = 3 === n2 ? a2.length - 1 : a2.length;
            for (let t3 = 0; t3 < o2; t3++) {
              1 === t3 && 1 !== n2 && e2.writeVarint(Cf2(2, o2 - 1));
              const r4 = a2[t3].x - i2, l2 = a2[t3].y - s2;
              e2.writeVarint(Lf2(r4)), e2.writeVarint(Lf2(l2)), i2 += r4, s2 += l2;
            }
            3 === t2.type && e2.writeVarint(Cf2(7, 1));
          }
        }
        function Rf2(t2, e2) {
          const r2 = typeof t2;
          "string" === r2 ? e2.writeStringField(1, t2) : "boolean" === r2 ? e2.writeBooleanField(7, t2) : "number" === r2 && (t2 % 1 != 0 ? e2.writeDoubleField(3, t2) : t2 < 0 ? e2.writeSVarintField(6, t2) : e2.writeVarintField(5, t2));
        }
        class Nf2 {
          constructor(t2, e2) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new cs2(M2, 16, 0), this.grid3D = new cs2(M2, 16, 0), this.featureIndexArray = new Na2(), this.promoteId = e2;
          }
          insert(t2, e2, r2, n2, i2, s2) {
            const a2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n2, i2);
            const o2 = s2 ? this.grid3D : this.grid;
            for (let t3 = 0; t3 < e2.length; t3++) {
              const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t4 = 0; t4 < r3.length; t4++) {
                const e3 = r3[t4];
                n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
              }
              n3[0] < M2 && n3[1] < M2 && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = "mlt" !== this.encoding ? new Vu2(new Tc2(this.rawTileData)).layers : new Ff2(this.rawTileData).layers, this.sourceLayerCoder = new Gh(this.vtLayers ? Object.keys(this.vtLayers).sort() : [zf2])), this.vtLayers;
          }
          query(t2, e2, n2, i2) {
            this.loadVTLayers();
            const s2 = t2.params, a2 = M2 / t2.tileSize / t2.scale, o2 = fi2(s2.filter, s2.globalState), l2 = t2.queryGeometry, u2 = t2.queryPadding * a2, c2 = jh.fromPoints(l2), h2 = this.grid.query(c2.minX - u2, c2.minY - u2, c2.maxX + u2, c2.maxY + u2), p2 = jh.fromPoints(t2.cameraQueryGeometry).expandBy(u2), f3 = this.grid3D.query(p2.minX, p2.minY, p2.maxX, p2.maxY, ((e3, n3, i3, s3) => (function(t3, e4, n4, i4, s4) {
              for (const r2 of t3) if (e4 <= r2.x && n4 <= r2.y && i4 >= r2.x && s4 >= r2.y) return true;
              const a3 = [new r(e4, n4), new r(e4, s4), new r(i4, s4), new r(i4, n4)];
              if (t3.length > 2) {
                for (const e5 of a3) if (tl2(t3, e5)) return true;
              }
              for (let e5 = 0; e5 < t3.length - 1; e5++) if (el2(t3[e5], t3[e5 + 1], a3)) return true;
              return false;
            })(t2.cameraQueryGeometry, e3 - u2, n3 - u2, i3 + u2, s3 + u2)));
            for (const t3 of f3) h2.push(t3);
            h2.sort(Uf2);
            const d2 = {};
            let y3;
            for (let r2 = 0; r2 < h2.length; r2++) {
              const u3 = h2[r2];
              if (u3 === y3) continue;
              y3 = u3;
              const c3 = this.featureIndexArray.get(u3);
              let p3 = null;
              this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, o2, s2.layers, s2.availableImages, e2, n2, i2, ((e3, r3, n3) => (p3 || (p3 = No2(e3)), r3.queryIntersectsFeature({ queryGeometry: l2, feature: e3, featureState: n3, geometry: p3, zoom: this.z, transform: t2.transform, pixelsToTileUnits: a2, pixelPosMatrix: t2.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t2.getElevation }))));
            }
            return d2;
          }
          loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = this.bucketLayerIDs[e2];
            if (s2 && !h2.some(((t3) => s2.has(t3)))) return;
            const p2 = this.sourceLayerCoder.decode(r2), f3 = this.vtLayers[p2].feature(n2);
            if (i2.needGeometry) {
              const t3 = $o2(f3, true);
              if (!i2.filter(new Ps2(this.tileID.overscaledZ), t3, this.tileID.canonical)) return;
            } else if (!i2.filter(new Ps2(this.tileID.overscaledZ), f3)) return;
            const d2 = this.getId(f3, p2);
            for (let e3 = 0; e3 < h2.length; e3++) {
              const r3 = h2[e3];
              if (s2 && !s2.has(r3)) continue;
              const i3 = o2[r3];
              if (!i3) continue;
              let p3 = {};
              d2 && u2 && (p3 = u2.getState(i3.sourceLayer || zf2, d2));
              const y3 = O2({}, l2[r3]);
              y3.paint = $f2(y3.paint, i3.paint, f3, p3, a2), y3.layout = $f2(y3.layout, i3.layout, f3, p3, a2);
              const m2 = !c2 || c2(f3, i3, p3);
              if (!m2) continue;
              const g2 = new Xh(f3, this.z, this.x, this.y, d2);
              g2.layer = y3;
              let x2 = t2[r3];
              void 0 === x2 && (x2 = t2[r3] = []), x2.push({ featureIndex: n2, feature: g2, intersectionZ: m2 });
            }
          }
          lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = {};
            this.loadVTLayers();
            const u2 = fi2(i2.filterSpec, i2.globalState);
            for (const i3 of t2) this.loadMatchingFeature(l2, r2, n2, i3, u2, s2, a2, o2, e2);
            return l2;
          }
          hasLayer(t2) {
            for (const e2 of this.bucketLayerIDs) for (const r2 of e2) if (t2 === r2) return true;
            return false;
          }
          getId(t2, e2) {
            var r2;
            let n2 = t2.id;
            return this.promoteId && (n2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]], "boolean" == typeof n2 && (n2 = Number(n2)), void 0 === n2 && (null === (r2 = t2.properties) || void 0 === r2 ? void 0 : r2.cluster) && this.promoteId && (n2 = Number(t2.properties.cluster_id))), n2;
          }
        }
        function $f2(t2, e2, r2, n2, i2) {
          return N(t2, ((t3, s2) => {
            const a2 = e2 instanceof qs2 ? e2.get(s2) : null;
            return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
          }));
        }
        function Uf2(t2, e2) {
          return e2 - t2;
        }
        function qf2(t2, e2, n2, i2, s2) {
          const a2 = [];
          for (let o2 = 0; o2 < t2.length; o2++) {
            const l2 = t2[o2];
            let u2;
            for (let t3 = 0; t3 < l2.length - 1; t3++) {
              let o3 = l2[t3], c2 = l2[t3 + 1];
              o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new r(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new r(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < n2 && c2.y < n2 || (o3.y < n2 ? o3 = new r(o3.x + (n2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), n2)._round() : c2.y < n2 && (c2 = new r(o3.x + (n2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), n2)._round()), o3.x >= i2 && c2.x >= i2 || (o3.x >= i2 ? o3 = new r(i2, o3.y + (i2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= i2 && (c2 = new r(i2, o3.y + (i2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= s2 && c2.y >= s2 || (o3.y >= s2 ? o3 = new r(o3.x + (s2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s2)._round() : c2.y >= s2 && (c2 = new r(o3.x + (s2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s2)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], a2.push(u2)), u2.push(c2)))));
            }
          }
          return a2;
        }
        function jf2(t2, e2, r2, n2, i2) {
          switch (e2) {
            case 1:
              return (function(t3, e3, r3, n3) {
                const i3 = [];
                for (const s2 of t3) for (const t4 of s2) {
                  const s3 = 0 === n3 ? t4.x : t4.y;
                  s3 >= e3 && s3 <= r3 && i3.push([t4]);
                }
                return i3;
              })(t2, r2, n2, i2);
            case 2:
              return Xf2(t2, r2, n2, i2, false);
            case 3:
              return Xf2(t2, r2, n2, i2, true);
          }
          return [];
        }
        function Gf2(t2, e2, n2, i2, s2) {
          const a2 = 0 === i2 ? Yf2 : Zf2;
          let o2 = [];
          const l2 = [];
          for (let r2 = 0; r2 < t2.length - 1; r2++) {
            const u3 = t2[r2], c3 = t2[r2 + 1], h2 = 0 === i2 ? u3.x : u3.y, p2 = 0 === i2 ? c3.x : c3.y;
            let f3 = false;
            h2 < e2 ? p2 > e2 && o2.push(a2(u3, c3, e2)) : h2 > n2 ? p2 < n2 && o2.push(a2(u3, c3, n2)) : o2.push(u3), p2 < e2 && h2 >= e2 && (o2.push(a2(u3, c3, e2)), f3 = true), p2 > n2 && h2 <= n2 && (o2.push(a2(u3, c3, n2)), f3 = true), !s2 && f3 && (l2.push(o2), o2 = []);
          }
          const u2 = t2.length - 1, c2 = 0 === i2 ? t2[u2].x : t2[u2].y;
          return c2 >= e2 && c2 <= n2 && o2.push(t2[u2]), s2 && o2.length > 0 && !o2[0].equals(o2[o2.length - 1]) && o2.push(new r(o2[0].x, o2[0].y)), o2.length > 0 && l2.push(o2), l2;
        }
        function Xf2(t2, e2, r2, n2, i2) {
          const s2 = [];
          for (const a2 of t2) {
            const t3 = Gf2(a2, e2, r2, n2, i2);
            t3.length > 0 && s2.push(...t3);
          }
          return s2;
        }
        function Yf2(t2, e2, n2) {
          return new r(n2, t2.y + (n2 - t2.x) / (e2.x - t2.x) * (e2.y - t2.y));
        }
        function Zf2(t2, e2, n2) {
          return new r(t2.x + (n2 - t2.y) / (e2.y - t2.y) * (e2.x - t2.x), n2);
        }
        ps2("FeatureIndex", Nf2, { omit: ["rawTileData", "sourceLayerCoder"] });
        class Hf2 extends r {
          constructor(t2, e2, r2, n2) {
            super(t2, e2), this.angle = r2, void 0 !== n2 && (this.segment = n2);
          }
          clone() {
            return new Hf2(this.x, this.y, this.angle, this.segment);
          }
        }
        function Kf2(t2, e2, r2, n2, i2) {
          if (void 0 === e2.segment || 0 === r2) return true;
          let s2 = e2, a2 = e2.segment + 1, o2 = 0;
          for (; o2 > -r2 / 2; ) {
            if (a2--, a2 < 0) return false;
            o2 -= t2[a2].dist(s2), s2 = t2[a2];
          }
          o2 += t2[a2].dist(t2[a2 + 1]), a2++;
          const l2 = [];
          let u2 = 0;
          for (; o2 < r2 / 2; ) {
            const e3 = t2[a2], r3 = t2[a2 + 1];
            if (!r3) return false;
            let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
            for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; ) u2 -= l2.shift().angleDelta;
            if (u2 > i2) return false;
            a2++, o2 += e3.dist(r3);
          }
          return true;
        }
        function Wf2(t2) {
          let e2 = 0;
          for (let r2 = 0; r2 < t2.length - 1; r2++) e2 += t2[r2].dist(t2[r2 + 1]);
          return e2;
        }
        function Jf2(t2, e2, r2) {
          return t2 ? 0.6 * e2 * r2 : 0;
        }
        function Qf2(t2, e2) {
          return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function td2(t2, e2, r2, n2, i2, s2) {
          const a2 = Jf2(r2, i2, s2), o2 = Qf2(r2, n2) * s2;
          let l2 = 0;
          const u2 = Wf2(t2) / 2;
          for (let r3 = 0; r3 < t2.length - 1; r3++) {
            const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
            if (l2 + s3 > u2) {
              const c2 = (u2 - l2) / s3, h2 = yr2.number(n3.x, i3.x, c2), p2 = yr2.number(n3.y, i3.y, c2), f3 = new Hf2(h2, p2, i3.angleTo(n3), r3);
              return f3._round(), !a2 || Kf2(t2, f3, o2, a2, e2) ? f3 : void 0;
            }
            l2 += s3;
          }
        }
        function ed2(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = Jf2(n2, s2, a2), c2 = Qf2(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
          return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), rd2(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
        }
        function rd2(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = s2 / 2, c2 = Wf2(t2);
          let h2 = 0, p2 = e2 - r2, f3 = [];
          for (let e3 = 0; e3 < t2.length - 1; e3++) {
            const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y3 = o3.angleTo(a3);
            for (; p2 + r2 < h2 + d2; ) {
              p2 += r2;
              const m2 = (p2 - h2) / d2, g2 = yr2.number(a3.x, o3.x, m2), x2 = yr2.number(a3.y, o3.y, m2);
              if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                const r3 = new Hf2(g2, x2, y3, e3);
                r3._round(), n2 && !Kf2(t2, r3, s2, n2, i2) || f3.push(r3);
              }
            }
            h2 += d2;
          }
          return o2 || f3.length || a2 || (f3 = rd2(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), f3;
        }
        function nd2(t2, e2, n2, i2) {
          const s2 = [], a2 = t2.image, o2 = a2.pixelRatio, l2 = a2.paddedRect.w - 2, u2 = a2.paddedRect.h - 2;
          let c2 = { x1: t2.left, y1: t2.top, x2: t2.right, y2: t2.bottom };
          const h2 = a2.stretchX || [[0, l2]], p2 = a2.stretchY || [[0, u2]], f3 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h2.reduce(f3, 0), y3 = p2.reduce(f3, 0), m2 = l2 - d2, g2 = u2 - y3;
          let x2 = 0, v2 = d2, b2 = 0, w3 = y3, _3 = 0, S3 = m2, A2 = 0, k3 = g2;
          if (a2.content && i2) {
            const e3 = a2.content, r2 = e3[2] - e3[0], n3 = e3[3] - e3[1];
            (a2.textFitWidth || a2.textFitHeight) && (c2 = eh(t2)), x2 = id2(h2, 0, e3[0]), b2 = id2(p2, 0, e3[1]), v2 = id2(h2, e3[0], e3[2]), w3 = id2(p2, e3[1], e3[3]), _3 = e3[0] - x2, A2 = e3[1] - b2, S3 = r2 - v2, k3 = n3 - w3;
          }
          const E2 = c2.x1, T3 = c2.y1, I3 = c2.x2 - E2, M3 = c2.y2 - T3, F3 = (t3, i3, s3, l3) => {
            const u3 = ad2(t3.stretch - x2, v2, I3, E2), c3 = od2(t3.fixed - _3, S3, t3.stretch, d2), h3 = ad2(i3.stretch - b2, w3, M3, T3), p3 = od2(i3.fixed - A2, k3, i3.stretch, y3), f4 = ad2(s3.stretch - x2, v2, I3, E2), m3 = od2(s3.fixed - _3, S3, s3.stretch, d2), g3 = ad2(l3.stretch - b2, w3, M3, T3), F4 = od2(l3.fixed - A2, k3, l3.stretch, y3), D3 = new r(u3, h3), z3 = new r(f4, h3), P3 = new r(f4, g3), B3 = new r(u3, g3), V3 = new r(c3 / o2, p3 / o2), C2 = new r(m3 / o2, F4 / o2), L3 = e2 * Math.PI / 180;
            if (L3) {
              const t4 = Math.sin(L3), e3 = Math.cos(L3), r2 = [e3, -t4, t4, e3];
              D3._matMult(r2), z3._matMult(r2), B3._matMult(r2), P3._matMult(r2);
            }
            const O3 = t3.stretch + t3.fixed, R3 = i3.stretch + i3.fixed;
            return { tl: D3, tr: z3, bl: B3, br: P3, tex: { x: a2.paddedRect.x + 1 + O3, y: a2.paddedRect.y + 1 + R3, w: s3.stretch + s3.fixed - O3, h: l3.stretch + l3.fixed - R3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: V3, pixelOffsetBR: C2, minFontScaleX: S3 / o2 / I3, minFontScaleY: k3 / o2 / M3, isSDF: n2 };
          };
          if (i2 && (a2.stretchX || a2.stretchY)) {
            const t3 = sd2(h2, m2, d2), e3 = sd2(p2, g2, y3);
            for (let r2 = 0; r2 < t3.length - 1; r2++) {
              const n3 = t3[r2], i3 = t3[r2 + 1];
              for (let t4 = 0; t4 < e3.length - 1; t4++) s2.push(F3(n3, e3[t4], i3, e3[t4 + 1]));
            }
          } else s2.push(F3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
          return s2;
        }
        function id2(t2, e2, r2) {
          let n2 = 0;
          for (const i2 of t2) n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
          return n2;
        }
        function sd2(t2, e2, r2) {
          const n2 = [{ fixed: -1, stretch: 0 }];
          for (const [e3, r3] of t2) {
            const t3 = n2[n2.length - 1];
            n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
          }
          return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
        }
        function ad2(t2, e2, r2, n2) {
          return t2 / e2 * r2 + n2;
        }
        function od2(t2, e2, r2, n2) {
          return t2 - e2 * r2 / n2;
        }
        ps2("Anchor", Hf2);
        class ld {
          constructor(t2, e2, n2, i2, s2, a2, o2, l2, u2, c2) {
            var h2;
            if (this.boxStartIndex = t2.length, u2) {
              let t3 = a2.top, e3 = a2.bottom;
              const r2 = a2.collisionPadding;
              r2 && (t3 -= r2[1], e3 += r2[3]);
              let n3 = e3 - t3;
              n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
            } else {
              const u3 = (null === (h2 = a2.image) || void 0 === h2 ? void 0 : h2.content) && (a2.image.textFitWidth || a2.image.textFitHeight) ? eh(a2) : { x1: a2.left, y1: a2.top, x2: a2.right, y2: a2.bottom };
              u3.y1 = u3.y1 * o2 - l2[0], u3.y2 = u3.y2 * o2 + l2[2], u3.x1 = u3.x1 * o2 - l2[3], u3.x2 = u3.x2 * o2 + l2[1];
              const p2 = a2.collisionPadding;
              if (p2 && (u3.x1 -= p2[0] * o2, u3.y1 -= p2[1] * o2, u3.x2 += p2[2] * o2, u3.y2 += p2[3] * o2), c2) {
                const t3 = new r(u3.x1, u3.y1), e3 = new r(u3.x2, u3.y1), n3 = new r(u3.x1, u3.y2), i3 = new r(u3.x2, u3.y2), s3 = c2 * Math.PI / 180;
                t3._rotate(s3), e3._rotate(s3), n3._rotate(s3), i3._rotate(s3), u3.x1 = Math.min(t3.x, e3.x, n3.x, i3.x), u3.x2 = Math.max(t3.x, e3.x, n3.x, i3.x), u3.y1 = Math.min(t3.y, e3.y, n3.y, i3.y), u3.y2 = Math.max(t3.y, e3.y, n3.y, i3.y);
              }
              t2.emplaceBack(e2.x, e2.y, u3.x1, u3.y1, u3.x2, u3.y2, n2, i2, s2);
            }
            this.boxEndIndex = t2.length;
          }
        }
        class ud {
          constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this._up(this.length++);
          }
          pop() {
            if (0 === this.length) return;
            const t2 = this.data[0], e2 = this.data.pop();
            return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e2, compare: r2 } = this, n2 = e2[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s2 = e2[i2];
              if (r2(n2, s2) >= 0) break;
              e2[t2] = s2, t2 = i2;
            }
            e2[t2] = n2;
          }
          _down(t2) {
            const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1);
              const s2 = n3 + 1;
              if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0) break;
              e2[t2] = e2[n3], t2 = n3;
            }
            e2[t2] = i2;
          }
        }
        function cd(t2, e2 = 1, n2 = false) {
          const i2 = jh.fromPoints(t2[0]), s2 = Math.min(i2.width(), i2.height());
          let a2 = s2 / 2;
          const o2 = new ud([], hd), { minX: l2, minY: u2, maxX: c2, maxY: h2 } = i2;
          if (0 === s2) return new r(l2, u2);
          for (let e3 = l2; e3 < c2; e3 += s2) for (let r2 = u2; r2 < h2; r2 += s2) o2.push(new pd(e3 + a2, r2 + a2, a2, t2));
          let p2 = (function(t3) {
            let e3 = 0, r2 = 0, n3 = 0;
            const i3 = t3[0];
            for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
              const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
              r2 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
            }
            return new pd(r2 / e3, n3 / e3, 0, t3);
          })(t2), f3 = o2.length;
          for (; o2.length; ) {
            const r2 = o2.pop();
            (r2.d > p2.d || !p2.d) && (p2 = r2, n2 && console.log("found best %d after %d probes", Math.round(1e4 * r2.d) / 1e4, f3)), r2.max - p2.d <= e2 || (a2 = r2.h / 2, o2.push(new pd(r2.p.x - a2, r2.p.y - a2, a2, t2)), o2.push(new pd(r2.p.x + a2, r2.p.y - a2, a2, t2)), o2.push(new pd(r2.p.x - a2, r2.p.y + a2, a2, t2)), o2.push(new pd(r2.p.x + a2, r2.p.y + a2, a2, t2)), f3 += 4);
          }
          return n2 && (console.log(`num probes: ${f3}`), console.log(`best distance: ${p2.d}`)), p2.p;
        }
        function hd(t2, e2) {
          return e2.max - t2.max;
        }
        function pd(t2, e2, n2, i2) {
          this.p = new r(t2, e2), this.h = n2, this.d = (function(t3, e3) {
            let r2 = false, n3 = 1 / 0;
            for (let i3 = 0; i3 < e3.length; i3++) {
              const s2 = e3[i3];
              for (let e4 = 0, i4 = s2.length, a2 = i4 - 1; e4 < i4; a2 = e4++) {
                const i5 = s2[e4], o2 = s2[a2];
                i5.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i5.x) * (t3.y - i5.y) / (o2.y - i5.y) + i5.x && (r2 = !r2), n3 = Math.min(n3, Jo2(t3, i5, o2));
              }
            }
            return (r2 ? 1 : -1) * Math.sqrt(n3);
          })(this.p, i2), this.max = this.d + this.h * Math.SQRT2;
        }
        var fd;
        t.aP = void 0, (fd = t.aP || (t.aP = {}))[fd.center = 1] = "center", fd[fd.left = 2] = "left", fd[fd.right = 3] = "right", fd[fd.top = 4] = "top", fd[fd.bottom = 5] = "bottom", fd[fd["top-left"] = 6] = "top-left", fd[fd["top-right"] = 7] = "top-right", fd[fd["bottom-left"] = 8] = "bottom-left", fd[fd["bottom-right"] = 9] = "bottom-right";
        const dd = Number.POSITIVE_INFINITY;
        function yd(t2, e2) {
          return e2[1] !== dd ? (function(t3, e3, r2) {
            let n2 = 0, i2 = 0;
            switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = 7 - r2;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e3;
            }
            return [n2, i2];
          })(t2, e2[0], e2[1]) : (function(t3, e3) {
            let r2 = 0, n2 = 0;
            e3 < 0 && (e3 = 0);
            const i2 = e3 / Math.SQRT2;
            switch (t3) {
              case "top-right":
              case "top-left":
                n2 = i2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = 7 - i2;
                break;
              case "bottom":
                n2 = 7 - e3;
                break;
              case "top":
                n2 = e3 - 7;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
                r2 = -i2;
                break;
              case "top-left":
              case "bottom-left":
                r2 = i2;
                break;
              case "left":
                r2 = e3;
                break;
              case "right":
                r2 = -e3;
            }
            return [r2, n2];
          })(t2, e2[0]);
        }
        function md(t2, e2, r2) {
          var n2;
          const i2 = t2.layout, s2 = null === (n2 = i2.get("text-variable-anchor-offset")) || void 0 === n2 ? void 0 : n2.evaluate(e2, {}, r2);
          if (s2) {
            const t3 = s2.values, e3 = [];
            for (let r3 = 0; r3 < t3.length; r3 += 2) {
              const n3 = e3[r3] = t3[r3], i3 = t3[r3 + 1].map(((t4) => t4 * dc2));
              n3.startsWith("top") ? i3[1] -= 7 : n3.startsWith("bottom") && (i3[1] += 7), e3[r3 + 1] = i3;
            }
            return new Le2(e3);
          }
          const a2 = i2.get("text-variable-anchor");
          if (a2) {
            let n3;
            n3 = void 0 !== t2._unevaluatedLayout.getValue("text-radial-offset") ? [i2.get("text-radial-offset").evaluate(e2, {}, r2) * dc2, dd] : i2.get("text-offset").evaluate(e2, {}, r2).map(((t3) => t3 * dc2));
            const s3 = [];
            for (const t3 of a2) s3.push(t3, yd(t3, n3));
            return new Le2(s3);
          }
          return null;
        }
        function gd(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function xd(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          let f3 = a2.textMaxSize.evaluate(r2, {});
          void 0 === f3 && (f3 = o2);
          const d2 = e2.layers[0].layout, y3 = d2.get("icon-offset").evaluate(r2, {}, h2), m2 = bd(n2.horizontal), g2 = o2 / 24, x2 = e2.tilePixelRatio * g2, v2 = e2.tilePixelRatio * f3 / 24, b2 = e2.tilePixelRatio * l2, w3 = e2.tilePixelRatio * d2.get("symbol-spacing"), _3 = d2.get("text-padding") * e2.tilePixelRatio, S3 = (function(t2, e3, r3, n3 = 1) {
            const i3 = t2.get("icon-padding").evaluate(e3, {}, r3), s3 = i3 && i3.values;
            return [s3[0] * n3, s3[1] * n3, s3[2] * n3, s3[3] * n3];
          })(d2, r2, h2, e2.tilePixelRatio), A2 = d2.get("text-max-angle") / 180 * Math.PI, k3 = "viewport" !== d2.get("text-rotation-alignment") && "point" !== d2.get("symbol-placement"), E2 = "map" === d2.get("icon-rotation-alignment") && "point" !== d2.get("symbol-placement"), T3 = d2.get("symbol-placement"), I3 = w3 / 2, F3 = d2.get("icon-text-fit");
          let D3;
          i2 && "none" !== F3 && (e2.allowVerticalPlacement && n2.vertical && (D3 = rh(i2, n2.vertical, F3, d2.get("icon-text-fit-padding"), y3, g2)), m2 && (i2 = rh(i2, m2, F3, d2.get("icon-text-fit-padding"), y3, g2)));
          const z3 = h2 ? p2.line.getGranularityForZoomLevel(h2.z) : 1, P3 = (l3, p3) => {
            p3.x < 0 || p3.x >= M2 || p3.y < 0 || p3.y >= M2 || (function(e3, r3, n3, i3, s3, a3, o3, l4, u3, c3, h3, p4, f4, d3, y4, m3, g3, x3, v6, b3, w4, _4, S4, A3, k4) {
              const E3 = e3.addToLineVertexArray(r3, n3);
              let T4, I4, M3, F4, D4 = 0, z4 = 0, P4 = 0, B3 = 0, V3 = -1, C2 = -1;
              const L3 = {};
              let O3 = mo2("");
              if (e3.allowVerticalPlacement && i3.vertical) {
                const t2 = l4.layout.get("text-rotate").evaluate(w4, {}, A3) + 90;
                M3 = new ld(u3, r3, c3, h3, p4, i3.vertical, f4, d3, y4, t2), o3 && (F4 = new ld(u3, r3, c3, h3, p4, o3, g3, x3, y4, t2));
              }
              if (s3) {
                const n4 = l4.layout.get("icon-rotate").evaluate(w4, {}), i4 = "none" !== l4.layout.get("icon-text-fit"), a4 = nd2(s3, n4, S4, i4), f5 = o3 ? nd2(o3, n4, S4, i4) : void 0;
                I4 = new ld(u3, r3, c3, h3, p4, s3, g3, x3, false, n4), D4 = 4 * a4.length;
                const d4 = e3.iconSizeData;
                let y5 = null;
                "source" === d4.kind ? (y5 = [nh * l4.layout.get("icon-size").evaluate(w4, {})], y5[0] > ih && j2(`${e3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d4.kind && (y5 = [nh * _4.compositeIconSizes[0].evaluate(w4, {}, A3), nh * _4.compositeIconSizes[1].evaluate(w4, {}, A3)], (y5[0] > ih || y5[1] > ih) && j2(`${e3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, a4, y5, b3, v6, w4, t.az.none, r3, E3.lineStartIndex, E3.lineLength, -1, A3), V3 = e3.icon.placedSymbolArray.length - 1, f5 && (z4 = 4 * f5.length, e3.addSymbols(e3.icon, f5, y5, b3, v6, w4, t.az.vertical, r3, E3.lineStartIndex, E3.lineLength, -1, A3), C2 = e3.icon.placedSymbolArray.length - 1);
              }
              const R3 = Object.keys(i3.horizontal);
              for (const n4 of R3) {
                const s4 = i3.horizontal[n4];
                if (!T4) {
                  O3 = mo2(s4.text);
                  const t2 = l4.layout.get("text-rotate").evaluate(w4, {}, A3);
                  T4 = new ld(u3, r3, c3, h3, p4, s4, f4, d3, y4, t2);
                }
                const o4 = 1 === s4.positionedLines.length;
                if (P4 += vd(e3, r3, s4, a3, l4, y4, w4, m3, E3, i3.vertical ? t.az.horizontal : t.az.horizontalOnly, o4 ? R3 : [n4], L3, V3, _4, A3), o4) break;
              }
              i3.vertical && (B3 += vd(e3, r3, i3.vertical, a3, l4, y4, w4, m3, E3, t.az.vertical, ["vertical"], L3, C2, _4, A3));
              const N2 = T4 ? T4.boxStartIndex : e3.collisionBoxArray.length, $3 = T4 ? T4.boxEndIndex : e3.collisionBoxArray.length, U3 = M3 ? M3.boxStartIndex : e3.collisionBoxArray.length, q3 = M3 ? M3.boxEndIndex : e3.collisionBoxArray.length, G3 = I4 ? I4.boxStartIndex : e3.collisionBoxArray.length, X2 = I4 ? I4.boxEndIndex : e3.collisionBoxArray.length, Y3 = F4 ? F4.boxStartIndex : e3.collisionBoxArray.length, Z3 = F4 ? F4.boxEndIndex : e3.collisionBoxArray.length;
              let H3 = -1;
              const K3 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
              H3 = K3(T4, H3), H3 = K3(M3, H3), H3 = K3(I4, H3), H3 = K3(F4, H3);
              const W3 = H3 > -1 ? 1 : 0;
              W3 && (H3 *= k4 / dc2), e3.glyphOffsetArray.length >= fh.MAX_GLYPHS && j2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w4.sortKey && e3.addToSortKeyRanges(e3.symbolInstances.length, w4.sortKey);
              const J3 = md(l4, w4, A3), [Q3, tt3] = (function(e4, r4) {
                const n4 = e4.length, i4 = null == r4 ? void 0 : r4.values;
                if ((null == i4 ? void 0 : i4.length) > 0) for (let r5 = 0; r5 < i4.length; r5 += 2) {
                  const n5 = i4[r5 + 1];
                  e4.emplaceBack(t.aP[i4[r5]], n5[0], n5[1]);
                }
                return [n4, e4.length];
              })(e3.textAnchorOffsets, J3);
              e3.symbolInstances.emplaceBack(r3.x, r3.y, L3.right >= 0 ? L3.right : -1, L3.center >= 0 ? L3.center : -1, L3.left >= 0 ? L3.left : -1, L3.vertical || -1, V3, C2, O3, N2, $3, U3, q3, G3, X2, Y3, Z3, c3, P4, B3, D4, z4, W3, 0, f4, H3, Q3, tt3);
            })(e2, p3, l3, n2, i2, s2, D3, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, x2, [_3, _3, _3, _3], k3, u2, b2, S3, E2, y3, r2, a2, c2, h2, o2);
          };
          if ("line" === T3) for (const t2 of qf2(r2.geometry, 0, 0, M2, M2)) {
            const r3 = gu2(t2, z3), s3 = ed2(r3, w3, A2, n2.vertical || m2, i2, 24, v2, e2.overscaling, M2);
            for (const t3 of s3) m2 && wd(e2, m2.text, I3, t3) || P3(r3, t3);
          }
          else if ("line-center" === T3) {
            for (const t2 of r2.geometry) if (t2.length > 1) {
              const e3 = gu2(t2, z3), r3 = td2(e3, A2, n2.vertical || m2, i2, 24, v2);
              r3 && P3(e3, r3);
            }
          } else if ("Polygon" === r2.type) for (const t2 of tn2(r2.geometry, 0)) {
            const e3 = cd(t2, 16);
            P3(gu2(t2[0], z3, true), new Hf2(e3.x, e3.y, 0));
          }
          else if ("LineString" === r2.type) for (const t2 of r2.geometry) {
            const e3 = gu2(t2, z3);
            P3(e3, new Hf2(e3[0].x, e3[0].y, 0));
          }
          else if ("Point" === r2.type) for (const t2 of r2.geometry) for (const e3 of t2) P3([e3], new Hf2(e3.x, e3.y, 0));
        }
        function vd(t2, e2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3) {
          const m2 = (function(t3, e3, n3, i3, s3, a3, o3, l3) {
            const u3 = i3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, c3 = [];
            for (const t4 of e3.positionedLines) for (const i4 of t4.positionedGlyphs) {
              if (!i4.rect) continue;
              const a4 = i4.rect || {};
              let h3 = 4, p3 = true, f4 = 1, d3 = 0;
              const y4 = (s3 || l3) && i4.vertical, m3 = i4.metrics.advance * i4.scale / 2;
              if (l3 && e3.verticalizable && (d3 = t4.lineOffset / 2 - (i4.imageName ? -(dc2 - i4.metrics.width * i4.scale) / 2 : (i4.scale - 1) * dc2)), i4.imageName) {
                const t5 = o3[i4.imageName];
                p3 = t5.sdf, f4 = t5.pixelRatio, h3 = 1 / f4;
              }
              const g3 = s3 ? [i4.x + m3, i4.y] : [0, 0];
              let x3 = s3 ? [0, 0] : [i4.x + m3 + n3[0], i4.y + n3[1] - d3], v2 = [0, 0];
              y4 && (v2 = x3, x3 = [0, 0]);
              const b2 = i4.metrics.isDoubleResolution ? 2 : 1, w3 = (i4.metrics.left - h3) * i4.scale - m3 + x3[0], _3 = (-i4.metrics.top - h3) * i4.scale + x3[1], S3 = w3 + a4.w / b2 * i4.scale / f4, A2 = _3 + a4.h / b2 * i4.scale / f4, k3 = new r(w3, _3), E2 = new r(S3, _3), T3 = new r(w3, A2), I3 = new r(S3, A2);
              if (y4) {
                const t5 = new r(-m3, m3 - -17), e4 = -Math.PI / 2, n4 = 12 - m3, s4 = new r(22 - n4, -(i4.imageName ? n4 : 0)), a5 = new r(...v2);
                k3._rotateAround(e4, t5)._add(s4)._add(a5), E2._rotateAround(e4, t5)._add(s4)._add(a5), T3._rotateAround(e4, t5)._add(s4)._add(a5), I3._rotateAround(e4, t5)._add(s4)._add(a5);
              }
              if (u3) {
                const t5 = Math.sin(u3), e4 = Math.cos(u3), r2 = [e4, -t5, t5, e4];
                k3._matMult(r2), E2._matMult(r2), T3._matMult(r2), I3._matMult(r2);
              }
              const M3 = new r(0, 0), F3 = new r(0, 0);
              c3.push({ tl: k3, tr: E2, bl: T3, br: I3, tex: a4, writingMode: e3.writingMode, glyphOffset: g3, sectionIndex: i4.sectionIndex, isSDF: p3, pixelOffsetTL: M3, pixelOffsetBR: F3, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return c3;
          })(0, n2, l2, s2, a2, o2, i2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
          let x2 = null;
          "source" === g2.kind ? (x2 = [nh * s2.layout.get("text-size").evaluate(o2, {})], x2[0] > ih && j2(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g2.kind && (x2 = [nh * d2.compositeTextSizes[0].evaluate(o2, {}, y3), nh * d2.compositeTextSizes[1].evaluate(o2, {}, y3)], (x2[0] > ih || x2[1] > ih) && j2(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x2, l2, a2, o2, c2, e2, u2.lineStartIndex, u2.lineLength, f3, y3);
          for (const e3 of h2) p2[e3] = t2.text.placedSymbolArray.length - 1;
          return 4 * m2.length;
        }
        function bd(t2) {
          for (const e2 in t2) return t2[e2];
          return null;
        }
        function wd(t2, e2, r2, n2) {
          const i2 = t2.compareText;
          if (e2 in i2) {
            const t3 = i2[e2];
            for (let e3 = t3.length - 1; e3 >= 0; e3--) if (n2.dist(t3[e3]) < r2) return true;
          } else i2[e2] = [];
          return i2[e2].push(n2), false;
        }
        const _d = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Sd {
          static from(t2) {
            if (!(t2 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [e2, r2] = new Uint8Array(t2, 0, 2);
            if (219 !== e2) throw new Error("Data does not appear to be in a KDBush format.");
            const n2 = r2 >> 4;
            if (1 !== n2) throw new Error(`Got v${n2} data when expected v1.`);
            const i2 = _d[15 & r2];
            if (!i2) throw new Error("Unrecognized array type.");
            const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
            return new Sd(a2, s2, i2, t2);
          }
          constructor(t2, e2 = 64, r2 = Float64Array, n2) {
            if (isNaN(t2) || t2 < 0) throw new Error(`Unpexpected numItems value: ${t2}.`);
            this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
            const i2 = _d.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
            if (i2 < 0) throw new Error(`Unexpected typed array class: ${r2}.`);
            n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
          }
          add(t2, e2) {
            const r2 = this._pos >> 1;
            return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
          }
          finish() {
            const t2 = this._pos >> 1;
            if (t2 !== this.numItems) throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
            return Ad(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t2, e2, r2, n2) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l2 = [];
            for (; o2.length; ) {
              const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
              if (c2 - h2 <= a2) {
                for (let a3 = h2; a3 <= c2; a3++) {
                  const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                  o3 >= t2 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l2.push(i2[a3]);
                }
                continue;
              }
              const p2 = h2 + c2 >> 1, f3 = s2[2 * p2], d2 = s2[2 * p2 + 1];
              f3 >= t2 && f3 <= r2 && d2 >= e2 && d2 <= n2 && l2.push(i2[p2]), (0 === u2 ? t2 <= f3 : e2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= f3 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
            }
            return l2;
          }
          within(t2, e2, r2) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
            for (; a2.length; ) {
              const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
              if (c2 - h2 <= s2) {
                for (let r3 = h2; r3 <= c2; r3++) Id(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l2 && o2.push(n2[r3]);
                continue;
              }
              const p2 = h2 + c2 >> 1, f3 = i2[2 * p2], d2 = i2[2 * p2 + 1];
              Id(f3, d2, t2, e2) <= l2 && o2.push(n2[p2]), (0 === u2 ? t2 - r2 <= f3 : e2 - r2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u2)), (0 === u2 ? t2 + r2 >= f3 : e2 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
            }
            return o2;
          }
        }
        function Ad(t2, e2, r2, n2, i2, s2) {
          if (i2 - n2 <= r2) return;
          const a2 = n2 + i2 >> 1;
          kd(t2, e2, a2, n2, i2, s2), Ad(t2, e2, r2, n2, a2 - 1, 1 - s2), Ad(t2, e2, r2, a2 + 1, i2, 1 - s2);
        }
        function kd(t2, e2, r2, n2, i2, s2) {
          for (; i2 > n2; ) {
            if (i2 - n2 > 600) {
              const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
              kd(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
            }
            const a2 = e2[2 * r2 + s2];
            let o2 = n2, l2 = i2;
            for (Ed(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && Ed(t2, e2, n2, i2); o2 < l2; ) {
              for (Ed(t2, e2, o2, l2), o2++, l2--; e2[2 * o2 + s2] < a2; ) o2++;
              for (; e2[2 * l2 + s2] > a2; ) l2--;
            }
            e2[2 * n2 + s2] === a2 ? Ed(t2, e2, n2, l2) : (l2++, Ed(t2, e2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
          }
        }
        function Ed(t2, e2, r2, n2) {
          Td(t2, r2, n2), Td(e2, 2 * r2, 2 * n2), Td(e2, 2 * r2 + 1, 2 * n2 + 1);
        }
        function Td(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function Id(t2, e2, r2, n2) {
          const i2 = t2 - r2, s2 = e2 - n2;
          return i2 * i2 + s2 * s2;
        }
        var Md;
        t.cH = void 0, (Md = t.cH || (t.cH = {})).create = "create", Md.load = "load", Md.fullLoad = "fullLoad";
        let Fd = null, Dd = [];
        const zd = 1e3 / 60, Pd = "loadTime", Bd = "fullLoadTime", Vd = { mark(t2) {
          performance.mark(t2);
        }, frame(t2) {
          const e2 = t2;
          null != Fd && Dd.push(e2 - Fd), Fd = e2;
        }, clearMetrics() {
          Fd = null, Dd = [], performance.clearMeasures(Pd), performance.clearMeasures(Bd);
          for (const e2 in t.cH) performance.clearMarks(t.cH[e2]);
        }, getPerformanceMetrics() {
          performance.measure(Pd, t.cH.create, t.cH.load), performance.measure(Bd, t.cH.create, t.cH.fullLoad);
          const e2 = performance.getEntriesByName(Pd)[0].duration, r2 = performance.getEntriesByName(Bd)[0].duration, n2 = Dd.length, i2 = 1 / (Dd.reduce(((t2, e3) => t2 + e3), 0) / n2 / 1e3), s2 = Dd.filter(((t2) => t2 > zd)).reduce(((t2, e3) => t2 + (e3 - zd) / zd), 0);
          return { loadTime: e2, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100, totalFrames: n2 };
        } };
        t.$ = c, t.A = f2, t.B = us2, t.C = is2, t.D = js2, t.E = xt2, t.F = function([t2, e2, r2]) {
          return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e2) * Math.sin(r2), y: t2 * Math.sin(e2) * Math.sin(r2), z: t2 * Math.cos(r2) };
        }, t.G = yr2, t.H = Ps2, t.I = qc2, t.J = as2, t.K = function(t2) {
          if (null == Y2) {
            const e2 = t2.navigator ? t2.navigator.userAgent : null;
            Y2 = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return Y2;
        }, t.L = class {
          constructor(t2, e2) {
            this.target = t2, this.mapId = e2, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Sh((() => this.process())), this.subscription = Q2(this.target, "message", ((t3) => this.receive(t3)), false), this.globalScope = X(self) ? t2 : window;
          }
          registerMessageHandler(t2, e2) {
            this.messageHandlers[t2] = e2;
          }
          unregisterMessageHandler(t2) {
            delete this.messageHandlers[t2];
          }
          sendAsync(t2, e2) {
            return new Promise(((r2, n2) => {
              const i2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), s2 = e2 ? Q2(e2.signal, "abort", (() => {
                null == s2 || s2.unsubscribe(), delete this.resolveRejects[i2];
                const e3 = { id: i2, type: "<cancel>", origin: location.origin, targetMapId: t2.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(e3);
              }), Ah) : null;
              this.resolveRejects[i2] = { resolve: (t3) => {
                null == s2 || s2.unsubscribe(), r2(t3);
              }, reject: (t3) => {
                null == s2 || s2.unsubscribe(), n2(t3);
              } };
              const a2 = [], o2 = Object.assign(Object.assign({}, t2), { id: i2, sourceMapId: this.mapId, origin: location.origin, data: ms2(t2.data, a2) });
              this.target.postMessage(o2, { transfer: a2 });
            }));
          }
          receive(t2) {
            const e2 = t2.data, r2 = e2.id;
            if (!("file://" !== e2.origin && "file://" !== location.origin && "resource://android" !== e2.origin && "resource://android" !== location.origin && e2.origin !== location.origin || e2.targetMapId && this.mapId !== e2.targetMapId)) {
              if ("<cancel>" === e2.type) {
                delete this.tasks[r2];
                const t3 = this.abortControllers[r2];
                return delete this.abortControllers[r2], void (t3 && t3.abort());
              }
              if (X(self) || e2.mustQueue) return this.tasks[r2] = e2, this.taskQueue.push(r2), void this.invoker.trigger();
              this.processTask(r2, e2);
            }
          }
          process() {
            if (0 === this.taskQueue.length) return;
            const t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
            delete this.tasks[t2], this.taskQueue.length > 0 && this.invoker.trigger(), e2 && this.processTask(t2, e2);
          }
          processTask(t2, r2) {
            return e(this, void 0, void 0, (function* () {
              if ("<response>" === r2.type) {
                const e3 = this.resolveRejects[t2];
                if (delete this.resolveRejects[t2], !e3) return;
                return void (r2.error ? e3.reject(gs2(r2.error)) : e3.resolve(gs2(r2.data)));
              }
              if (!this.messageHandlers[r2.type]) return void this.completeTask(t2, new Error(`Could not find a registered handler for ${r2.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const e2 = gs2(r2.data), n2 = new AbortController();
              this.abortControllers[t2] = n2;
              try {
                const i2 = yield this.messageHandlers[r2.type](r2.sourceMapId, e2, n2);
                this.completeTask(t2, null, i2);
              } catch (e3) {
                this.completeTask(t2, e3);
              }
            }));
          }
          completeTask(t2, e2, r2) {
            const n2 = [];
            delete this.abortControllers[t2];
            const i2 = { id: t2, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e2 ? ms2(e2) : null, data: ms2(r2, n2) };
            this.target.postMessage(i2, { transfer: n2 });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, t.M = ut2, t.N = function() {
          var t2 = new f2(16);
          return f2 != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, t.O = function(t2, e2, r2) {
          var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f3, d2, y3 = r2[0], m2 = r2[1], g2 = r2[2];
          return e2 === t2 ? (t2[12] = e2[0] * y3 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y3 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y3 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y3 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f3 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f3, t2[11] = d2, t2[12] = n2 * y3 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y3 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y3 + u2 * m2 + f3 * g2 + e2[14], t2[15] = a2 * y3 + c2 * m2 + d2 * g2 + e2[15]), t2;
        }, t.P = r, t.Q = function(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[1], s2 = r2[2];
          return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.R = Sl2, t.S = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f3 = e2[10], d2 = e2[11], y3 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w3 = r2[2], _3 = r2[3];
          return t2[0] = v2 * n2 + b2 * o2 + w3 * h2 + _3 * y3, t2[1] = v2 * i2 + b2 * l2 + w3 * p2 + _3 * m2, t2[2] = v2 * s2 + b2 * u2 + w3 * f3 + _3 * g2, t2[3] = v2 * a2 + b2 * c2 + w3 * d2 + _3 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w3 = r2[6]) * h2 + (_3 = r2[7]) * y3, t2[5] = v2 * i2 + b2 * l2 + w3 * p2 + _3 * m2, t2[6] = v2 * s2 + b2 * u2 + w3 * f3 + _3 * g2, t2[7] = v2 * a2 + b2 * c2 + w3 * d2 + _3 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w3 = r2[10]) * h2 + (_3 = r2[11]) * y3, t2[9] = v2 * i2 + b2 * l2 + w3 * p2 + _3 * m2, t2[10] = v2 * s2 + b2 * u2 + w3 * f3 + _3 * g2, t2[11] = v2 * a2 + b2 * c2 + w3 * d2 + _3 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w3 = r2[14]) * h2 + (_3 = r2[15]) * y3, t2[13] = v2 * i2 + b2 * l2 + w3 * p2 + _3 * m2, t2[14] = v2 * s2 + b2 * u2 + w3 * f3 + _3 * g2, t2[15] = v2 * a2 + b2 * c2 + w3 * d2 + _3 * x2, t2;
        }, t.T = zl2, t.U = function(t2, e2) {
          const r2 = {};
          for (let n2 = 0; n2 < e2.length; n2++) {
            const i2 = e2[n2];
            i2 in t2 && (r2[i2] = t2[i2]);
          }
          return r2;
        }, t.V = Eh, t.W = L2, t.X = Fh, t.Y = Mh, t.Z = at3, t._ = e, t.a = st2, t.a$ = b, t.a0 = h, t.a1 = K2, t.a2 = Rh, t.a3 = zh, t.a4 = Ph, t.a5 = M2, t.a6 = function(t2, e2, r2) {
          if (!t2) return e2 || {};
          if (!e2) return t2 || {};
          const n2 = qh(t2), i2 = qh(e2);
          !(function(t3, e3) {
            e3.removeAll && (t3.add.clear(), t3.update.clear(), t3.remove.clear(), e3.remove.clear());
            for (const r3 of e3.remove) t3.add.delete(r3), t3.update.delete(r3);
            for (const [r3, n3] of e3.update) {
              const i3 = t3.update.get(r3);
              i3 && (e3.update.set(r3, Uh(i3, n3)), t3.update.delete(r3));
            }
          })(n2, i2);
          const s2 = {};
          if ((n2.removeAll || i2.removeAll) && (s2.removeAll = true), s2.remove = /* @__PURE__ */ new Set([...n2.remove, ...i2.remove]), s2.add = new Map([...n2.add, ...i2.add]), s2.update = new Map([...n2.update, ...i2.update]), s2.remove.size && s2.add.size) for (const t3 of s2.add.keys()) s2.remove.delete(t3);
          return (function(t3) {
            const e3 = {};
            return t3.removeAll && (e3.removeAll = t3.removeAll), t3.remove && (e3.remove = Array.from(t3.remove)), t3.add && (e3.add = Array.from(t3.add.values())), t3.update && (e3.update = Array.from(t3.update.values())), e3;
          })(s2);
        }, t.a7 = function(t2, e2) {
          const r2 = /* @__PURE__ */ new Map();
          if (null == t2) return r2;
          if (null == t2.type) return r2;
          if ("Feature" === t2.type) {
            const n2 = $h(t2, e2);
            if (null == n2) return;
            return r2.set(n2, t2), r2;
          }
          if ("FeatureCollection" === t2.type) {
            const n2 = /* @__PURE__ */ new Set();
            for (const i2 of t2.features) {
              const t3 = $h(i2, e2);
              if (null == t3) return;
              if (n2.has(t3)) return;
              n2.add(t3), r2.set(t3, i2);
            }
            return r2;
          }
        }, t.a8 = function(t2, e2, r2) {
          var n2, i2;
          const s2 = [];
          if (e2.removeAll) t2.clear();
          else if (e2.remove) for (const r3 of e2.remove) {
            const e3 = t2.get(r3);
            e3 && (s2.push(e3.geometry), t2.delete(r3));
          }
          if (e2.add) for (const n3 of e2.add) {
            const e3 = $h(n3, r2);
            if (null == e3) continue;
            const i3 = t2.get(e3);
            i3 && s2.push(i3.geometry), s2.push(n3.geometry), t2.set(e3, n3);
          }
          if (e2.update) for (const r3 of e2.update) {
            const e3 = t2.get(r3.id);
            if (!e3) continue;
            const a2 = !!r3.newGeometry, o2 = r3.removeAllProperties || (null === (n2 = r3.removeProperties) || void 0 === n2 ? void 0 : n2.length) > 0 || (null === (i2 = r3.addOrUpdateProperties) || void 0 === i2 ? void 0 : i2.length) > 0;
            if (!a2 && !o2) continue;
            s2.push(e3.geometry);
            const l2 = Object.assign({}, e3);
            if (t2.set(r3.id, l2), a2 && (s2.push(r3.newGeometry), l2.geometry = r3.newGeometry), o2) {
              if (l2.properties = r3.removeAllProperties ? {} : Object.assign({}, l2.properties || {}), r3.removeProperties) for (const t3 of r3.removeProperties) delete l2.properties[t3];
              if (r3.addOrUpdateProperties) for (const { key: t3, value: e4 } of r3.addOrUpdateProperties) l2.properties[t3] = e4;
            }
          }
          return s2;
        }, t.a9 = Vh, t.aA = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
          return "source" === t2.kind ? n2 / nh : "composite" === t2.kind ? yr2.number(n2 / nh, i2 / nh, r2) : e2;
        }, t.aB = function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f3 = e2[11], d2 = e2[12], y3 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w3 = n2 * l2 - i2 * o2, _3 = n2 * u2 - s2 * o2, S3 = i2 * u2 - s2 * l2, A2 = c2 * y3 - h2 * d2, k3 = c2 * m2 - p2 * d2, E2 = c2 * g2 - f3 * d2, T3 = h2 * m2 - p2 * y3, I3 = h2 * g2 - f3 * y3, M3 = p2 * g2 - f3 * m2, F3 = x2 * M3 - v2 * I3 + b2 * T3 + w3 * E2 - _3 * k3 + S3 * A2;
          return F3 ? (t2[0] = (o2 * M3 - l2 * I3 + u2 * T3) * (F3 = 1 / F3), t2[1] = (i2 * I3 - n2 * M3 - s2 * T3) * F3, t2[2] = (y3 * S3 - m2 * _3 + g2 * w3) * F3, t2[3] = (p2 * _3 - h2 * S3 - f3 * w3) * F3, t2[4] = (l2 * E2 - a2 * M3 - u2 * k3) * F3, t2[5] = (r2 * M3 - i2 * E2 + s2 * k3) * F3, t2[6] = (m2 * b2 - d2 * S3 - g2 * v2) * F3, t2[7] = (c2 * S3 - p2 * b2 + f3 * v2) * F3, t2[8] = (a2 * I3 - o2 * E2 + u2 * A2) * F3, t2[9] = (n2 * E2 - r2 * I3 - s2 * A2) * F3, t2[10] = (d2 * _3 - y3 * b2 + g2 * x2) * F3, t2[11] = (h2 * b2 - c2 * _3 - f3 * x2) * F3, t2[12] = (o2 * k3 - a2 * T3 - l2 * A2) * F3, t2[13] = (r2 * T3 - n2 * k3 + i2 * A2) * F3, t2[14] = (y3 * v2 - d2 * w3 - m2 * x2) * F3, t2[15] = (c2 * w3 - h2 * v2 + p2 * x2) * F3, t2) : null;
        }, t.aC = T2, t.aD = function(t2) {
          var e2 = t2[0], r2 = t2[1];
          return Math.sqrt(e2 * e2 + r2 * r2);
        }, t.aE = function(t2) {
          return t2[0] = 0, t2[1] = 0, t2;
        }, t.aF = function(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2;
        }, t.aG = uh, t.aH = A, t.aI = function(t2, e2, n2, i2) {
          const s2 = e2.y - t2.y, a2 = e2.x - t2.x, o2 = i2.y - n2.y, l2 = i2.x - n2.x, u2 = o2 * a2 - l2 * s2;
          if (0 === u2) return null;
          const c2 = (l2 * (t2.y - n2.y) - o2 * (t2.x - n2.x)) / u2;
          return new r(t2.x + c2 * a2, t2.y + c2 * s2);
        }, t.aJ = qf2, t.aK = Go2, t.aL = function(t2) {
          let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
          for (const s2 of t2) e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
          return [e2, r2, n2, i2];
        }, t.aM = dc2, t.aN = F2, t.aO = function(t2, e2, r2, n2, i2 = false) {
          if (!r2[0] && !r2[1]) return [0, 0];
          const s2 = i2 ? "map" === n2 ? -t2.bearingInRadians : 0 : "viewport" === n2 ? t2.bearingInRadians : 0;
          if (s2) {
            const t3 = Math.sin(s2), e3 = Math.cos(s2);
            r2 = [r2[0] * e3 - r2[1] * t3, r2[0] * t3 + r2[1] * e3];
          }
          return [i2 ? r2[0] : F2(e2, r2[0], t2.zoom), i2 ? r2[1] : F2(e2, r2[1], t2.zoom)];
        }, t.aQ = ah, t.aR = gd, t.aS = Yc2, t.aT = Sd, t.aU = na2, t.aV = pu2, t.aW = $a2, t.aX = io2, t.aY = to2, t.aZ = et2, t.a_ = Bh, t.aa = jh, t.ab = 25, t.ac = Lh, t.ad = (t2) => {
          const e2 = window.document.createElement("video");
          return e2.muted = true, new Promise(((r2) => {
            e2.onloadstart = () => {
              r2(e2);
            };
            for (const r3 of t2) {
              const t3 = window.document.createElement("source");
              ft2(r3) || (e2.crossOrigin = "Anonymous"), t3.src = r3, e2.appendChild(t3);
            }
          }));
        }, t.ae = Dt2, t.af = function() {
          return R2++;
        }, t.ag = Fa2, t.ah = fh, t.ai = zf2, t.aj = fi2, t.ak = $o2, t.al = Xh, t.am = function(t2) {
          const e2 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((t3, r2, n2, i2) => {
            const s2 = n2 || i2;
            return e2[r2] = !s2 || s2.toLowerCase(), "";
          })), e2["max-age"]) {
            const t3 = parseInt(e2["max-age"], 10);
            isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
          }
          return e2;
        }, t.an = C, t.ao = 85.051129, t.ap = tt2, t.aq = function(t2) {
          return Math.pow(2, t2);
        }, t.ar = y2, t.as = Dh, t.at = function(t2) {
          return Math.log(t2) / Math.LN2;
        }, t.au = function(t2) {
          var e2 = t2[0], r2 = t2[1];
          return e2 * e2 + r2 * r2;
        }, t.av = function(t2) {
          if (!t2.length) return /* @__PURE__ */ new Set();
          const e2 = Math.max(...t2.map(((t3) => t3.canonical.z)));
          let r2 = 1 / 0, n2 = -1 / 0, i2 = 1 / 0, s2 = -1 / 0;
          const a2 = [];
          for (const o3 of t2) {
            const { x: t3, y: l2, z: u2 } = o3.canonical, c2 = Math.pow(2, e2 - u2), h2 = t3 * c2, p2 = l2 * c2;
            a2.push({ id: o3, x: h2, y: p2 }), h2 < r2 && (r2 = h2), h2 > n2 && (n2 = h2), p2 < i2 && (i2 = p2), p2 > s2 && (s2 = p2);
          }
          const o2 = /* @__PURE__ */ new Set();
          for (const t3 of a2) t3.x !== r2 && t3.x !== n2 && t3.y !== i2 && t3.y !== s2 || o2.add(t3.id);
          return o2;
        }, t.aw = function(t2, e2) {
          const r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), n2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t2.overscaledZ - e2.overscaledZ || n2 - r2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
        }, t.ax = class {
          constructor(t2, e2) {
            this.max = t2, this.onRemove = e2, this.reset();
          }
          reset() {
            for (const t2 in this.data) for (const e2 of this.data[t2]) e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
            return this.data = {}, this.order = [], this;
          }
          add(t2, e2, r2) {
            const n2 = t2.wrapped().key;
            void 0 === this.data[n2] && (this.data[n2] = []);
            const i2 = { value: e2, timeout: void 0 };
            if (void 0 !== r2 && (i2.timeout = setTimeout((() => {
              this.remove(t2, i2);
            }), r2)), this.data[n2].push(i2), this.order.push(n2), this.order.length > this.max) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          has(t2) {
            return t2.wrapped().key in this.data;
          }
          getAndRemove(t2) {
            return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
          }
          _getAndRemoveByKey(t2) {
            const e2 = this.data[t2].shift();
            return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
          }
          getByKey(t2) {
            const e2 = this.data[t2];
            return e2 ? e2[0].value : null;
          }
          get(t2) {
            return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
          }
          remove(t2, e2) {
            if (!this.has(t2)) return this;
            const r2 = t2.wrapped().key, n2 = void 0 === e2 ? 0 : this.data[r2].indexOf(e2), i2 = this.data[r2][n2];
            return this.data[r2].splice(n2, 1), i2.timeout && clearTimeout(i2.timeout), 0 === this.data[r2].length && delete this.data[r2], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r2), 1), this;
          }
          setMaxSize(t2) {
            for (this.max = t2; this.order.length > this.max; ) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          filter(t2) {
            const e2 = [];
            for (const r2 in this.data) for (const n2 of this.data[r2]) t2(n2.value) || e2.push(n2);
            for (const t3 of e2) this.remove(t3.value.tileID, t3);
          }
        }, t.ay = function(t2, e2) {
          let r2 = 0, n2 = 0;
          if ("constant" === t2.kind) n2 = t2.layoutSize;
          else if ("source" !== t2.kind) {
            const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? C(fr2.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
            "camera" === t2.kind ? n2 = yr2.number(t2.minSize, t2.maxSize, o2) : r2 = o2;
          }
          return { uSizeT: r2, uSize: n2 };
        }, t.b = Z2, t.b$ = Ao2, t.b0 = v, t.b1 = function(t2) {
          var e2 = new f2(3);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
        }, t.b2 = function(t2, e2, r2) {
          return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
        }, t.b3 = function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
          return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
        }, t.b4 = w2, t.b5 = function(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
        }, t.b6 = function(t2, e2, r2) {
          return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
        }, t.b7 = g, t.b8 = function(t2, e2, r2) {
          const n2 = e2[0] * r2[0] + e2[1] * r2[1] + e2[2] * r2[2];
          return 0 === n2 ? null : (-(t2[0] * r2[0] + t2[1] * r2[1] + t2[2] * r2[2]) - r2[3]) / n2;
        }, t.b9 = S2, t.bA = function(t2, e2, r2, n2) {
          return t2[0] = e2[0] + r2[0] * n2, t2[1] = e2[1] + r2[1] * n2, t2[2] = e2[2] + r2[2] * n2, t2;
        }, t.bB = E, t.bC = function(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[1], s2 = r2[2], a2 = r2[3], o2 = e2[0], l2 = e2[1], u2 = e2[2], c2 = i2 * u2 - s2 * l2, h2 = s2 * o2 - n2 * u2, p2 = n2 * l2 - i2 * o2;
          return t2[0] = o2 + a2 * (c2 += c2) + i2 * (p2 += p2) - s2 * (h2 += h2), t2[1] = l2 + a2 * h2 + s2 * c2 - n2 * p2, t2[2] = u2 + a2 * p2 + n2 * h2 - i2 * c2, t2;
        }, t.bD = function(t2, e2, r2) {
          const n2 = (function(t3) {
            var e3 = t3[3], r3 = t3[4], n3 = t3[5], i3 = t3[6], s3 = t3[7], a3 = t3[8];
            return t3[0] * (a3 * r3 - n3 * s3) + t3[1] * (-a3 * e3 + n3 * i3) + t3[2] * (s3 * e3 - r3 * i3);
          })([t2[0], t2[1], t2[2], e2[0], e2[1], e2[2], r2[0], r2[1], r2[2]]);
          if (0 === n2) return null;
          const i2 = w2([], [e2[0], e2[1], e2[2]], [r2[0], r2[1], r2[2]]), s2 = w2([], [r2[0], r2[1], r2[2]], [t2[0], t2[1], t2[2]]), a2 = w2([], [t2[0], t2[1], t2[2]], [e2[0], e2[1], e2[2]]), o2 = b([], i2, -t2[3]);
          return v(o2, o2, b([], s2, -e2[3])), v(o2, o2, b([], a2, -r2[3])), b(o2, o2, 1 / n2), o2;
        }, t.bE = kh, t.bF = function() {
          return new Float64Array(4);
        }, t.bG = function(t2, e2, r2, n2) {
          var i2 = [], s2 = [];
          return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[0] * Math.cos(n2) - i2[1] * Math.sin(n2), s2[1] = i2[0] * Math.sin(n2) + i2[1] * Math.cos(n2), s2[2] = i2[2], t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
        }, t.bH = function(t2, e2, r2, n2) {
          var i2 = [], s2 = [];
          return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[0], s2[1] = i2[1] * Math.cos(n2) - i2[2] * Math.sin(n2), s2[2] = i2[1] * Math.sin(n2) + i2[2] * Math.cos(n2), t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
        }, t.bI = function(t2, e2, r2, n2) {
          var i2 = [], s2 = [];
          return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[2] * Math.sin(n2) + i2[0] * Math.cos(n2), s2[1] = i2[1], s2[2] = i2[2] * Math.cos(n2) - i2[0] * Math.sin(n2), t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
        }, t.bJ = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h2 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h2 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
        }, t.bK = function(t2, e2) {
          const r2 = D2(t2, 360), n2 = D2(e2, 360), i2 = n2 - r2, s2 = n2 > r2 ? i2 - 360 : i2 + 360;
          return Math.abs(i2) < Math.abs(s2) ? i2 : s2;
        }, t.bL = function(t2) {
          return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2;
        }, t.bM = function(t2, e2, r2, n2) {
          const i2 = Math.sqrt(t2 * t2 + e2 * e2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
          t2 /= i2, e2 /= i2, r2 /= s2, n2 /= s2;
          const a2 = Math.acos(t2 * r2 + e2 * n2);
          return -e2 * r2 + t2 * n2 > 0 ? a2 : -a2;
        }, t.bN = function(t2, e2) {
          const r2 = D2(t2, 2 * Math.PI), n2 = D2(e2, 2 * Math.PI);
          return Math.min(Math.abs(r2 - n2), Math.abs(r2 - n2 + 2 * Math.PI), Math.abs(r2 - n2 - 2 * Math.PI));
        }, t.bO = function() {
          const t2 = {}, e2 = vt2.$version;
          for (const r2 in vt2.$root) {
            const n2 = vt2.$root[r2];
            if (n2.required) {
              let i2 = null;
              i2 = "version" === r2 ? e2 : "array" === n2.type ? [] : {}, null != i2 && (t2[r2] = i2);
            }
          }
          return t2;
        }, t.bP = ht2, t.bQ = xs2, t.bR = function t2(e2, r2) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(r2) || e2.length !== r2.length) return false;
            for (let n2 = 0; n2 < e2.length; n2++) if (!t2(e2[n2], r2[n2])) return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== r2) {
            if ("object" != typeof r2) return false;
            if (Object.keys(e2).length !== Object.keys(r2).length) return false;
            for (const n2 in e2) if (!t2(e2[n2], r2[n2])) return false;
            return true;
          }
          return e2 === r2;
        }, t.bS = function(t2) {
          t2 = t2.slice();
          const e2 = /* @__PURE__ */ Object.create(null);
          for (let r2 = 0; r2 < t2.length; r2++) e2[t2[r2].id] = t2[r2];
          for (let r2 = 0; r2 < t2.length; r2++) "ref" in t2[r2] && (t2[r2] = wt2(t2[r2], e2[t2[r2].ref]));
          return t2;
        }, t.bT = function(t2, e2) {
          if ("custom" === t2.type) return new _h(t2, e2);
          switch (t2.type) {
            case "background":
              return new wh(t2, e2);
            case "circle":
              return new yl2(t2, e2);
            case "color-relief":
              return new Vl2(t2, e2);
            case "fill":
              return new ku2(t2, e2);
            case "fill-extrusion":
              return new Gu2(t2, e2);
            case "heatmap":
              return new El2(t2, e2);
            case "hillshade":
              return new Ml2(t2, e2);
            case "line":
              return new ac2(t2, e2);
            case "raster":
              return new Qs2(t2, e2);
            case "symbol":
              return new xh(t2, e2);
          }
        }, t.bU = (t2) => "raster" === t2.type, t.bV = U2, t.bW = function(t2, e2) {
          if (!t2) return [{ command: "setStyle", args: [e2] }];
          let r2 = [];
          try {
            if (!_t2(t2.version, e2.version)) return [{ command: "setStyle", args: [e2] }];
            _t2(t2.center, e2.center) || r2.push({ command: "setCenter", args: [e2.center] }), _t2(t2.state, e2.state) || r2.push({ command: "setGlobalState", args: [e2.state] }), _t2(t2.centerAltitude, e2.centerAltitude) || r2.push({ command: "setCenterAltitude", args: [e2.centerAltitude] }), _t2(t2.zoom, e2.zoom) || r2.push({ command: "setZoom", args: [e2.zoom] }), _t2(t2.bearing, e2.bearing) || r2.push({ command: "setBearing", args: [e2.bearing] }), _t2(t2.pitch, e2.pitch) || r2.push({ command: "setPitch", args: [e2.pitch] }), _t2(t2.roll, e2.roll) || r2.push({ command: "setRoll", args: [e2.roll] }), _t2(t2.sprite, e2.sprite) || r2.push({ command: "setSprite", args: [e2.sprite] }), _t2(t2.glyphs, e2.glyphs) || r2.push({ command: "setGlyphs", args: [e2.glyphs] }), _t2(t2.transition, e2.transition) || r2.push({ command: "setTransition", args: [e2.transition] }), _t2(t2.light, e2.light) || r2.push({ command: "setLight", args: [e2.light] }), _t2(t2.terrain, e2.terrain) || r2.push({ command: "setTerrain", args: [e2.terrain] }), _t2(t2.sky, e2.sky) || r2.push({ command: "setSky", args: [e2.sky] }), _t2(t2.projection, e2.projection) || r2.push({ command: "setProjection", args: [e2.projection] });
            const n2 = {}, i2 = [];
            !(function(t3, e3, r3, n3) {
              let i3;
              for (i3 in e3 = e3 || {}, t3 = t3 || {}) Object.prototype.hasOwnProperty.call(t3, i3) && (Object.prototype.hasOwnProperty.call(e3, i3) || kt2(i3, r3, n3));
              for (i3 in e3) Object.prototype.hasOwnProperty.call(e3, i3) && (Object.prototype.hasOwnProperty.call(t3, i3) ? _t2(t3[i3], e3[i3]) || ("geojson" === t3[i3].type && "geojson" === e3[i3].type && Tt2(t3, e3, i3) ? St2(r3, { command: "setGeoJSONSourceData", args: [i3, e3[i3].data] }) : Et2(i3, e3, r3, n3)) : At2(i3, e3, r3));
            })(t2.sources, e2.sources, i2, n2);
            const s2 = [];
            t2.layers && t2.layers.forEach(((t3) => {
              "source" in t3 && n2[t3.source] ? r2.push({ command: "removeLayer", args: [t3.id] }) : s2.push(t3);
            })), r2 = r2.concat(i2), (function(t3, e3, r3) {
              e3 = e3 || [];
              const n3 = (t3 = t3 || []).map(Mt2), i3 = e3.map(Mt2), s3 = t3.reduce(Ft2, {}), a2 = e3.reduce(Ft2, {}), o2 = n3.slice(), l2 = /* @__PURE__ */ Object.create(null);
              let u2, c2, h2, p2, f3;
              for (let t4 = 0, e4 = 0; t4 < n3.length; t4++) u2 = n3[t4], Object.prototype.hasOwnProperty.call(a2, u2) ? e4++ : (St2(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.indexOf(u2, e4), 1));
              for (let t4 = 0, e4 = 0; t4 < i3.length; t4++) u2 = i3[i3.length - 1 - t4], o2[o2.length - 1 - t4] !== u2 && (Object.prototype.hasOwnProperty.call(s3, u2) ? (St2(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.lastIndexOf(u2, o2.length - e4), 1)) : e4++, p2 = o2[o2.length - t4], St2(r3, { command: "addLayer", args: [a2[u2], p2] }), o2.splice(o2.length - t4, 0, u2), l2[u2] = true);
              for (let t4 = 0; t4 < i3.length; t4++) if (u2 = i3[t4], c2 = s3[u2], h2 = a2[u2], !l2[u2] && !_t2(c2, h2)) if (_t2(c2.source, h2.source) && _t2(c2["source-layer"], h2["source-layer"]) && _t2(c2.type, h2.type)) {
                for (f3 in It2(c2.layout, h2.layout, r3, u2, null, "setLayoutProperty"), It2(c2.paint, h2.paint, r3, u2, null, "setPaintProperty"), _t2(c2.filter, h2.filter) || St2(r3, { command: "setFilter", args: [u2, h2.filter] }), _t2(c2.minzoom, h2.minzoom) && _t2(c2.maxzoom, h2.maxzoom) || St2(r3, { command: "setLayerZoomRange", args: [u2, h2.minzoom, h2.maxzoom] }), c2) Object.prototype.hasOwnProperty.call(c2, f3) && "layout" !== f3 && "paint" !== f3 && "filter" !== f3 && "metadata" !== f3 && "minzoom" !== f3 && "maxzoom" !== f3 && (0 === f3.indexOf("paint.") ? It2(c2[f3], h2[f3], r3, u2, f3.slice(6), "setPaintProperty") : _t2(c2[f3], h2[f3]) || St2(r3, { command: "setLayerProperty", args: [u2, f3, h2[f3]] }));
                for (f3 in h2) Object.prototype.hasOwnProperty.call(h2, f3) && !Object.prototype.hasOwnProperty.call(c2, f3) && "layout" !== f3 && "paint" !== f3 && "filter" !== f3 && "metadata" !== f3 && "minzoom" !== f3 && "maxzoom" !== f3 && (0 === f3.indexOf("paint.") ? It2(c2[f3], h2[f3], r3, u2, f3.slice(6), "setPaintProperty") : _t2(c2[f3], h2[f3]) || St2(r3, { command: "setLayerProperty", args: [u2, f3, h2[f3]] }));
              } else St2(r3, { command: "removeLayer", args: [u2] }), p2 = o2[o2.lastIndexOf(u2) + 1], St2(r3, { command: "addLayer", args: [h2, p2] });
            })(s2, e2.layers, r2);
          } catch (t3) {
            console.warn("Unable to compute style diff:", t3), r2 = [{ command: "setStyle", args: [e2] }];
          }
          return r2;
        }, t.bX = function(t2) {
          const e2 = [], r2 = t2.id;
          return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
        }, t.bY = N, t.bZ = $2, t.b_ = class extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
          }
        }, t.ba = function(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
        }, t.bb = function(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3];
        }, t.bc = Oh, t.bd = Nh, t.be = function(t2, e2, r2, n2, i2) {
          var s2 = 1 / Math.tan(e2 / 2);
          if (t2[0] = s2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = s2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0) {
            var a2 = 1 / (n2 - i2);
            t2[10] = (i2 + n2) * a2, t2[14] = 2 * i2 * n2 * a2;
          } else t2[10] = -1, t2[14] = -2 * n2;
          return t2;
        }, t.bf = function(t2) {
          var e2 = new f2(16);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
        }, t.bg = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
          return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
        }, t.bh = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
        }, t.bi = function() {
          const t2 = new Float32Array(16);
          return y2(t2), t2;
        }, t.bj = function() {
          const t2 = new Float64Array(16);
          return y2(t2), t2;
        }, t.bk = function() {
          return new Float64Array(16);
        }, t.bl = function(t2, e2, r2) {
          const n2 = new Float64Array(4);
          return E(n2, t2, e2 - 90, r2), n2;
        }, t.bm = function(t2, e2, r2, n2) {
          var i2, s2, a2, o2, l2, u2 = e2[0], c2 = e2[1], h2 = e2[2], f3 = e2[3], d2 = r2[0], y3 = r2[1], m2 = r2[2], g2 = r2[3];
          return (s2 = u2 * d2 + c2 * y3 + h2 * m2 + f3 * g2) < 0 && (s2 = -s2, d2 = -d2, y3 = -y3, m2 = -m2, g2 = -g2), 1 - s2 > p ? (i2 = Math.acos(s2), a2 = Math.sin(i2), o2 = Math.sin((1 - n2) * i2) / a2, l2 = Math.sin(n2 * i2) / a2) : (o2 = 1 - n2, l2 = n2), t2[0] = o2 * u2 + l2 * d2, t2[1] = o2 * c2 + l2 * y3, t2[2] = o2 * h2 + l2 * m2, t2[3] = o2 * f3 + l2 * g2, t2;
        }, t.bn = function(t2) {
          const e2 = new Float64Array(9);
          !(function(t3, e3) {
            var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = r3 + r3, o2 = n3 + n3, l2 = i3 + i3, u2 = r3 * a2, c2 = n3 * a2, h2 = n3 * o2, p2 = i3 * a2, f3 = i3 * o2, d2 = i3 * l2, y3 = s2 * a2, m2 = s2 * o2, g2 = s2 * l2;
            t3[0] = 1 - h2 - d2, t3[3] = c2 - g2, t3[6] = p2 + m2, t3[1] = c2 + g2, t3[4] = 1 - u2 - d2, t3[7] = f3 - y3, t3[2] = p2 - m2, t3[5] = f3 + y3, t3[8] = 1 - u2 - h2;
          })(e2, t2);
          const r2 = et2(-Math.asin(C(e2[2], -1, 1)));
          let n2, i2;
          return Math.hypot(e2[5], e2[8]) < 1e-3 ? (n2 = 0, i2 = -et2(Math.atan2(e2[3], e2[4]))) : (n2 = et2(0 === e2[5] && 0 === e2[8] ? 0 : Math.atan2(e2[5], e2[8])), i2 = et2(0 === e2[1] && 0 === e2[0] ? 0 : Math.atan2(e2[1], e2[0]))), { roll: n2, pitch: r2 + 90, bearing: i2 };
        }, t.bo = function(t2, e2) {
          return t2.roll == e2.roll && t2.pitch == e2.pitch && t2.bearing == e2.bearing;
        }, t.bp = Te2, t.bq = _o2, t.br = fu2, t.bs = du2, t.bt = hu2, t.bu = z2, t.bv = P2, t.bw = Re2, t.bx = function(t2, e2, r2, n2, i2) {
          return z2(n2, i2, C((t2 - e2) / (r2 - e2), 0, 1));
        }, t.by = D2, t.bz = function() {
          return new Float64Array(3);
        }, t.c = ot2, t.c$ = function(t2, r2, n2, i2, s2) {
          return e(this, void 0, void 0, (function* () {
            if (h()) try {
              return yield K2(t2, r2, n2, i2, s2);
            } catch (t3) {
            }
            return (function(t3, e2, r3, n3, i3) {
              const s3 = t3.width, a2 = t3.height;
              W2 && J2 || (W2 = new OffscreenCanvas(s3, a2), J2 = W2.getContext("2d", { willReadFrequently: true })), W2.width = s3, W2.height = a2, J2.drawImage(t3, 0, 0, s3, a2);
              const o2 = J2.getImageData(e2, r3, n3, i3);
              return J2.clearRect(0, 0, s3, a2), o2.data;
            })(t2, r2, n2, i2, s2);
          }));
        }, t.c0 = class extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = ko2;
          }
          set(t2) {
            if (t2[12] !== this.current[12] || t2[0] !== this.current[0]) return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
            for (let e2 = 1; e2 < 16; e2++) if (t2[e2] !== this.current[e2]) {
              this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
              break;
            }
          }
        }, t.c1 = So2, t.c2 = class extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
          }
        }, t.c3 = class extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
          }
        }, t.c4 = d, t.c5 = function(t2, e2) {
          var r2 = Math.sin(e2), n2 = Math.cos(e2);
          return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, t.c6 = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2];
          return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
        }, t.c7 = function(t2, e2, r2, n2, i2, s2, a2) {
          var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
          return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
        }, t.c8 = class extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = new Array();
          }
          set(t2) {
            if (t2 != this.current) {
              this.current = t2;
              const e2 = new Float32Array(4 * t2.length);
              for (let r2 = 0; r2 < t2.length; r2++) e2[4 * r2] = t2[r2].r, e2[4 * r2 + 1] = t2[r2].g, e2[4 * r2 + 2] = t2[r2].b, e2[4 * r2 + 3] = t2[r2].a;
              this.gl.uniform4fv(this.location, e2);
            }
          }
        }, t.c9 = class extends wo2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = new Array();
          }
          set(t2) {
            if (t2 != this.current) {
              this.current = t2;
              const e2 = new Float32Array(t2);
              this.gl.uniform1fv(this.location, e2);
            }
          }
        }, t.cA = function(t2, e2) {
          return rt2[e2] && "touches" in t2;
        }, t.cB = function(t2) {
          return rt2[t2] || nt2[t2];
        }, t.cC = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[12], t2[1] = r2[1] * n2 + r2[5] * i2 + r2[13], t2;
        }, t.cD = function(t2, e2) {
          const { x: r2, y: n2 } = Vh.fromLngLat(e2);
          return !(t2 < 0 || t2 > 25 || n2 < 0 || n2 >= 1 || r2 < 0 || r2 >= 1);
        }, t.cE = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, t.cF = class extends aa2 {
        }, t.cG = Vd, t.cI = ct2, t.cJ = function(t2, e2) {
          ot2.REGISTERED_PROTOCOLS[t2] = e2;
        }, t.cK = function(t2) {
          delete ot2.REGISTERED_PROTOCOLS[t2];
        }, t.cL = function(t2, e2) {
          const r2 = {};
          for (let n3 = 0; n3 < t2.length; n3++) {
            const i2 = e2 && e2[t2[n3].id] || _i2(t2[n3]);
            e2 && (e2[t2[n3].id] = i2);
            let s2 = r2[i2];
            s2 || (s2 = r2[i2] = []), s2.push(t2[n3]);
          }
          const n2 = [];
          for (const t3 in r2) n2.push(r2[t3]);
          return n2;
        }, t.cM = ps2, t.cN = Gh, t.cO = Nf2, t.cP = jc2, t.cQ = function(e2) {
          e2.bucket.createArrays(), e2.bucket.tilePixelRatio = M2 / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
          const r2 = e2.bucket.layers[0], n2 = r2.layout, i2 = r2._unevaluatedLayout._values, s2 = { layoutIconSize: i2["icon-size"].possiblyEvaluate(new Ps2(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i2["text-size"].possiblyEvaluate(new Ps2(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i2["text-size"].possiblyEvaluate(new Ps2(18)) };
          if ("composite" === e2.bucket.textSizeData.kind) {
            const { minZoom: t2, maxZoom: r3 } = e2.bucket.textSizeData;
            s2.compositeTextSizes = [i2["text-size"].possiblyEvaluate(new Ps2(t2), e2.canonical), i2["text-size"].possiblyEvaluate(new Ps2(r3), e2.canonical)];
          }
          if ("composite" === e2.bucket.iconSizeData.kind) {
            const { minZoom: t2, maxZoom: r3 } = e2.bucket.iconSizeData;
            s2.compositeIconSizes = [i2["icon-size"].possiblyEvaluate(new Ps2(t2), e2.canonical), i2["icon-size"].possiblyEvaluate(new Ps2(r3), e2.canonical)];
          }
          const a2 = n2.get("text-line-height") * dc2, o2 = "viewport" !== n2.get("text-rotation-alignment") && "point" !== n2.get("symbol-placement"), l2 = n2.get("text-keep-upright"), u2 = n2.get("text-size");
          for (const i3 of e2.bucket.features) {
            const c2 = n2.get("text-font").evaluate(i3, {}, e2.canonical).join(","), h2 = u2.evaluate(i3, {}, e2.canonical), p2 = s2.layoutTextSize.evaluate(i3, {}, e2.canonical), f3 = s2.layoutIconSize.evaluate(i3, {}, e2.canonical), d2 = { horizontal: {}, vertical: void 0 }, y3 = i3.text;
            let m2, g2 = [0, 0];
            if (y3) {
              const s3 = y3.toString(), u3 = n2.get("text-letter-spacing").evaluate(i3, {}, e2.canonical) * dc2, f4 = Ss2(s3) ? u3 : 0, m3 = n2.get("text-anchor").evaluate(i3, {}, e2.canonical), x3 = md(r2, i3, e2.canonical);
              if (!x3) {
                const t2 = n2.get("text-radial-offset").evaluate(i3, {}, e2.canonical);
                g2 = t2 ? yd(m3, [t2 * dc2, dd]) : n2.get("text-offset").evaluate(i3, {}, e2.canonical).map(((t3) => t3 * dc2));
              }
              let v6 = o2 ? "center" : n2.get("text-justify").evaluate(i3, {}, e2.canonical);
              const b2 = "point" === n2.get("symbol-placement") ? n2.get("text-max-width").evaluate(i3, {}, e2.canonical) * dc2 : 1 / 0, w3 = () => {
                e2.bucket.allowVerticalPlacement && _s2(s3) && (d2.vertical = Xc2(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, "left", f4, g2, t.az.vertical, true, p2, h2));
              };
              if (!o2 && x3) {
                const r3 = /* @__PURE__ */ new Set();
                if ("auto" === v6) for (let t2 = 0; t2 < x3.values.length; t2 += 2) r3.add(gd(x3.values[t2]));
                else r3.add(v6);
                let n3 = false;
                for (const i4 of r3) if (!d2.horizontal[i4]) if (n3) d2.horizontal[i4] = d2.horizontal[0];
                else {
                  const r4 = Xc2(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, "center", i4, f4, g2, t.az.horizontal, false, p2, h2);
                  r4 && (d2.horizontal[i4] = r4, n3 = 1 === r4.positionedLines.length);
                }
                w3();
              } else {
                "auto" === v6 && (v6 = gd(m3));
                const r3 = Xc2(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v6, f4, g2, t.az.horizontal, false, p2, h2);
                r3 && (d2.horizontal[v6] = r3), w3(), _s2(s3) && o2 && l2 && (d2.vertical = Xc2(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v6, f4, g2, t.az.vertical, false, p2, h2));
              }
            }
            let x2 = false;
            if (i3.icon && i3.icon.name) {
              const t2 = e2.imageMap[i3.icon.name];
              t2 && (m2 = th(e2.imagePositions[i3.icon.name], n2.get("icon-offset").evaluate(i3, {}, e2.canonical), n2.get("icon-anchor").evaluate(i3, {}, e2.canonical)), x2 = !!t2.sdf, void 0 === e2.bucket.sdfIcons ? e2.bucket.sdfIcons = x2 : e2.bucket.sdfIcons !== x2 && j2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.bucket.pixelRatio || 0 !== n2.get("icon-rotate").constantOr(1)) && (e2.bucket.iconsNeedLinear = true));
            }
            const v2 = bd(d2.horizontal) || d2.vertical;
            e2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && xd(e2.bucket, i3, d2, m2, e2.imageMap, s2, p2, f3, g2, x2, e2.canonical, e2.subdivisionGranularity);
          }
          e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
        }, t.cR = wu2, t.cS = Ru2, t.cT = tc2, t.cU = function(t2) {
          const e2 = new Tc2();
          return (function(t3, e3) {
            for (const r2 in t3.layers) e3.writeMessage(3, Pf2, t3.layers[r2]);
          })(t2, e2), e2.finish();
        }, t.cV = function(t2, e2, r2, n2, i2, s2) {
          let a2 = jf2(t2, e2, r2, i2, 0);
          return a2 = jf2(a2, e2, n2, s2, 1), a2;
        }, t.cW = class {
          constructor(t2) {
            this.maxEntries = t2, this.map = /* @__PURE__ */ new Map();
          }
          get(t2) {
            const e2 = this.map.get(t2);
            return void 0 !== e2 && (this.map.delete(t2), this.map.set(t2, e2)), e2;
          }
          set(t2, e2) {
            if (this.map.has(t2)) this.map.delete(t2);
            else if (this.map.size >= this.maxEntries) {
              const t3 = this.map.keys().next().value;
              this.map.delete(t3);
            }
            this.map.set(t2, e2);
          }
          clear() {
            this.map.clear();
          }
        }, t.cX = Vu2, t.cY = Tc2, t.cZ = Ff2, t.c_ = class {
          constructor(t2) {
            this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t2 = performance.getEntriesByName(this._marks.measure);
            return 0 === t2.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
          }
        }, t.ca = class extends xa2 {
        }, t.cb = pc2, t.cc = class extends ba2 {
        }, t.cd = kl2, t.ce = function(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
        }, t.cf = Al2, t.cg = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
          return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / a2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / a2, t2;
        }, t.ch = class extends oa2 {
        }, t.ci = class extends Ta2 {
        }, t.cj = function(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3] && t2[4] === e2[4] && t2[5] === e2[5] && t2[6] === e2[6] && t2[7] === e2[7] && t2[8] === e2[8] && t2[9] === e2[9] && t2[10] === e2[10] && t2[11] === e2[11] && t2[12] === e2[12] && t2[13] === e2[13] && t2[14] === e2[14] && t2[15] === e2[15];
        }, t.ck = function(t2, e2) {
          var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], f3 = t2[10], d2 = t2[11], y3 = t2[12], m2 = t2[13], g2 = t2[14], x2 = t2[15], v2 = e2[0], b2 = e2[1], w3 = e2[2], _3 = e2[3], S3 = e2[4], A2 = e2[5], k3 = e2[6], E2 = e2[7], T3 = e2[8], I3 = e2[9], M3 = e2[10], F3 = e2[11], D3 = e2[12], z3 = e2[13], P3 = e2[14], B3 = e2[15];
          return Math.abs(r2 - v2) <= p * Math.max(1, Math.abs(r2), Math.abs(v2)) && Math.abs(n2 - b2) <= p * Math.max(1, Math.abs(n2), Math.abs(b2)) && Math.abs(i2 - w3) <= p * Math.max(1, Math.abs(i2), Math.abs(w3)) && Math.abs(s2 - _3) <= p * Math.max(1, Math.abs(s2), Math.abs(_3)) && Math.abs(a2 - S3) <= p * Math.max(1, Math.abs(a2), Math.abs(S3)) && Math.abs(o2 - A2) <= p * Math.max(1, Math.abs(o2), Math.abs(A2)) && Math.abs(l2 - k3) <= p * Math.max(1, Math.abs(l2), Math.abs(k3)) && Math.abs(u2 - E2) <= p * Math.max(1, Math.abs(u2), Math.abs(E2)) && Math.abs(c2 - T3) <= p * Math.max(1, Math.abs(c2), Math.abs(T3)) && Math.abs(h2 - I3) <= p * Math.max(1, Math.abs(h2), Math.abs(I3)) && Math.abs(f3 - M3) <= p * Math.max(1, Math.abs(f3), Math.abs(M3)) && Math.abs(d2 - F3) <= p * Math.max(1, Math.abs(d2), Math.abs(F3)) && Math.abs(y3 - D3) <= p * Math.max(1, Math.abs(y3), Math.abs(D3)) && Math.abs(m2 - z3) <= p * Math.max(1, Math.abs(m2), Math.abs(z3)) && Math.abs(g2 - P3) <= p * Math.max(1, Math.abs(g2), Math.abs(P3)) && Math.abs(x2 - B3) <= p * Math.max(1, Math.abs(x2), Math.abs(B3));
        }, t.cl = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.cm = (t2) => "symbol" === t2.type, t.cn = (t2) => "circle" === t2.type, t.co = (t2) => "heatmap" === t2.type, t.cp = (t2) => "line" === t2.type, t.cq = (t2) => "fill" === t2.type, t.cr = (t2) => "fill-extrusion" === t2.type, t.cs = (t2) => "hillshade" === t2.type, t.ct = (t2) => "color-relief" === t2.type, t.cu = (t2) => "background" === t2.type, t.cv = (t2) => "custom" === t2.type, t.cw = B2, t.cx = function(t2, e2, r2) {
          const n2 = I2(e2.x - r2.x, e2.y - r2.y), i2 = I2(t2.x - r2.x, t2.y - r2.y), s2 = Math.atan2(n2[0] * i2[1] - n2[1] * i2[0], (function(t3, e3) {
            return t3[0] * e3[0] + t3[1] * e3[1];
          })(n2, i2));
          return et2(s2);
        }, t.cy = V2, t.cz = function(t2, e2) {
          return nt2[e2] && (t2 instanceof MouseEvent || t2 instanceof WheelEvent);
        }, t.d = ft2, t.d0 = Pl2, t.d1 = n, t.d2 = class {
          constructor(t2, e2) {
            this.layers = { [zf2]: this }, this.name = zf2, this.version = e2 ? e2.version : 1, this.extent = e2 ? e2.extent : 4096, this.length = t2.length, this.features = t2;
          }
          feature(t2) {
            return new Df2(this.features[t2], this.extent);
          }
        }, t.d3 = ni2, t.d4 = zs2, t.e = O2, t.f = (t2) => e(void 0, void 0, void 0, (function* () {
          if (0 === t2.byteLength) return createImageBitmap(new ImageData(1, 1));
          const e2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
          try {
            return createImageBitmap(e2);
          } catch (t3) {
            throw new Error(`Could not load image because of ${t3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), t.g = lt2, t.h = (t2) => new Promise(((e2, r2) => {
          const n2 = new Image();
          n2.onload = () => {
            e2(n2), URL.revokeObjectURL(n2.src), n2.onload = null, window.requestAnimationFrame((() => {
              n2.src = H2;
            }));
          }, n2.onerror = () => r2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const i2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
          n2.src = t2.byteLength ? URL.createObjectURL(i2) : H2;
        })), t.i = X, t.j = (t2, e2) => pt2(O2(t2, { type: "json" }), e2), t.k = gt2, t.l = mt2, t.m = pt2, t.n = (t2, e2) => pt2(O2(t2, { type: "arrayBuffer" }), e2), t.o = function(t2) {
          return new Tc2(t2).readFields(Rc2, []);
        }, t.p = Uc2, t.q = function(t2) {
          return /[\u02EA\u02EB\u1100-\u11FF\u2E80-\u2FDF\u3000-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t2));
        }, t.r = _l2, t.s = Q2, t.t = Hs2, t.u = vt2, t.v = ns2, t.w = j2, t.x = Os2, t.y = ss2, t.z = Vs2;
      }));
      define2("worker", ["./shared"], (function(e) {
        "use strict";
        class t {
          constructor(e2, t2) {
            this.keyCache = {}, e2 && this.replace(e2, t2);
          }
          replace(e2, t2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, [], t2);
          }
          update(t2, o2, i2) {
            for (const o3 of t2) {
              this._layerConfigs[o3.id] = o3;
              const t3 = this._layers[o3.id] = e.bT(o3, i2);
              t3._featureFilter = e.aj(t3.filter, i2), this.keyCache[o3.id] && delete this.keyCache[o3.id];
            }
            for (const e2 of o2) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            const s2 = e.cL(Object.values(this._layerConfigs), this.keyCache);
            for (const t3 of s2) {
              const o3 = t3.map(((e2) => this._layers[e2.id])), i3 = o3[0];
              if (i3.isHidden()) continue;
              const s3 = i3.source || "";
              let n2 = this.familiesBySource[s3];
              n2 || (n2 = this.familiesBySource[s3] = {});
              const r2 = i3.sourceLayer || e.ai;
              let a2 = n2[r2];
              a2 || (a2 = n2[r2] = []), a2.push(o3);
            }
          }
        }
        class o {
          constructor(t2) {
            const o2 = {}, i2 = [];
            for (const e2 in t2) {
              const s3 = t2[e2], n3 = o2[e2] = {};
              for (const e3 in s3) {
                const t3 = s3[+e3];
                if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height) continue;
                const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
                i2.push(o3), n3[e3] = { rect: o3, metrics: t3.metrics };
              }
            }
            const { w: s2, h: n2 } = e.p(i2), r2 = new e.r({ width: s2 || 1, height: n2 || 1 });
            for (const i3 in t2) {
              const s3 = t2[i3];
              for (const t3 in s3) {
                const n3 = s3[+t3];
                if (!n3 || 0 === n3.bitmap.width || 0 === n3.bitmap.height) continue;
                const a2 = o2[i3][t3].rect;
                e.r.copy(n3.bitmap, r2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, n3.bitmap);
              }
            }
            this.image = r2, this.positions = o2;
          }
        }
        e.cM("GlyphAtlas", o);
        class i {
          constructor(t2) {
            this.tileID = new e.a2(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.inFlightDependencies = [];
          }
          parse(t2, i2, n2, r2, a2) {
            return e._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.ag();
              const l2 = new e.cN(Object.keys(t2.layers).sort()), c2 = new e.cO(this.tileID, this.promoteId);
              c2.bucketLayerIDs = [];
              const h2 = {}, u2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: n2, subdivisionGranularity: a2 }, d2 = i2.familiesBySource[this.source];
              for (const o2 in d2) {
                const i3 = t2.layers[o2];
                if (!i3) continue;
                1 === i3.version && e.w(`Vector tile source "${this.source}" layer "${o2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const r3 = l2.encode(o2), a3 = [];
                for (let e2 = 0; e2 < i3.length; e2++) {
                  const t3 = i3.feature(e2), s2 = c2.getId(t3, o2);
                  a3.push({ feature: t3, id: s2, index: e2, sourceLayerIndex: r3 });
                }
                for (const t3 of d2[o2]) {
                  const o3 = t3[0];
                  o3.source !== this.source && e.w(`layer.source = ${o3.source} does not equal this.source = ${this.source}`), o3.isHidden(this.zoom, true) || (s(t3, this.zoom, n2), (h2[o3.id] = o3.createBucket({ index: c2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: r3, sourceID: this.source })).populate(a3, u2, this.tileID.canonical), c2.bucketLayerIDs.push(t3.map(((e2) => e2.id))));
                }
              }
              const g2 = e.bY(u2.glyphDependencies, ((e2) => Object.keys(e2).map(Number)));
              this.inFlightDependencies.forEach(((e2) => null == e2 ? void 0 : e2.abort())), this.inFlightDependencies = [];
              let f3 = Promise.resolve({});
              if (Object.keys(g2).length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), f3 = r2.sendAsync({ type: "GG", data: { stacks: g2, source: this.source, tileID: this.tileID, type: "glyphs" } }, e2);
              }
              const p2 = Object.keys(u2.iconDependencies);
              let m2 = Promise.resolve({});
              if (p2.length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), m2 = r2.sendAsync({ type: "GI", data: { icons: p2, source: this.source, tileID: this.tileID, type: "icons" } }, e2);
              }
              const y3 = Object.keys(u2.patternDependencies);
              let v2 = Promise.resolve({});
              if (y3.length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), v2 = r2.sendAsync({ type: "GI", data: { icons: y3, source: this.source, tileID: this.tileID, type: "patterns" } }, e2);
              }
              const x2 = u2.dashDependencies;
              let _3 = Promise.resolve({});
              if (Object.keys(x2).length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), _3 = r2.sendAsync({ type: "GDA", data: { dashes: x2 } }, e2);
              }
              const [w3, S3, b2, M3] = yield Promise.all([f3, m2, v2, _3]), I3 = new o(w3), P3 = new e.cP(S3, b2);
              for (const t3 in h2) {
                const o2 = h2[t3];
                o2 instanceof e.ah ? (s(o2.layers, this.zoom, n2), e.cQ({ bucket: o2, glyphMap: w3, glyphPositions: I3.positions, imageMap: S3, imagePositions: P3.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: u2.subdivisionGranularity })) : o2.hasDependencies && (o2 instanceof e.cR || o2 instanceof e.cS || o2 instanceof e.cT) && (s(o2.layers, this.zoom, n2), o2.addFeatures(u2, this.tileID.canonical, P3.patternPositions, M3));
              }
              return this.status = "done", { buckets: Object.values(h2).filter(((e2) => !e2.isEmpty())), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: I3.image, imageAtlas: P3, dashPositions: M3, glyphMap: this.returnDependencies ? w3 : null, iconMap: this.returnDependencies ? S3 : null, glyphPositions: this.returnDependencies ? I3.positions : null };
            }));
          }
        }
        function s(t2, o2, i2) {
          const s2 = new e.H(o2);
          for (const e2 of t2) e2.recalculate(s2, i2);
        }
        class n {
          constructor(e2, t2, o2, i2, s2) {
            this.type = e2, this.properties = o2 || {}, this.extent = s2, this.pointsArray = t2, this.id = i2;
          }
          loadGeometry() {
            return this.pointsArray.map(((t2) => t2.map(((t3) => new e.P(t3.x, t3.y)))));
          }
        }
        class r {
          constructor(e2, t2, o2) {
            this.version = 2, this._myFeatures = e2, this.name = t2, this.length = e2.length, this.extent = o2;
          }
          feature(e2) {
            return this._myFeatures[e2];
          }
        }
        class a {
          constructor() {
            this.layers = {};
          }
          addLayer(e2) {
            this.layers[e2.name] = e2;
          }
        }
        function l(t2) {
          let o2 = e.cU(t2);
          return 0 === o2.byteOffset && o2.byteLength === o2.buffer.byteLength || (o2 = new Uint8Array(o2)), { vectorTile: t2, rawData: o2.buffer };
        }
        function c(t2, o2, i2) {
          const { extent: s2 } = t2, a2 = Math.pow(2, i2.z - o2.z), l2 = (i2.x - o2.x * a2) * s2, c2 = (i2.y - o2.y * a2) * s2, h2 = [];
          for (let o3 = 0; o3 < t2.length; o3++) {
            const i3 = t2.feature(o3);
            let r2 = i3.loadGeometry();
            for (const e2 of r2) for (const t3 of e2) t3.x = t3.x * a2 - l2, t3.y = t3.y * a2 - c2;
            const u2 = 128;
            r2 = e.cV(r2, i3.type, -u2, -u2, s2 + u2, s2 + u2), 0 !== r2.length && h2.push(new n(i3.type, r2, i3.properties, i3.id, s2));
          }
          return new r(h2, t2.name, s2);
        }
        class h {
          constructor(t2, o2, i2) {
            this.actor = t2, this.layerIndex = o2, this.availableImages = i2, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new e.cW(1e3);
          }
          loadVectorTile(t2, o2) {
            return e._(this, void 0, void 0, (function* () {
              const i2 = yield e.n(t2.request, o2);
              try {
                return { vectorTile: "mlt" !== t2.encoding ? new e.cX(new e.cY(i2.data)) : new e.cZ(i2.data), rawData: i2.data, cacheControl: i2.cacheControl, expires: i2.expires };
              } catch (e2) {
                const o3 = new Uint8Array(i2.data);
                let s2 = `Unable to parse the tile at ${t2.request.url}, `;
                throw s2 += 31 === o3[0] && 139 === o3[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.message}`, new Error(s2);
              }
            }));
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, (function* () {
              const { uid: o2, overzoomParameters: s2 } = t2;
              s2 && (t2.request = s2.overzoomRequest);
              const n2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.c_(t2.request), r2 = new i(t2);
              this.loading[o2] = r2;
              const a2 = new AbortController();
              r2.abort = a2;
              try {
                const i2 = yield this.loadVectorTile(t2, a2);
                if (delete this.loading[o2], !i2) return null;
                if (s2) {
                  const e2 = this._getOverzoomTile(t2, i2.vectorTile);
                  i2.rawData = e2.rawData, i2.vectorTile = e2.vectorTile;
                }
                const l2 = i2.rawData, c2 = {};
                i2.expires && (c2.expires = i2.expires), i2.cacheControl && (c2.cacheControl = i2.cacheControl);
                const h2 = {};
                if (n2) {
                  const e2 = n2.finish();
                  e2 && (h2.resourceTiming = JSON.parse(JSON.stringify(e2)));
                }
                r2.vectorTile = i2.vectorTile;
                const u2 = r2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
                this.loaded[o2] = r2, this.fetching[o2] = { rawTileData: l2, cacheControl: c2, resourceTiming: h2 };
                try {
                  const o3 = yield u2;
                  return e.e({ rawTileData: l2.slice(0), encoding: t2.encoding }, o3, c2, h2);
                } finally {
                  delete this.fetching[o2];
                }
              } catch (e2) {
                throw delete this.loading[o2], r2.status = "done", this.loaded[o2] = r2, e2;
              }
            }));
          }
          _getOverzoomTile(e2, t2) {
            const { tileID: o2, source: i2, overzoomParameters: s2 } = e2, { maxZoomTileID: n2 } = s2, r2 = `${n2.key}_${o2.key}`, h2 = this.overzoomedTileResultCache.get(r2);
            if (h2) return h2;
            const u2 = new a(), d2 = this.layerIndex.familiesBySource[i2];
            for (const e3 in d2) {
              const i3 = t2.layers[e3];
              if (!i3) continue;
              const s3 = c(i3, n2, o2.canonical);
              s3.length > 0 && u2.addLayer(s3);
            }
            const g2 = l(u2);
            return this.overzoomedTileResultCache.set(r2, g2), g2;
          }
          reloadTile(t2) {
            return e._(this, void 0, void 0, (function* () {
              const o2 = t2.uid;
              if (!this.loaded || !this.loaded[o2]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const i2 = this.loaded[o2];
              if (i2.showCollisionBoxes = t2.showCollisionBoxes, "parsing" === i2.status) {
                const s2 = yield i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
                let n2;
                if (this.fetching[o2]) {
                  const { rawTileData: i3, cacheControl: r2, resourceTiming: a2 } = this.fetching[o2];
                  delete this.fetching[o2], n2 = e.e({ rawTileData: i3.slice(0), encoding: t2.encoding }, s2, r2, a2);
                } else n2 = s2;
                return n2;
              }
              if ("done" === i2.status && i2.vectorTile) return i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
            }));
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, (function* () {
              const e2 = this.loading, o2 = t2.uid;
              e2 && e2[o2] && e2[o2].abort && (e2[o2].abort.abort(), delete e2[o2]);
            }));
          }
          removeTile(t2) {
            return e._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[t2.uid] && delete this.loaded[t2.uid];
            }));
          }
        }
        class u {
          constructor() {
            this.loaded = {};
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, (function* () {
              const { uid: o2, encoding: i2, rawImageData: s2, redFactor: n2, greenFactor: r2, blueFactor: a2, baseShift: l2 } = t2, c2 = s2.width + 2, h2 = s2.height + 2, u2 = e.b(s2) ? new e.R({ width: c2, height: h2 }, yield e.c$(s2, -1, -1, c2, h2)) : s2, d2 = new e.d0(o2, u2, i2, n2, r2, a2, l2);
              return this.loaded = this.loaded || {}, this.loaded[o2] = d2, d2;
            }));
          }
          removeTile(e2) {
            const t2 = this.loaded, o2 = e2.uid;
            t2 && t2[o2] && delete t2[o2];
          }
        }
        var d, g, f2 = (function() {
          if (g) return d;
          function e2(e3, o2) {
            if (0 !== e3.length) {
              t2(e3[0], o2);
              for (var i2 = 1; i2 < e3.length; i2++) t2(e3[i2], !o2);
            }
          }
          function t2(e3, t3) {
            for (var o2 = 0, i2 = 0, s2 = 0, n2 = e3.length, r2 = n2 - 1; s2 < n2; r2 = s2++) {
              var a2 = (e3[s2][0] - e3[r2][0]) * (e3[r2][1] + e3[s2][1]), l2 = o2 + a2;
              i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l2 + a2 : a2 - l2 + o2, o2 = l2;
            }
            o2 + i2 >= 0 != !!t3 && e3.reverse();
          }
          return g = 1, d = function t3(o2, i2) {
            var s2, n2 = o2 && o2.type;
            if ("FeatureCollection" === n2) for (s2 = 0; s2 < o2.features.length; s2++) t3(o2.features[s2], i2);
            else if ("GeometryCollection" === n2) for (s2 = 0; s2 < o2.geometries.length; s2++) t3(o2.geometries[s2], i2);
            else if ("Feature" === n2) t3(o2.geometry, i2);
            else if ("Polygon" === n2) e2(o2.coordinates, i2);
            else if ("MultiPolygon" === n2) for (s2 = 0; s2 < o2.coordinates.length; s2++) e2(o2.coordinates[s2], i2);
            return o2;
          };
        })(), p = e.d1(f2);
        const m = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, y2 = Math.fround || (v = new Float32Array(1), (e2) => (v[0] = +e2, v[0]));
        var v;
        class x {
          constructor(e2) {
            this.options = Object.assign(Object.create(m), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e2) {
            const { log: t2, minZoom: o2, maxZoom: i2 } = this.options;
            t2 && console.time("total time");
            const s2 = `prepare ${e2.length} points`;
            t2 && console.time(s2), this.points = e2;
            const n2 = [];
            for (let t3 = 0; t3 < e2.length; t3++) {
              const o3 = e2[t3];
              if (!o3.geometry) continue;
              const [i3, s3] = o3.geometry.coordinates, r3 = y2(S2(i3)), a2 = y2(b(s3));
              n2.push(r3, a2, 1 / 0, t3, -1, 1), this.options.reduce && n2.push(0);
            }
            let r2 = this.trees[i2 + 1] = this._createTree(n2);
            t2 && console.timeEnd(s2);
            for (let e3 = i2; e3 >= o2; e3--) {
              const o3 = +Date.now();
              r2 = this.trees[e3] = this._createTree(this._cluster(r2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, r2.numItems, +Date.now() - o3);
            }
            return t2 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t2) {
            let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
            const i2 = Math.max(-90, Math.min(90, e2[1]));
            let s2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
            const n2 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360) o2 = -180, s2 = 180;
            else if (o2 > s2) {
              const e3 = this.getClusters([o2, i2, 180, n2], t2), r3 = this.getClusters([-180, i2, s2, n2], t2);
              return e3.concat(r3);
            }
            const r2 = this.trees[this._limitZoom(t2)], a2 = r2.range(S2(o2), b(n2), S2(s2), b(i2)), l2 = r2.data, c2 = [];
            for (const e3 of a2) {
              const t3 = this.stride * e3;
              c2.push(l2[t3 + 5] > 1 ? _2(l2, t3, this.clusterProps) : this.points[l2[t3 + 3]]);
            }
            return c2;
          }
          getChildren(e2) {
            const t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", s2 = this.trees[o2];
            if (!s2) throw new Error(i2);
            const n2 = s2.data;
            if (t2 * this.stride >= n2.length) throw new Error(i2);
            const r2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = s2.within(n2[t2 * this.stride], n2[t2 * this.stride + 1], r2), l2 = [];
            for (const t3 of a2) {
              const o3 = t3 * this.stride;
              n2[o3 + 4] === e2 && l2.push(n2[o3 + 5] > 1 ? _2(n2, o3, this.clusterProps) : this.points[n2[o3 + 3]]);
            }
            if (0 === l2.length) throw new Error(i2);
            return l2;
          }
          getLeaves(e2, t2, o2) {
            const i2 = [];
            return this._appendLeaves(i2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
          }
          getTile(e2, t2, o2) {
            const i2 = this.trees[this._limitZoom(e2)], s2 = Math.pow(2, e2), { extent: n2, radius: r2 } = this.options, a2 = r2 / n2, l2 = (o2 - a2) / s2, c2 = (o2 + 1 + a2) / s2, h2 = { features: [] };
            return this._addTileFeatures(i2.range((t2 - a2) / s2, l2, (t2 + 1 + a2) / s2, c2), i2.data, t2, o2, s2, h2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / s2, l2, 1, c2), i2.data, s2, o2, s2, h2), t2 === s2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / s2, c2), i2.data, -1, o2, s2, h2), h2.features.length ? h2 : null;
          }
          getClusterExpansionZoom(e2) {
            let t2 = this._getOriginZoom(e2) - 1;
            for (; t2 <= this.options.maxZoom; ) {
              const o2 = this.getChildren(e2);
              if (t2++, 1 !== o2.length) break;
              e2 = o2[0].properties.cluster_id;
            }
            return t2;
          }
          _appendLeaves(e2, t2, o2, i2, s2) {
            const n2 = this.getChildren(t2);
            for (const t3 of n2) {
              const n3 = t3.properties;
              if (n3 && n3.cluster ? s2 + n3.point_count <= i2 ? s2 += n3.point_count : s2 = this._appendLeaves(e2, n3.cluster_id, o2, i2, s2) : s2 < i2 ? s2++ : e2.push(t3), e2.length === o2) break;
            }
            return s2;
          }
          _createTree(t2) {
            const o2 = new e.aT(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e2 = 0; e2 < t2.length; e2 += this.stride) o2.add(t2[e2], t2[e2 + 1]);
            return o2.finish(), o2.data = t2, o2;
          }
          _addTileFeatures(e2, t2, o2, i2, s2, n2) {
            for (const r2 of e2) {
              const e3 = r2 * this.stride, a2 = t2[e3 + 5] > 1;
              let l2, c2, h2;
              if (a2) l2 = w2(t2, e3, this.clusterProps), c2 = t2[e3], h2 = t2[e3 + 1];
              else {
                const o3 = this.points[t2[e3 + 3]];
                l2 = o3.properties;
                const [i3, s3] = o3.geometry.coordinates;
                c2 = S2(i3), h2 = b(s3);
              }
              const u2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * s2 - o2)), Math.round(this.options.extent * (h2 * s2 - i2))]], tags: l2 };
              let d2;
              d2 = a2 || this.options.generateId ? t2[e3 + 3] : this.points[t2[e3 + 3]].id, void 0 !== d2 && (u2.id = d2), n2.features.push(u2);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t2) {
            const { radius: o2, extent: i2, reduce: s2, minPoints: n2 } = this.options, r2 = o2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], c2 = this.stride;
            for (let o3 = 0; o3 < a2.length; o3 += c2) {
              if (a2[o3 + 2] <= t2) continue;
              a2[o3 + 2] = t2;
              const i3 = a2[o3], h2 = a2[o3 + 1], u2 = e2.within(a2[o3], a2[o3 + 1], r2), d2 = a2[o3 + 5];
              let g2 = d2;
              for (const e3 of u2) {
                const o4 = e3 * c2;
                a2[o4 + 2] > t2 && (g2 += a2[o4 + 5]);
              }
              if (g2 > d2 && g2 >= n2) {
                let e3, n3 = i3 * d2, r3 = h2 * d2, f3 = -1;
                const p2 = (o3 / c2 << 5) + (t2 + 1) + this.points.length;
                for (const i4 of u2) {
                  const l3 = i4 * c2;
                  if (a2[l3 + 2] <= t2) continue;
                  a2[l3 + 2] = t2;
                  const h3 = a2[l3 + 5];
                  n3 += a2[l3] * h3, r3 += a2[l3 + 1] * h3, a2[l3 + 4] = p2, s2 && (e3 || (e3 = this._map(a2, o3, true), f3 = this.clusterProps.length, this.clusterProps.push(e3)), s2(e3, this._map(a2, l3)));
                }
                a2[o3 + 4] = p2, l2.push(n3 / g2, r3 / g2, 1 / 0, p2, -1, g2), s2 && l2.push(f3);
              } else {
                for (let e3 = 0; e3 < c2; e3++) l2.push(a2[o3 + e3]);
                if (g2 > 1) for (const e3 of u2) {
                  const o4 = e3 * c2;
                  if (!(a2[o4 + 2] <= t2)) {
                    a2[o4 + 2] = t2;
                    for (let e4 = 0; e4 < c2; e4++) l2.push(a2[o4 + e4]);
                  }
                }
              }
            }
            return l2;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t2, o2) {
            if (e2[t2 + 5] > 1) {
              const i3 = this.clusterProps[e2[t2 + 6]];
              return o2 ? Object.assign({}, i3) : i3;
            }
            const i2 = this.points[e2[t2 + 3]].properties, s2 = this.options.map(i2);
            return o2 && s2 === i2 ? Object.assign({}, s2) : s2;
          }
        }
        function _2(e2, t2, o2) {
          return { type: "Feature", id: e2[t2 + 3], properties: w2(e2, t2, o2), geometry: { type: "Point", coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), M2(e2[t2 + 1])] } };
          var i2;
        }
        function w2(e2, t2, o2) {
          const i2 = e2[t2 + 5], s2 = i2 >= 1e4 ? `${Math.round(i2 / 1e3)}k` : i2 >= 1e3 ? Math.round(i2 / 100) / 10 + "k" : i2, n2 = e2[t2 + 6], r2 = -1 === n2 ? {} : Object.assign({}, o2[n2]);
          return Object.assign(r2, { cluster: true, cluster_id: e2[t2 + 3], point_count: i2, point_count_abbreviated: s2 });
        }
        function S2(e2) {
          return e2 / 360 + 0.5;
        }
        function b(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
        }
        function M2(e2) {
          const t2 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
        }
        function I2(e2, t2, o2, i2) {
          let s2 = i2;
          const n2 = t2 + (o2 - t2 >> 1);
          let r2, a2 = o2 - t2;
          const l2 = e2[t2], c2 = e2[t2 + 1], h2 = e2[o2], u2 = e2[o2 + 1];
          for (let i3 = t2 + 3; i3 < o2; i3 += 3) {
            const t3 = P2(e2[i3], e2[i3 + 1], l2, c2, h2, u2);
            if (t3 > s2) r2 = i3, s2 = t3;
            else if (t3 === s2) {
              const e3 = Math.abs(i3 - n2);
              e3 < a2 && (r2 = i3, a2 = e3);
            }
          }
          s2 > i2 && (r2 - t2 > 3 && I2(e2, t2, r2, i2), e2[r2 + 2] = s2, o2 - r2 > 3 && I2(e2, r2, o2, i2));
        }
        function P2(e2, t2, o2, i2, s2, n2) {
          let r2 = s2 - o2, a2 = n2 - i2;
          if (0 !== r2 || 0 !== a2) {
            const l2 = ((e2 - o2) * r2 + (t2 - i2) * a2) / (r2 * r2 + a2 * a2);
            l2 > 1 ? (o2 = s2, i2 = n2) : l2 > 0 && (o2 += r2 * l2, i2 += a2 * l2);
          }
          return r2 = e2 - o2, a2 = t2 - i2, r2 * r2 + a2 * a2;
        }
        function D2(e2, t2, o2, i2) {
          const s2 = { id: null == e2 ? null : e2, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if ("Point" === t2 || "MultiPoint" === t2 || "LineString" === t2) T2(s2, o2);
          else if ("Polygon" === t2) T2(s2, o2[0]);
          else if ("MultiLineString" === t2) for (const e3 of o2) T2(s2, e3);
          else if ("MultiPolygon" === t2) for (const e3 of o2) T2(s2, e3[0]);
          return s2;
        }
        function T2(e2, t2) {
          for (let o2 = 0; o2 < t2.length; o2 += 3) e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
        }
        function k2(e2, t2, o2, i2) {
          if (!t2.geometry) return;
          const s2 = t2.geometry.coordinates;
          if (s2 && 0 === s2.length) return;
          const n2 = t2.geometry.type, r2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2);
          let a2 = [], l2 = t2.id;
          if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = i2 || 0), "Point" === n2) C(s2, a2);
          else if ("MultiPoint" === n2) for (const e3 of s2) C(e3, a2);
          else if ("LineString" === n2) O2(s2, a2, r2, false);
          else if ("MultiLineString" === n2) {
            if (o2.lineMetrics) {
              for (const o3 of s2) a2 = [], O2(o3, a2, r2, false), e2.push(D2(l2, "LineString", a2, t2.properties));
              return;
            }
            L2(s2, a2, r2, false);
          } else if ("Polygon" === n2) L2(s2, a2, r2, true);
          else {
            if ("MultiPolygon" !== n2) {
              if ("GeometryCollection" === n2) {
                for (const s3 of t2.geometry.geometries) k2(e2, { id: l2, geometry: s3, properties: t2.properties }, o2, i2);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const e3 of s2) {
              const t3 = [];
              L2(e3, t3, r2, true), a2.push(t3);
            }
          }
          e2.push(D2(l2, n2, a2, t2.properties));
        }
        function C(e2, t2) {
          t2.push(z2(e2[0]), F2(e2[1]), 0);
        }
        function O2(e2, t2, o2, i2) {
          let s2, n2, r2 = 0;
          for (let o3 = 0; o3 < e2.length; o3++) {
            const a3 = z2(e2[o3][0]), l2 = F2(e2[o3][1]);
            t2.push(a3, l2, 0), o3 > 0 && (r2 += i2 ? (s2 * l2 - a3 * n2) / 2 : Math.sqrt(Math.pow(a3 - s2, 2) + Math.pow(l2 - n2, 2))), s2 = a3, n2 = l2;
          }
          const a2 = t2.length - 3;
          t2[2] = 1, I2(t2, 0, a2, o2), t2[a2 + 2] = 1, t2.size = Math.abs(r2), t2.start = 0, t2.end = t2.size;
        }
        function L2(e2, t2, o2, i2) {
          for (let s2 = 0; s2 < e2.length; s2++) {
            const n2 = [];
            O2(e2[s2], n2, o2, i2), t2.push(n2);
          }
        }
        function z2(e2) {
          return e2 / 360 + 0.5;
        }
        function F2(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
        }
        function G2(e2, t2, o2, i2, s2, n2, r2, a2) {
          if (i2 /= t2, n2 >= (o2 /= t2) && r2 < i2) return e2;
          if (r2 < o2 || n2 >= i2) return null;
          const l2 = [];
          for (const t3 of e2) {
            const e3 = t3.geometry;
            let n3 = t3.type;
            const r3 = 0 === s2 ? t3.minX : t3.minY, c2 = 0 === s2 ? t3.maxX : t3.maxY;
            if (r3 >= o2 && c2 < i2) {
              l2.push(t3);
              continue;
            }
            if (c2 < o2 || r3 >= i2) continue;
            let h2 = [];
            if ("Point" === n3 || "MultiPoint" === n3) A(e3, h2, o2, i2, s2);
            else if ("LineString" === n3) Z2(e3, h2, o2, i2, s2, false, a2.lineMetrics);
            else if ("MultiLineString" === n3) E(e3, h2, o2, i2, s2, false);
            else if ("Polygon" === n3) E(e3, h2, o2, i2, s2, true);
            else if ("MultiPolygon" === n3) for (const t4 of e3) {
              const e4 = [];
              E(t4, e4, o2, i2, s2, true), e4.length && h2.push(e4);
            }
            if (h2.length) {
              if (a2.lineMetrics && "LineString" === n3) {
                for (const e4 of h2) l2.push(D2(t3.id, n3, e4, t3.tags));
                continue;
              }
              "LineString" !== n3 && "MultiLineString" !== n3 || (1 === h2.length ? (n3 = "LineString", h2 = h2[0]) : n3 = "MultiLineString"), "Point" !== n3 && "MultiPoint" !== n3 || (n3 = 3 === h2.length ? "Point" : "MultiPoint"), l2.push(D2(t3.id, n3, h2, t3.tags));
            }
          }
          return l2.length ? l2 : null;
        }
        function A(e2, t2, o2, i2, s2) {
          for (let n2 = 0; n2 < e2.length; n2 += 3) {
            const r2 = e2[n2 + s2];
            r2 >= o2 && r2 <= i2 && j2(t2, e2[n2], e2[n2 + 1], e2[n2 + 2]);
          }
        }
        function Z2(e2, t2, o2, i2, s2, n2, r2) {
          let a2 = R2(e2);
          const l2 = 0 === s2 ? N : W2;
          let c2, h2, u2 = e2.start;
          for (let d3 = 0; d3 < e2.length - 3; d3 += 3) {
            const g3 = e2[d3], f4 = e2[d3 + 1], p3 = e2[d3 + 2], m2 = e2[d3 + 3], y3 = e2[d3 + 4], v2 = 0 === s2 ? g3 : f4, x2 = 0 === s2 ? m2 : y3;
            let _3 = false;
            r2 && (c2 = Math.sqrt(Math.pow(g3 - m2, 2) + Math.pow(f4 - y3, 2))), v2 < o2 ? x2 > o2 && (h2 = l2(a2, g3, f4, m2, y3, o2), r2 && (a2.start = u2 + c2 * h2)) : v2 > i2 ? x2 < i2 && (h2 = l2(a2, g3, f4, m2, y3, i2), r2 && (a2.start = u2 + c2 * h2)) : j2(a2, g3, f4, p3), x2 < o2 && v2 >= o2 && (h2 = l2(a2, g3, f4, m2, y3, o2), _3 = true), x2 > i2 && v2 <= i2 && (h2 = l2(a2, g3, f4, m2, y3, i2), _3 = true), !n2 && _3 && (r2 && (a2.end = u2 + c2 * h2), t2.push(a2), a2 = R2(e2)), r2 && (u2 += c2);
          }
          let d2 = e2.length - 3;
          const g2 = e2[d2], f3 = e2[d2 + 1], p2 = 0 === s2 ? g2 : f3;
          p2 >= o2 && p2 <= i2 && j2(a2, g2, f3, e2[d2 + 2]), d2 = a2.length - 3, n2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && j2(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
        }
        function R2(e2) {
          const t2 = [];
          return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
        }
        function E(e2, t2, o2, i2, s2, n2) {
          for (const r2 of e2) Z2(r2, t2, o2, i2, s2, n2, false);
        }
        function j2(e2, t2, o2, i2) {
          e2.push(t2, o2, i2);
        }
        function N(e2, t2, o2, i2, s2, n2) {
          const r2 = (n2 - t2) / (i2 - t2);
          return j2(e2, n2, o2 + (s2 - o2) * r2, 1), r2;
        }
        function W2(e2, t2, o2, i2, s2, n2) {
          const r2 = (n2 - o2) / (s2 - o2);
          return j2(e2, t2 + (i2 - t2) * r2, n2, 1), r2;
        }
        function J2(e2, t2) {
          const o2 = [];
          for (let i2 = 0; i2 < e2.length; i2++) {
            const s2 = e2[i2], n2 = s2.type;
            let r2;
            if ("Point" === n2 || "MultiPoint" === n2 || "LineString" === n2) r2 = Y2(s2.geometry, t2);
            else if ("MultiLineString" === n2 || "Polygon" === n2) {
              r2 = [];
              for (const e3 of s2.geometry) r2.push(Y2(e3, t2));
            } else if ("MultiPolygon" === n2) {
              r2 = [];
              for (const e3 of s2.geometry) {
                const o3 = [];
                for (const i3 of e3) o3.push(Y2(i3, t2));
                r2.push(o3);
              }
            }
            o2.push(D2(s2.id, n2, r2, s2.tags));
          }
          return o2;
        }
        function Y2(e2, t2) {
          const o2 = [];
          o2.size = e2.size, void 0 !== e2.start && (o2.start = e2.start, o2.end = e2.end);
          for (let i2 = 0; i2 < e2.length; i2 += 3) o2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
          return o2;
        }
        function q2(e2, t2) {
          if (e2.transformed) return e2;
          const o2 = 1 << e2.z, i2 = e2.x, s2 = e2.y;
          for (const n2 of e2.features) {
            const e3 = n2.geometry, r2 = n2.type;
            if (n2.geometry = [], 1 === r2) for (let r3 = 0; r3 < e3.length; r3 += 2) n2.geometry.push(H2(e3[r3], e3[r3 + 1], t2, o2, i2, s2));
            else for (let r3 = 0; r3 < e3.length; r3++) {
              const a2 = [];
              for (let n3 = 0; n3 < e3[r3].length; n3 += 2) a2.push(H2(e3[r3][n3], e3[r3][n3 + 1], t2, o2, i2, s2));
              n2.geometry.push(a2);
            }
          }
          return e2.transformed = true, e2;
        }
        function H2(e2, t2, o2, i2, s2, n2) {
          return [Math.round(o2 * (e2 * i2 - s2)), Math.round(o2 * (t2 * i2 - n2))];
        }
        function X(e2, t2, o2, i2, s2) {
          const n2 = t2 === s2.maxZoom ? 0 : s2.tolerance / ((1 << t2) * s2.extent), r2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: o2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const t3 of e2) B2(r2, t3, n2, s2);
          return r2;
        }
        function B2(e2, t2, o2, i2) {
          const s2 = t2.geometry, n2 = t2.type, r2 = [];
          if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), "Point" === n2 || "MultiPoint" === n2) for (let t3 = 0; t3 < s2.length; t3 += 3) r2.push(s2[t3], s2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === n2) $2(r2, s2, e2, o2, false, false);
          else if ("MultiLineString" === n2 || "Polygon" === n2) for (let t3 = 0; t3 < s2.length; t3++) $2(r2, s2[t3], e2, o2, "Polygon" === n2, 0 === t3);
          else if ("MultiPolygon" === n2) for (let t3 = 0; t3 < s2.length; t3++) {
            const i3 = s2[t3];
            for (let t4 = 0; t4 < i3.length; t4++) $2(r2, i3[t4], e2, o2, true, 0 === t4);
          }
          if (r2.length) {
            let o3 = t2.tags || null;
            if ("LineString" === n2 && i2.lineMetrics) {
              o3 = {};
              for (const e3 in t2.tags) o3[e3] = t2.tags[e3];
              o3.mapbox_clip_start = s2.start / s2.size, o3.mapbox_clip_end = s2.end / s2.size;
            }
            const a2 = { geometry: r2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: o3 };
            null !== t2.id && (a2.id = t2.id), e2.features.push(a2);
          }
        }
        function $2(e2, t2, o2, i2, s2, n2) {
          const r2 = i2 * i2;
          if (i2 > 0 && t2.size < (s2 ? r2 : i2)) return void (o2.numPoints += t2.length / 3);
          const a2 = [];
          for (let e3 = 0; e3 < t2.length; e3 += 3) (0 === i2 || t2[e3 + 2] > r2) && (o2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), o2.numPoints++;
          s2 && (function(e3, t3) {
            let o3 = 0;
            for (let t4 = 0, i3 = e3.length, s3 = i3 - 2; t4 < i3; s3 = t4, t4 += 2) o3 += (e3[t4] - e3[s3]) * (e3[t4 + 1] + e3[s3 + 1]);
            if (o3 > 0 === t3) for (let t4 = 0, o4 = e3.length; t4 < o4 / 2; t4 += 2) {
              const i3 = e3[t4], s3 = e3[t4 + 1];
              e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = i3, e3[o4 - 1 - t4] = s3;
            }
          })(a2, n2), e2.push(a2);
        }
        const U2 = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class V2 {
          constructor(e2, t2) {
            const o2 = (t2 = this.options = (function(e3, t3) {
              for (const o3 in t3) e3[o3] = t3[o3];
              return e3;
            })(Object.create(U2), t2)).debug;
            if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t2.promoteId && t2.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let i2 = (function(e3, t3) {
              const o3 = [];
              if ("FeatureCollection" === e3.type) for (let i3 = 0; i3 < e3.features.length; i3++) k2(o3, e3.features[i3], t3, i3);
              else k2(o3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
              return o3;
            })(e2, t2);
            this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = (function(e3, t3) {
              const o3 = t3.buffer / t3.extent;
              let i3 = e3;
              const s2 = G2(e3, 1, -1 - o3, o3, 0, -1, 2, t3), n2 = G2(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
              return (s2 || n2) && (i3 = G2(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], s2 && (i3 = J2(s2, 1).concat(i3)), n2 && (i3 = i3.concat(J2(n2, -1)))), i3;
            })(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(e2, t2, o2, i2, s2, n2, r2) {
            const a2 = [e2, t2, o2, i2], l2 = this.options, c2 = l2.debug;
            for (; a2.length; ) {
              i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
              const h2 = 1 << t2, u2 = K2(t2, o2, i2);
              let d2 = this.tiles[u2];
              if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[u2] = X(e2, t2, o2, i2, l2), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
                c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
                const e3 = `z${t2}`;
                this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
              }
              if (d2.source = e2, null == s2) {
                if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints) continue;
              } else {
                if (t2 === l2.maxZoom || t2 === s2) continue;
                if (null != s2) {
                  const e3 = s2 - t2;
                  if (o2 !== n2 >> e3 || i2 !== r2 >> e3) continue;
                }
              }
              if (d2.source = null, 0 === e2.length) continue;
              c2 > 1 && console.time("clipping");
              const g2 = 0.5 * l2.buffer / l2.extent, f3 = 0.5 - g2, p2 = 0.5 + g2, m2 = 1 + g2;
              let y3 = null, v2 = null, x2 = null, _3 = null, w3 = G2(e2, h2, o2 - g2, o2 + p2, 0, d2.minX, d2.maxX, l2), S3 = G2(e2, h2, o2 + f3, o2 + m2, 0, d2.minX, d2.maxX, l2);
              e2 = null, w3 && (y3 = G2(w3, h2, i2 - g2, i2 + p2, 1, d2.minY, d2.maxY, l2), v2 = G2(w3, h2, i2 + f3, i2 + m2, 1, d2.minY, d2.maxY, l2), w3 = null), S3 && (x2 = G2(S3, h2, i2 - g2, i2 + p2, 1, d2.minY, d2.maxY, l2), _3 = G2(S3, h2, i2 + f3, i2 + m2, 1, d2.minY, d2.maxY, l2), S3 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y3 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(x2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(_3 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
            }
          }
          getTile(e2, t2, o2) {
            e2 = +e2, t2 = +t2, o2 = +o2;
            const i2 = this.options, { extent: s2, debug: n2 } = i2;
            if (e2 < 0 || e2 > 24) return null;
            const r2 = 1 << e2, a2 = K2(e2, t2 = t2 + r2 & r2 - 1, o2);
            if (this.tiles[a2]) return q2(this.tiles[a2], s2);
            n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
            let l2, c2 = e2, h2 = t2, u2 = o2;
            for (; !l2 && c2 > 0; ) c2--, h2 >>= 1, u2 >>= 1, l2 = this.tiles[K2(c2, h2, u2)];
            return l2 && l2.source ? (n2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, h2, u2), console.time("drilling down")), this.splitTile(l2.source, c2, h2, u2, e2, t2, o2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? q2(this.tiles[a2], s2) : null) : null;
          }
        }
        function K2(e2, t2, o2) {
          return 32 * ((1 << e2) * o2 + t2) + e2;
        }
        class Q2 extends h {
          constructor(e2, t2, o2, i2 = ee2) {
            super(e2, t2, o2), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = i2;
          }
          loadVectorTile(t2, o2) {
            return e._(this, void 0, void 0, (function* () {
              const o3 = t2.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const i2 = this._geoJSONIndex.getTile(o3.z, o3.x, o3.y);
              return i2 ? l(new e.d2(i2.features, { version: 2, extent: e.a5 })) : null;
            }));
          }
          loadData(t2) {
            return e._(this, void 0, void 0, (function* () {
              var o2;
              null === (o2 = this._pendingRequest) || void 0 === o2 || o2.abort();
              const i2 = this._startPerformance(t2);
              this._pendingRequest = new AbortController();
              try {
                (!this._pendingData || t2.request || t2.data || t2.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(t2, this._pendingRequest));
                const e2 = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(e2, t2), this.loaded = {};
                const o3 = {};
                return t2.request && (o3.data = e2), this._finishPerformance(i2, t2, o3), o3;
              } catch (t3) {
                if (delete this._pendingRequest, e.Z(t3)) return { abandoned: true };
                throw t3;
              }
            }));
          }
          _startPerformance(t2) {
            var o2;
            if (null === (o2 = null == t2 ? void 0 : t2.request) || void 0 === o2 ? void 0 : o2.collectResourceTiming) return new e.c_(t2.request);
          }
          _finishPerformance(e2, t2, o2) {
            if (!e2) return;
            const i2 = e2.finish();
            i2 && (o2.resourceTiming = {}, o2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(i2)));
          }
          getData() {
            return e._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(e2) {
            const t2 = this.loaded;
            return t2 && t2[e2.uid] ? super.reloadTile(e2) : this.loadTile(e2);
          }
          loadAndProcessGeoJSON(t2, o2) {
            return e._(this, void 0, void 0, (function* () {
              let e2;
              if (t2.request ? e2 = yield this.loadGeoJSONFromUrl(t2.request, t2.promoteId, o2) : t2.data ? e2 = this._loadGeoJSONFromObject(t2.data, t2.promoteId) : t2.dataDiff && (e2 = this._loadGeoJSONFromDiff(t2.dataDiff, t2.promoteId, t2.source)), delete this._pendingRequest, "object" != typeof e2) throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
              return p(e2, true), t2.filter && (e2 = this._filterGeoJSON(e2, t2.filter)), e2;
            }));
          }
          loadGeoJSONFromUrl(t2, o2, i2) {
            return e._(this, void 0, void 0, (function* () {
              const s2 = yield e.j(t2, i2);
              return this._dataUpdateable = e.a7(s2.data, o2), s2.data;
            }));
          }
          _loadGeoJSONFromObject(t2, o2) {
            return this._dataUpdateable = e.a7(t2, o2), t2;
          }
          _loadGeoJSONFromDiff(t2, o2, i2) {
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${i2}`);
            e.a8(this._dataUpdateable, t2, o2);
            const s2 = Array.from(this._dataUpdateable.values());
            return this._toFeatureCollection(s2);
          }
          _filterGeoJSON(t2, o2) {
            const i2 = e.d3(o2, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
            if ("error" === i2.result) throw new Error(i2.value.map(((e2) => `${e2.key}: ${e2.message}`)).join(", "));
            const s2 = t2.features.filter(((e2) => i2.value.evaluate({ zoom: 0 }, e2)));
            return this._toFeatureCollection(s2);
          }
          _toFeatureCollection(e2) {
            return { type: "FeatureCollection", features: e2 };
          }
          removeSource(t2) {
            return e._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(e2) {
            return this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId);
          }
          getClusterChildren(e2) {
            return this._geoJSONIndex.getChildren(e2.clusterId);
          }
          getClusterLeaves(e2) {
            return this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset);
          }
        }
        function ee2(t2, o2) {
          return o2.cluster ? new x((function({ superclusterOptions: t3, clusterProperties: o3 }) {
            if (!o3 || !t3) return t3;
            const i2 = {}, s2 = {}, n2 = { accumulated: null, zoom: 0 }, r2 = { properties: null }, a2 = Object.keys(o3);
            for (const t4 of a2) {
              const [n3, r3] = o3[t4], a3 = e.d3(r3), l2 = e.d3("string" == typeof n3 ? [n3, ["accumulated"], ["get", t4]] : n3);
              i2[t4] = a3.value, s2[t4] = l2.value;
            }
            return t3.map = (e2) => {
              r2.properties = e2;
              const t4 = {};
              for (const e3 of a2) t4[e3] = i2[e3].evaluate(n2, r2);
              return t4;
            }, t3.reduce = (e2, t4) => {
              r2.properties = t4;
              for (const t5 of a2) n2.accumulated = e2[t5], e2[t5] = s2[t5].evaluate(n2, r2);
            }, t3;
          })(o2)).load(t2.features) : (function(e2, t3) {
            return new V2(e2, t3);
          })(t2, o2.geojsonVtOptions);
        }
        class te2 {
          constructor(t2) {
            this.self = t2, this.actor = new e.L(t2), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (e2, t3) => {
              if (this.externalWorkerSourceTypes[e2]) throw new Error(`Worker source with name "${e2}" already registered.`);
              this.externalWorkerSourceTypes[e2] = t3;
            }, this.self.addProtocol = e.cJ, this.self.removeProtocol = e.cK, this.self.registerRTLTextPlugin = (t3) => {
              e.d4.setMethods(t3);
            }, this.actor.registerMessageHandler("LDT", ((e2, t3) => this._getDEMWorkerSource(e2, t3.source).loadTile(t3))), this.actor.registerMessageHandler("RDT", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(t3, o2.source).removeTile(o2);
            })))), this.actor.registerMessageHandler("GCEZ", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(t3, o2.type, o2.source).getClusterExpansionZoom(o2);
            })))), this.actor.registerMessageHandler("GCC", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(t3, o2.type, o2.source).getClusterChildren(o2);
            })))), this.actor.registerMessageHandler("GCL", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(t3, o2.type, o2.source).getClusterLeaves(o2);
            })))), this.actor.registerMessageHandler("LD", ((e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadData(t3))), this.actor.registerMessageHandler("GD", ((e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).getData())), this.actor.registerMessageHandler("LT", ((e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadTile(t3))), this.actor.registerMessageHandler("RT", ((e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).reloadTile(t3))), this.actor.registerMessageHandler("AT", ((e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).abortTile(t3))), this.actor.registerMessageHandler("RMT", ((e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).removeTile(t3))), this.actor.registerMessageHandler("RS", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              if (!this.workerSources[t3] || !this.workerSources[t3][o2.type] || !this.workerSources[t3][o2.type][o2.source]) return;
              const e2 = this.workerSources[t3][o2.type][o2.source];
              delete this.workerSources[t3][o2.type][o2.source], void 0 !== e2.removeSource && e2.removeSource(o2);
            })))), this.actor.registerMessageHandler("RM", ((t3) => e._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[t3], delete this.availableImages[t3], delete this.workerSources[t3], delete this.demWorkerSources[t3], this.globalStates.delete(t3);
            })))), this.actor.registerMessageHandler("SR", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              this.referrer = o2;
            })))), this.actor.registerMessageHandler("SRPS", ((e2, t3) => this._syncRTLPluginState(e2, t3))), this.actor.registerMessageHandler("IS", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              this.self.importScripts(o2);
            })))), this.actor.registerMessageHandler("SI", ((e2, t3) => this._setImages(e2, t3))), this.actor.registerMessageHandler("UL", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              this._getLayerIndex(t3).update(o2.layers, o2.removedIds, this._getGlobalState(t3));
            })))), this.actor.registerMessageHandler("UGS", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              const e2 = this._getGlobalState(t3);
              for (const t4 in o2) e2[t4] = o2[t4];
            })))), this.actor.registerMessageHandler("SL", ((t3, o2) => e._(this, void 0, void 0, (function* () {
              this._getLayerIndex(t3).replace(o2, this._getGlobalState(t3));
            }))));
          }
          _getGlobalState(e2) {
            let t2 = this.globalStates.get(e2);
            return t2 || (t2 = {}, this.globalStates.set(e2, t2)), t2;
          }
          _setImages(t2, o2) {
            return e._(this, void 0, void 0, (function* () {
              this.availableImages[t2] = o2;
              for (const e2 in this.workerSources[t2]) {
                const i2 = this.workerSources[t2][e2];
                for (const e3 in i2) i2[e3].availableImages = o2;
              }
            }));
          }
          _syncRTLPluginState(t2, o2) {
            return e._(this, void 0, void 0, (function* () {
              return yield e.d4.syncState(o2, this.self.importScripts);
            }));
          }
          _getAvailableImages(e2) {
            let t2 = this.availableImages[e2];
            return t2 || (t2 = []), t2;
          }
          _getLayerIndex(e2) {
            let o2 = this.layerIndexes[e2];
            return o2 || (o2 = this.layerIndexes[e2] = new t()), o2;
          }
          _getWorkerSource(e2, t2, o2) {
            if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][o2]) {
              const i2 = { sendAsync: (t3, o3) => (t3.targetMapId = e2, this.actor.sendAsync(t3, o3)) };
              switch (t2) {
                case "vector":
                  this.workerSources[e2][t2][o2] = new h(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                  break;
                case "geojson":
                  this.workerSources[e2][t2][o2] = new Q2(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                  break;
                default:
                  this.workerSources[e2][t2][o2] = new this.externalWorkerSourceTypes[t2](i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
              }
            }
            return this.workerSources[e2][t2][o2];
          }
          _getDEMWorkerSource(e2, t2) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new u()), this.demWorkerSources[e2][t2];
          }
        }
        return e.i(self) && (self.worker = new te2(self)), te2;
      }));
      define2("index", ["exports", "./shared"], (function(e, t) {
        "use strict";
        var i = "5.16.0";
        function a() {
          var e2 = new t.A(4);
          return t.A != Float32Array && (e2[1] = 0, e2[2] = 0), e2[0] = 1, e2[3] = 1, e2;
        }
        let r, o, s;
        const n = { frame(e2, i2, a2) {
          const r2 = requestAnimationFrame(((e3) => {
            o2(), i2(e3);
          })), { unsubscribe: o2 } = t.s(e2.signal, "abort", (() => {
            o2(), cancelAnimationFrame(r2), a2(new t.a(e2.signal.reason));
          }), false);
        }, frameAsync(e2) {
          return new Promise(((t2, i2) => {
            this.frame(e2, t2, i2);
          }));
        }, getImageData(e2, t2 = 0) {
          return this.getImageCanvasContext(e2).getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
        }, getImageCanvasContext(e2) {
          const t2 = window.document.createElement("canvas"), i2 = t2.getContext("2d", { willReadFrequently: true });
          if (!i2) throw new Error("failed to create canvas 2d context");
          return t2.width = e2.width, t2.height = e2.height, i2.drawImage(e2, 0, 0, e2.width, e2.height), i2;
        }, resolveURL: (e2) => (r || (r = document.createElement("a")), r.href = e2, r.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return void 0 !== s ? s : !!matchMedia && (null == o && (o = matchMedia("(prefers-reduced-motion: reduce)")), o.matches);
        }, set prefersReducedMotion(e2) {
          s = e2;
        } }, l = new class {
          constructor() {
            this._realTime = "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
          }
          getCurrentTime() {
            return null !== this._frozenAt ? this._frozenAt : this._realTime();
          }
          setNow(e2) {
            this._frozenAt = e2;
          }
          restoreNow() {
            this._frozenAt = null;
          }
          isFrozen() {
            return null !== this._frozenAt;
          }
        }();
        function c() {
          return l.getCurrentTime();
        }
        class h {
          static testProp(e2) {
            if (!h.docStyle) return e2[0];
            for (let t2 = 0; t2 < e2.length; t2++) if (e2[t2] in h.docStyle) return e2[t2];
            return e2[0];
          }
          static create(e2, t2, i2) {
            const a2 = window.document.createElement(e2);
            return void 0 !== t2 && (a2.className = t2), i2 && i2.appendChild(a2), a2;
          }
          static createNS(e2, t2) {
            return window.document.createElementNS(e2, t2);
          }
          static disableDrag() {
            h.docStyle && h.selectProp && (h.userSelect = h.docStyle[h.selectProp], h.docStyle[h.selectProp] = "none");
          }
          static enableDrag() {
            h.docStyle && h.selectProp && (h.docStyle[h.selectProp] = h.userSelect);
          }
          static setTransform(e2, t2) {
            e2.style[h.transformProp] = t2;
          }
          static addEventListener(e2, t2, i2, a2 = {}) {
            e2.addEventListener(t2, i2, "passive" in a2 ? a2 : a2.capture);
          }
          static removeEventListener(e2, t2, i2, a2 = {}) {
            e2.removeEventListener(t2, i2, "passive" in a2 ? a2 : a2.capture);
          }
          static suppressClickInternal(e2) {
            e2.preventDefault(), e2.stopPropagation(), window.removeEventListener("click", h.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", h.suppressClickInternal, true), window.setTimeout((() => {
              window.removeEventListener("click", h.suppressClickInternal, true);
            }), 0);
          }
          static getScale(e2) {
            const t2 = e2.getBoundingClientRect();
            return { x: t2.width / e2.offsetWidth || 1, y: t2.height / e2.offsetHeight || 1, boundingClientRect: t2 };
          }
          static getPoint(e2, i2, a2) {
            const r2 = i2.boundingClientRect;
            return new t.P((a2.clientX - r2.left) / i2.x - e2.clientLeft, (a2.clientY - r2.top) / i2.y - e2.clientTop);
          }
          static mousePos(e2, t2) {
            const i2 = h.getScale(e2);
            return h.getPoint(e2, i2, t2);
          }
          static touchPos(e2, t2) {
            const i2 = [], a2 = h.getScale(e2);
            for (let r2 = 0; r2 < t2.length; r2++) i2.push(h.getPoint(e2, a2, t2[r2]));
            return i2;
          }
          static mouseButton(e2) {
            return e2.button;
          }
          static remove(e2) {
            e2.parentNode && e2.parentNode.removeChild(e2);
          }
          static sanitize(e2) {
            const t2 = new DOMParser().parseFromString(e2, "text/html").body || document.createElement("body"), i2 = t2.querySelectorAll("script");
            for (const e3 of i2) e3.remove();
            return h.clean(t2), t2.innerHTML;
          }
          static isPossiblyDangerous(e2, t2) {
            const i2 = t2.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e2) || !i2.includes("javascript:") && !i2.includes("data:")) || !!e2.startsWith("on") || void 0;
          }
          static clean(e2) {
            const t2 = e2.children;
            for (const e3 of t2) h.removeAttributes(e3), h.clean(e3);
          }
          static removeAttributes(e2) {
            for (const { name: t2, value: i2 } of e2.attributes) h.isPossiblyDangerous(t2, i2) && e2.removeAttribute(t2);
          }
        }
        h.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, h.selectProp = h.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), h.transformProp = h.testProp(["transform", "WebkitTransform"]);
        const u = { supported: false, testSupport: function(e2) {
          !p && _2 && (m ? f2(e2) : d = e2);
        } };
        let d, _2, p = false, m = false;
        function f2(e2) {
          const t2 = e2.createTexture();
          e2.bindTexture(e2.TEXTURE_2D, t2);
          try {
            if (e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, e2.UNSIGNED_BYTE, _2), e2.isContextLost()) return;
            u.supported = true;
          } catch (e3) {
          }
          e2.deleteTexture(t2), p = true;
        }
        var g;
        "undefined" != typeof document && (_2 = document.createElement("img"), _2.onload = () => {
          d && f2(d), d = null, m = true;
        }, _2.onerror = () => {
          p = true, d = null;
        }, _2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(e2) {
          let i2, a2, r2, o2;
          e2.resetRequestQueue = () => {
            i2 = [], a2 = 0, r2 = 0, o2 = {};
          }, e2.addThrottleControl = (e3) => {
            const t2 = r2++;
            return o2[t2] = e3, t2;
          }, e2.removeThrottleControl = (e3) => {
            delete o2[e3], n2();
          }, e2.getImage = (e3, a3, r3 = true) => new Promise(((o3, s3) => {
            u.supported && (e3.headers || (e3.headers = {}), e3.headers.accept = "image/webp,*/*"), t.e(e3, { type: "image" }), i2.push({ abortController: a3, requestParameters: e3, supportImageRefresh: r3, state: "queued", onError: (e4) => {
              s3(e4);
            }, onSuccess: (e4) => {
              o3(e4);
            } }), n2();
          }));
          const s2 = (e3) => t._(this, void 0, void 0, (function* () {
            e3.state = "running";
            const { requestParameters: i3, supportImageRefresh: r3, onError: o3, onSuccess: s3, abortController: c2 } = e3, h2 = false === r3 && !t.i(self) && !t.g(i3.url) && (!i3.headers || Object.keys(i3.headers).reduce(((e4, t2) => e4 && "accept" === t2), true));
            a2++;
            const u2 = h2 ? l2(i3, c2) : t.m(i3, c2);
            try {
              const i4 = yield u2;
              delete e3.abortController, e3.state = "completed", i4.data instanceof HTMLImageElement || t.b(i4.data) ? s3(i4) : i4.data && s3({ data: yield (d2 = i4.data, "function" == typeof createImageBitmap ? t.f(d2) : t.h(d2)), cacheControl: i4.cacheControl, expires: i4.expires });
            } catch (t2) {
              delete e3.abortController, o3(t2);
            } finally {
              a2--, n2();
            }
            var d2;
          })), n2 = () => {
            const e3 = (() => {
              for (const e4 of Object.keys(o2)) if (o2[e4]()) return true;
              return false;
            })() ? t.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.c.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let t2 = a2; t2 < e3 && i2.length > 0; t2++) {
              const e4 = i2.shift();
              e4.abortController.signal.aborted ? t2-- : s2(e4);
            }
          }, l2 = (e3, i3) => new Promise(((a3, r3) => {
            const o3 = new Image(), s3 = e3.url, n3 = e3.credentials;
            n3 && "include" === n3 ? o3.crossOrigin = "use-credentials" : (n3 && "same-origin" === n3 || !t.d(s3)) && (o3.crossOrigin = "anonymous"), i3.signal.addEventListener("abort", (() => {
              o3.src = "", r3(new t.a(i3.signal.reason));
            })), o3.fetchPriority = "high", o3.onload = () => {
              o3.onerror = o3.onload = null, a3({ data: o3 });
            }, o3.onerror = () => {
              o3.onerror = o3.onload = null, i3.signal.aborted || r3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, o3.src = s3;
          }));
        })(g || (g = {})), g.resetRequestQueue();
        class v {
          constructor(e2) {
            this._transformRequestFn = null != e2 ? e2 : null;
          }
          transformRequest(e2, t2) {
            return this._transformRequestFn && this._transformRequestFn(e2, t2) || { url: e2 };
          }
          setTransformRequest(e2) {
            this._transformRequestFn = e2;
          }
        }
        function x(e2) {
          const t2 = [];
          if ("string" == typeof e2) t2.push({ id: "default", url: e2 });
          else if (e2 && e2.length > 0) {
            const i2 = [];
            for (const { id: a2, url: r2 } of e2) {
              const e3 = `${a2}${r2}`;
              -1 === i2.indexOf(e3) && (i2.push(e3), t2.push({ id: a2, url: r2 }));
            }
          }
          return t2;
        }
        function b(e2, t2, i2) {
          try {
            const a2 = new URL(e2);
            return a2.pathname += `${t2}${i2}`, a2.toString();
          } catch (t3) {
            throw new Error(`Invalid sprite URL "${e2}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function y2(e2) {
          const { userImage: t2 } = e2;
          return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
        }
        class w2 extends t.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({ width: 1, height: 1 }), this.dirty = true;
          }
          destroy() {
            this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null);
            for (const e2 of Object.keys(this.images)) this.removeImage(e2);
            this.patterns = {}, this.atlasImage = new t.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e2) {
            if (this.loaded !== e2 && (this.loaded = e2, e2)) {
              for (const { ids: e3, promiseResolve: t2 } of this.requestors) t2(this._getImagesForIds(e3));
              this.requestors = [];
            }
          }
          getImage(e2) {
            const i2 = this.images[e2];
            if (i2 && !i2.data && i2.spriteData) {
              const e3 = i2.spriteData;
              i2.data = new t.R({ width: e3.width, height: e3.height }, e3.context.getImageData(e3.x, e3.y, e3.width, e3.height).data), i2.spriteData = null;
            }
            return i2;
          }
          addImage(e2, t2) {
            if (this.images[e2]) throw new Error(`Image id ${e2} already exist, use updateImage instead`);
            this._validate(e2, t2) && (this.images[e2] = t2);
          }
          _validate(e2, i2) {
            let a2 = true;
            const r2 = i2.data || i2.spriteData;
            return this._validateStretch(i2.stretchX, r2 && r2.width) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "stretchX" value`))), a2 = false), this._validateStretch(i2.stretchY, r2 && r2.height) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "stretchY" value`))), a2 = false), this._validateContent(i2.content, i2) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "content" value`))), a2 = false), a2;
          }
          _validateStretch(e2, t2) {
            if (!e2) return true;
            let i2 = 0;
            for (const a2 of e2) {
              if (a2[0] < i2 || a2[1] < a2[0] || t2 < a2[1]) return false;
              i2 = a2[1];
            }
            return true;
          }
          _validateContent(e2, t2) {
            if (!e2) return true;
            if (4 !== e2.length) return false;
            const i2 = t2.spriteData, a2 = i2 && i2.width || t2.data.width, r2 = i2 && i2.height || t2.data.height;
            return !(e2[0] < 0 || a2 < e2[0] || e2[1] < 0 || r2 < e2[1] || e2[2] < 0 || a2 < e2[2] || e2[3] < 0 || r2 < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]);
          }
          updateImage(e2, t2, i2 = true) {
            const a2 = this.getImage(e2);
            if (i2 && (a2.data.width !== t2.data.width || a2.data.height !== t2.data.height)) throw new Error(`size mismatch between old image (${a2.data.width}x${a2.data.height}) and new image (${t2.data.width}x${t2.data.height}).`);
            t2.version = a2.version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
          }
          removeImage(e2) {
            const t2 = this.images[e2];
            delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e2) {
            return new Promise(((t2, i2) => {
              let a2 = true;
              if (!this.isLoaded()) for (const t3 of e2) this.images[t3] || (a2 = false);
              this.isLoaded() || a2 ? t2(this._getImagesForIds(e2)) : this.requestors.push({ ids: e2, promiseResolve: t2 });
            }));
          }
          _getImagesForIds(e2) {
            const i2 = {};
            for (const a2 of e2) {
              let e3 = this.getImage(a2);
              e3 || (this.fire(new t.l("styleimagemissing", { id: a2 })), e3 = this.getImage(a2)), e3 ? i2[a2] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, textFitWidth: e3.textFitWidth, textFitHeight: e3.textFitHeight, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t.w(`Image "${a2}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return i2;
          }
          getPixelSize() {
            const { width: e2, height: t2 } = this.atlasImage;
            return { width: e2, height: t2 };
          }
          getPattern(e2) {
            const i2 = this.patterns[e2], a2 = this.getImage(e2);
            if (!a2) return null;
            if (i2 && i2.position.version === a2.version) return i2.position;
            if (i2) i2.position.version = a2.version;
            else {
              const i3 = { w: a2.data.width + 2, h: a2.data.height + 2, x: 0, y: 0 }, r2 = new t.I(i3, a2);
              this.patterns[e2] = { bin: i3, position: r2 };
            }
            return this._updatePatternAtlas(), this.patterns[e2].position;
          }
          bind(e2) {
            const i2 = e2.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new t.T(e2, this.atlasImage, i2.RGBA), this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e2 = [];
            for (const t2 in this.patterns) e2.push(this.patterns[t2].bin);
            const { w: i2, h: a2 } = t.p(e2), r2 = this.atlasImage;
            r2.resize({ width: i2 || 1, height: a2 || 1 });
            for (const e3 in this.patterns) {
              const { bin: i3 } = this.patterns[e3], a3 = i3.x + 1, o2 = i3.y + 1, s2 = this.getImage(e3).data, n2 = s2.width, l2 = s2.height;
              t.R.copy(s2, r2, { x: 0, y: 0 }, { x: a3, y: o2 }, { width: n2, height: l2 }), t.R.copy(s2, r2, { x: 0, y: l2 - 1 }, { x: a3, y: o2 - 1 }, { width: n2, height: 1 }), t.R.copy(s2, r2, { x: 0, y: 0 }, { x: a3, y: o2 + l2 }, { width: n2, height: 1 }), t.R.copy(s2, r2, { x: n2 - 1, y: 0 }, { x: a3 - 1, y: o2 }, { width: 1, height: l2 }), t.R.copy(s2, r2, { x: 0, y: 0 }, { x: a3 + n2, y: o2 }, { width: 1, height: l2 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e2) {
            for (const i2 of e2) {
              if (this.callbackDispatchedThisFrame[i2]) continue;
              this.callbackDispatchedThisFrame[i2] = true;
              const e3 = this.getImage(i2);
              e3 || t.w(`Image with ID: "${i2}" was not found`), y2(e3) && this.updateImage(i2, e3);
            }
          }
          cloneImages() {
            const e2 = {};
            for (const t2 in this.images) {
              const i2 = this.images[t2];
              e2[t2] = Object.assign(Object.assign({}, i2), { data: i2.data ? i2.data.clone() : null });
            }
            return e2;
          }
        }
        const T2 = 1e20;
        function P2(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
          for (let c2 = t2; c2 < t2 + a2; c2++) C(e2, i2 * o2 + c2, o2, r2, s2, n2, l2);
          for (let c2 = i2; c2 < i2 + r2; c2++) C(e2, c2 * o2 + t2, 1, a2, s2, n2, l2);
        }
        function C(e2, t2, i2, a2, r2, o2, s2) {
          o2[0] = 0, s2[0] = -T2, s2[1] = T2, r2[0] = e2[t2];
          for (let n2 = 1, l2 = 0, c2 = 0; n2 < a2; n2++) {
            r2[n2] = e2[t2 + n2 * i2];
            const a3 = n2 * n2;
            do {
              const e3 = o2[l2];
              c2 = (r2[n2] - r2[e3] + a3 - e3 * e3) / (n2 - e3) / 2;
            } while (c2 <= s2[l2] && --l2 > -1);
            l2++, o2[l2] = n2, s2[l2] = c2, s2[l2 + 1] = T2;
          }
          for (let n2 = 0, l2 = 0; n2 < a2; n2++) {
            for (; s2[l2 + 1] < n2; ) l2++;
            const a3 = o2[l2], c2 = n2 - a3;
            e2[t2 + n2 * i2] = r2[a3] + c2 * c2;
          }
        }
        const I2 = t.v.layout_symbol["text-font"].default.join(",");
        class M2 {
          constructor(e2, t2, i2) {
            this.requestManager = e2, this.localIdeographFontFamily = t2, this.entries = {}, this.lang = i2;
          }
          setURL(e2) {
            this.url = e2;
          }
          getGlyphs(e2) {
            return t._(this, void 0, void 0, (function* () {
              const t2 = [];
              for (const i3 in e2) for (const a3 of e2[i3]) t2.push(this._getAndCacheGlyphsPromise(i3, a3));
              const i2 = yield Promise.all(t2), a2 = {};
              for (const { stack: e3, id: t3, glyph: r2 } of i2) a2[e3] || (a2[e3] = {}), a2[e3][t3] = r2 && { id: r2.id, bitmap: r2.bitmap.clone(), metrics: r2.metrics };
              return a2;
            }));
          }
          _getAndCacheGlyphsPromise(e2, i2) {
            return t._(this, void 0, void 0, (function* () {
              let t2 = this.entries[e2];
              t2 || (t2 = this.entries[e2] = { glyphs: {}, requests: {}, ranges: {} });
              let a2 = t2.glyphs[i2];
              return void 0 !== a2 ? { stack: e2, id: i2, glyph: a2 } : !this.url || this._charUsesLocalIdeographFontFamily(i2) ? (a2 = t2.glyphs[i2] = this._drawGlyph(t2, e2, i2), { stack: e2, id: i2, glyph: a2 }) : yield this._downloadAndCacheRangePromise(e2, i2);
            }));
          }
          _downloadAndCacheRangePromise(e2, i2) {
            return t._(this, void 0, void 0, (function* () {
              const t2 = this.entries[e2], a2 = Math.floor(i2 / 256);
              if (t2.ranges[a2]) return { stack: e2, id: i2, glyph: null };
              if (!t2.requests[a2]) {
                const i3 = M2.loadGlyphRange(e2, a2, this.url, this.requestManager);
                t2.requests[a2] = i3;
              }
              try {
                const r2 = yield t2.requests[a2];
                for (const e3 in r2) t2.glyphs[+e3] = r2[+e3];
                return t2.ranges[a2] = true, { stack: e2, id: i2, glyph: r2[i2] || null };
              } catch (r2) {
                const o2 = t2.glyphs[i2] = this._drawGlyph(t2, e2, i2);
                return this._warnOnMissingGlyphRange(o2, a2, i2, r2), { stack: e2, id: i2, glyph: o2 };
              }
            }));
          }
          _warnOnMissingGlyphRange(e2, i2, a2, r2) {
            const o2 = 256 * i2, s2 = o2 + 255, n2 = a2.toString(16).padStart(4, "0").toUpperCase();
            t.w(`Unable to load glyph range ${i2}, ${o2}-${s2}. Rendering codepoint U+${n2} locally instead. ${r2}`);
          }
          _charUsesLocalIdeographFontFamily(e2) {
            return !!this.localIdeographFontFamily && t.q(e2);
          }
          _drawGlyph(e2, i2, a2) {
            const r2 = i2 === I2 && "" !== this.localIdeographFontFamily && this._charUsesLocalIdeographFontFamily(a2), o2 = r2 ? "ideographTinySDF" : "tinySDF";
            e2[o2] || (e2[o2] = this._createTinySDF(r2 ? this.localIdeographFontFamily : i2));
            const s2 = e2[o2].draw(String.fromCodePoint(a2)), n2 = new RegExp("^\\p{gc=Cf}+$", "u").test(String.fromCodePoint(a2));
            return { id: a2, bitmap: new t.r({ width: s2.width || 60, height: s2.height || 60 }, s2.data), metrics: { width: n2 ? 0 : s2.glyphWidth / 2 || 24, height: s2.glyphHeight / 2 || 24, left: s2.glyphLeft / 2 + 0.5 || 0, top: s2.glyphTop / 2 - 27.5 || -8, advance: n2 ? 0 : s2.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
          _createTinySDF(e2) {
            const t2 = e2 ? e2.split(",") : [];
            t2.push("sans-serif");
            const i2 = t2.map(((e3) => /[-\w]+/.test(e3) ? e3 : `'${CSS.escape(e3)}'`)).join(",");
            return new M2.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: i2, fontWeight: this._fontWeight(t2[0]), fontStyle: this._fontStyle(t2[0]), lang: this.lang });
          }
          _fontStyle(e2) {
            return /italic/i.test(e2) ? "italic" : /oblique/i.test(e2) ? "oblique" : "normal";
          }
          _fontWeight(e2) {
            const t2 = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 };
            let i2;
            for (const [a2, r2] of Object.entries(t2)) new RegExp(`\\b${a2}\\b`, "i").test(e2) && (i2 = `${r2}`);
            return i2;
          }
          destroy() {
            for (const e2 in this.entries) {
              const t2 = this.entries[e2];
              t2.tinySDF && (t2.tinySDF = null), t2.ideographTinySDF && (t2.ideographTinySDF = null), t2.glyphs = {}, t2.requests = {}, t2.ranges = {};
            }
            this.entries = {};
          }
        }
        M2.loadGlyphRange = function(e2, i2, a2, r2) {
          return t._(this, void 0, void 0, (function* () {
            const o2 = 256 * i2, s2 = o2 + 255, n2 = r2.transformRequest(a2.replace("{fontstack}", e2).replace("{range}", `${o2}-${s2}`), "Glyphs"), l2 = yield t.n(n2, new AbortController());
            if (!l2 || !l2.data) throw new Error(`Could not load glyph range. range: ${i2}, ${o2}-${s2}`);
            const c2 = {};
            for (const e3 of t.o(l2.data)) c2[e3.id] = e3;
            return c2;
          }));
        }, M2.TinySDF = class {
          constructor({ fontSize: e2 = 24, buffer: t2 = 3, radius: i2 = 8, cutoff: a2 = 0.25, fontFamily: r2 = "sans-serif", fontWeight: o2 = "normal", fontStyle: s2 = "normal", lang: n2 = null } = {}) {
            this.buffer = t2, this.cutoff = a2, this.radius = i2, this.lang = n2;
            const l2 = this.size = e2 + 4 * t2, c2 = this._createCanvas(l2), h2 = this.ctx = c2.getContext("2d", { willReadFrequently: true });
            h2.font = `${s2} ${o2} ${e2}px ${r2}`, h2.textBaseline = "alphabetic", h2.textAlign = "left", h2.fillStyle = "black", this.gridOuter = new Float64Array(l2 * l2), this.gridInner = new Float64Array(l2 * l2), this.f = new Float64Array(l2), this.z = new Float64Array(l2 + 1), this.v = new Uint16Array(l2);
          }
          _createCanvas(e2) {
            const t2 = document.createElement("canvas");
            return t2.width = t2.height = e2, t2;
          }
          draw(e2) {
            const { width: t2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: a2, actualBoundingBoxLeft: r2, actualBoundingBoxRight: o2 } = this.ctx.measureText(e2), s2 = Math.ceil(i2), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - r2))), l2 = Math.min(this.size - this.buffer, s2 + Math.ceil(a2)), c2 = n2 + 2 * this.buffer, h2 = l2 + 2 * this.buffer, u2 = Math.max(c2 * h2, 0), d2 = new Uint8ClampedArray(u2), _3 = { data: d2, width: c2, height: h2, glyphWidth: n2, glyphHeight: l2, glyphTop: s2, glyphLeft: 0, glyphAdvance: t2 };
            if (0 === n2 || 0 === l2) return _3;
            const { ctx: p2, buffer: m2, gridInner: f3, gridOuter: g2 } = this;
            this.lang && (p2.lang = this.lang), p2.clearRect(m2, m2, n2, l2), p2.fillText(e2, m2, m2 + s2);
            const v2 = p2.getImageData(m2, m2, n2, l2);
            g2.fill(T2, 0, u2), f3.fill(0, 0, u2);
            for (let e3 = 0; e3 < l2; e3++) for (let t3 = 0; t3 < n2; t3++) {
              const i3 = v2.data[4 * (e3 * n2 + t3) + 3] / 255;
              if (0 === i3) continue;
              const a3 = (e3 + m2) * c2 + t3 + m2;
              if (1 === i3) g2[a3] = 0, f3[a3] = T2;
              else {
                const e4 = 0.5 - i3;
                g2[a3] = e4 > 0 ? e4 * e4 : 0, f3[a3] = e4 < 0 ? e4 * e4 : 0;
              }
            }
            P2(g2, 0, 0, c2, h2, c2, this.f, this.v, this.z), P2(f3, m2, m2, n2, l2, c2, this.f, this.v, this.z);
            for (let e3 = 0; e3 < u2; e3++) {
              const t3 = Math.sqrt(g2[e3]) - Math.sqrt(f3[e3]);
              d2[e3] = Math.round(255 - 255 * (t3 / this.radius + this.cutoff));
            }
            return _3;
          }
        };
        class E {
          constructor() {
            this.specification = t.u.light.position;
          }
          possiblyEvaluate(e2, i2) {
            return t.F(e2.expression.evaluate(i2));
          }
          interpolate(e2, i2, a2) {
            return { x: t.G.number(e2.x, i2.x, a2), y: t.G.number(e2.y, i2.y, a2), z: t.G.number(e2.z, i2.z, a2) };
          }
        }
        let S2;
        class z2 extends t.E {
          constructor(e2) {
            super(), S2 = S2 || new t.t({ anchor: new t.D(t.u.light.anchor), position: new E(), color: new t.D(t.u.light.color), intensity: new t.D(t.u.light.intensity) }), this._transitionable = new t.x(S2, void 0), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e2, i2 = {}) {
            if (!this._validate(t.y, e2, i2)) for (const i3 in e2) {
              const a2 = e2[i3];
              i3.endsWith(t.z) ? this._transitionable.setTransition(i3.slice(0, -t.z.length), a2) : this._transitionable.setValue(i3, a2);
            }
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(e2, i2, a2) {
            return (!a2 || false !== a2.validate) && t.B(this, e2.call(t.C, { value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.u }));
          }
        }
        const R2 = new t.t({ "sky-color": new t.D(t.u.sky["sky-color"]), "horizon-color": new t.D(t.u.sky["horizon-color"]), "fog-color": new t.D(t.u.sky["fog-color"]), "fog-ground-blend": new t.D(t.u.sky["fog-ground-blend"]), "horizon-fog-blend": new t.D(t.u.sky["horizon-fog-blend"]), "sky-horizon-blend": new t.D(t.u.sky["sky-horizon-blend"]), "atmosphere-blend": new t.D(t.u.sky["atmosphere-blend"]) });
        class D2 extends t.E {
          constructor(e2) {
            super(), this._transitionable = new t.x(R2, void 0), this.setSky(e2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.H(0));
          }
          setSky(e2, i2 = {}) {
            if (!this._validate(t.J, e2, i2)) {
              e2 || (e2 = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const i3 in e2) {
                const a2 = e2[i3];
                i3.endsWith(t.z) ? this._transitionable.setTransition(i3.slice(0, -t.z.length), a2) : this._transitionable.setValue(i3, a2);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(e2, i2, a2 = {}) {
            return false !== (null == a2 ? void 0 : a2.validate) && t.B(this, e2.call(t.C, t.e({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.u })));
          }
          calculateFogBlendOpacity(e2) {
            return e2 < 60 ? 0 : e2 < 70 ? (e2 - 60) / 10 : 1;
          }
        }
        class A {
          constructor(e2, t2) {
            this.width = e2, this.height = t2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e2, t2) {
            const i2 = e2.join(",") + String(t2);
            return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(e2, t2)), this.dashEntry[i2];
          }
          getDashRanges(e2, t2, i2) {
            const a2 = [];
            let r2 = e2.length % 2 == 1 ? -e2[e2.length - 1] * i2 : 0, o2 = e2[0] * i2, s2 = true;
            a2.push({ left: r2, right: o2, isDash: s2, zeroLength: 0 === e2[0] });
            let n2 = e2[0];
            for (let t3 = 1; t3 < e2.length; t3++) {
              s2 = !s2;
              const l2 = e2[t3];
              r2 = n2 * i2, n2 += l2, o2 = n2 * i2, a2.push({ left: r2, right: o2, isDash: s2, zeroLength: 0 === l2 });
            }
            return a2;
          }
          addRoundDash(e2, t2, i2) {
            const a2 = t2 / 2;
            for (let t3 = -i2; t3 <= i2; t3++) {
              const r2 = this.width * (this.nextRow + i2 + t3);
              let o2 = 0, s2 = e2[o2];
              for (let n2 = 0; n2 < this.width; n2++) {
                n2 / s2.right > 1 && (s2 = e2[++o2]);
                const l2 = Math.abs(n2 - s2.left), c2 = Math.abs(n2 - s2.right), h2 = Math.min(l2, c2);
                let u2;
                const d2 = t3 / i2 * (a2 + 1);
                if (s2.isDash) {
                  const e3 = a2 - Math.abs(d2);
                  u2 = Math.sqrt(h2 * h2 + e3 * e3);
                } else u2 = a2 - Math.sqrt(h2 * h2 + d2 * d2);
                this.data[r2 + n2] = Math.max(0, Math.min(255, u2 + 128));
              }
            }
          }
          addRegularDash(e2) {
            for (let t3 = e2.length - 1; t3 >= 0; --t3) {
              const i3 = e2[t3], a3 = e2[t3 + 1];
              i3.zeroLength ? e2.splice(t3, 1) : a3 && a3.isDash === i3.isDash && (a3.left = i3.left, e2.splice(t3, 1));
            }
            const t2 = e2[0], i2 = e2[e2.length - 1];
            t2.isDash === i2.isDash && (t2.left = i2.left - this.width, i2.right = t2.right + this.width);
            const a2 = this.width * this.nextRow;
            let r2 = 0, o2 = e2[r2];
            for (let t3 = 0; t3 < this.width; t3++) {
              t3 / o2.right > 1 && (o2 = e2[++r2]);
              const i3 = Math.abs(t3 - o2.left), s2 = Math.abs(t3 - o2.right), n2 = Math.min(i3, s2);
              this.data[a2 + t3] = Math.max(0, Math.min(255, (o2.isDash ? n2 : -n2) + 128));
            }
          }
          addDash(e2, i2) {
            const a2 = i2 ? 7 : 0, r2 = 2 * a2 + 1;
            if (this.nextRow + r2 > this.height) return t.w("LineAtlas out of space"), null;
            let o2 = 0;
            for (let t2 = 0; t2 < e2.length; t2++) o2 += e2[t2];
            if (0 !== o2) {
              const t2 = this.width / o2, r3 = this.getDashRanges(e2, this.width, t2);
              i2 ? this.addRoundDash(r3, t2, a2) : this.addRegularDash(r3);
            }
            const s2 = { y: this.nextRow + a2, height: 2 * a2, width: o2 };
            return this.nextRow += r2, this.dirty = true, s2;
          }
          bind(e2) {
            const t2 = e2.gl;
            this.texture ? (t2.bindTexture(t2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t2.texSubImage2D(t2.TEXTURE_2D, 0, 0, 0, this.width, this.height, t2.ALPHA, t2.UNSIGNED_BYTE, this.data))) : (this.texture = t2.createTexture(), t2.bindTexture(t2.TEXTURE_2D, this.texture), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_S, t2.REPEAT), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_T, t2.REPEAT), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MIN_FILTER, t2.LINEAR), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MAG_FILTER, t2.LINEAR), t2.texImage2D(t2.TEXTURE_2D, 0, t2.ALPHA, this.width, this.height, 0, t2.ALPHA, t2.UNSIGNED_BYTE, this.data));
          }
        }
        const L2 = "maplibre_preloaded_worker_pool";
        class k2 {
          constructor() {
            this.active = {};
          }
          acquire(e2) {
            if (!this.workers) for (this.workers = []; this.workers.length < k2.workerCount; ) this.workers.push(new Worker(t.c.WORKER_URL));
            return this.active[e2] = true, this.workers.slice();
          }
          release(e2) {
            delete this.active[e2], 0 === this.numActive() && (this.workers.forEach(((e3) => {
              e3.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[L2];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const F2 = Math.floor(n.hardwareConcurrency / 2);
        let B2, O2;
        function j2() {
          return B2 || (B2 = new k2()), B2;
        }
        k2.workerCount = t.K(globalThis) ? Math.max(Math.min(F2, 3), 1) : 1;
        class N {
          constructor(e2, i2) {
            this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = i2;
            const a2 = this.workerPool.acquire(i2);
            for (let e3 = 0; e3 < a2.length; e3++) {
              const r2 = new t.L(a2[e3], i2);
              r2.name = `Worker ${e3}`, this.actors.push(r2);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e2, t2) {
            const i2 = [];
            for (const a2 of this.actors) i2.push(a2.sendAsync({ type: e2, data: t2 }));
            return Promise.all(i2);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e2 = true) {
            this.actors.forEach(((e3) => {
              e3.remove();
            })), this.actors = [], e2 && this.workerPool.release(this.id);
          }
          registerMessageHandler(e2, t2) {
            for (const i2 of this.actors) i2.registerMessageHandler(e2, t2);
          }
          unregisterMessageHandler(e2) {
            for (const t2 of this.actors) t2.unregisterMessageHandler(e2);
          }
        }
        function Z2() {
          return O2 || (O2 = new N(j2(), t.M), O2.registerMessageHandler("GR", ((e2, i2, a2) => t.m(i2, a2)))), O2;
        }
        function G2(e2, i2) {
          const a2 = t.N();
          return t.O(a2, a2, [1, 1, 0]), t.Q(a2, a2, [0.5 * e2.width, 0.5 * e2.height, 1]), e2.calculatePosMatrix ? t.S(a2, a2, e2.calculatePosMatrix(i2.toUnwrapped())) : a2;
        }
        function U2(e2, t2, i2, a2, r2, o2, s2) {
          var n2;
          const l2 = (function(e3, t3, i3) {
            if (e3) for (const a3 of e3) {
              const e4 = t3[a3];
              if (e4 && e4.source === i3 && "fill-extrusion" === e4.type) return true;
            }
            else for (const e4 in t3) {
              const a3 = t3[e4];
              if (a3.source === i3 && "fill-extrusion" === a3.type) return true;
            }
            return false;
          })(null !== (n2 = null == r2 ? void 0 : r2.layers) && void 0 !== n2 ? n2 : null, t2, e2.id), c2 = o2.maxPitchScaleFactor(), h2 = e2.tilesIn(a2, c2, l2);
          h2.sort(V2);
          const u2 = [];
          for (const a3 of h2) u2.push({ wrappedTileID: a3.tileID.wrapped().key, queryResults: a3.tile.queryRenderedFeatures(t2, i2, e2.getState(), a3.queryGeometry, a3.cameraQueryGeometry, a3.scale, r2, o2, c2, G2(o2, a3.tileID), s2 ? (e3, t3) => s2(a3.tileID, e3, t3) : void 0) });
          return (function(e3, t3) {
            for (const i3 in e3) for (const a3 of e3[i3]) q2(a3, t3);
            return e3;
          })((function(e3) {
            const t3 = {}, i3 = {};
            for (const a3 of e3) {
              const e4 = a3.queryResults, r3 = a3.wrappedTileID, o3 = i3[r3] = i3[r3] || {};
              for (const i4 in e4) {
                const a4 = e4[i4], r4 = o3[i4] = o3[i4] || {}, s3 = t3[i4] = t3[i4] || [];
                for (const e5 of a4) r4[e5.featureIndex] || (r4[e5.featureIndex] = true, s3.push(e5));
              }
            }
            return t3;
          })(u2), e2);
        }
        function V2(e2, t2) {
          const i2 = e2.tileID, a2 = t2.tileID;
          return i2.overscaledZ - a2.overscaledZ || i2.canonical.y - a2.canonical.y || i2.wrap - a2.wrap || i2.canonical.x - a2.canonical.x;
        }
        function q2(e2, t2) {
          const i2 = e2.feature, a2 = t2.getFeatureState(i2.layer["source-layer"], i2.id);
          i2.source = i2.layer.source, i2.layer["source-layer"] && (i2.sourceLayer = i2.layer["source-layer"]), i2.state = a2;
        }
        function W2(e2, i2, a2) {
          return t._(this, void 0, void 0, (function* () {
            let r2 = e2;
            if (e2.url ? r2 = (yield t.j(i2.transformRequest(e2.url, "Source"), a2)).data : yield n.frameAsync(a2), !r2) return null;
            const o2 = t.U(t.e(r2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in r2 && r2.vector_layers && (o2.vectorLayerIds = r2.vector_layers.map(((e3) => e3.id))), o2;
          }));
        }
        class $2 {
          constructor(e2, t2) {
            e2 && (t2 ? this.setSouthWest(e2).setNorthEast(t2) : Array.isArray(e2) && (4 === e2.length ? this.setSouthWest([e2[0], e2[1]]).setNorthEast([e2[2], e2[3]]) : this.setSouthWest(e2[0]).setNorthEast(e2[1])));
          }
          setNorthEast(e2) {
            return this._ne = e2 instanceof t.V ? new t.V(e2.lng, e2.lat) : t.V.convert(e2), this;
          }
          setSouthWest(e2) {
            return this._sw = e2 instanceof t.V ? new t.V(e2.lng, e2.lat) : t.V.convert(e2), this;
          }
          extend(e2) {
            const i2 = this._sw, a2 = this._ne;
            let r2, o2;
            if (e2 instanceof t.V) r2 = e2, o2 = e2;
            else {
              if (!(e2 instanceof $2)) return Array.isArray(e2) ? 4 === e2.length || e2.every(Array.isArray) ? this.extend($2.convert(e2)) : this.extend(t.V.convert(e2)) : e2 && ("lng" in e2 || "lon" in e2) && "lat" in e2 ? this.extend(t.V.convert(e2)) : this;
              if (r2 = e2._sw, o2 = e2._ne, !r2 || !o2) return this;
            }
            return i2 || a2 ? (i2.lng = Math.min(r2.lng, i2.lng), i2.lat = Math.min(r2.lat, i2.lat), a2.lng = Math.max(o2.lng, a2.lng), a2.lat = Math.max(o2.lat, a2.lat)) : (this._sw = new t.V(r2.lng, r2.lat), this._ne = new t.V(o2.lng, o2.lat)), this;
          }
          getCenter() {
            return new t.V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new t.V(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new t.V(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e2) {
            const { lng: i2, lat: a2 } = t.V.convert(e2);
            let r2 = this._sw.lng <= i2 && i2 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (r2 = this._sw.lng >= i2 && i2 >= this._ne.lng), this._sw.lat <= a2 && a2 <= this._ne.lat && r2;
          }
          intersects(e2) {
            if (!((e2 = $2.convert(e2)).getNorth() >= this.getSouth() && e2.getSouth() <= this.getNorth())) return false;
            const i2 = Math.abs(this.getEast() - this.getWest()), a2 = Math.abs(e2.getEast() - e2.getWest());
            if (i2 >= 360 || a2 >= 360) return true;
            const r2 = t.W(this.getWest(), -180, 180), o2 = t.W(this.getEast(), -180, 180), s2 = t.W(e2.getWest(), -180, 180), n2 = t.W(e2.getEast(), -180, 180), l2 = r2 >= o2, c2 = s2 >= n2;
            return !(!l2 || !c2) || (l2 ? n2 >= r2 || s2 <= o2 : c2 ? o2 >= s2 || r2 <= n2 : s2 <= o2 && n2 >= r2);
          }
          static convert(e2) {
            return e2 instanceof $2 ? e2 : e2 ? new $2(e2) : e2;
          }
          static fromLngLat(e2, i2 = 0) {
            const a2 = 360 * i2 / 40075017, r2 = a2 / Math.cos(Math.PI / 180 * e2.lat);
            return new $2(new t.V(e2.lng - r2, e2.lat - a2), new t.V(e2.lng + r2, e2.lat + a2));
          }
          adjustAntiMeridian() {
            const e2 = new t.V(this._sw.lng, this._sw.lat), i2 = new t.V(this._ne.lng, this._ne.lat);
            return new $2(e2, e2.lng > i2.lng ? new t.V(i2.lng + 360, i2.lat) : i2);
          }
        }
        class H2 {
          constructor(e2, t2, i2) {
            this.bounds = $2.convert(this.validateBounds(e2)), this.minzoom = t2 || 0, this.maxzoom = i2 || 24;
          }
          validateBounds(e2) {
            return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
          }
          contains(e2) {
            const i2 = Math.pow(2, e2.z), a2 = Math.floor(t.Y(this.bounds.getWest()) * i2), r2 = Math.floor(t.X(this.bounds.getNorth()) * i2), o2 = Math.ceil(t.Y(this.bounds.getEast()) * i2), s2 = Math.ceil(t.X(this.bounds.getSouth()) * i2);
            return e2.x >= a2 && e2.x < o2 && e2.y >= r2 && e2.y < s2;
          }
        }
        class X extends t.E {
          constructor(e2, i2, a2, r2) {
            if (super(), this.id = e2, this.dispatcher = a2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.e(this, t.U(i2, ["url", "scheme", "tileSize", "promoteId", "encoding"])), this._options = t.e({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(r2);
          }
          load() {
            return t._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e2 = yield W2(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.tileManagers[this.id].clearTiles(), e2 && (t.e(this, e2), e2.bounds && (this.tileBounds = new H2(e2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e2) {
                this._tileJSONRequest = null, this._loaded = true, t.Z(e2) || this.fire(new t.k(e2));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          setSourceProperty(e2) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e2(), this.load();
          }
          setTiles(e2) {
            return this.setSourceProperty((() => {
              this._options.tiles = e2;
            })), this;
          }
          setUrl(e2) {
            return this.setSourceProperty((() => {
              this.url = e2, this._options.url = e2;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return t.e({}, this._options);
          }
          loadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              const t2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i2 = { request: this.map._requestManager.transformRequest(t2, "Tile"), uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, tileSize: this.tileSize * e2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, encoding: this.encoding, overzoomParameters: this._getOverzoomParameters(e2) };
              i2.request.collectResourceTiming = this._collectResourceTiming;
              let a2 = "RT";
              if (e2.actor && "expired" !== e2.state) {
                if ("loading" === e2.state) return new Promise(((t3, i3) => {
                  e2.reloadPromise = { resolve: t3, reject: i3 };
                }));
              } else e2.actor = this.dispatcher.getActor(), a2 = "LT";
              e2.abortController = new AbortController();
              try {
                const t3 = yield e2.actor.sendAsync({ type: a2, data: i2 }, e2.abortController);
                if (delete e2.abortController, e2.aborted) return;
                this._afterTileLoadWorkerResponse(e2, t3);
              } catch (t3) {
                if (delete e2.abortController, e2.aborted) return;
                if (t3 && 404 !== t3.status) throw t3;
                this._afterTileLoadWorkerResponse(e2, null);
              }
            }));
          }
          _getOverzoomParameters(e2) {
            if (e2.tileID.canonical.z <= this.maxzoom) return;
            if (void 0 === this.map._zoomLevelsToOverscale) return;
            const t2 = e2.tileID.scaledTo(this.maxzoom).canonical, i2 = t2.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            return { maxZoomTileID: t2, overzoomRequest: this.map._requestManager.transformRequest(i2, "Tile") };
          }
          _afterTileLoadWorkerResponse(e2, t2) {
            if (t2 && t2.resourceTiming && (e2.resourceTiming = t2.resourceTiming), t2 && this.map._refreshExpiredTiles && e2.setExpiryData(t2), e2.loadVectorData(t2, this.map.painter), e2.reloadPromise) {
              const t3 = e2.reloadPromise;
              e2.reloadPromise = null, this.loadTile(e2).then(t3.resolve).catch(t3.reject);
            }
          }
          abortTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              e2.abortController && (e2.abortController.abort(), delete e2.abortController), e2.actor && (yield e2.actor.sendAsync({ type: "AT", data: { uid: e2.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              e2.unloadVectorData(), e2.actor && (yield e2.actor.sendAsync({ type: "RMT", data: { uid: e2.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class K2 extends t.E {
          constructor(e2, i2, a2, r2) {
            super(), this.id = e2, this.dispatcher = a2, this.setEventedParent(r2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.e({ type: "raster" }, i2), t.e(this, t.U(i2, ["url", "scheme", "tileSize"]));
          }
          load() {
            return t._(this, arguments, void 0, (function* (e2 = false) {
              this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const i2 = yield W2(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, i2 && (t.e(this, i2), i2.bounds && (this.tileBounds = new H2(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e2 })));
              } catch (e3) {
                this._tileJSONRequest = null, this._loaded = true, t.Z(e3) || this.fire(new t.k(e3));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e2) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e2(), this.load(true);
          }
          setTiles(e2) {
            return this.setSourceProperty((() => {
              this._options.tiles = e2;
            })), this;
          }
          setUrl(e2) {
            return this.setSourceProperty((() => {
              this.url = e2, this._options.url = e2;
            })), this;
          }
          serialize() {
            return t.e({}, this._options);
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          loadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              const i2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e2.abortController = new AbortController();
              try {
                const a2 = yield g.getImage(this.map._requestManager.transformRequest(i2, "Tile"), e2.abortController, this.map._refreshExpiredTiles);
                if (delete e2.abortController, e2.aborted) return void (e2.state = "unloaded");
                if (a2 && a2.data) {
                  this.map._refreshExpiredTiles && (a2.cacheControl || a2.expires) && e2.setExpiryData({ cacheControl: a2.cacheControl, expires: a2.expires });
                  const i3 = this.map.painter.context, r2 = i3.gl, o2 = a2.data;
                  e2.texture = this.map.painter.getTileTexture(o2.width), e2.texture ? e2.texture.update(o2, { useMipmap: true }) : (e2.texture = new t.T(i3, o2, r2.RGBA, { useMipmap: true }), e2.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST)), e2.state = "loaded";
                }
              } catch (t2) {
                if (delete e2.abortController, e2.aborted) e2.state = "unloaded";
                else if (t2) throw e2.state = "errored", t2;
              }
            }));
          }
          abortTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              e2.abortController && (e2.abortController.abort(), delete e2.abortController);
            }));
          }
          unloadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              e2.texture && this.map.painter.saveTileTexture(e2.texture);
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class Y2 extends K2 {
          constructor(e2, i2, a2, r2) {
            super(e2, i2, a2, r2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox", this.redFactor = i2.redFactor, this.greenFactor = i2.greenFactor, this.blueFactor = i2.blueFactor, this.baseShift = i2.baseShift;
          }
          loadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              const i2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = this.map._requestManager.transformRequest(i2, "Tile");
              e2.neighboringTiles = this._getNeighboringTiles(e2.tileID), e2.abortController = new AbortController();
              try {
                const i3 = yield g.getImage(a2, e2.abortController, this.map._refreshExpiredTiles);
                if (delete e2.abortController, e2.aborted) return void (e2.state = "unloaded");
                if (i3 && i3.data) {
                  const a3 = i3.data;
                  this.map._refreshExpiredTiles && (i3.cacheControl || i3.expires) && e2.setExpiryData({ cacheControl: i3.cacheControl, expires: i3.expires });
                  const r2 = t.b(a3) && t.$() ? a3 : yield this.readImageNow(a3), o2 = { type: this.type, uid: e2.uid, source: this.id, rawImageData: r2, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e2.actor || "expired" === e2.state) {
                    e2.actor = this.dispatcher.getActor();
                    const t2 = yield e2.actor.sendAsync({ type: "LDT", data: o2 });
                    e2.dem = t2, e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true, e2.state = "loaded";
                  }
                }
              } catch (t2) {
                if (delete e2.abortController, e2.aborted) e2.state = "unloaded";
                else if (t2) throw e2.state = "errored", t2;
              }
            }));
          }
          readImageNow(e2) {
            return t._(this, void 0, void 0, (function* () {
              if ("undefined" != typeof VideoFrame && t.a0()) {
                const i2 = e2.width + 2, a2 = e2.height + 2;
                try {
                  return new t.R({ width: i2, height: a2 }, yield t.a1(e2, -1, -1, i2, a2));
                } catch (e3) {
                }
              }
              return n.getImageData(e2, 1);
            }));
          }
          _getNeighboringTiles(e2) {
            const i2 = e2.canonical, a2 = Math.pow(2, i2.z), r2 = (i2.x - 1 + a2) % a2, o2 = 0 === i2.x ? e2.wrap - 1 : e2.wrap, s2 = (i2.x + 1 + a2) % a2, n2 = i2.x + 1 === a2 ? e2.wrap + 1 : e2.wrap, l2 = {};
            return l2[new t.a2(e2.overscaledZ, o2, i2.z, r2, i2.y).key] = { backfilled: false }, l2[new t.a2(e2.overscaledZ, n2, i2.z, s2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new t.a2(e2.overscaledZ, o2, i2.z, r2, i2.y - 1).key] = { backfilled: false }, l2[new t.a2(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new t.a2(e2.overscaledZ, n2, i2.z, s2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < a2 && (l2[new t.a2(e2.overscaledZ, o2, i2.z, r2, i2.y + 1).key] = { backfilled: false }, l2[new t.a2(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new t.a2(e2.overscaledZ, n2, i2.z, s2, i2.y + 1).key] = { backfilled: false }), l2;
          }
          unloadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded", e2.actor && (yield e2.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e2.uid, source: this.id } }));
            }));
          }
        }
        function Q2(e2) {
          return "GeometryCollection" === e2.type ? e2.geometries.map(((e3) => e3.coordinates)).flat(1 / 0) : e2.coordinates.flat(1 / 0);
        }
        function J2(e2) {
          const t2 = new $2();
          let i2;
          switch (e2.type) {
            case "FeatureCollection":
              i2 = e2.features.map(((e3) => Q2(e3.geometry))).flat(1 / 0);
              break;
            case "Feature":
              i2 = Q2(e2.geometry);
              break;
            default:
              i2 = Q2(e2);
          }
          if (0 == i2.length) return t2;
          for (let e3 = 0; e3 < i2.length - 1; e3 += 2) t2.extend([i2[e3], i2[e3 + 1]]);
          return t2;
        }
        class ee2 extends t.E {
          constructor(e2, i2, a2, r2) {
            super(), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: i2.data }, this.actor = a2.getActor(), this.setEventedParent(r2), this._data = "string" == typeof i2.data ? { url: i2.data } : { geojson: i2.data }, this._options = t.e({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId, void 0 !== i2.clusterMaxZoom && this.maxzoom <= i2.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i2.clusterMaxZoom}".`), this.workerOptions = t.e({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(void 0 !== i2.buffer ? i2.buffer : 128), tolerance: this._pixelsToTileUnits(void 0 !== i2.tolerance ? i2.tolerance : 0.375), extent: t.a5, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(i2.clusterMaxZoom), minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.a5, radius: this._pixelsToTileUnits(i2.clusterRadius || 50), log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
          }
          _hasPendingWorkerUpdate() {
            return void 0 !== this._pendingWorkerUpdate.data || void 0 !== this._pendingWorkerUpdate.diff || this._pendingWorkerUpdate.optionsChanged;
          }
          _pixelsToTileUnits(e2) {
            return e2 * (t.a5 / this.tileSize);
          }
          _getClusterMaxZoom(e2) {
            const i2 = e2 ? Math.round(e2) : this.maxzoom - 1;
            return Number.isInteger(e2) || void 0 === e2 || t.w(`Integer expected for option 'clusterMaxZoom': provided value "${e2}" rounded to "${i2}"`), i2;
          }
          load() {
            return t._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          setData(e2, t2) {
            this._data = "string" == typeof e2 ? { url: e2 } : { geojson: e2 }, this._pendingWorkerUpdate = { data: e2 };
            const i2 = this._updateWorkerData();
            return t2 ? i2 : this;
          }
          updateData(e2, i2) {
            this._pendingWorkerUpdate.diff = t.a6(this._pendingWorkerUpdate.diff, e2);
            const a2 = this._updateWorkerData();
            return i2 ? a2 : this;
          }
          getData() {
            return t._(this, void 0, void 0, (function* () {
              const e2 = t.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e2 });
            }));
          }
          getBounds() {
            return t._(this, void 0, void 0, (function* () {
              return J2(yield this.getData());
            }));
          }
          setClusterOptions(e2) {
            return this.workerOptions.cluster = e2.cluster, void 0 !== e2.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e2.clusterRadius)), void 0 !== e2.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e2.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = true, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e2) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e2, source: this.id } });
          }
          getClusterChildren(e2) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e2, source: this.id } });
          }
          getClusterLeaves(e2, t2, i2) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e2, limit: t2, offset: i2 } });
          }
          _updateWorkerData() {
            return t._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void t.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const { data: e2, diff: i2 } = this._pendingWorkerUpdate, a2 = t.e({ type: this.type }, this.workerOptions);
              void 0 !== e2 ? ("string" == typeof e2 ? (a2.request = this.map._requestManager.transformRequest(n.resolveURL(e2), "Source"), a2.request.collectResourceTiming = this._collectResourceTiming) : a2.data = e2, this._pendingWorkerUpdate.data = void 0) : i2 && (a2.dataDiff = i2, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = true, this.fire(new t.l("dataloading", { dataType: "source" }));
              try {
                const e3 = yield this.actor.sendAsync({ type: "LD", data: a2 });
                if (this._isUpdatingWorker = false, this._removed || e3.abandoned) return void this.fire(new t.l("dataabort", { dataType: "source" }));
                e3.data && (this._data = { geojson: e3.data });
                const r2 = this._applyDiffToSource(i2), o2 = this._getShouldReloadTileOptions(r2);
                let s2 = null;
                e3.resourceTiming && e3.resourceTiming[this.id] && (s2 = e3.resourceTiming[this.id].slice(0));
                const n2 = { dataType: "source" };
                this._collectResourceTiming && s2 && s2.length > 0 && t.e(n2, { resourceTiming: s2 }), this.fire(new t.l("data", Object.assign(Object.assign({}, n2), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, n2), { sourceDataType: "content", shouldReloadTileOptions: o2 })));
              } catch (e3) {
                if (this._isUpdatingWorker = false, this._removed) return void this.fire(new t.l("dataabort", { dataType: "source" }));
                this.fire(new t.k(e3));
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData();
              }
            }));
          }
          _applyDiffToSource(e2) {
            if (!e2) return;
            const i2 = "string" == typeof this.promoteId ? this.promoteId : void 0;
            if (!this._data.url && !this._data.updateable) {
              const e3 = t.a7(this._data.geojson, i2);
              if (!e3) throw new Error(`GeoJSONSource "${this.id}": GeoJSON data is not compatible with updateData`);
              this._data = { updateable: e3 };
            }
            if (!this._data.updateable) return;
            const a2 = t.a8(this._data.updateable, e2, i2);
            return e2.removeAll || this._options.cluster ? void 0 : a2;
          }
          _getShouldReloadTileOptions(e2) {
            if (e2) return { affectedBounds: e2.filter(Boolean).map(((e3) => J2(e3))) };
          }
          shouldReloadTile(e2, { affectedBounds: i2 }) {
            if ("loading" === e2.state) return true;
            if ("unloaded" === e2.state) return false;
            const { buffer: a2, extent: r2 } = this.workerOptions.geojsonVtOptions, o2 = (function({ x: e3, y: i3, z: a3 }, r3 = 0) {
              const o3 = t.a3((e3 - r3) / Math.pow(2, a3)), s2 = t.a4((i3 + 1 + r3) / Math.pow(2, a3)), n2 = t.a3((e3 + 1 + r3) / Math.pow(2, a3)), l2 = t.a4((i3 - r3) / Math.pow(2, a3));
              return new $2([o3, s2], [n2, l2]);
            })(e2.tileID.canonical, a2 / r2);
            for (const e3 of i2) if (o2.intersects(e3)) return true;
            return false;
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
          }
          loadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              const t2 = e2.actor ? "RT" : "LT";
              e2.actor = this.actor;
              const i2 = { type: this.type, uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              e2.abortController = new AbortController();
              const a2 = yield this.actor.sendAsync({ type: t2, data: i2 }, e2.abortController);
              delete e2.abortController, e2.unloadVectorData(), e2.aborted || e2.loadVectorData(a2, this.map.painter, "RT" === t2);
            }));
          }
          abortTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              e2.abortController && (e2.abortController.abort(), delete e2.abortController), e2.aborted = true;
            }));
          }
          unloadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              e2.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e2.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return t.e({}, this._options, { type: this.type, data: this._data.updateable ? { type: "FeatureCollection", features: Array.from(this._data.updateable.values()) } : this._data.url || this._data.geojson });
          }
          hasTransition() {
            return false;
          }
        }
        class te2 extends t.E {
          constructor(e2, t2, i2, a2) {
            super(), this.flippedWindingOrder = false, this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a2), this.options = t2;
          }
          load(e2) {
            return t._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const t2 = yield g.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, t2 && t2.data && (this.image = t2.data, e2 && (this.coordinates = e2), this._finishLoading());
              } catch (e3) {
                this._request = null, this._loaded = true, t.Z(e3) || this.fire(new t.k(e3));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e2) {
            return e2.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e2.url, this.load(e2.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e2) {
            this.coordinates = e2;
            const i2 = e2.map(t.a9.fromLngLat);
            var a2;
            return this.tileID = (function(e3) {
              const i3 = t.aa.fromPoints(e3), a3 = i3.width(), r2 = i3.height(), o2 = Math.max(a3, r2), s2 = Math.max(0, Math.floor(-Math.log(o2) / Math.LN2)), n2 = Math.pow(2, s2);
              return new t.ac(s2, Math.floor((i3.minX + i3.maxX) / 2 * n2), Math.floor((i3.minY + i3.maxY) / 2 * n2));
            })(i2), this.terrainTileRanges = this._getOverlappingTileRanges(i2), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i2.map(((e3) => this.tileID.getTilePoint(e3)._round())), this.flippedWindingOrder = ((a2 = this.tileCoords)[1].x - a2[0].x) * (a2[2].y - a2[0].y) - (a2[1].y - a2[0].y) * (a2[2].x - a2[0].x) < 0, this.fire(new t.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image) return;
            const e2 = this.map.painter.context, i2 = e2.gl;
            this.texture || (this.texture = new t.T(e2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            let a2 = false;
            for (const e3 in this.tiles) {
              const t2 = this.tiles[e3];
              "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, a2 = true);
            }
            a2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e2) {
            return t._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}) : e2.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          _getOverlappingTileRanges(e2) {
            const { minX: i2, minY: a2, maxX: r2, maxY: o2 } = t.aa.fromPoints(e2), s2 = {};
            for (let e3 = 0; e3 <= t.ab; e3++) {
              const t2 = Math.pow(2, e3), n2 = Math.floor(i2 * t2), l2 = Math.floor(a2 * t2), c2 = Math.floor(r2 * t2), h2 = Math.floor(o2 * t2), u2 = (n2 % t2 + t2) % t2, d2 = c2 % t2, _3 = Math.floor(n2 / t2), p2 = Math.floor(c2 / t2);
              s2[e3] = { minWrap: _3, maxWrap: p2, minTileXWrapped: u2, maxTileXWrapped: d2, minTileY: l2, maxTileY: h2 };
            }
            return s2;
          }
        }
        class ie2 extends te2 {
          constructor(e2, t2, i2, a2) {
            super(e2, t2, i2, a2), this.roundZoom = true, this.type = "video", this.options = t2;
          }
          load() {
            return t._(this, void 0, void 0, (function* () {
              this._loaded = false;
              const e2 = this.options;
              this.urls = [];
              for (const t2 of e2.urls) this.urls.push(this.map._requestManager.transformRequest(t2, "Source").url);
              try {
                const e3 = yield t.ad(this.urls);
                if (this._loaded = true, !e3) return;
                this.video = e3, this.video.loop = true, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (e3) {
                this.fire(new t.k(e3));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e2) {
            if (this.video) {
              const i2 = this.video.seekable;
              e2 < i2.start(0) || e2 > i2.end(0) ? this.fire(new t.k(new t.ae(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e2) {
            this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const e2 = this.map.painter.context, i2 = e2.gl;
            this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new t.T(e2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            let a2 = false;
            for (const e3 in this.tiles) {
              const t2 = this.tiles[e3];
              "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, a2 = true);
            }
            a2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class ae2 extends te2 {
          constructor(e2, i2, a2, r2) {
            super(e2, i2, a2, r2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some(((e3) => !Array.isArray(e3) || 2 !== e3.length || e3.some(((e4) => "number" != typeof e4)))) || this.fire(new t.k(new t.ae(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.k(new t.ae(`sources.${e2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new t.k(new t.ae(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.ae(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.k(new t.ae(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
          }
          load() {
            return t._(this, void 0, void 0, (function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e2) {
            this.map = e2, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e2 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e2 = true), this._hasInvalidDimensions()) return;
            if (0 === Object.keys(this.tiles).length) return;
            const i2 = this.map.painter.context, a2 = i2.gl;
            this.texture ? (e2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : (this.texture = new t.T(i2, this.canvas, a2.RGBA, { premultiply: true }), this.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE));
            let r2 = false;
            for (const e3 in this.tiles) {
              const t2 = this.tiles[e3];
              "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, r2 = true);
            }
            r2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", animate: this.animate, canvas: this.options.canvas, coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e2 of [this.canvas.width, this.canvas.height]) if (isNaN(e2) || e2 <= 0) return true;
            return false;
          }
        }
        const re2 = {}, oe2 = (e2) => {
          switch (e2) {
            case "geojson":
              return ee2;
            case "image":
              return te2;
            case "raster":
              return K2;
            case "raster-dem":
              return Y2;
            case "vector":
              return X;
            case "video":
              return ie2;
            case "canvas":
              return ae2;
          }
          return re2[e2];
        }, se2 = "RTLPluginLoaded";
        class ne2 extends t.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Z2();
          }
          _syncState(e2) {
            return this.status = e2, this.dispatcher.broadcast("SRPS", { pluginStatus: e2, pluginURL: this.url }).catch(((e3) => {
              throw this.status = "error", e3;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e2) {
            return t._(this, arguments, void 0, (function* (e3, t2 = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = n.resolveURL(e3), !this.url) throw new Error(`requested url ${e3} is invalid`);
              if ("unavailable" === this.status) {
                if (!t2) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if ("requested" === this.status) return this._requestImport();
            }));
          }
          _requestImport() {
            return t._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(se2));
            }));
          }
          lazyLoad() {
            "unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
          }
        }
        let le = null;
        function ce2() {
          return le || (le = new ne2()), le;
        }
        var he2, ue2;
        !(function(e2) {
          e2[e2.Base = 0] = "Base", e2[e2.Parent = 1] = "Parent";
        })(he2 || (he2 = {})), (function(e2) {
          e2[e2.Departing = 0] = "Departing", e2[e2.Incoming = 1] = "Incoming";
        })(ue2 || (ue2 = {}));
        class de2 {
          constructor(e2, i2) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e2, this.uid = t.af(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          isRenderable(e2) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e2 || !this.holdingForSymbolFade());
          }
          setCrossFadeLogic({ fadingRole: e2, fadingDirection: t2, fadingParentID: i2, fadeEndTime: a2 }) {
            this.resetFadeLogic(), this.fadingRole = e2, this.fadingDirection = t2, this.fadingParentID = i2, this.fadeEndTime = a2;
          }
          setSelfFadeLogic(e2) {
            this.resetFadeLogic(), this.selfFading = true, this.fadeEndTime = e2;
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = false, this.timeAdded = c(), this.fadeEndTime = 0, this.fadeOpacity = 1;
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          clearTextures(e2) {
            this.demTexture && e2.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e2, i2, a2) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
              e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData, this.latestFeatureIndex.encoding = e2.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = (function(e3, t2) {
                const i3 = {};
                if (!t2) return i3;
                for (const a3 of e3) {
                  const e4 = a3.layerIds.map(((e5) => t2.getLayer(e5))).filter(Boolean);
                  if (0 !== e4.length) {
                    a3.layers = e4, a3.stateDependentLayerIds && (a3.stateDependentLayers = a3.stateDependentLayerIds.map(((t3) => e4.filter(((e5) => e5.id === t3))[0])));
                    for (const t3 of e4) i3[t3.id] = a3;
                  }
                }
                return i3;
              })(e2.buckets, null == i2 ? void 0 : i2.style), this.hasSymbolBuckets = false;
              for (const e3 in this.buckets) {
                const i3 = this.buckets[e3];
                if (i3 instanceof t.ah) {
                  if (this.hasSymbolBuckets = true, !a2) break;
                  i3.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const e3 in this.buckets) {
                const i3 = this.buckets[e3];
                if (i3 instanceof t.ah && i3.hasRTLText) {
                  this.hasRTLText = true, ce2().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const e3 in this.buckets) {
                const t2 = this.buckets[e3];
                this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(e3).queryRadius(t2));
              }
              e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage), this.dashPositions = e2.dashPositions;
            } else this.collisionBoxArray = new t.ag();
          }
          unloadVectorData() {
            for (const e2 in this.buckets) this.buckets[e2].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e2) {
            return this.buckets[e2.id];
          }
          upload(e2) {
            for (const t2 in this.buckets) {
              const i3 = this.buckets[t2];
              i3.uploadPending() && i3.upload(e2);
            }
            const i2 = e2.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new t.T(e2, this.imageAtlas.image, i2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new t.T(e2, this.glyphAtlasImage, i2.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e2) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e2, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: a2, cameraQueryGeometry: r2, scale: o2, tileSize: this.tileSize, pixelPosMatrix: c2, transform: n2, params: s2, queryPadding: this.queryPadding * l2, getElevation: h2 }, e2, t2, i2) : {};
          }
          querySourceFeatures(e2, i2) {
            const a2 = this.latestFeatureIndex;
            if (!a2 || !a2.rawTileData) return;
            const r2 = a2.loadVTLayers(), o2 = i2 && i2.sourceLayer ? i2.sourceLayer : "", s2 = r2[t.ai] || r2[o2];
            if (!s2) return;
            const n2 = t.aj(null == i2 ? void 0 : i2.filter, null == i2 ? void 0 : i2.globalState), { z: l2, x: c2, y: h2 } = this.tileID.canonical, u2 = { z: l2, x: c2, y: h2 };
            for (let i3 = 0; i3 < s2.length; i3++) {
              const r3 = s2.feature(i3);
              if (n2.needGeometry) {
                const e3 = t.ak(r3, true);
                if (!n2.filter(new t.H(this.tileID.overscaledZ), e3, this.tileID.canonical)) continue;
              } else if (!n2.filter(new t.H(this.tileID.overscaledZ), r3)) continue;
              const d2 = a2.getId(r3, o2), _3 = new t.al(r3, l2, c2, h2, d2);
              _3.tile = u2, e2.push(_3);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e2) {
            const i2 = this.expirationTime;
            if (e2.cacheControl) {
              const i3 = t.am(e2.cacheControl);
              i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
            } else e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
            if (this.expirationTime) {
              const e3 = Date.now();
              let t2 = false;
              if (this.expirationTime > e3) t2 = false;
              else if (i2) if (this.expirationTime < i2) t2 = true;
              else {
                const a2 = this.expirationTime - i2;
                a2 ? this.expirationTime = e3 + Math.max(a2, 3e4) : t2 = true;
              }
              else t2 = true;
              t2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e2, i2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e2).length) return;
            const a2 = this.latestFeatureIndex.loadVTLayers();
            for (const r2 in this.buckets) {
              if (!i2.style.hasLayer(r2)) continue;
              const o2 = this.buckets[r2], s2 = o2.layers[0].sourceLayer || t.ai, n2 = a2[s2], l2 = e2[s2];
              if (!n2 || !l2 || 0 === Object.keys(l2).length) continue;
              o2.update(l2, n2, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const c2 = i2 && i2.style && i2.style.getLayer(r2);
              c2 && (this.queryPadding = Math.max(this.queryPadding, c2.queryRadius(o2)));
            }
          }
          holdingForSymbolFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < c();
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setSymbolHoldDuration(e2) {
            this.symbolFadeHoldUntil = c() + e2;
          }
          setDependencies(e2, t2) {
            const i2 = {};
            for (const e3 of t2) i2[e3] = true;
            this.dependencies[e2] = i2;
          }
          hasDependency(e2, t2) {
            for (const i2 of e2) {
              const e3 = this.dependencies[i2];
              if (e3) {
                for (const i3 of t2) if (e3[i3]) return true;
              }
            }
            return false;
          }
        }
        class _e2 {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e2, i2, a2) {
            const r2 = String(i2);
            if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][r2] = this.stateChanges[e2][r2] || {}, t.e(this.stateChanges[e2][r2], a2), null === this.deletedStates[e2]) {
              this.deletedStates[e2] = {};
              for (const t2 in this.state[e2]) t2 !== r2 && (this.deletedStates[e2][t2] = null);
            } else if (this.deletedStates[e2] && null === this.deletedStates[e2][r2]) {
              this.deletedStates[e2][r2] = {};
              for (const t2 in this.state[e2][r2]) a2[t2] || (this.deletedStates[e2][r2][t2] = null);
            } else for (const t2 in a2) this.deletedStates[e2] && this.deletedStates[e2][r2] && null === this.deletedStates[e2][r2][t2] && delete this.deletedStates[e2][r2][t2];
          }
          removeFeatureState(e2, t2, i2) {
            if (null === this.deletedStates[e2]) return;
            const a2 = String(t2);
            if (this.deletedStates[e2] = this.deletedStates[e2] || {}, i2 && void 0 !== t2) null !== this.deletedStates[e2][a2] && (this.deletedStates[e2][a2] = this.deletedStates[e2][a2] || {}, this.deletedStates[e2][a2][i2] = null);
            else if (void 0 !== t2) if (this.stateChanges[e2] && this.stateChanges[e2][a2]) for (i2 in this.deletedStates[e2][a2] = {}, this.stateChanges[e2][a2]) this.deletedStates[e2][a2][i2] = null;
            else this.deletedStates[e2][a2] = null;
            else this.deletedStates[e2] = null;
          }
          getState(e2, i2) {
            const a2 = String(i2), r2 = t.e({}, (this.state[e2] || {})[a2], (this.stateChanges[e2] || {})[a2]);
            if (null === this.deletedStates[e2]) return {};
            if (this.deletedStates[e2]) {
              const t2 = this.deletedStates[e2][i2];
              if (null === t2) return {};
              for (const e3 in t2) delete r2[e3];
            }
            return r2;
          }
          initializeTileState(e2, t2) {
            e2.setFeatureState(this.state, t2);
          }
          coalesceChanges(e2, i2) {
            const a2 = {};
            for (const e3 in this.stateChanges) {
              this.state[e3] = this.state[e3] || {};
              const i3 = {};
              for (const a3 in this.stateChanges[e3]) this.state[e3][a3] || (this.state[e3][a3] = {}), t.e(this.state[e3][a3], this.stateChanges[e3][a3]), i3[a3] = this.state[e3][a3];
              a2[e3] = i3;
            }
            for (const e3 in this.deletedStates) {
              this.state[e3] = this.state[e3] || {};
              const i3 = {};
              if (null === this.deletedStates[e3]) for (const t2 in this.state[e3]) i3[t2] = {}, this.state[e3][t2] = {};
              else for (const t2 in this.deletedStates[e3]) {
                if (null === this.deletedStates[e3][t2]) this.state[e3][t2] = {};
                else for (const i4 of Object.keys(this.deletedStates[e3][t2])) delete this.state[e3][t2][i4];
                i3[t2] = this.state[e3][t2];
              }
              a2[e3] = a2[e3] || {}, t.e(a2[e3], i3);
            }
            this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(a2).length && e2.setFeatureState(a2, i2);
          }
        }
        const pe2 = 89.25;
        function me2(e2, i2) {
          const a2 = t.an(i2.lat, -t.ao, t.ao);
          return new t.P(t.Y(i2.lng) * e2, t.X(a2) * e2);
        }
        function fe2(e2, i2) {
          return new t.a9(i2.x / e2, i2.y / e2).toLngLat();
        }
        function ge2(e2) {
          return e2.cameraToCenterDistance * Math.min(0.85 * Math.tan(t.ap(90 - e2.pitch)), Math.tan(t.ap(pe2 - e2.pitch)));
        }
        function ve2(e2, i2) {
          const a2 = e2.canonical, r2 = i2 / t.aq(a2.z), o2 = a2.x + Math.pow(2, a2.z) * e2.wrap, s2 = t.ar(new Float64Array(16));
          return t.O(s2, s2, [o2 * r2, a2.y * r2, 0]), t.Q(s2, s2, [r2 / t.a5, r2 / t.a5, 1]), s2;
        }
        function xe2(e2, i2, a2, r2, o2) {
          const s2 = t.a9.fromLngLat(e2, i2), n2 = o2 * t.as(1, e2.lat), { x: l2, y: c2, z: h2 } = be2(a2, r2);
          return new t.a9(s2.x + n2 * -l2, s2.y + n2 * -c2, s2.z + n2 * -h2);
        }
        function be2(e2, i2) {
          const a2 = t.ap(e2), r2 = t.ap(i2), o2 = Math.cos(-a2), s2 = Math.sin(a2);
          return { x: s2 * Math.sin(r2), y: -s2 * Math.cos(r2), z: o2 };
        }
        function ye2(e2, t2, i2) {
          const a2 = t2.intersectsFrustum(e2);
          if (!i2 || 0 === a2) return a2;
          const r2 = t2.intersectsPlane(i2);
          return 0 === r2 ? 0 : 2 === a2 && 2 === r2 ? 2 : 1;
        }
        function we2(e2, t2, i2) {
          let a2 = 0;
          const r2 = (i2 - t2) / 10;
          for (let o2 = 0; o2 < 10; o2++) a2 += r2 * Math.pow(Math.cos(t2 + (o2 + 0.5) / 10 * (i2 - t2)), e2);
          return a2;
        }
        function Te2(e2, i2) {
          return function(a2, r2, o2, s2, n2) {
            const l2 = 2 * ((e2 - 1) / t.at(Math.cos(t.ap(pe2 - n2)) / Math.cos(t.ap(pe2))) - 1), c2 = Math.acos(o2 / s2), h2 = 2 * we2(l2 - 1, 0, t.ap(n2 / 2)), u2 = Math.min(t.ap(pe2), c2 + t.ap(n2 / 2)), d2 = we2(l2 - 1, Math.min(u2, c2 - t.ap(n2 / 2)), u2), _3 = Math.atan(r2 / o2), p2 = Math.hypot(r2, o2);
            let m2 = a2;
            return m2 += t.at(s2 / p2 / Math.max(0.5, Math.cos(t.ap(n2 / 2)))), m2 += l2 * t.at(Math.cos(_3)) / 2, m2 -= t.at(Math.max(1, d2 / h2 / i2)) / 2, m2;
          };
        }
        const Pe2 = Te2(9.314, 3);
        function Ce2(e2, i2) {
          const a2 = (i2.roundZoom ? Math.round : Math.floor)(e2.zoom + t.at(e2.tileSize / i2.tileSize));
          return Math.max(0, a2);
        }
        function Ie2(e2, i2) {
          const a2 = e2.getCameraFrustum(), r2 = e2.getClippingPlane(), o2 = e2.screenPointToMercatorCoordinate(e2.getCameraPoint()), s2 = t.a9.fromLngLat(e2.center, e2.elevation);
          o2.z = s2.z + Math.cos(e2.pitchInRadians) * e2.cameraToCenterDistance / e2.worldSize;
          const n2 = e2.getCoveringTilesDetailsProvider(), l2 = n2.allowVariableZoom(e2, i2), c2 = Ce2(e2, i2), h2 = i2.minzoom || 0, u2 = void 0 !== i2.maxzoom ? i2.maxzoom : e2.maxZoom, d2 = Math.min(Math.max(0, c2), u2), _3 = Math.pow(2, d2), p2 = [_3 * o2.x, _3 * o2.y, 0], m2 = [_3 * s2.x, _3 * s2.y, 0], f3 = Math.hypot(s2.x - o2.x, s2.y - o2.y), g2 = Math.abs(s2.z - o2.z), v2 = Math.hypot(f3, g2), x2 = (e3) => ({ zoom: 0, x: 0, y: 0, wrap: e3, fullyVisible: false }), b2 = [], y3 = [];
          if (e2.renderWorldCopies && n2.allowWorldCopies()) for (let e3 = 1; e3 <= 3; e3++) b2.push(x2(-e3)), b2.push(x2(e3));
          for (b2.push(x2(0)); b2.length > 0; ) {
            const _4 = b2.pop(), f4 = _4.x, x3 = _4.y;
            let w3 = _4.fullyVisible;
            const T3 = { x: f4, y: x3, z: _4.zoom }, P3 = n2.getTileBoundingVolume(T3, _4.wrap, e2.elevation, i2);
            if (!w3) {
              const e3 = ye2(a2, P3, r2);
              if (0 === e3) continue;
              w3 = 2 === e3;
            }
            const C2 = n2.distanceToTile2d(o2.x, o2.y, T3, P3);
            let I3 = c2;
            l2 && (I3 = (i2.calculateTileZoom || Pe2)(e2.zoom + t.at(e2.tileSize / i2.tileSize), C2, g2, v2, e2.fov)), I3 = (i2.roundZoom ? Math.round : Math.floor)(I3), I3 = Math.max(0, I3);
            const M3 = Math.min(I3, u2);
            if (_4.wrap = n2.getWrap(s2, T3, _4.wrap), _4.zoom >= M3) {
              if (_4.zoom < h2) continue;
              const e3 = d2 - _4.zoom, a3 = p2[0] - 0.5 - (f4 << e3), r3 = p2[1] - 0.5 - (x3 << e3), o3 = i2.reparseOverscaled ? Math.max(_4.zoom, I3) : _4.zoom;
              y3.push({ tileID: new t.a2(_4.zoom === u2 ? o3 : _4.zoom, _4.wrap, _4.zoom, f4, x3), distanceSq: t.au([m2[0] - 0.5 - f4, m2[1] - 0.5 - x3]), tileDistanceToCamera: Math.sqrt(a3 * a3 + r3 * r3) });
            } else for (let e3 = 0; e3 < 4; e3++) b2.push({ zoom: _4.zoom + 1, x: (f4 << 1) + e3 % 2, y: (x3 << 1) + (e3 >> 1), wrap: _4.wrap, fullyVisible: w3 });
          }
          return y3.sort(((e3, t2) => e3.distanceSq - t2.distanceSq)).map(((e3) => e3.tileID));
        }
        const Me2 = t.aa.fromPoints([new t.P(0, 0), new t.P(t.a5, t.a5)]);
        function Ee2(e2) {
          return "raster" === e2 || "image" === e2 || "video" === e2;
        }
        function Se2(e2, t2, i2, a2, r2, o2, s2) {
          if (!t2.hasData()) return false;
          const { tileID: n2, fadingRole: l2, fadingDirection: c2, fadingParentID: h2 } = t2;
          if (l2 === he2.Base && c2 === ue2.Incoming && h2) return i2[h2.key] = h2, true;
          const u2 = Math.max(n2.overscaledZ - r2, o2);
          for (let r3 = n2.overscaledZ - 1; r3 >= u2; r3--) {
            const o3 = n2.scaledTo(r3), l3 = e2.getLoadedTile(o3);
            if (l3) return t2.setCrossFadeLogic({ fadingRole: he2.Base, fadingDirection: ue2.Incoming, fadingParentID: l3.tileID, fadeEndTime: a2 + s2 }), l3.setCrossFadeLogic({ fadingRole: he2.Parent, fadingDirection: ue2.Departing, fadeEndTime: a2 + s2 }), i2[o3.key] = o3, true;
          }
          return false;
        }
        function ze2(e2, t2, i2, a2, r2, o2) {
          if (!t2.hasData()) return false;
          const s2 = t2.tileID.children(r2);
          let n2 = Re2(e2, t2, s2, i2, a2, r2, o2);
          if (n2) return true;
          for (const l2 of s2) Re2(e2, t2, l2.children(r2), i2, a2, r2, o2) && (n2 = true);
          return n2;
        }
        function Re2(e2, t2, i2, a2, r2, o2, s2) {
          if (i2[0].overscaledZ >= o2) return false;
          let n2 = false;
          for (const o3 of i2) {
            const i3 = e2.getLoadedTile(o3);
            if (!i3) continue;
            const { fadingRole: l2, fadingDirection: c2, fadingParentID: h2 } = i3;
            l2 === he2.Base && c2 === ue2.Departing && h2 || (i3.setCrossFadeLogic({ fadingRole: he2.Base, fadingDirection: ue2.Departing, fadingParentID: t2.tileID, fadeEndTime: r2 + s2 }), t2.setCrossFadeLogic({ fadingRole: he2.Parent, fadingDirection: ue2.Incoming, fadeEndTime: r2 + s2 })), a2[o3.key] = o3, n2 = true;
          }
          return n2;
        }
        function De2(e2, t2, i2, a2) {
          const r2 = e2.tileID;
          return !!e2.selfFading || !e2.hasData() && !!t2.has(r2) && (e2.setSelfFadeLogic(i2 + a2), true);
        }
        function Ae2(e2, t2) {
          var i2;
          e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true;
          let a2 = t2.tileID.canonical.x - e2.tileID.canonical.x;
          const r2 = t2.tileID.canonical.y - e2.tileID.canonical.y, o2 = Math.pow(2, e2.tileID.canonical.z), s2 = t2.tileID.key;
          0 === a2 && 0 === r2 || Math.abs(r2) > 1 || (Math.abs(a2) > 1 && (1 === Math.abs(a2 + o2) ? a2 += o2 : 1 === Math.abs(a2 - o2) && (a2 -= o2)), t2.dem && e2.dem && (e2.dem.backfillBorder(t2.dem, a2, r2), (null === (i2 = e2.neighboringTiles) || void 0 === i2 ? void 0 : i2[s2]) && (e2.neighboringTiles[s2].backfilled = true)));
        }
        class Le2 {
          constructor() {
            this._tiles = {};
          }
          handleWrapJump(e2) {
            const t2 = {};
            for (const i2 in this._tiles) {
              const a2 = this._tiles[i2];
              a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e2), t2[a2.tileID.key] = a2;
            }
            this._tiles = t2;
          }
          setFeatureState(e2, t2) {
            for (const i2 in this._tiles) this._tiles[i2].setFeatureState(e2, t2);
          }
          getAllTiles() {
            return Object.values(this._tiles);
          }
          getAllIds(e2 = false) {
            return e2 ? Object.values(this._tiles).map(((e3) => e3.tileID)).sort(t.aw).map(((e3) => e3.key)) : Object.keys(this._tiles);
          }
          getTileById(e2) {
            return this._tiles[e2];
          }
          setTile(e2, t2) {
            this._tiles[e2] = t2;
          }
          deleteTileById(e2) {
            delete this._tiles[e2];
          }
          getLoadedTile(e2) {
            const t2 = this.getTileById(e2.key);
            return (null == t2 ? void 0 : t2.hasData()) ? t2 : null;
          }
          isIdRenderable(e2, t2 = false) {
            var i2;
            return null === (i2 = this.getTileById(e2)) || void 0 === i2 ? void 0 : i2.isRenderable(t2);
          }
          getRenderableIds(e2 = 0, i2) {
            const a2 = [];
            for (const e3 of this.getAllIds()) this.isIdRenderable(e3, i2) && a2.push(this.getTileById(e3));
            return i2 ? a2.sort(((i3, a3) => {
              const r2 = i3.tileID, o2 = a3.tileID, s2 = new t.P(r2.canonical.x, r2.canonical.y)._rotate(-e2), n2 = new t.P(o2.canonical.x, o2.canonical.y)._rotate(-e2);
              return r2.overscaledZ - o2.overscaledZ || n2.y - s2.y || n2.x - s2.x;
            })).map(((e3) => e3.tileID.key)) : a2.map(((e3) => e3.tileID)).sort(t.aw).map(((e3) => e3.key));
          }
        }
        class ke2 extends t.E {
          constructor(e2, i2, a2) {
            super(), this.id = e2, this.dispatcher = a2, this.on("data", ((e3) => this._dataHandler(e3))), this.on("dataloading", (() => {
              this._sourceErrored = false;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((e3, t2, i3, a3) => {
              const r2 = new (oe2(t2.type))(e3, t2, i3, a3);
              if (r2.id !== e3) throw new Error(`Expected Source id to be ${e3} instead of ${r2.id}`);
              return r2;
            })(e2, i2, a2, this), this._inViewTiles = new Le2(), this._outOfViewCache = new t.ax(0, ((e3) => this._unloadTile(e3))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new _e2(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(e2) {
            this.map = e2, this._maxTileCacheSize = e2 ? e2._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e2 ? e2._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e2);
          }
          onRemove(e2) {
            for (const e3 of this._inViewTiles.getAllTiles()) e3.unloadVectorData();
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e2), this._inViewTiles = new Le2();
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded) return false;
            if (!this._source.loaded()) return false;
            if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const e2 of this._inViewTiles.getAllTiles()) if ("loaded" !== e2.state && "errored" !== e2.state) return false;
            return true;
          }
          getSource() {
            return this._source;
          }
          getState() {
            return this._state;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e2 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e2, i2, a2) {
            return t._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(e2), this._tileLoaded(e2, i2, a2);
              } catch (i3) {
                e2.state = "errored", 404 !== i3.status ? this._source.fire(new t.k(i3, { tile: e2 })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(e2) {
            this._source.unloadTile && this._source.unloadTile(e2);
          }
          _abortTile(e2) {
            this._source.abortTile && this._source.abortTile(e2), this._source.fire(new t.l("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e2) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._inViewTiles, this.map ? this.map.painter : null);
            for (const t2 of this._inViewTiles.getAllTiles()) t2.upload(e2), t2.prepare(this.map.style.imageManager);
          }
          getIds() {
            return this._inViewTiles.getAllIds(true);
          }
          getRenderableIds(e2) {
            var t2;
            return this._inViewTiles.getRenderableIds(null === (t2 = this.transform) || void 0 === t2 ? void 0 : t2.bearingInRadians, e2);
          }
          hasRenderableParent(e2) {
            const t2 = e2.overscaledZ - 1;
            if (t2 >= this._source.minzoom) {
              const i2 = this.getLoadedTile(e2.scaledTo(t2));
              if (i2) return this._inViewTiles.isIdRenderable(i2.tileID.key);
            }
            return false;
          }
          reload(e2, t2 = void 0) {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._outOfViewCache.reset();
              for (const i2 of this._inViewTiles.getAllIds()) {
                const a2 = this._inViewTiles.getTileById(i2);
                t2 && !this._source.shouldReloadTile(a2, t2) || (e2 ? this._reloadTile(i2, "expired") : "errored" !== a2.state && this._reloadTile(i2, "reloading"));
              }
            }
          }
          _reloadTile(e2, i2) {
            return t._(this, void 0, void 0, (function* () {
              const t2 = this._inViewTiles.getTileById(e2);
              t2 && ("loading" !== t2.state && (t2.state = i2), yield this._loadTile(t2, e2, i2));
            }));
          }
          _tileLoaded(e2, i2, a2) {
            e2.timeAdded = c(), e2.selfFading && (e2.fadeEndTime = e2.timeAdded + this._rasterFadeDuration), "expired" === a2 && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, e2), "raster-dem" === this.getSource().type && e2.dem && (function(e3, t2) {
              var i3, a3;
              const r2 = t2.getRenderableIds();
              for (const o2 of r2) {
                if (!e3.neighboringTiles || !e3.neighboringTiles[o2]) continue;
                const r3 = t2.getTileById(o2);
                e3.neighboringTiles[o2].backfilled || Ae2(e3, r3), (null === (a3 = null === (i3 = r3.neighboringTiles) || void 0 === i3 ? void 0 : i3[e3.tileID.key]) || void 0 === a3 ? void 0 : a3.backfilled) || Ae2(r3, e3);
              }
            })(e2, this._inViewTiles), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t.l("data", { dataType: "source", tile: e2, coord: e2.tileID }));
          }
          getTile(e2) {
            return this.getTileByID(e2.key);
          }
          getTileByID(e2) {
            return this._inViewTiles.getTileById(e2);
          }
          _retainLoadedChildren(e2, t2) {
            const i2 = this._getLoadedDescendents(t2), a2 = /* @__PURE__ */ new Set();
            for (const r2 of t2) {
              const t3 = i2[r2.key];
              if (!(null == t3 ? void 0 : t3.length)) {
                a2.add(r2);
                continue;
              }
              const o2 = r2.overscaledZ + ke2.maxOverzooming, s2 = t3.filter(((e3) => e3.tileID.overscaledZ <= o2));
              if (!s2.length) {
                a2.add(r2);
                continue;
              }
              const n2 = Math.min(...s2.map(((e3) => e3.tileID.overscaledZ))), l2 = s2.filter(((e3) => e3.tileID.overscaledZ === n2)).map(((e3) => e3.tileID));
              for (const t4 of l2) e2[t4.key] = t4;
              this._areDescendentsComplete(l2, n2, r2.overscaledZ) || a2.add(r2);
            }
            return a2;
          }
          _getLoadedDescendents(e2) {
            var t2;
            const i2 = {};
            for (const a2 of this._inViewTiles.getAllTiles().filter(((e3) => e3.hasData()))) for (const r2 of e2) a2.tileID.isChildOf(r2) && (i2[t2 = r2.key] || (i2[t2] = [])).push(a2);
            return i2;
          }
          _areDescendentsComplete(e2, t2, i2) {
            return 1 === e2.length && e2[0].isOverscaled() ? e2[0].overscaledZ === t2 : Math.pow(4, t2 - i2) === e2.length;
          }
          getLoadedTile(e2) {
            return this._inViewTiles.getLoadedTile(e2);
          }
          updateCacheSize(e2) {
            const i2 = Math.ceil(e2.width / this._source.tileSize) + 1, a2 = Math.ceil(e2.height / this._source.tileSize) + 1, r2 = Math.floor(i2 * a2 * (null === this._maxTileCacheZoomLevels ? t.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r2) : r2;
            this._outOfViewCache.setMaxSize(o2);
          }
          handleWrapJump(e2) {
            const t2 = Math.round((e2 - (void 0 === this._prevLng ? e2 : this._prevLng)) / 360);
            this._prevLng = e2, t2 && (this._inViewTiles.handleWrapJump(t2), this._resetTileReloadTimers());
          }
          update(e2, i2) {
            if (!this._sourceLoaded || this._paused) return;
            let a2;
            this.transform = e2, this.terrain = i2, this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? a2 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map(((e3) => new t.a2(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y))) : (a2 = Ie2(e2, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: "vector" === this._source.type && void 0 !== this.map._zoomLevelsToOverscale ? e2.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (a2 = a2.filter(((e3) => this._source.hasTile(e3))))) : a2 = [], this.usedForTerrain && (a2 = this._addTerrainIdealTiles(a2));
            const r2 = 0 === a2.length && !this._updated && this._didEmitContent;
            this._updated = true, r2 && this.fire(new t.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const o2 = Ce2(e2, this._source), s2 = this._updateRetainedTiles(a2, o2), n2 = Ee2(this._source.type);
            n2 && this._rasterFadeDuration > 0 && !i2 && (function(e3, i3, a3, r3, o3, s3, n3) {
              const l2 = c(), h2 = t.av(i3);
              for (const t2 of i3) {
                const i4 = e3.getTileById(t2.key);
                i4.fadingDirection !== ue2.Departing && 0 !== i4.fadeOpacity || i4.resetFadeLogic(), Se2(e3, i4, a3, l2, r3, o3, n3) || ze2(e3, i4, a3, l2, s3, n3) || De2(i4, h2, l2, n3) || i4.resetFadeLogic();
              }
            })(this._inViewTiles, a2, s2, this._maxFadingAncestorLevels, this._source.minzoom, this._source.maxzoom, this._rasterFadeDuration), n2 ? this._cleanUpRasterTiles(s2) : this._cleanUpVectorTiles(s2);
          }
          _cleanUpRasterTiles(e2) {
            for (const t2 of this._inViewTiles.getAllIds()) e2[t2] || this._removeTile(t2);
          }
          _cleanUpVectorTiles(e2) {
            for (const t2 of this._inViewTiles.getAllIds()) {
              const i2 = this._inViewTiles.getTileById(t2);
              e2[t2] ? i2.clearSymbolFadeHold() : i2.hasSymbolBuckets ? i2.holdingForSymbolFade() ? i2.symbolFadeFinished() && this._removeTile(t2) : i2.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(t2);
            }
          }
          _addTerrainIdealTiles(e2) {
            const t2 = [];
            for (const i2 of e2) if (i2.canonical.z > this._source.minzoom) {
              const e3 = i2.scaledTo(i2.canonical.z - 1);
              t2.push(e3);
              const a2 = i2.scaledTo(Math.max(this._source.minzoom, Math.min(i2.canonical.z, 5)));
              t2.push(a2);
            }
            return e2.concat(t2);
          }
          releaseSymbolFadeTiles() {
            for (const e2 of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(e2).holdingForSymbolFade() && this._removeTile(e2);
          }
          _updateRetainedTiles(e2, t2) {
            var i2;
            const a2 = /* @__PURE__ */ new Set();
            for (const t3 of e2) this._addTile(t3).hasData() || a2.add(t3);
            const r2 = e2.reduce(((e3, t3) => (e3[t3.key] = t3, e3)), {}), o2 = this._retainLoadedChildren(r2, a2), s2 = {}, n2 = Math.max(t2 - ke2.maxUnderzooming, this._source.minzoom);
            for (const e3 of o2) {
              let t3 = this._inViewTiles.getTileById(e3.key), a3 = null == t3 ? void 0 : t3.wasRequested();
              for (let o3 = e3.overscaledZ - 1; o3 >= n2; --o3) {
                const n3 = e3.scaledTo(o3);
                if (s2[n3.key]) break;
                if (s2[n3.key] = true, t3 = this.getTile(n3), !t3 && a3 && (t3 = this._addTile(n3)), t3) {
                  const e4 = t3.hasData();
                  if ((e4 || !(null === (i2 = this.map) || void 0 === i2 ? void 0 : i2.cancelPendingTileRequestsWhileZooming) || a3) && (r2[n3.key] = n3), a3 = t3.wasRequested(), e4) break;
                }
              }
            }
            return r2;
          }
          _addTile(e2) {
            let i2 = this._inViewTiles.getTileById(e2.key);
            if (i2) return i2;
            i2 = this._outOfViewCache.getAndRemove(e2), i2 && (i2.resetFadeLogic(), this._setTileReloadTimer(e2.key, i2), i2.tileID = e2, this._state.initializeTileState(i2, this.map ? this.map.painter : null));
            const a2 = i2;
            return i2 || (i2 = new de2(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i2, e2.key, i2.state)), i2.uses++, this._inViewTiles.setTile(e2.key, i2), a2 || this._source.fire(new t.l("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
          }
          _setTileReloadTimer(e2, t2) {
            this._clearTileReloadTimer(e2);
            const i2 = t2.getExpiryTimeout();
            i2 && (this._timers[e2] = setTimeout((() => {
              this._reloadTile(e2, "expired"), delete this._timers[e2];
            }), i2));
          }
          _clearTileReloadTimer(e2) {
            const t2 = this._timers[e2];
            t2 && (clearTimeout(t2), delete this._timers[e2]);
          }
          _resetTileReloadTimers() {
            for (const e2 in this._timers) clearTimeout(this._timers[e2]), delete this._timers[e2];
            for (const e2 of this._inViewTiles.getAllIds()) {
              const t2 = this._inViewTiles.getTileById(e2);
              this._setTileReloadTimer(e2, t2);
            }
          }
          refreshTiles(e2) {
            for (const t2 of this._inViewTiles.getAllIds()) {
              const i2 = this._inViewTiles.getTileById(t2);
              (this._inViewTiles.isIdRenderable(t2) || "errored" == i2.state) && e2.some(((e3) => e3.equals(i2.tileID.canonical))) && this._reloadTile(t2, "expired");
            }
          }
          _removeTile(e2) {
            const t2 = this._inViewTiles.getTileById(e2);
            t2 && (t2.uses--, this._inViewTiles.deleteTileById(e2), this._clearTileReloadTimer(e2), t2.uses > 0 || (t2.hasData() && "reloading" !== t2.state ? this._outOfViewCache.add(t2.tileID, t2, t2.getExpiryTimeout()) : (t2.aborted = true, this._abortTile(t2), this._unloadTile(t2))));
          }
          _dataHandler(e2) {
            "source" === e2.dataType && ("metadata" !== e2.sourceDataType ? "content" === e2.sourceDataType && this._sourceLoaded && !this._paused && (this.reload(e2.sourceDataChanged, e2.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true) : this._sourceLoaded = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e2 of this._inViewTiles.getAllIds()) this._removeTile(e2);
            this._outOfViewCache.reset();
          }
          tilesIn(e2, i2, a2) {
            const r2 = [], o2 = this.transform;
            if (!o2) return r2;
            const s2 = o2.getCoveringTilesDetailsProvider().allowWorldCopies(), n2 = a2 ? o2.getCameraQueryGeometry(e2) : e2, l2 = (e3) => o2.screenPointToMercatorCoordinate(e3, this.terrain), c2 = this.transformBbox(e2, l2, !s2), h2 = this.transformBbox(n2, l2, !s2), u2 = this.getIds(), d2 = t.aa.fromPoints(h2);
            for (let e3 = 0; e3 < u2.length; e3++) {
              const a3 = this._inViewTiles.getTileById(u2[e3]);
              if (a3.holdingForSymbolFade()) continue;
              const n3 = s2 ? [a3.tileID] : [a3.tileID.unwrapTo(-1), a3.tileID.unwrapTo(0)], l3 = Math.pow(2, o2.zoom - a3.tileID.overscaledZ), _3 = i2 * a3.queryPadding * t.a5 / a3.tileSize / l3;
              for (const e4 of n3) {
                const i3 = d2.map(((i4) => e4.getTilePoint(new t.a9(i4.x, i4.y))));
                if (i3.expandBy(_3), i3.intersects(Me2)) {
                  const t2 = c2.map(((t3) => e4.getTilePoint(t3))), i4 = h2.map(((t3) => e4.getTilePoint(t3)));
                  r2.push({ tile: a3, tileID: s2 ? e4 : e4.unwrapTo(0), queryGeometry: t2, cameraQueryGeometry: i4, scale: l3 });
                }
              }
            }
            return r2;
          }
          transformBbox(e2, i2, a2) {
            let r2 = e2.map(i2);
            if (a2) {
              const a3 = t.aa.fromPoints(e2);
              a3.shrinkBy(1e-3 * Math.min(a3.width(), a3.height()));
              const o2 = a3.map(i2);
              t.aa.fromPoints(r2).covers(o2) || (r2 = r2.map(((e3) => e3.x > 0.5 ? new t.a9(e3.x - 1, e3.y, e3.z) : e3)));
            }
            return r2;
          }
          getVisibleCoordinates(e2) {
            const t2 = this.getRenderableIds(e2).map(((e3) => this._inViewTiles.getTileById(e3).tileID));
            return this.transform && this.transform.populateCache(t2), t2;
          }
          hasTransition() {
            return !!this._source.hasTransition() || !(!Ee2(this._source.type) || !(function(e2, t2) {
              if (t2 <= 0) return false;
              const i2 = c();
              for (const t3 of e2.getAllTiles()) if (t3.fadeEndTime >= i2) return true;
              return false;
            })(this._inViewTiles, this._rasterFadeDuration));
          }
          setRasterFadeDuration(e2) {
            this._rasterFadeDuration = e2;
          }
          setFeatureState(e2, i2, a2) {
            this._state.updateState(e2 = e2 || t.ai, i2, a2);
          }
          removeFeatureState(e2, i2, a2) {
            this._state.removeFeatureState(e2 = e2 || t.ai, i2, a2);
          }
          getFeatureState(e2, i2) {
            return this._state.getState(e2 = e2 || t.ai, i2);
          }
          setDependencies(e2, t2, i2) {
            const a2 = this._inViewTiles.getTileById(e2);
            a2 && a2.setDependencies(t2, i2);
          }
          reloadTilesForDependencies(e2, t2) {
            for (const i2 of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(i2).hasDependency(e2, t2) && this._reloadTile(i2, "reloading");
            this._outOfViewCache.filter(((i2) => !i2.hasDependency(e2, t2)));
          }
          areTilesLoaded() {
            for (const e2 of this._inViewTiles.getAllTiles()) if ("loaded" !== e2.state && "errored" !== e2.state) return false;
            return true;
          }
        }
        ke2.maxUnderzooming = 10, ke2.maxOverzooming = 3;
        class Fe2 {
          constructor(e2, t2) {
            this.reset(e2, t2);
          }
          reset(e2, t2) {
            this.points = e2 || [], this._distances = [0];
            for (let e3 = 1; e3 < this.points.length; e3++) this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e2) {
            if (1 === this.points.length) return this.points[0];
            e2 = t.an(e2, 0, 1);
            let i2 = 1, a2 = this._distances[i2];
            const r2 = e2 * this.paddedLength + this.padding;
            for (; a2 < r2 && i2 < this._distances.length; ) a2 = this._distances[++i2];
            const o2 = i2 - 1, s2 = this._distances[o2], n2 = a2 - s2, l2 = n2 > 0 ? (r2 - s2) / n2 : 0;
            return this.points[o2].mult(1 - l2).add(this.points[i2].mult(l2));
          }
        }
        function Be2(e2, t2) {
          let i2 = true;
          return "always" === e2 || "never" !== e2 && "never" !== t2 || (i2 = false), i2;
        }
        class Oe2 {
          constructor(e2, t2, i2) {
            const a2 = this.boxCells = [], r2 = this.circleCells = [];
            this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
            for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++) a2.push([]), r2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e2, t2, i2, a2, r2) {
            this._forEachCell(t2, i2, a2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(a2), this.bboxes.push(r2);
          }
          insertCircle(e2, t2, i2, a2) {
            this._forEachCell(t2 - a2, i2 - a2, t2 + a2, i2 + a2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(a2);
          }
          _insertBoxCell(e2, t2, i2, a2, r2, o2) {
            this.boxCells[r2].push(o2);
          }
          _insertCircleCell(e2, t2, i2, a2, r2, o2) {
            this.circleCells[r2].push(o2);
          }
          _query(e2, t2, i2, a2, r2, o2, s2) {
            if (i2 < 0 || e2 > this.width || a2 < 0 || t2 > this.height) return [];
            const n2 = [];
            if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= a2) {
              if (r2) return [{ key: null, x1: e2, y1: t2, x2: i2, y2: a2 }];
              for (let e3 = 0; e3 < this.boxKeys.length; e3++) n2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
              for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
                const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], a3 = this.circles[3 * e3 + 2];
                n2.push({ key: this.circleKeys[e3], x1: t3 - a3, y1: i3 - a3, x2: t3 + a3, y2: i3 + a3 });
              }
            } else this._forEachCell(e2, t2, i2, a2, this._queryCell, n2, { hitTest: r2, overlapMode: o2, seenUids: { box: {}, circle: {} } }, s2);
            return n2;
          }
          query(e2, t2, i2, a2) {
            return this._query(e2, t2, i2, a2, false, null);
          }
          hitTest(e2, t2, i2, a2, r2, o2) {
            return this._query(e2, t2, i2, a2, true, r2, o2).length > 0;
          }
          hitTestCircle(e2, t2, i2, a2, r2) {
            const o2 = e2 - i2, s2 = e2 + i2, n2 = t2 - i2, l2 = t2 + i2;
            if (s2 < 0 || o2 > this.width || l2 < 0 || n2 > this.height) return false;
            const c2 = [];
            return this._forEachCell(o2, n2, s2, l2, this._queryCellCircle, c2, { hitTest: true, overlapMode: a2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), c2.length > 0;
          }
          _queryCell(e2, t2, i2, a2, r2, o2, s2, n2) {
            const { seenUids: l2, hitTest: c2, overlapMode: h2 } = s2, u2 = this.boxCells[r2];
            if (null !== u2) {
              const r3 = this.bboxes;
              for (const s3 of u2) if (!l2.box[s3]) {
                l2.box[s3] = true;
                const u3 = 4 * s3, d3 = this.boxKeys[s3];
                if (e2 <= r3[u3 + 2] && t2 <= r3[u3 + 3] && i2 >= r3[u3 + 0] && a2 >= r3[u3 + 1] && (!n2 || n2(d3)) && (!c2 || !Be2(h2, d3.overlapMode)) && (o2.push({ key: d3, x1: r3[u3], y1: r3[u3 + 1], x2: r3[u3 + 2], y2: r3[u3 + 3] }), c2)) return true;
              }
            }
            const d2 = this.circleCells[r2];
            if (null !== d2) {
              const r3 = this.circles;
              for (const s3 of d2) if (!l2.circle[s3]) {
                l2.circle[s3] = true;
                const u3 = 3 * s3, d3 = this.circleKeys[s3];
                if (this._circleAndRectCollide(r3[u3], r3[u3 + 1], r3[u3 + 2], e2, t2, i2, a2) && (!n2 || n2(d3)) && (!c2 || !Be2(h2, d3.overlapMode))) {
                  const e3 = r3[u3], t3 = r3[u3 + 1], i3 = r3[u3 + 2];
                  if (o2.push({ key: d3, x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 }), c2) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(e2, t2, i2, a2, r2, o2, s2, n2) {
            const { circle: l2, seenUids: c2, overlapMode: h2 } = s2, u2 = this.boxCells[r2];
            if (null !== u2) {
              const e3 = this.bboxes;
              for (const t3 of u2) if (!c2.box[t3]) {
                c2.box[t3] = true;
                const i3 = 4 * t3, a3 = this.boxKeys[t3];
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!n2 || n2(a3)) && !Be2(h2, a3.overlapMode)) return o2.push(true), true;
              }
            }
            const d2 = this.circleCells[r2];
            if (null !== d2) {
              const e3 = this.circles;
              for (const t3 of d2) if (!c2.circle[t3]) {
                c2.circle[t3] = true;
                const i3 = 3 * t3, a3 = this.circleKeys[t3];
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(a3)) && !Be2(h2, a3.overlapMode)) return o2.push(true), true;
              }
            }
          }
          _forEachCell(e2, t2, i2, a2, r2, o2, s2, n2) {
            const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(a2);
            for (let d2 = l2; d2 <= h2; d2++) for (let l3 = c2; l3 <= u2; l3++) if (r2.call(this, e2, t2, i2, a2, this.xCellCount * l3 + d2, o2, s2, n2)) return;
          }
          _convertToXCellCoord(e2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
          }
          _convertToYCellCoord(e2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
          }
          _circlesCollide(e2, t2, i2, a2, r2, o2) {
            const s2 = a2 - e2, n2 = r2 - t2, l2 = i2 + o2;
            return l2 * l2 > s2 * s2 + n2 * n2;
          }
          _circleAndRectCollide(e2, t2, i2, a2, r2, o2, s2) {
            const n2 = (o2 - a2) / 2, l2 = Math.abs(e2 - (a2 + n2));
            if (l2 > n2 + i2) return false;
            const c2 = (s2 - r2) / 2, h2 = Math.abs(t2 - (r2 + c2));
            if (h2 > c2 + i2) return false;
            if (l2 <= n2 || h2 <= c2) return true;
            const u2 = l2 - n2, d2 = h2 - c2;
            return u2 * u2 + d2 * d2 <= i2 * i2;
          }
        }
        function je2(e2, i2, r2) {
          const o2 = t.N();
          if (!e2) {
            const { vecSouth: e3, vecEast: t2 } = Ze2(i2), r3 = a();
            r3[0] = t2[0], r3[1] = t2[1], r3[2] = e3[0], r3[3] = e3[1], s2 = r3, (d2 = (l2 = (n2 = r3)[0]) * (u2 = n2[3]) - (h2 = n2[2]) * (c2 = n2[1])) && (s2[0] = u2 * (d2 = 1 / d2), s2[1] = -c2 * d2, s2[2] = -h2 * d2, s2[3] = l2 * d2), o2[0] = r3[0], o2[1] = r3[1], o2[4] = r3[2], o2[5] = r3[3];
          }
          var s2, n2, l2, c2, h2, u2, d2;
          return t.Q(o2, o2, [1 / r2, 1 / r2, 1]), o2;
        }
        function Ne2(e2, i2, a2, r2) {
          if (e2) {
            const e3 = t.N();
            if (!i2) {
              const { vecSouth: t2, vecEast: i3 } = Ze2(a2);
              e3[0] = i3[0], e3[1] = i3[1], e3[4] = t2[0], e3[5] = t2[1];
            }
            return t.Q(e3, e3, [r2, r2, 1]), e3;
          }
          return a2.pixelsToClipSpaceMatrix;
        }
        function Ze2(e2) {
          const i2 = Math.cos(e2.rollInRadians), a2 = Math.sin(e2.rollInRadians), r2 = Math.cos(e2.pitchInRadians), o2 = Math.cos(e2.bearingInRadians), s2 = Math.sin(e2.bearingInRadians), n2 = t.aC();
          n2[0] = -o2 * r2 * a2 - s2 * i2, n2[1] = -s2 * r2 * a2 + o2 * i2;
          const l2 = t.aD(n2);
          l2 < 1e-9 ? t.aE(n2) : t.aF(n2, n2, 1 / l2);
          const c2 = t.aC();
          c2[0] = o2 * r2 * i2 - s2 * a2, c2[1] = s2 * r2 * i2 + o2 * a2;
          const h2 = t.aD(c2);
          return h2 < 1e-9 ? t.aE(c2) : t.aF(c2, c2, 1 / h2), { vecEast: c2, vecSouth: n2 };
        }
        function Ge2(e2, i2, a2, r2) {
          let o2;
          r2 ? (o2 = [e2, i2, r2(e2, i2), 1], t.aH(o2, o2, a2)) : (o2 = [e2, i2, 0, 1], ot2(o2, o2, a2));
          const s2 = o2[3];
          return { point: new t.P(o2[0] / s2, o2[1] / s2), signedDistanceFromCamera: s2, isOccluded: false };
        }
        function Ue2(e2, t2) {
          return 0.5 + e2 / t2 * 0.5;
        }
        function Ve2(e2, t2) {
          return e2.x >= -t2[0] && e2.x <= t2[0] && e2.y >= -t2[1] && e2.y <= t2[1];
        }
        function qe2(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _3) {
          const p2 = a2 ? e2.textSizeData : e2.iconSizeData, m2 = t.ay(p2, i2.transform.zoom), f3 = [256 / i2.width * 2 + 1, 256 / i2.height * 2 + 1], g2 = a2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
          g2.clear();
          const v2 = e2.lineVertexArray, x2 = a2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, b2 = i2.transform.width / i2.transform.height;
          let y3 = false;
          for (let a3 = 0; a3 < x2.length; a3++) {
            const w3 = x2.get(a3);
            if (w3.hidden || w3.writingMode === t.az.vertical && !y3) {
              rt2(w3.numGlyphs, g2);
              continue;
            }
            y3 = false;
            const T3 = new t.P(w3.anchorX, w3.anchorY), P3 = { getElevation: _3, pitchedLabelPlaneMatrix: r2, lineVertexArray: v2, pitchWithMap: s2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: i2.transform, tileAnchorPoint: T3, unwrappedTileID: c2, width: h2, height: u2, translation: d2 }, C2 = Je(w3.anchorX, w3.anchorY, P3);
            if (!Ve2(C2.point, f3)) {
              rt2(w3.numGlyphs, g2);
              continue;
            }
            const I3 = Ue2(i2.transform.cameraToCenterDistance, C2.signedDistanceFromCamera), M3 = t.aA(p2, m2, w3), E2 = s2 ? M3 * i2.transform.getPitchedTextCorrection(w3.anchorX, w3.anchorY, c2) / I3 : M3 * I3, S3 = He2({ projectionContext: P3, pitchedLabelPlaneMatrixInverse: o2, symbol: w3, fontSize: E2, flip: false, keepUpright: n2, glyphOffsetArray: e2.glyphOffsetArray, dynamicLayoutVertexArray: g2, aspectRatio: b2, rotateToLine: l2 });
            y3 = S3.useVertical, (S3.notEnoughRoom || y3 || S3.needsFlipping && He2({ projectionContext: P3, pitchedLabelPlaneMatrixInverse: o2, symbol: w3, fontSize: E2, flip: true, keepUpright: n2, glyphOffsetArray: e2.glyphOffsetArray, dynamicLayoutVertexArray: g2, aspectRatio: b2, rotateToLine: l2 }).notEnoughRoom) && rt2(w3.numGlyphs, g2);
          }
          a2 ? e2.text.dynamicLayoutVertexBuffer.updateData(g2) : e2.icon.dynamicLayoutVertexBuffer.updateData(g2);
        }
        function We(e2, t2, i2, a2, r2, o2, s2, n2) {
          const l2 = o2.glyphStartIndex + o2.numGlyphs, c2 = o2.lineStartIndex, h2 = o2.lineStartIndex + o2.lineLength, u2 = t2.getoffsetX(o2.glyphStartIndex), d2 = t2.getoffsetX(l2 - 1), _3 = it2(e2 * u2, i2, a2, r2, o2.segment, c2, h2, n2, s2);
          if (!_3) return null;
          const p2 = it2(e2 * d2, i2, a2, r2, o2.segment, c2, h2, n2, s2);
          return p2 ? n2.projectionCache.anyProjectionOccluded ? null : { first: _3, last: p2 } : null;
        }
        function $e2(e2, i2, a2, r2) {
          return e2 === t.az.horizontal && Math.abs(a2.y - i2.y) > Math.abs(a2.x - i2.x) * r2 ? { useVertical: true } : (e2 === t.az.vertical ? i2.y < a2.y : i2.x > a2.x) ? { needsFlipping: true } : null;
        }
        function He2(e2) {
          const { projectionContext: i2, pitchedLabelPlaneMatrixInverse: a2, symbol: r2, fontSize: o2, flip: s2, keepUpright: n2, glyphOffsetArray: l2, dynamicLayoutVertexArray: c2, aspectRatio: h2, rotateToLine: u2 } = e2, d2 = o2 / 24, _3 = r2.lineOffsetX * d2, p2 = r2.lineOffsetY * d2;
          let m2;
          if (r2.numGlyphs > 1) {
            const e3 = r2.glyphStartIndex + r2.numGlyphs, t2 = r2.lineStartIndex, o3 = r2.lineStartIndex + r2.lineLength, c3 = We(d2, l2, _3, p2, s2, r2, u2, i2);
            if (!c3) return { notEnoughRoom: true };
            const f3 = Qe2(c3.first.point.x, c3.first.point.y, i2, a2), g2 = Qe2(c3.last.point.x, c3.last.point.y, i2, a2);
            if (n2 && !s2) {
              const e4 = $e2(r2.writingMode, f3, g2, h2);
              if (e4) return e4;
            }
            m2 = [c3.first];
            for (let a3 = r2.glyphStartIndex + 1; a3 < e3 - 1; a3++) {
              const e4 = it2(d2 * l2.getoffsetX(a3), _3, p2, s2, r2.segment, t2, o3, i2, u2);
              if (!e4) return { notEnoughRoom: true };
              m2.push(e4);
            }
            m2.push(c3.last);
          } else {
            if (n2 && !s2) {
              const e4 = Ye(i2.tileAnchorPoint.x, i2.tileAnchorPoint.y, i2).point, o3 = r2.lineStartIndex + r2.segment + 1, s3 = new t.P(i2.lineVertexArray.getx(o3), i2.lineVertexArray.gety(o3)), n3 = Ye(s3.x, s3.y, i2), l3 = n3.signedDistanceFromCamera > 0 ? n3.point : Xe2(i2.tileAnchorPoint, s3, e4, 1, i2), c3 = Qe2(e4.x, e4.y, i2, a2), u3 = Qe2(l3.x, l3.y, i2, a2), d3 = $e2(r2.writingMode, c3, u3, h2);
              if (d3) return d3;
            }
            const e3 = it2(d2 * l2.getoffsetX(r2.glyphStartIndex), _3, p2, s2, r2.segment, r2.lineStartIndex, r2.lineStartIndex + r2.lineLength, i2, u2);
            if (!e3 || i2.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            m2 = [e3];
          }
          for (const e3 of m2) t.aG(c2, e3.point, e3.angle);
          return {};
        }
        function Xe2(e2, t2, i2, a2, r2) {
          const o2 = e2.add(e2.sub(t2)._unit()), s2 = Ye(o2.x, o2.y, r2).point, n2 = i2.sub(s2);
          return i2.add(n2._mult(a2 / n2.mag()));
        }
        function Ke2(e2, i2, a2) {
          const r2 = i2.projectionCache;
          if (r2.projections[e2]) return r2.projections[e2];
          const o2 = new t.P(i2.lineVertexArray.getx(e2), i2.lineVertexArray.gety(e2)), s2 = Ye(o2.x, o2.y, i2);
          if (s2.signedDistanceFromCamera > 0) return r2.projections[e2] = s2.point, r2.anyProjectionOccluded = r2.anyProjectionOccluded || s2.isOccluded, s2.point;
          const n2 = e2 - a2.direction;
          return Xe2(0 === a2.distanceFromAnchor ? i2.tileAnchorPoint : new t.P(i2.lineVertexArray.getx(n2), i2.lineVertexArray.gety(n2)), o2, a2.previousVertex, a2.absOffsetX - a2.distanceFromAnchor + 1, i2);
        }
        function Ye(e2, t2, i2) {
          const a2 = e2 + i2.translation[0], r2 = t2 + i2.translation[1];
          let o2;
          return i2.pitchWithMap ? (o2 = Ge2(a2, r2, i2.pitchedLabelPlaneMatrix, i2.getElevation), o2.isOccluded = false) : (o2 = i2.transform.projectTileCoordinates(a2, r2, i2.unwrappedTileID, i2.getElevation), o2.point.x = (0.5 * o2.point.x + 0.5) * i2.width, o2.point.y = (0.5 * -o2.point.y + 0.5) * i2.height), o2;
        }
        function Qe2(e2, i2, a2, r2) {
          if (a2.pitchWithMap) {
            const o2 = [e2, i2, 0, 1];
            return t.aH(o2, o2, r2), a2.transform.projectTileCoordinates(o2[0] / o2[3], o2[1] / o2[3], a2.unwrappedTileID, a2.getElevation).point;
          }
          return { x: e2 / a2.width * 2 - 1, y: 1 - i2 / a2.height * 2 };
        }
        function Je(e2, t2, i2) {
          return i2.transform.projectTileCoordinates(e2, t2, i2.unwrappedTileID, i2.getElevation);
        }
        function et2(e2, t2, i2) {
          return e2._unit()._perp()._mult(t2 * i2);
        }
        function tt2(e2, i2, a2, r2, o2, s2, n2, l2, c2) {
          if (l2.projectionCache.offsets[e2]) return l2.projectionCache.offsets[e2];
          const h2 = a2.add(i2);
          if (e2 + c2.direction < r2 || e2 + c2.direction >= o2) return l2.projectionCache.offsets[e2] = h2, h2;
          const u2 = Ke2(e2 + c2.direction, l2, c2), d2 = et2(u2.sub(a2), n2, c2.direction), _3 = a2.add(d2), p2 = u2.add(d2);
          return l2.projectionCache.offsets[e2] = t.aI(s2, h2, _3, p2) || h2, l2.projectionCache.offsets[e2];
        }
        function it2(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
          const c2 = a2 ? e2 - t2 : e2 + t2;
          let h2 = c2 > 0 ? 1 : -1, u2 = 0;
          a2 && (h2 *= -1, u2 = Math.PI), h2 < 0 && (u2 += Math.PI);
          let d2, _3 = h2 > 0 ? o2 + r2 : o2 + r2 + 1;
          n2.projectionCache.cachedAnchorPoint ? d2 = n2.projectionCache.cachedAnchorPoint : (d2 = Ye(n2.tileAnchorPoint.x, n2.tileAnchorPoint.y, n2).point, n2.projectionCache.cachedAnchorPoint = d2);
          let p2, m2, f3 = d2, g2 = d2, v2 = 0, x2 = 0;
          const b2 = Math.abs(c2), y3 = [];
          let w3;
          for (; v2 + x2 <= b2; ) {
            if (_3 += h2, _3 < o2 || _3 >= s2) return null;
            v2 += x2, g2 = f3, m2 = p2;
            const e3 = { absOffsetX: b2, direction: h2, distanceFromAnchor: v2, previousVertex: g2 };
            if (f3 = Ke2(_3, n2, e3), 0 === i2) y3.push(g2), w3 = f3.sub(g2);
            else {
              let t3;
              const a3 = f3.sub(g2);
              t3 = 0 === a3.mag() ? et2(Ke2(_3 + h2, n2, e3).sub(f3), i2, h2) : et2(a3, i2, h2), m2 || (m2 = g2.add(t3)), p2 = tt2(_3, t3, f3, o2, s2, m2, i2, n2, e3), y3.push(m2), w3 = p2.sub(m2);
            }
            x2 = w3.mag();
          }
          const T3 = w3._mult((b2 - v2) / x2)._add(m2 || g2), P3 = u2 + Math.atan2(f3.y - g2.y, f3.x - g2.x);
          return y3.push(T3), { point: T3, angle: l2 ? P3 : 0, path: y3 };
        }
        const at3 = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function rt2(e2, t2) {
          for (let i2 = 0; i2 < e2; i2++) {
            const e3 = t2.length;
            t2.resize(e3 + 4), t2.float32.set(at3, 3 * e3);
          }
        }
        function ot2(e2, t2, i2) {
          const a2 = t2[0], r2 = t2[1];
          return e2[0] = i2[0] * a2 + i2[4] * r2 + i2[12], e2[1] = i2[1] * a2 + i2[5] * r2 + i2[13], e2[3] = i2[3] * a2 + i2[7] * r2 + i2[15], e2;
        }
        const st2 = 100;
        class nt2 {
          constructor(e2, t2 = new Oe2(e2.width + 200, e2.height + 200, 25), i2 = new Oe2(e2.width + 200, e2.height + 200, 25)) {
            this.transform = e2, this.grid = t2, this.ignoredGrid = i2, this.pitchFactor = Math.cos(e2.pitch * Math.PI / 180) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + st2, this.screenBottomBoundary = e2.height + st2, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2) {
            const d2 = this.projectAndGetPerspectiveRatio(e2.anchorPointX + n2[0], e2.anchorPointY + n2[1], r2, c2, u2), _3 = i2 * d2.perspectiveRatio;
            let p2;
            if (o2 || s2) p2 = this._projectCollisionBox(e2, _3, a2, r2, o2, s2, n2, d2, c2, h2, u2);
            else {
              const t3 = d2.x + (h2 ? h2.x * _3 : 0), i3 = d2.y + (h2 ? h2.y * _3 : 0);
              p2 = { allPointsOccluded: false, box: [t3 + e2.x1 * _3, i3 + e2.y1 * _3, t3 + e2.x2 * _3, i3 + e2.y2 * _3] };
            }
            const [m2, f3, g2, v2] = p2.box, x2 = o2 ? p2.allPointsOccluded : d2.isOccluded;
            let b2 = x2;
            return b2 || (b2 = d2.perspectiveRatio < this.perspectiveRatioCutoff), b2 || (b2 = !this.isInsideGrid(m2, f3, g2, v2)), b2 || "always" !== t2 && this.grid.hitTest(m2, f3, g2, v2, t2, l2) ? { box: [m2, f3, g2, v2], placeable: false, offscreen: false, occluded: x2 } : { box: [m2, f3, g2, v2], placeable: true, offscreen: this.isOffscreen(m2, f3, g2, v2), occluded: x2 };
          }
          placeCollisionCircles(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _3, p2) {
            const m2 = [], f3 = new t.P(i2.anchorX, i2.anchorY), g2 = this.getPerspectiveRatio(f3.x, f3.y, s2, p2), v2 = (c2 ? o2 * this.transform.getPitchedTextCorrection(i2.anchorX, i2.anchorY, s2) / g2 : o2 * g2) / t.aM, x2 = { getElevation: p2, pitchedLabelPlaneMatrix: n2, lineVertexArray: a2, pitchWithMap: c2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: f3, unwrappedTileID: s2, width: this.transform.width, height: this.transform.height, translation: _3 }, b2 = We(v2, r2, i2.lineOffsetX * v2, i2.lineOffsetY * v2, false, i2, false, x2);
            let y3 = false, w3 = false, T3 = true;
            if (b2) {
              const i3 = 0.5 * u2 * g2 + d2, a3 = new t.P(-100, -100), r3 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), o3 = new Fe2(), s3 = b2.first, n3 = b2.last;
              let _4 = [];
              for (let e3 = s3.path.length - 1; e3 >= 1; e3--) _4.push(s3.path[e3]);
              for (let e3 = 1; e3 < n3.path.length; e3++) _4.push(n3.path[e3]);
              const p3 = 2.5 * i3;
              if (c2) {
                const e3 = this.projectPathToScreenSpace(_4, x2);
                _4 = e3.some(((e4) => e4.signedDistanceFromCamera <= 0)) ? [] : e3.map(((e4) => e4.point));
              }
              let f4 = [];
              if (_4.length > 0) {
                const e3 = _4[0].clone(), i4 = _4[0].clone();
                for (let t2 = 1; t2 < _4.length; t2++) e3.x = Math.min(e3.x, _4[t2].x), e3.y = Math.min(e3.y, _4[t2].y), i4.x = Math.max(i4.x, _4[t2].x), i4.y = Math.max(i4.y, _4[t2].y);
                f4 = e3.x >= a3.x && i4.x <= r3.x && e3.y >= a3.y && i4.y <= r3.y ? [_4] : i4.x < a3.x || e3.x > r3.x || i4.y < a3.y || e3.y > r3.y ? [] : t.aJ([_4], a3.x, a3.y, r3.x, r3.y);
              }
              for (const t2 of f4) {
                o3.reset(t2, 0.25 * i3);
                let a4 = 0;
                a4 = o3.length <= 0.5 * i3 ? 1 : Math.ceil(o3.paddedLength / p3) + 1;
                for (let t3 = 0; t3 < a4; t3++) {
                  const r4 = t3 / Math.max(a4 - 1, 1), s4 = o3.lerp(r4), n4 = s4.x + st2, c3 = s4.y + st2;
                  m2.push(n4, c3, i3, 0);
                  const u3 = n4 - i3, d3 = c3 - i3, _5 = n4 + i3, p4 = c3 + i3;
                  if (T3 = T3 && this.isOffscreen(u3, d3, _5, p4), w3 = w3 || this.isInsideGrid(u3, d3, _5, p4), "always" !== e2 && this.grid.hitTestCircle(n4, c3, i3, e2, h2) && (y3 = true, !l2)) return { circles: [], offscreen: false, collisionDetected: y3 };
                }
              }
            }
            return { circles: !l2 && y3 || !w3 || g2 < this.perspectiveRatioCutoff ? [] : m2, offscreen: T3, collisionDetected: y3 };
          }
          projectPathToScreenSpace(e2, i2) {
            const a2 = (function(e3, i3) {
              const a3 = t.N();
              return t.aB(a3, i3.pitchedLabelPlaneMatrix), e3.map(((e4) => {
                const t2 = Ge2(e4.x, e4.y, a3, i3.getElevation), r2 = i3.transform.projectTileCoordinates(t2.point.x, t2.point.y, i3.unwrappedTileID, i3.getElevation);
                return r2.point.x = (0.5 * r2.point.x + 0.5) * i3.width, r2.point.y = (0.5 * -r2.point.y + 0.5) * i3.height, r2;
              }));
            })(e2, i2);
            return (function(e3) {
              let t2 = 0, i3 = 0, a3 = 0, r2 = 0;
              for (let o2 = 0; o2 < e3.length; o2++) e3[o2].isOccluded ? (a3 = o2 + 1, r2 = 0) : (r2++, r2 > i3 && (i3 = r2, t2 = a3));
              return e3.slice(t2, t2 + i3);
            })(a2);
          }
          queryRenderedSymbols(e2) {
            if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
            const i2 = [], a2 = new t.aa();
            for (const r3 of e2) {
              const e3 = new t.P(r3.x + st2, r3.y + st2);
              a2.extend(e3), i2.push(e3);
            }
            const { minX: r2, minY: o2, maxX: s2, maxY: n2 } = a2, l2 = this.grid.query(r2, o2, s2, n2).concat(this.ignoredGrid.query(r2, o2, s2, n2)), c2 = {}, h2 = {};
            for (const e3 of l2) {
              const a3 = e3.key;
              if (void 0 === c2[a3.bucketInstanceId] && (c2[a3.bucketInstanceId] = {}), c2[a3.bucketInstanceId][a3.featureIndex]) continue;
              const r3 = [new t.P(e3.x1, e3.y1), new t.P(e3.x2, e3.y1), new t.P(e3.x2, e3.y2), new t.P(e3.x1, e3.y2)];
              t.aK(i2, r3) && (c2[a3.bucketInstanceId][a3.featureIndex] = true, void 0 === h2[a3.bucketInstanceId] && (h2[a3.bucketInstanceId] = []), h2[a3.bucketInstanceId].push(a3.featureIndex));
            }
            return h2;
          }
          insertCollisionBox(e2, t2, i2, a2, r2, o2) {
            (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: a2, featureIndex: r2, collisionGroupID: o2, overlapMode: t2 }, e2[0], e2[1], e2[2], e2[3]);
          }
          insertCollisionCircles(e2, t2, i2, a2, r2, o2) {
            const s2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: a2, featureIndex: r2, collisionGroupID: o2, overlapMode: t2 };
            for (let t3 = 0; t3 < e2.length; t3 += 4) s2.insertCircle(n2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
          }
          projectAndGetPerspectiveRatio(e2, i2, a2, r2, o2) {
            if (o2) {
              let a3;
              r2 ? (a3 = [e2, i2, r2(e2, i2), 1], t.aH(a3, a3, o2)) : (a3 = [e2, i2, 0, 1], ot2(a3, a3, o2));
              const s2 = a3[3];
              return { x: (a3[0] / s2 + 1) / 2 * this.transform.width + st2, y: (-a3[1] / s2 + 1) / 2 * this.transform.height + st2, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / s2 * 0.5, isOccluded: false, signedDistanceFromCamera: s2 };
            }
            {
              const t2 = this.transform.projectTileCoordinates(e2, i2, a2, r2);
              return { x: (t2.point.x + 1) / 2 * this.transform.width + st2, y: (1 - t2.point.y) / 2 * this.transform.height + st2, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / t2.signedDistanceFromCamera * 0.5, isOccluded: t2.isOccluded, signedDistanceFromCamera: t2.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e2, t2, i2, a2) {
            const r2 = this.transform.projectTileCoordinates(e2, t2, i2, a2);
            return 0.5 + this.transform.cameraToCenterDistance / r2.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e2, t2, i2, a2) {
            return i2 < st2 || e2 >= this.screenRightBoundary || a2 < st2 || t2 > this.screenBottomBoundary;
          }
          isInsideGrid(e2, t2, i2, a2) {
            return i2 >= 0 && e2 < this.gridRightBoundary && a2 >= 0 && t2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e2 = t.ar([]);
            return t.O(e2, e2, [-100, -100, 0]), e2;
          }
          _projectCollisionBox(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2) {
            let d2 = 1, _3 = 0, p2 = 0, m2 = 1;
            const f3 = e2.anchorPointX + n2[0], g2 = e2.anchorPointY + n2[1];
            if (s2 && !o2) {
              const e3 = this.projectAndGetPerspectiveRatio(f3 + 1, g2, r2, c2, u2), t2 = e3.x - l2.x, i3 = Math.atan((e3.y - l2.y) / t2) + (t2 < 0 ? Math.PI : 0), a3 = Math.sin(i3), o3 = Math.cos(i3);
              d2 = o3, _3 = a3, p2 = -a3, m2 = o3;
            } else if (!s2 && o2) {
              const e3 = Ze2(this.transform);
              d2 = e3.vecEast[0], _3 = e3.vecEast[1], p2 = e3.vecSouth[0], m2 = e3.vecSouth[1];
            }
            let v2 = l2.x, x2 = l2.y, b2 = i2;
            o2 && (v2 = f3, x2 = g2, b2 = Math.pow(2, -(this.transform.zoom - a2.overscaledZ)), b2 *= this.transform.getPitchedTextCorrection(f3, g2, r2), h2 || (b2 *= t.an(0.5 + l2.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), h2 && (v2 += d2 * h2.x * b2 + p2 * h2.y * b2, x2 += _3 * h2.x * b2 + m2 * h2.y * b2);
            const y3 = e2.x1 * b2, w3 = e2.x2 * b2, T3 = (y3 + w3) / 2, P3 = e2.y1 * b2, C2 = e2.y2 * b2, I3 = (P3 + C2) / 2, M3 = [{ offsetX: y3, offsetY: P3 }, { offsetX: T3, offsetY: P3 }, { offsetX: w3, offsetY: P3 }, { offsetX: w3, offsetY: I3 }, { offsetX: w3, offsetY: C2 }, { offsetX: T3, offsetY: C2 }, { offsetX: y3, offsetY: C2 }, { offsetX: y3, offsetY: I3 }];
            let E2 = [];
            for (const { offsetX: e3, offsetY: i3 } of M3) E2.push(new t.P(v2 + d2 * e3 + p2 * i3, x2 + _3 * e3 + m2 * i3));
            let S3 = false;
            if (o2) {
              const e3 = E2.map(((e4) => this.projectAndGetPerspectiveRatio(e4.x, e4.y, r2, c2, u2)));
              S3 = e3.some(((e4) => !e4.isOccluded)), E2 = e3.map(((e4) => new t.P(e4.x, e4.y)));
            } else S3 = true;
            return { box: t.aL(E2), allPointsOccluded: !S3 };
          }
        }
        class lt2 {
          constructor(e2, t2, i2, a2) {
            this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : a2 && i2 ? 1 : 0, this.placed = i2;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class ct2 {
          constructor(e2, t2, i2, a2, r2) {
            this.text = new lt2(e2 ? e2.text : null, t2, i2, r2), this.icon = new lt2(e2 ? e2.icon : null, t2, a2, r2);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class ht2 {
          constructor(e2, t2, i2) {
            this.text = e2, this.icon = t2, this.skipFade = i2;
          }
        }
        class ut2 {
          constructor(e2, t2, i2, a2, r2) {
            this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = a2, this.tileID = r2;
          }
        }
        class dt {
          constructor(e2) {
            this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e2) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e2]) {
              const t2 = ++this.maxGroupID;
              this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
            }
            return this.collisionGroups[e2];
          }
        }
        function _t2(e2, i2, a2, r2, o2) {
          const { horizontalAlign: s2, verticalAlign: n2 } = t.aS(e2);
          return new t.P(-(s2 - 0.5) * i2 + r2[0] * o2, -(n2 - 0.5) * a2 + r2[1] * o2);
        }
        class pt2 {
          constructor(e2, t2, i2, a2, r2) {
            this.transform = e2.clone(), this.terrain = t2, this.collisionIndex = new nt2(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i2, this.retainedQueryData = {}, this.collisionGroups = new dt(a2), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = r2, r2 && (r2.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e2) {
            const t2 = this.terrain;
            return t2 ? (i2, a2) => t2.getElevation(e2, i2, a2) : null;
          }
          getBucketParts(e2, i2, a2, r2) {
            const o2 = a2.getBucket(i2), s2 = a2.latestFeatureIndex;
            if (!o2 || !s2 || i2.id !== o2.layerIds[0]) return;
            const n2 = a2.collisionBoxArray, l2 = o2.layers[0].layout, c2 = o2.layers[0].paint, h2 = Math.pow(2, this.transform.zoom - a2.tileID.overscaledZ), u2 = a2.tileSize / t.a5, d2 = a2.tileID.toUnwrapped(), _3 = "map" === l2.get("text-rotation-alignment"), p2 = t.aN(a2, 1, this.transform.zoom), m2 = t.aO(this.collisionIndex.transform, a2, c2.get("text-translate"), c2.get("text-translate-anchor")), f3 = t.aO(this.collisionIndex.transform, a2, c2.get("icon-translate"), c2.get("icon-translate-anchor")), g2 = je2(_3, this.transform, p2);
            this.retainedQueryData[o2.bucketInstanceId] = new ut2(o2.bucketInstanceId, s2, o2.sourceLayerIndex, o2.index, a2.tileID);
            const v2 = { bucket: o2, layout: l2, translationText: m2, translationIcon: f3, unwrappedTileID: d2, pitchedLabelPlaneMatrix: g2, scale: h2, textPixelRatio: u2, holdingForFade: a2.holdingForSymbolFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.ay(o2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o2.sourceID) };
            if (r2) for (const t2 of o2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: r3 } = t2;
              e2.push({ sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: r3, parameters: v2 });
            }
            else e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: o2.symbolInstances.length, parameters: v2 });
          }
          attemptAnchorPlacement(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _3, p2, m2, f3, g2, v2, x2, b2) {
            const y3 = t.aP[e2.textAnchor], w3 = [e2.textOffset0, e2.textOffset1], T3 = _t2(y3, a2, r2, w3, o2), P3 = this.collisionIndex.placeCollisionBox(i2, d2, l2, c2, h2, n2, s2, f3, u2.predicate, x2, T3, b2);
            if ((!v2 || this.collisionIndex.placeCollisionBox(v2, d2, l2, c2, h2, n2, s2, g2, u2.predicate, x2, T3, b2).placeable) && P3.placeable) {
              let e3;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[_3.crossTileID] && this.prevPlacement.placements[_3.crossTileID] && this.prevPlacement.placements[_3.crossTileID].text && (e3 = this.prevPlacement.variableOffsets[_3.crossTileID].anchor), 0 === _3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[_3.crossTileID] = { textOffset: w3, width: a2, height: r2, anchor: y3, textBoxScale: o2, prevAnchor: e3 }, this.markUsedJustification(p2, y3, _3, m2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, m2, _3), this.placedOrientations[_3.crossTileID] = m2), { shift: T3, placedGlyphBoxes: P3 };
            }
          }
          placeLayerBucketPart(e2, i2, a2) {
            const { bucket: r2, layout: o2, translationText: s2, translationIcon: n2, unwrappedTileID: l2, pitchedLabelPlaneMatrix: c2, textPixelRatio: h2, holdingForFade: u2, collisionBoxArray: d2, partiallyEvaluatedTextSize: _3, collisionGroup: p2 } = e2.parameters, m2 = o2.get("text-optional"), f3 = o2.get("icon-optional"), g2 = t.aQ(o2, "text-overlap", "text-allow-overlap"), v2 = "always" === g2, x2 = t.aQ(o2, "icon-overlap", "icon-allow-overlap"), b2 = "always" === x2, y3 = "map" === o2.get("text-rotation-alignment"), w3 = "map" === o2.get("text-pitch-alignment"), T3 = "none" !== o2.get("icon-text-fit"), P3 = "viewport-y" === o2.get("symbol-z-order"), C2 = v2 && (b2 || !r2.hasIconData() || f3), I3 = b2 && (v2 || !r2.hasTextData() || m2);
            !r2.collisionArrays && d2 && r2.deserializeCollisionBoxes(d2);
            const M3 = this.retainedQueryData[r2.bucketInstanceId].tileID, E2 = this._getTerrainElevationFunc(M3), S3 = this.transform.getFastPathSimpleProjectionMatrix(M3), z3 = (e3, d3, b3) => {
              var P4, z4;
              if (i2[e3.crossTileID]) return;
              if (u2) return void (this.placements[e3.crossTileID] = new ht2(false, false, false));
              let R3 = false, D3 = false, A2 = true, L3 = null, k3 = { box: null, placeable: false, offscreen: null, occluded: false }, F3 = { placeable: false }, B3 = null, O3 = null, j3 = null, N2 = 0, Z3 = 0, G3 = 0;
              d3.textFeatureIndex ? N2 = d3.textFeatureIndex : e3.useRuntimeCollisionCircles && (N2 = e3.featureIndex), d3.verticalTextFeatureIndex && (Z3 = d3.verticalTextFeatureIndex);
              const U3 = d3.textBox;
              if (U3) {
                const i3 = (i4) => {
                  let a3 = t.az.horizontal;
                  if (r2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                    const t2 = this.prevPlacement.placedOrientations[e3.crossTileID];
                    t2 && (this.placedOrientations[e3.crossTileID] = t2, a3 = t2, this.markUsedOrientation(r2, a3, e3));
                  }
                  return a3;
                }, o3 = (i4, a3) => {
                  if (r2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && d3.verticalTextBox) {
                    for (const e4 of r2.writingModes) if (e4 === t.az.vertical ? (k3 = a3(), F3 = k3) : k3 = i4(), k3 && k3.placeable) break;
                  } else k3 = i4();
                }, c3 = e3.textAnchorOffsetStartIndex, u3 = e3.textAnchorOffsetEndIndex;
                if (u3 === c3) {
                  const a3 = (t2, i4) => {
                    const a4 = this.collisionIndex.placeCollisionBox(t2, g2, h2, M3, l2, w3, y3, s2, p2.predicate, E2, void 0, S3);
                    return a4 && a4.placeable && (this.markUsedOrientation(r2, i4, e3), this.placedOrientations[e3.crossTileID] = i4), a4;
                  };
                  o3((() => a3(U3, t.az.horizontal)), (() => {
                    const i4 = d3.verticalTextBox;
                    return r2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i4 ? a3(i4, t.az.vertical) : { box: null, offscreen: null };
                  })), i3(k3 && k3.placeable);
                } else {
                  let _4 = t.aP[null === (z4 = null === (P4 = this.prevPlacement) || void 0 === P4 ? void 0 : P4.variableOffsets[e3.crossTileID]) || void 0 === z4 ? void 0 : z4.anchor];
                  const m3 = (t2, i4, o4) => {
                    const d4 = t2.x2 - t2.x1, m4 = t2.y2 - t2.y1, f5 = e3.textBoxScale, v6 = T3 && "never" === x2 ? i4 : null;
                    let b4 = null, P5 = "never" === g2 ? 1 : 2, C3 = "never";
                    _4 && P5++;
                    for (let i5 = 0; i5 < P5; i5++) {
                      for (let i6 = c3; i6 < u3; i6++) {
                        const a3 = r2.textAnchorOffsets.get(i6);
                        if (_4 && a3.textAnchor !== _4) continue;
                        const c4 = this.attemptAnchorPlacement(a3, t2, d4, m4, f5, y3, w3, h2, M3, l2, p2, C3, e3, r2, o4, s2, n2, v6, E2);
                        if (c4 && (b4 = c4.placedGlyphBoxes, b4 && b4.placeable)) return R3 = true, L3 = c4.shift, b4;
                      }
                      _4 ? _4 = null : C3 = g2;
                    }
                    return a2 && !b4 && (b4 = { box: this.collisionIndex.placeCollisionBox(U3, "always", h2, M3, l2, w3, y3, s2, p2.predicate, E2, void 0, S3).box, offscreen: false, placeable: false, occluded: false }), b4;
                  };
                  o3((() => m3(U3, d3.iconBox, t.az.horizontal)), (() => {
                    const i4 = d3.verticalTextBox;
                    return r2.allowVerticalPlacement && (!k3 || !k3.placeable) && e3.numVerticalGlyphVertices > 0 && i4 ? m3(i4, d3.verticalIconBox, t.az.vertical) : { box: null, occluded: true, offscreen: null };
                  })), k3 && (R3 = k3.placeable, A2 = k3.offscreen);
                  const f4 = i3(k3 && k3.placeable);
                  if (!R3 && this.prevPlacement) {
                    const t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                    t2 && (this.variableOffsets[e3.crossTileID] = t2, this.markUsedJustification(r2, t2.anchor, e3, f4));
                  }
                }
              }
              if (B3 = k3, R3 = B3 && B3.placeable, A2 = B3 && B3.offscreen, e3.useRuntimeCollisionCircles && e3.centerJustifiedTextSymbolIndex >= 0) {
                const i3 = r2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), n3 = t.aA(r2.textSizeData, _3, i3), h3 = o2.get("text-padding");
                O3 = this.collisionIndex.placeCollisionCircles(g2, i3, r2.lineVertexArray, r2.glyphOffsetArray, n3, l2, c2, a2, w3, p2.predicate, e3.collisionCircleDiameter, h3, s2, E2), O3.circles.length && O3.collisionDetected && !a2 && t.w("Collisions detected, but collision boxes are not shown"), R3 = v2 || O3.circles.length > 0 && !O3.collisionDetected, A2 = A2 && O3.offscreen;
              }
              if (d3.iconFeatureIndex && (G3 = d3.iconFeatureIndex), d3.iconBox) {
                const e4 = (e5) => this.collisionIndex.placeCollisionBox(e5, x2, h2, M3, l2, w3, y3, n2, p2.predicate, E2, T3 && L3 ? L3 : void 0, S3);
                F3 && F3.placeable && d3.verticalIconBox ? (j3 = e4(d3.verticalIconBox), D3 = j3.placeable) : (j3 = e4(d3.iconBox), D3 = j3.placeable), A2 = A2 && j3.offscreen;
              }
              const V3 = m2 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, q3 = f3 || 0 === e3.numIconVertices;
              V3 || q3 ? q3 ? V3 || (D3 = D3 && R3) : R3 = D3 && R3 : D3 = R3 = D3 && R3;
              const W3 = D3 && j3.placeable;
              if (R3 && B3.placeable && this.collisionIndex.insertCollisionBox(B3.box, g2, o2.get("text-ignore-placement"), r2.bucketInstanceId, F3 && F3.placeable && Z3 ? Z3 : N2, p2.ID), W3 && this.collisionIndex.insertCollisionBox(j3.box, x2, o2.get("icon-ignore-placement"), r2.bucketInstanceId, G3, p2.ID), O3 && R3 && this.collisionIndex.insertCollisionCircles(O3.circles, g2, o2.get("text-ignore-placement"), r2.bucketInstanceId, N2, p2.ID), a2 && this.storeCollisionData(r2.bucketInstanceId, b3, d3, B3, j3, O3), 0 === e3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              if (0 === r2.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[e3.crossTileID] = new ht2((R3 || C2) && !(null == B3 ? void 0 : B3.occluded), (D3 || I3) && !(null == j3 ? void 0 : j3.occluded), A2 || r2.justReloaded), i2[e3.crossTileID] = true;
            };
            if (P3) {
              if (0 !== e2.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
              const t2 = r2.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                const i3 = t2[e3];
                z3(r2.symbolInstances.get(i3), r2.collisionArrays[i3], i3);
              }
            } else for (let t2 = e2.symbolInstanceStart; t2 < e2.symbolInstanceEnd; t2++) z3(r2.symbolInstances.get(t2), r2.collisionArrays[t2], t2);
            r2.justReloaded = false;
          }
          storeCollisionData(e2, t2, i2, a2, r2, o2) {
            if (i2.textBox || i2.iconBox) {
              let o3, s2;
              this.collisionBoxArrays.has(e2) ? o3 = this.collisionBoxArrays.get(e2) : (o3 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e2, o3)), o3.has(t2) ? s2 = o3.get(t2) : (s2 = { text: null, icon: null }, o3.set(t2, s2)), i2.textBox && (s2.text = a2.box), i2.iconBox && (s2.icon = r2.box);
            }
            if (o2) {
              let t3 = this.collisionCircleArrays[e2];
              void 0 === t3 && (t3 = this.collisionCircleArrays[e2] = []);
              for (let e3 = 0; e3 < o2.circles.length; e3 += 4) t3.push(o2.circles[e3 + 0] - st2), t3.push(o2.circles[e3 + 1] - st2), t3.push(o2.circles[e3 + 2]), t3.push(o2.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e2, i2, a2, r2) {
            let o2;
            o2 = r2 === t.az.vertical ? a2.verticalPlacedTextSymbolIndex : { left: a2.leftJustifiedTextSymbolIndex, center: a2.centerJustifiedTextSymbolIndex, right: a2.rightJustifiedTextSymbolIndex }[t.aR(i2)];
            const s2 = [a2.leftJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.rightJustifiedTextSymbolIndex, a2.verticalPlacedTextSymbolIndex];
            for (const t2 of s2) t2 >= 0 && (e2.text.placedSymbolArray.get(t2).crossTileID = o2 >= 0 && t2 !== o2 ? 0 : a2.crossTileID);
          }
          markUsedOrientation(e2, i2, a2) {
            const r2 = i2 === t.az.horizontal || i2 === t.az.horizontalOnly ? i2 : 0, o2 = i2 === t.az.vertical ? i2 : 0, s2 = [a2.leftJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.rightJustifiedTextSymbolIndex];
            for (const t2 of s2) e2.text.placedSymbolArray.get(t2).placedOrientation = r2;
            a2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(a2.verticalPlacedTextSymbolIndex).placedOrientation = o2);
          }
          commit(e2) {
            this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t2 = this.prevPlacement;
            let i2 = false;
            this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
            const a2 = t2 ? t2.symbolFadeChange(e2) : 1, r2 = t2 ? t2.opacities : {}, o2 = t2 ? t2.variableOffsets : {}, s2 = t2 ? t2.placedOrientations : {};
            for (const e3 in this.placements) {
              const t3 = this.placements[e3], o3 = r2[e3];
              o3 ? (this.opacities[e3] = new ct2(o3, a2, t3.text, t3.icon), i2 = i2 || t3.text !== o3.text.placed || t3.icon !== o3.icon.placed) : (this.opacities[e3] = new ct2(null, a2, t3.text, t3.icon, t3.skipFade), i2 = i2 || t3.text || t3.icon);
            }
            for (const e3 in r2) {
              const t3 = r2[e3];
              if (!this.opacities[e3]) {
                const r3 = new ct2(t3, a2, false, false);
                r3.isHidden() || (this.opacities[e3] = r3, i2 = i2 || t3.text.placed || t3.icon.placed);
              }
            }
            for (const e3 in o2) this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = o2[e3]);
            for (const e3 in s2) this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s2[e3]);
            if (t2 && void 0 === t2.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
            i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
          }
          updateLayerOpacities(e2, t2) {
            const i2 = {};
            for (const a2 of t2) {
              const t3 = a2.getBucket(e2);
              t3 && a2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, a2.tileID, i2, a2.collisionBoxArray);
            }
          }
          updateBucketOpacities(e2, i2, a2, r2) {
            e2.hasTextData() && (e2.text.opacityVertexArray.clear(), e2.text.hasVisibleVertices = false), e2.hasIconData() && (e2.icon.opacityVertexArray.clear(), e2.icon.hasVisibleVertices = false), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
            const o2 = e2.layers[0], s2 = o2.layout, n2 = new ct2(null, 0, false, false, true), l2 = s2.get("text-allow-overlap"), c2 = s2.get("icon-allow-overlap"), h2 = o2._unevaluatedLayout.hasValue("text-variable-anchor") || o2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u2 = "map" === s2.get("text-rotation-alignment"), d2 = "map" === s2.get("text-pitch-alignment"), _3 = "none" !== s2.get("icon-text-fit"), p2 = new ct2(null, 0, l2 && (c2 || !e2.hasIconData() || s2.get("icon-optional")), c2 && (l2 || !e2.hasTextData() || s2.get("text-optional")), true);
            !e2.collisionArrays && r2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(r2);
            const m2 = (e3, t2, i3) => {
              for (let a3 = 0; a3 < t2 / 4; a3++) e3.opacityVertexArray.emplaceBack(i3);
              e3.hasVisibleVertices = e3.hasVisibleVertices || i3 !== Pt2;
            }, f3 = this.collisionBoxArrays.get(e2.bucketInstanceId);
            for (let i3 = 0; i3 < e2.symbolInstances.length; i3++) {
              const r3 = e2.symbolInstances.get(i3), { numHorizontalGlyphVertices: o3, numVerticalGlyphVertices: s3, crossTileID: l3 } = r3;
              let c3 = this.opacities[l3];
              a2[l3] ? c3 = n2 : c3 || (c3 = p2, this.opacities[l3] = c3), a2[l3] = true;
              const g2 = r3.numIconVertices > 0, v2 = this.placedOrientations[r3.crossTileID], x2 = v2 === t.az.vertical, b2 = v2 === t.az.horizontal || v2 === t.az.horizontalOnly;
              if (o3 > 0 || s3 > 0) {
                const t2 = Tt2(c3.text);
                m2(e2.text, o3, x2 ? Pt2 : t2), m2(e2.text, s3, b2 ? Pt2 : t2);
                const i4 = c3.text.isHidden();
                [r3.rightJustifiedTextSymbolIndex, r3.centerJustifiedTextSymbolIndex, r3.leftJustifiedTextSymbolIndex].forEach(((t3) => {
                  t3 >= 0 && (e2.text.placedSymbolArray.get(t3).hidden = i4 || x2 ? 1 : 0);
                })), r3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(r3.verticalPlacedTextSymbolIndex).hidden = i4 || b2 ? 1 : 0);
                const a3 = this.variableOffsets[r3.crossTileID];
                a3 && this.markUsedJustification(e2, a3.anchor, r3, v2);
                const n3 = this.placedOrientations[r3.crossTileID];
                n3 && (this.markUsedJustification(e2, "left", r3, n3), this.markUsedOrientation(e2, n3, r3));
              }
              if (g2) {
                const t2 = Tt2(c3.icon), i4 = !(_3 && r3.verticalPlacedIconSymbolIndex && x2);
                r3.placedIconSymbolIndex >= 0 && (m2(e2.icon, r3.numIconVertices, i4 ? t2 : Pt2), e2.icon.placedSymbolArray.get(r3.placedIconSymbolIndex).hidden = c3.icon.isHidden()), r3.verticalPlacedIconSymbolIndex >= 0 && (m2(e2.icon, r3.numVerticalIconVertices, i4 ? Pt2 : t2), e2.icon.placedSymbolArray.get(r3.verticalPlacedIconSymbolIndex).hidden = c3.icon.isHidden());
              }
              const y3 = f3 && f3.has(i3) ? f3.get(i3) : { text: null, icon: null };
              if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
                const a3 = e2.collisionArrays[i3];
                if (a3) {
                  let i4 = new t.P(0, 0);
                  if (a3.textBox || a3.verticalTextBox) {
                    let t2 = true;
                    if (h2) {
                      const e3 = this.variableOffsets[l3];
                      e3 ? (i4 = _t2(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), u2 && i4._rotate(d2 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t2 = false;
                    }
                    if (a3.textBox || a3.verticalTextBox) {
                      let r4;
                      a3.textBox && (r4 = x2), a3.verticalTextBox && (r4 = b2), mt2(e2.textCollisionBox.collisionVertexArray, c3.text.placed, !t2 || r4, y3.text, i4.x, i4.y);
                    }
                  }
                  if (a3.iconBox || a3.verticalIconBox) {
                    const t2 = Boolean(!b2 && a3.verticalIconBox);
                    let r4;
                    a3.iconBox && (r4 = t2), a3.verticalIconBox && (r4 = !t2), mt2(e2.iconCollisionBox.collisionVertexArray, c3.icon.placed, r4, y3.icon, _3 ? i4.x : 0, _3 ? i4.y : 0);
                  }
                }
              }
            }
            if (e2.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.text.opacityVertexArray.length !== e2.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e2.text.layoutVertexArray.length}) / 4`);
            if (e2.icon.opacityVertexArray.length !== e2.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e2.icon.layoutVertexArray.length}) / 4`);
            e2.bucketInstanceId in this.collisionCircleArrays && (e2.collisionCircleArray = this.collisionCircleArrays[e2.bucketInstanceId], delete this.collisionCircleArrays[e2.bucketInstanceId]);
          }
          symbolFadeChange(e2) {
            return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e2) {
            return Math.max(0, (this.transform.zoom - e2) / 1.5);
          }
          hasTransitions(e2) {
            return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e2, t2) {
            const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
            return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
          }
          setStale() {
            this.stale = true;
          }
        }
        function mt2(e2, t2, i2, a2, r2, o2) {
          a2 && 0 !== a2.length || (a2 = [0, 0, 0, 0]);
          const s2 = a2[0] - st2, n2 = a2[1] - st2, l2 = a2[2] - st2, c2 = a2[3] - st2;
          e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, o2 || 0, s2, n2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, o2 || 0, l2, n2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, o2 || 0, l2, c2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, o2 || 0, s2, c2);
        }
        const ft2 = Math.pow(2, 25), gt2 = Math.pow(2, 24), vt2 = Math.pow(2, 17), xt2 = Math.pow(2, 16), bt2 = Math.pow(2, 9), yt2 = Math.pow(2, 8), wt2 = Math.pow(2, 1);
        function Tt2(e2) {
          if (0 === e2.opacity && !e2.placed) return 0;
          if (1 === e2.opacity && e2.placed) return 4294967295;
          const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
          return i2 * ft2 + t2 * gt2 + i2 * vt2 + t2 * xt2 + i2 * bt2 + t2 * yt2 + i2 * wt2 + t2;
        }
        const Pt2 = 0;
        class Ct2 {
          constructor(e2) {
            this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && !e2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e2, t2, i2, a2, r2) {
            const o2 = this._bucketParts;
            for (; this._currentTileIndex < e2.length; ) if (t2.getBucketParts(o2, a2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort(((e3, t3) => e3.sortKey - t3.sortKey))); this._currentPartIndex < o2.length; ) if (t2.placeLayerBucketPart(o2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, r2()) return true;
            return false;
          }
        }
        class It2 {
          constructor(e2, t2, i2, a2, r2, o2, s2, n2) {
            this.placement = new pt2(e2, t2, o2, s2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = a2, this._showCollisionBoxes = r2, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e2, t2, i2) {
            const a2 = c(), r2 = () => !this._forceFullPlacement && c() - a2 > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const a3 = t2[e2[this._currentPlacementIndex]], o2 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === a3.type && (!a3.minzoom || a3.minzoom <= o2) && (!a3.maxzoom || a3.maxzoom > o2)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ct2(a3)), this._inProgressLayer.continuePlacement(i2[a3.source], this.placement, this._showCollisionBoxes, a3, r2)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e2) {
            return this.placement.commit(e2), this.placement;
          }
        }
        const Mt2 = 512 / t.a5 / 2;
        class Et2 {
          constructor(e2, i2, a2) {
            this.tileID = e2, this.bucketInstanceId = a2, this._symbolsByKey = {};
            const r2 = /* @__PURE__ */ new Map();
            for (let e3 = 0; e3 < i2.length; e3++) {
              const t2 = i2.get(e3), a3 = t2.key, o2 = r2.get(a3);
              o2 ? o2.push(t2) : r2.set(a3, [t2]);
            }
            for (const [e3, i3] of r2) {
              const a3 = { positions: i3.map(((e4) => ({ x: Math.floor(e4.anchorX * Mt2), y: Math.floor(e4.anchorY * Mt2) }))), crossTileIDs: i3.map(((e4) => e4.crossTileID)) };
              if (a3.positions.length > 128) {
                const e4 = new t.aT(a3.positions.length, 16, Uint16Array);
                for (const { x: t2, y: i4 } of a3.positions) e4.add(t2, i4);
                e4.finish(), delete a3.positions, a3.index = e4;
              }
              this._symbolsByKey[e3] = a3;
            }
          }
          getScaledCoordinates(e2, i2) {
            const { x: a2, y: r2, z: o2 } = this.tileID.canonical, { x: s2, y: n2, z: l2 } = i2.canonical, c2 = Mt2 / Math.pow(2, l2 - o2), h2 = (n2 * t.a5 + e2.anchorY) * c2, u2 = r2 * t.a5 * Mt2;
            return { x: Math.floor((s2 * t.a5 + e2.anchorX) * c2 - a2 * t.a5 * Mt2), y: Math.floor(h2 - u2) };
          }
          findMatches(e2, t2, i2) {
            const a2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const o2 = e2.get(r2);
              if (o2.crossTileID) continue;
              const s2 = this._symbolsByKey[o2.key];
              if (!s2) continue;
              const n2 = this.getScaledCoordinates(o2, t2);
              if (s2.index) {
                const e3 = s2.index.range(n2.x - a2, n2.y - a2, n2.x + a2, n2.y + a2).sort();
                for (const t3 of e3) {
                  const e4 = s2.crossTileIDs[t3];
                  if (!i2[e4]) {
                    i2[e4] = true, o2.crossTileID = e4;
                    break;
                  }
                }
              } else if (s2.positions) for (let e3 = 0; e3 < s2.positions.length; e3++) {
                const t3 = s2.positions[e3], r3 = s2.crossTileIDs[e3];
                if (Math.abs(t3.x - n2.x) <= a2 && Math.abs(t3.y - n2.y) <= a2 && !i2[r3]) {
                  i2[r3] = true, o2.crossTileID = r3;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: e2 }) => e2));
          }
        }
        class St2 {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class zt2 {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e2) {
            const t2 = Math.round((e2 - this.lng) / 360);
            if (0 !== t2) for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], a2 = {};
              for (const e4 in i2) {
                const r2 = i2[e4];
                r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), a2[r2.tileID.key] = r2;
              }
              this.indexes[e3] = a2;
            }
            this.lng = e2;
          }
          addBucket(e2, t2, i2) {
            if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
              if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
            }
            for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) t2.symbolInstances.get(e3).crossTileID = 0;
            this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
            const a2 = this.usedCrossTileIDs[e2.overscaledZ];
            for (const i3 in this.indexes) {
              const r2 = this.indexes[i3];
              if (Number(i3) > e2.overscaledZ) for (const i4 in r2) {
                const o2 = r2[i4];
                o2.tileID.isChildOf(e2) && o2.findMatches(t2.symbolInstances, e2, a2);
              }
              else {
                const o2 = r2[e2.scaledTo(Number(i3)).key];
                o2 && o2.findMatches(t2.symbolInstances, e2, a2);
              }
            }
            for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
              const r2 = t2.symbolInstances.get(e3);
              r2.crossTileID || (r2.crossTileID = i2.generate(), a2[r2.crossTileID] = true);
            }
            return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Et2(e2, t2.symbolInstances, t2.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e2, t2) {
            for (const i2 of t2.getCrossTileIDsLists()) for (const t3 of i2) delete this.usedCrossTileIDs[e2][t3];
          }
          removeStaleBuckets(e2) {
            let t2 = false;
            for (const i2 in this.indexes) {
              const a2 = this.indexes[i2];
              for (const r2 in a2) e2[a2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, a2[r2]), delete a2[r2], t2 = true);
            }
            return t2;
          }
        }
        class Rt2 {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new St2(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e2, t2, i2) {
            let a2 = this.layerIndexes[e2.id];
            void 0 === a2 && (a2 = this.layerIndexes[e2.id] = new zt2());
            let r2 = false;
            const o2 = {};
            a2.handleWrapJump(i2);
            for (const i3 of t2) {
              const t3 = i3.getBucket(e2);
              t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), a2.addBucket(i3.tileID, t3, this.crossTileIDs) && (r2 = true), o2[t3.bucketInstanceId] = true);
            }
            return a2.removeStaleBuckets(o2) && (r2 = true), r2;
          }
          pruneUnusedLayers(e2) {
            const t2 = {};
            e2.forEach(((e3) => {
              t2[e3] = true;
            }));
            for (const e3 in this.layerIndexes) t2[e3] || delete this.layerIndexes[e3];
          }
        }
        var Dt2 = "void main() {fragColor=vec4(1.0);}";
        const At2 = { prelude: Lt2("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"), projectionMercator: Lt2("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Lt2("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"), background: Lt2("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Lt2("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Lt2("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: Lt2(Dt2, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Lt2("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"), heatmapTexture: Lt2("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Lt2("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Lt2("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Lt2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Lt2("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Lt2(Dt2, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"), fill: Lt2("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"), fillOutline: Lt2("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillOutlinePattern: Lt2("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillPattern: Lt2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: Lt2("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: Lt2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: Lt2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Lt2("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Lt2("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: Lt2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: Lt2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: Lt2("uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"), lineGradientSDF: Lt2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"), raster: Lt2("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Lt2("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: Lt2("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: Lt2("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: Lt2("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Lt2("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Lt2("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Lt2("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Lt2("#ifdef GL_ES\nprecision highp float;\n#endif\nin vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Lt2("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Lt2(e2, t2) {
          const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, a2 = t2.match(/in ([\w]+) ([\w]+)/g), r2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s2 = o2 ? o2.concat(r2) : r2, n2 = {};
          return { fragmentSource: e2 = e2.replace(i2, ((e3, t3, i3, a3, r3) => (n2[r3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
in ${i3} ${a3} ${r3};
#else
uniform ${i3} ${a3} u_${r3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${r3}
    ${i3} ${a3} ${r3} = u_${r3};
#endif
`))), vertexSource: t2 = t2.replace(i2, ((e3, t3, i3, a3, r3) => {
            const o3 = "float" === a3 ? "vec2" : "vec4", s3 = r3.match(/color/) ? "color" : o3;
            return n2[r3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
in ${i3} ${o3} a_${r3};
out ${i3} ${a3} ${r3};
#else
uniform ${i3} ${a3} u_${r3};
#endif
` : "vec4" === s3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = a_${r3};
#else
    ${i3} ${a3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = unpack_mix_${s3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${a3} ${r3} = u_${r3};
#endif
` : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
in ${i3} ${o3} a_${r3};
#else
uniform ${i3} ${a3} u_${r3};
#endif
` : "vec4" === s3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${a3} ${r3} = a_${r3};
#else
    ${i3} ${a3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${a3} ${r3} = unpack_mix_${s3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${a3} ${r3} = u_${r3};
#endif
`;
          })), staticAttributes: a2, staticUniforms: s2 };
        }
        class kt2 {
          constructor(e2, t2, i2) {
            this.vertexBuffer = e2, this.indexBuffer = t2, this.segments = i2;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var Ft2 = t.aU([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Bt2 = "#define PROJECTION_MERCATOR", Ot2 = "mercator";
        class jt2 {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return false;
          }
          get shaderVariantName() {
            return Ot2;
          }
          get shaderDefine() {
            return Bt2;
          }
          get shaderPreludeCode() {
            return At2.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return At2.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return t.aV.noSubdivision;
          }
          get useGlobeControls() {
            return false;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e2) {
          }
          getMeshFromTileID(e2, i2, a2, r2, o2) {
            if (this._cachedMesh) return this._cachedMesh;
            const s2 = new t.aW();
            s2.emplaceBack(0, 0), s2.emplaceBack(t.a5, 0), s2.emplaceBack(0, t.a5), s2.emplaceBack(t.a5, t.a5);
            const n2 = e2.createVertexBuffer(s2, Ft2.members), l2 = t.aX.simpleSegment(0, 0, 4, 2), c2 = new t.aY();
            c2.emplaceBack(1, 0, 2), c2.emplaceBack(1, 2, 3);
            const h2 = e2.createIndexBuffer(c2);
            return this._cachedMesh = new kt2(n2, h2, l2), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return false;
          }
          setErrorQueryLatitudeDegrees(e2) {
          }
        }
        class Nt2 {
          constructor(e2 = 0, t2 = 0, i2 = 0, a2 = 0) {
            if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(a2) || a2 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e2, this.bottom = t2, this.left = i2, this.right = a2;
          }
          interpolate(e2, i2, a2) {
            return null != i2.top && null != e2.top && (this.top = t.G.number(e2.top, i2.top, a2)), null != i2.bottom && null != e2.bottom && (this.bottom = t.G.number(e2.bottom, i2.bottom, a2)), null != i2.left && null != e2.left && (this.left = t.G.number(e2.left, i2.left, a2)), null != i2.right && null != e2.right && (this.right = t.G.number(e2.right, i2.right, a2)), this;
          }
          getCenter(e2, i2) {
            const a2 = t.an((this.left + e2 - this.right) / 2, 0, e2), r2 = t.an((this.top + i2 - this.bottom) / 2, 0, i2);
            return new t.P(a2, r2);
          }
          equals(e2) {
            return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
          }
          clone() {
            return new Nt2(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Zt2(e2, t2) {
          if (!e2.renderWorldCopies || e2.lngRange) return;
          const i2 = t2.lng - e2.center.lng;
          t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
        function Gt2(e2) {
          return Math.max(0, Math.floor(e2));
        }
        class Ut2 {
          constructor(e2, i2) {
            var a2;
            this.applyConstrain = (e3, t2) => null !== this._constrainOverride ? this._constrainOverride(e3, t2) : this._callbacks.defaultConstrain(e3, t2), this._callbacks = e2, this._tileSize = 512, this._renderWorldCopies = void 0 === (null == i2 ? void 0 : i2.renderWorldCopies) || !!(null == i2 ? void 0 : i2.renderWorldCopies), this._minZoom = (null == i2 ? void 0 : i2.minZoom) || 0, this._maxZoom = (null == i2 ? void 0 : i2.maxZoom) || 22, this._minPitch = null == (null == i2 ? void 0 : i2.minPitch) ? 0 : null == i2 ? void 0 : i2.minPitch, this._maxPitch = null == (null == i2 ? void 0 : i2.maxPitch) ? 60 : null == i2 ? void 0 : i2.maxPitch, this._constrainOverride = null !== (a2 = null == i2 ? void 0 : i2.constrainOverride) && void 0 !== a2 ? a2 : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.V(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Gt2(this._zoom), this._scale = t.aq(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Nt2(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
          }
          apply(e2, i2, a2) {
            this._constrainOverride = e2.constrainOverride, this._latRange = e2.latRange, this._lngRange = e2.lngRange, this._width = e2.width, this._height = e2.height, this._center = e2.center, this._elevation = e2.elevation, this._minElevationForCurrentTile = e2.minElevationForCurrentTile, this._zoom = e2.zoom, this._tileZoom = Gt2(this._zoom), this._scale = t.aq(this._zoom), this._bearingInRadians = e2.bearingInRadians, this._fovInRadians = e2.fovInRadians, this._pitchInRadians = e2.pitchInRadians, this._rollInRadians = e2.rollInRadians, this._unmodified = e2.unmodified, this._edgeInsets = new Nt2(e2.padding.top, e2.padding.bottom, e2.padding.left, e2.padding.right), this._minZoom = e2.minZoom, this._maxZoom = e2.maxZoom, this._minPitch = e2.minPitch, this._maxPitch = e2.maxPitch, this._renderWorldCopies = e2.renderWorldCopies, this._cameraToCenterDistance = e2.cameraToCenterDistance, this._nearZ = e2.nearZ, this._farZ = e2.farZ, this._autoCalculateNearFarZ = !a2 && e2.autoCalculateNearFarZ, i2 && this.constrainInternal(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e2) {
            this._minElevationForCurrentTile = e2;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e2) {
            this._minZoom !== e2 && (this._minZoom = e2, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e2) {
            this._maxZoom !== e2 && (this._maxZoom = e2, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e2) {
            this._minPitch !== e2 && (this._minPitch = e2, this.setPitch(Math.max(this.pitch, e2)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e2) {
            this._maxPitch !== e2 && (this._maxPitch = e2, this.setPitch(Math.min(this.pitch, e2)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e2) {
            void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
          }
          get constrainOverride() {
            return this._constrainOverride;
          }
          setConstrainOverride(e2) {
            void 0 === e2 && (e2 = null), this._constrainOverride !== e2 && (this._constrainOverride = e2, this.constrainInternal(), this._calcMatrices());
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new t.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e2) {
            const i2 = t.W(e2, -180, 180) * Math.PI / 180;
            var r2, o2, s2, n2, l2, c2, h2, u2, d2;
            this._bearingInRadians !== i2 && (this._unmodified = false, this._bearingInRadians = i2, this._calcMatrices(), this._rotationMatrix = a(), r2 = this._rotationMatrix, s2 = -this._bearingInRadians, n2 = (o2 = this._rotationMatrix)[0], l2 = o2[1], c2 = o2[2], h2 = o2[3], u2 = Math.sin(s2), d2 = Math.cos(s2), r2[0] = n2 * d2 + c2 * u2, r2[1] = l2 * d2 + h2 * u2, r2[2] = n2 * -u2 + c2 * d2, r2[3] = l2 * -u2 + h2 * d2);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e2) {
            const i2 = t.an(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== i2 && (this._unmodified = false, this._pitchInRadians = i2, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e2) {
            const t2 = e2 / 180 * Math.PI;
            this._rollInRadians !== t2 && (this._unmodified = false, this._rollInRadians = t2, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return t.aZ(this._fovInRadians);
          }
          setFov(e2) {
            e2 = t.an(e2, 0.1, 150), this.fov !== e2 && (this._unmodified = false, this._fovInRadians = t.ap(e2), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e2) {
            const i2 = this.applyConstrain(this._center, e2).zoom;
            this._zoom !== i2 && (this._unmodified = false, this._zoom = i2, this._tileZoom = Math.max(0, Math.floor(i2)), this._scale = t.aq(i2), this.constrainInternal(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e2) {
            e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this.constrainInternal(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e2) {
            e2 !== this._elevation && (this._elevation = e2, this.constrainInternal(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e2) {
            this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e2, t2) {
            this._autoCalculateNearFarZ = false, this._nearZ = e2, this._farZ = t2, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = true, this._calcMatrices();
          }
          isPaddingEqual(e2) {
            return this._edgeInsets.equals(e2);
          }
          interpolatePadding(e2, t2, i2) {
            this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this.constrainInternal(), this._calcMatrices();
          }
          resize(e2, t2, i2 = true) {
            this._width = e2, this._height = t2, i2 && this.constrainInternal(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new $2([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e2) {
            e2 ? (this._lngRange = [e2.getWest(), e2.getEast()], this._latRange = [e2.getSouth(), e2.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-t.ao, t.ao]);
          }
          getCameraQueryGeometry(e2, i2) {
            if (1 === i2.length) return [i2[0], e2];
            {
              const { minX: a2, minY: r2, maxX: o2, maxY: s2 } = t.aa.fromPoints(i2).extend(e2);
              return [new t.P(a2, r2), new t.P(o2, r2), new t.P(o2, s2), new t.P(a2, s2), new t.P(a2, r2)];
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = true;
            const e2 = this._unmodified, { center: t2, zoom: i2 } = this.applyConstrain(this.center, this.zoom);
            this.setCenter(t2), this.setZoom(i2), this._unmodified = e2, this._constraining = false;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e2 = t.ar(new Float64Array(16));
              t.Q(e2, e2, [this._width / 2, -this._height / 2, 1]), t.O(e2, e2, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e2, e2 = t.ar(new Float64Array(16)), t.Q(e2, e2, [1, -1, 1]), t.O(e2, e2, [-1, -1, 0]), t.Q(e2, e2, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e2, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e2, i2, a2, r2) {
            const o2 = void 0 !== a2 ? a2 : this.bearing, s2 = r2 = void 0 !== r2 ? r2 : this.pitch, { distanceToCenter: n2, clampedElevation: l2 } = this._distanceToCenterFromAltElevationPitch(i2, this.elevation, s2), { x: c2, y: h2 } = be2(s2, o2), u2 = t.a9.fromLngLat(e2, i2);
            let d2, _3, p2 = t.a_(1, u2.y), m2 = 0;
            do {
              if (m2 += 1, m2 > 10) break;
              _3 = n2 / p2, d2 = new t.a9(u2.x + c2 * _3, u2.y + h2 * _3), p2 = 1 / d2.meterInMercatorCoordinateUnits();
            } while (Math.abs(n2 - _3 * p2) > 1e-12);
            return { center: d2.toLngLat(), elevation: l2, zoom: t.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / _3 / this.tileSize) };
          }
          recalculateZoomAndCenter(e2) {
            if (this.elevation - e2 == 0) return;
            const i2 = 1 / this.worldSize, a2 = t.as(1, this.center.lat) * this.worldSize, r2 = t.a9.fromLngLat(this.center, this.elevation), o2 = r2.x / i2, s2 = r2.y / i2, n2 = r2.z / i2, l2 = this.pitch, c2 = this.bearing, { x: h2, y: u2, z: d2 } = be2(l2, c2), _3 = this.cameraToCenterDistance, p2 = o2 + _3 * -h2, m2 = s2 + _3 * -u2, f3 = n2 + _3 * d2, { distanceToCenter: g2, clampedElevation: v2 } = this._distanceToCenterFromAltElevationPitch(f3 / a2, e2, l2), x2 = g2 * a2, b2 = new t.a9((p2 + h2 * x2) * i2, (m2 + u2 * x2) * i2, 0).toLngLat(), y3 = t.as(1, b2.lat), w3 = t.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / g2 / y3 / this.tileSize);
            this._elevation = v2, this._center = b2, this.setZoom(w3);
          }
          _distanceToCenterFromAltElevationPitch(e2, i2, a2) {
            const r2 = -Math.cos(t.ap(a2)), o2 = e2 - i2;
            let s2, n2 = i2;
            return r2 * o2 >= 0 || Math.abs(r2) < 0.1 ? (s2 = 1e4, n2 = e2 + s2 * r2) : s2 = -o2 / r2, { distanceToCenter: s2, clampedElevation: n2 };
          }
          getCameraPoint() {
            const e2 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new t.P(e2 * Math.sin(this.rollInRadians), e2 * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e2 = t.as(1, this.center.lat) * this.worldSize;
            return xe2(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e2).toLngLat();
          }
          getMercatorTileCoordinates(e2) {
            if (!e2) return [0, 0, 1, 1];
            const i2 = e2.canonical.z >= 0 ? 1 << e2.canonical.z : Math.pow(2, e2.canonical.z);
            return [e2.canonical.x / i2, e2.canonical.y / i2, 1 / i2 / t.a5, 1 / i2 / t.a5];
          }
        }
        class Vt2 {
          constructor(e2, i2) {
            this.min = e2, this.max = i2, this.center = t.a$([], t.b0([], this.min, this.max), 0.5);
          }
          quadrant(e2) {
            const i2 = [e2 % 2 == 0, e2 < 2], a2 = t.b1(this.min), r2 = t.b1(this.max);
            for (let e3 = 0; e3 < i2.length; e3++) a2[e3] = i2[e3] ? this.min[e3] : this.center[e3], r2[e3] = i2[e3] ? this.center[e3] : this.max[e3];
            return r2[2] = this.max[2], new Vt2(a2, r2);
          }
          distanceX(e2) {
            return Math.max(Math.min(this.max[0], e2[0]), this.min[0]) - e2[0];
          }
          distanceY(e2) {
            return Math.max(Math.min(this.max[1], e2[1]), this.min[1]) - e2[1];
          }
          intersectsFrustum(e2) {
            let t2 = true;
            for (let i2 = 0; i2 < e2.planes.length; i2++) {
              const a2 = this.intersectsPlane(e2.planes[i2]);
              if (0 === a2) return 0;
              1 === a2 && (t2 = false);
            }
            return t2 ? 2 : e2.aabb.min[0] > this.max[0] || e2.aabb.min[1] > this.max[1] || e2.aabb.min[2] > this.max[2] || e2.aabb.max[0] < this.min[0] || e2.aabb.max[1] < this.min[1] || e2.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e2) {
            let t2 = e2[3], i2 = e2[3];
            for (let a2 = 0; a2 < 3; a2++) e2[a2] > 0 ? (t2 += e2[a2] * this.min[a2], i2 += e2[a2] * this.max[a2]) : (i2 += e2[a2] * this.min[a2], t2 += e2[a2] * this.max[a2]);
            return t2 >= 0 ? 2 : i2 < 0 ? 0 : 1;
          }
        }
        class qt2 {
          distanceToTile2d(e2, t2, i2, a2) {
            const r2 = a2.distanceX([e2, t2]), o2 = a2.distanceY([e2, t2]);
            return Math.hypot(r2, o2);
          }
          getWrap(e2, t2, i2) {
            return i2;
          }
          getTileBoundingVolume(e2, i2, a2, r2) {
            var o2, s2;
            let n2 = 0, l2 = 0;
            if (null == r2 ? void 0 : r2.terrain) {
              const c3 = new t.a2(e2.z, i2, e2.z, e2.x, e2.y), h2 = r2.terrain.getMinMaxElevation(c3);
              n2 = null !== (o2 = h2.minElevation) && void 0 !== o2 ? o2 : Math.min(0, a2), l2 = null !== (s2 = h2.maxElevation) && void 0 !== s2 ? s2 : Math.max(0, a2);
            }
            const c2 = 1 << e2.z;
            return new Vt2([i2 + e2.x / c2, e2.y / c2, n2], [i2 + (e2.x + 1) / c2, (e2.y + 1) / c2, l2]);
          }
          allowVariableZoom(e2, i2) {
            const a2 = e2.fov * (Math.abs(Math.cos(e2.rollInRadians)) * e2.height + Math.abs(Math.sin(e2.rollInRadians)) * e2.width) / e2.height, r2 = t.an(78.5 - a2 / 2, 0, 60);
            return !!i2.terrain || e2.pitch > r2;
          }
          allowWorldCopies() {
            return true;
          }
          prepareNextFrame() {
          }
        }
        class Wt2 {
          constructor(e2, t2, i2) {
            this.points = e2, this.planes = t2, this.aabb = i2;
          }
          static fromInvProjectionMatrix(e2, i2 = 1, a2 = 0, r2, o2) {
            const s2 = o2 ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], n2 = Math.pow(2, a2), l2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((a3) => (function(e3, i3, a4, r3) {
              const o3 = t.aH([], e3, i3), s3 = 1 / o3[3] / a4 * r3;
              return t.b6(o3, o3, [s3, s3, 1 / o3[3], s3]);
            })(a3, e2, i2, n2)));
            r2 && (function(e3, i3, a3, r3) {
              const o3 = r3 ? 4 : 0, s3 = r3 ? 0 : 4;
              let n3 = 0;
              const l3 = [], c3 = [];
              for (let i4 = 0; i4 < 4; i4++) {
                const a4 = t.b2([], e3[i4 + s3], e3[i4 + o3]), r4 = t.b7(a4);
                t.a$(a4, a4, 1 / r4), l3.push(r4), c3.push(a4);
              }
              for (let i4 = 0; i4 < 4; i4++) {
                const r4 = t.b8(e3[i4 + o3], c3[i4], a3);
                n3 = null !== r4 && r4 >= 0 ? Math.max(n3, r4) : Math.max(n3, l3[i4]);
              }
              const h3 = (function(e4, i4) {
                const a4 = t.b2([], e4[i4[0]], e4[i4[1]]), r4 = t.b2([], e4[i4[2]], e4[i4[1]]), o4 = [0, 0, 0, 0];
                return t.b3(o4, t.b4([], a4, r4)), o4[3] = -t.b5(o4, e4[i4[0]]), o4;
              })(e3, i3), u3 = (function(e4, i4) {
                const a4 = t.b9(e4), r4 = t.ba([], e4, 1 / a4), o4 = t.b2([], i4, t.a$([], r4, t.b5(i4, r4))), s4 = t.b9(o4);
                if (s4 > 0) {
                  const e5 = Math.sqrt(1 - r4[3] * r4[3]), a5 = t.a$([], r4, -r4[3]), n4 = t.b0([], a5, t.a$([], o4, e5 / s4));
                  return t.bb(i4, n4);
                }
                return null;
              })(a3, h3);
              if (null !== u3) {
                const e4 = u3 / t.b5(c3[0], h3);
                n3 = Math.min(n3, e4);
              }
              for (let t2 = 0; t2 < 4; t2++) {
                const i4 = Math.min(n3, l3[t2]);
                e3[t2 + s3] = [e3[t2 + o3][0] + c3[t2][0] * i4, e3[t2 + o3][1] + c3[t2][1] * i4, e3[t2 + o3][2] + c3[t2][2] * i4, 1];
              }
            })(l2, s2[0], r2, o2);
            const c2 = s2.map(((e3) => {
              const i3 = t.b2([], l2[e3[0]], l2[e3[1]]), a3 = t.b2([], l2[e3[2]], l2[e3[1]]), r3 = t.b3([], t.b4([], i3, a3)), o3 = -t.b5(r3, l2[e3[1]]);
              return r3.concat(o3);
            })), h2 = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], u2 = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const e3 of l2) for (let t2 = 0; t2 < 3; t2++) h2[t2] = Math.min(h2[t2], e3[t2]), u2[t2] = Math.max(u2[t2], e3[t2]);
            return new Wt2(l2, c2, new Vt2(h2, u2));
          }
        }
        class $t2 {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e2) {
            this._helper.setMinZoom(e2);
          }
          setMaxZoom(e2) {
            this._helper.setMaxZoom(e2);
          }
          setMinPitch(e2) {
            this._helper.setMinPitch(e2);
          }
          setMaxPitch(e2) {
            this._helper.setMaxPitch(e2);
          }
          setRenderWorldCopies(e2) {
            this._helper.setRenderWorldCopies(e2);
          }
          setBearing(e2) {
            this._helper.setBearing(e2);
          }
          setPitch(e2) {
            this._helper.setPitch(e2);
          }
          setRoll(e2) {
            this._helper.setRoll(e2);
          }
          setFov(e2) {
            this._helper.setFov(e2);
          }
          setZoom(e2) {
            this._helper.setZoom(e2);
          }
          setCenter(e2) {
            this._helper.setCenter(e2);
          }
          setElevation(e2) {
            this._helper.setElevation(e2);
          }
          setMinElevationForCurrentTile(e2) {
            this._helper.setMinElevationForCurrentTile(e2);
          }
          setPadding(e2) {
            this._helper.setPadding(e2);
          }
          interpolatePadding(e2, t2, i2) {
            return this._helper.interpolatePadding(e2, t2, i2);
          }
          isPaddingEqual(e2) {
            return this._helper.isPaddingEqual(e2);
          }
          resize(e2, t2, i2 = true) {
            this._helper.resize(e2, t2, i2);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e2) {
            this._helper.setMaxBounds(e2);
          }
          setConstrainOverride(e2) {
            this._helper.setConstrainOverride(e2);
          }
          overrideNearFarZ(e2, t2) {
            this._helper.overrideNearFarZ(e2, t2);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e2) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e2, t2) {
          }
          constructor(e2) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (e3, i2) => {
              i2 = t.an(+i2, this.minZoom, this.maxZoom);
              const a2 = { center: new t.V(e3.lng, e3.lat), zoom: i2 };
              let r2 = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && null === r2) {
                const e4 = 180 - 1e-10;
                r2 = [-e4, e4];
              }
              const o2 = this.tileSize * t.aq(a2.zoom);
              let s2 = 0, n2 = o2, l2 = 0, c2 = o2, h2 = 0, u2 = 0;
              const { x: d2, y: _3 } = this.size;
              if (this._helper._latRange) {
                const e4 = this._helper._latRange;
                s2 = t.X(e4[1]) * o2, n2 = t.X(e4[0]) * o2, n2 - s2 < _3 && (h2 = _3 / (n2 - s2));
              }
              r2 && (l2 = t.W(t.Y(r2[0]) * o2, 0, o2), c2 = t.W(t.Y(r2[1]) * o2, 0, o2), c2 < l2 && (c2 += o2), c2 - l2 < d2 && (u2 = d2 / (c2 - l2)));
              const { x: p2, y: m2 } = me2(o2, e3);
              let f3, g2;
              const v2 = Math.max(u2 || 0, h2 || 0);
              if (v2) {
                const e4 = new t.P(u2 ? (c2 + l2) / 2 : p2, h2 ? (n2 + s2) / 2 : m2);
                return a2.center = fe2(o2, e4).wrap(), a2.zoom += t.at(v2), a2;
              }
              if (this._helper._latRange) {
                const e4 = _3 / 2;
                m2 - e4 < s2 && (g2 = s2 + e4), m2 + e4 > n2 && (g2 = n2 - e4);
              }
              if (r2) {
                const e4 = (l2 + c2) / 2;
                let i3 = p2;
                this._helper._renderWorldCopies && (i3 = t.W(p2, e4 - o2 / 2, e4 + o2 / 2));
                const a3 = d2 / 2;
                i3 - a3 < l2 && (f3 = l2 + a3), i3 + a3 > c2 && (f3 = c2 - a3);
              }
              if (void 0 !== f3 || void 0 !== g2) {
                const e4 = new t.P(null != f3 ? f3 : p2, null != g2 ? g2 : m2);
                a2.center = fe2(o2, e4).wrap();
              }
              return a2;
            }, this.applyConstrain = (e3, t2) => this._helper.applyConstrain(e3, t2), this._helper = new Ut2({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (e3, t2) => this.defaultConstrain(e3, t2) }, e2), this._coveringTilesDetailsProvider = new qt2();
          }
          clone() {
            const e2 = new $t2();
            return e2.apply(this, false), e2;
          }
          apply(e2, t2, i2) {
            this._helper.apply(e2, t2, i2);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e2) {
            const i2 = [new t.bc(0, e2)];
            if (this._helper._renderWorldCopies) {
              const a2 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), r2 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), o2 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s2 = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n2 = Math.floor(Math.min(a2.x, r2.x, o2.x, s2.x)), l2 = Math.floor(Math.max(a2.x, r2.x, o2.x, s2.x)), c2 = 1;
              for (let a3 = n2 - c2; a3 <= l2 + c2; a3++) 0 !== a3 && i2.push(new t.bc(a3, e2));
            }
            return i2;
          }
          getCameraFrustum() {
            return Wt2.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e2) {
            const t2 = this.screenPointToLocation(this.centerPoint, e2), i2 = e2 ? e2.getElevationForLngLatZoom(t2, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(i2);
          }
          setLocationAtPoint(e2, i2) {
            const a2 = t.as(this.elevation, this.center.lat), r2 = this.screenPointToMercatorCoordinateAtZ(i2, a2), o2 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, a2), s2 = t.a9.fromLngLat(e2), n2 = new t.a9(s2.x - (r2.x - o2.x), s2.y - (r2.y - o2.y));
            this.setCenter(null == n2 ? void 0 : n2.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e2, i2) {
            return i2 ? this.coordinatePoint(t.a9.fromLngLat(e2), i2.getElevationForLngLat(e2, this), this._pixelMatrix3D) : this.coordinatePoint(t.a9.fromLngLat(e2));
          }
          screenPointToLocation(e2, t2) {
            var i2;
            return null === (i2 = this.screenPointToMercatorCoordinate(e2, t2)) || void 0 === i2 ? void 0 : i2.toLngLat();
          }
          screenPointToMercatorCoordinate(e2, t2) {
            if (t2) {
              const i2 = t2.pointCoordinate(e2);
              if (null != i2) return i2;
            }
            return this.screenPointToMercatorCoordinateAtZ(e2);
          }
          screenPointToMercatorCoordinateAtZ(e2, i2) {
            const a2 = i2 || 0, r2 = [e2.x, e2.y, 0, 1], o2 = [e2.x, e2.y, 1, 1];
            t.aH(r2, r2, this._pixelMatrixInverse), t.aH(o2, o2, this._pixelMatrixInverse);
            const s2 = r2[3], n2 = o2[3], l2 = r2[1] / s2, c2 = o2[1] / n2, h2 = r2[2] / s2, u2 = o2[2] / n2, d2 = h2 === u2 ? 0 : (a2 - h2) / (u2 - h2);
            return new t.a9(t.G.number(r2[0] / s2, o2[0] / n2, d2) / this.worldSize, t.G.number(l2, c2, d2) / this.worldSize, a2);
          }
          coordinatePoint(e2, i2 = 0, a2 = this._pixelMatrix) {
            const r2 = [e2.x * this.worldSize, e2.y * this.worldSize, i2, 1];
            return t.aH(r2, r2, a2), new t.P(r2[0] / r2[3], r2[1] / r2[3]);
          }
          getBounds() {
            const e2 = Math.max(0, this._helper._height / 2 - ge2(this));
            return new $2().extend(this.screenPointToLocation(new t.P(0, e2))).extend(this.screenPointToLocation(new t.P(this._helper._width, e2))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e2, t2) {
            return t2 ? null != t2.pointCoordinate(e2) : e2.y > this.height / 2 - ge2(this);
          }
          calculatePosMatrix(e2, i2 = false, a2) {
            var r2;
            const o2 = null !== (r2 = e2.key) && void 0 !== r2 ? r2 : t.bd(e2.wrap, e2.canonical.z, e2.canonical.z, e2.canonical.x, e2.canonical.y), s2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (s2.has(o2)) {
              const e3 = s2.get(o2);
              return a2 ? e3.f32 : e3.f64;
            }
            const n2 = ve2(e2, this.worldSize);
            t.S(n2, i2 ? this._alignedProjMatrix : this._viewProjMatrix, n2);
            const l2 = { f64: n2, f32: new Float32Array(n2) };
            return s2.set(o2, l2), a2 ? l2.f32 : l2.f64;
          }
          calculateFogMatrix(e2) {
            const i2 = e2.key, a2 = this._fogMatrixCacheF32;
            if (a2.has(i2)) return a2.get(i2);
            const r2 = ve2(e2, this.worldSize);
            return t.S(r2, this._fogMatrix, r2), a2.set(i2, new Float32Array(r2)), a2.get(i2);
          }
          calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2);
          }
          _calculateNearFarZIfNeeded(e2, i2, a2) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const r2 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), o2 = e2 - r2 * this._helper._pixelPerMeter / Math.cos(i2), s2 = r2 < 0 ? o2 : e2, n2 = Math.PI / 2 + this.pitchInRadians, l2 = t.ap(this.fov) * (Math.abs(Math.cos(t.ap(this.roll))) * this.height + Math.abs(Math.sin(t.ap(this.roll))) * this.width) / this.height * (0.5 + a2.y / this.height), c2 = Math.sin(l2) * s2 / Math.sin(t.an(Math.PI - n2 - l2, 0.01, Math.PI - 0.01)), h2 = ge2(this), u2 = Math.atan(h2 / this._helper.cameraToCenterDistance), d2 = t.ap(0.75), _3 = u2 > d2 ? 2 * u2 * (0.5 + a2.y / (2 * h2)) : d2, p2 = Math.sin(_3) * s2 / Math.sin(t.an(Math.PI - n2 - _3, 0.01, Math.PI - 0.01)), m2 = Math.min(c2, p2);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i2) * m2 + s2), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e2 = this.centerOffset, i2 = me2(this.worldSize, this.center), a2 = i2.x, r2 = i2.y;
            this._helper._pixelPerMeter = t.as(1, this.center.lat) * this.worldSize;
            const o2 = t.ap(Math.min(this.pitch, pe2)), s2 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(o2));
            let n2;
            this._calculateNearFarZIfNeeded(s2, o2, e2), n2 = new Float64Array(16), t.be(n2, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.aB(this._invProjMatrix, n2), n2[8] = 2 * -e2.x / this._helper._width, n2[9] = 2 * e2.y / this._helper._height, this._projectionMatrix = t.bf(n2), t.Q(n2, n2, [1, -1, 1]), t.O(n2, n2, [0, 0, -this._helper.cameraToCenterDistance]), t.bg(n2, n2, -this.rollInRadians), t.bh(n2, n2, this.pitchInRadians), t.bg(n2, n2, -this.bearingInRadians), t.O(n2, n2, [-a2, -r2, 0]), this._mercatorMatrix = t.Q([], n2, [this.worldSize, this.worldSize, this.worldSize]), t.Q(n2, n2, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = t.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, n2), t.O(n2, n2, [0, 0, -this.elevation]), this._viewProjMatrix = n2, this._invViewProjMatrix = t.aB([], n2);
            const l2 = [0, 0, -1, 1];
            t.aH(l2, l2, this._invViewProjMatrix), this._cameraPosition = [l2[0] / l2[3], l2[1] / l2[3], l2[2] / l2[3]], this._fogMatrix = new Float64Array(16), t.be(this._fogMatrix, this.fovInRadians, this.width / this.height, s2, this._helper._farZ), this._fogMatrix[8] = 2 * -e2.x / this.width, this._fogMatrix[9] = 2 * e2.y / this.height, t.Q(this._fogMatrix, this._fogMatrix, [1, -1, 1]), t.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), t.bg(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.bh(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.bg(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.O(this._fogMatrix, this._fogMatrix, [-a2, -r2, 0]), t.Q(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), t.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = t.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, n2);
            const c2 = this._helper._width % 2 / 2, h2 = this._helper._height % 2 / 2, u2 = Math.cos(this.bearingInRadians), d2 = Math.sin(-this.bearingInRadians), _3 = a2 - Math.round(a2) + u2 * c2 + d2 * h2, p2 = r2 - Math.round(r2) + u2 * h2 + d2 * c2, m2 = new Float64Array(n2);
            if (t.O(m2, m2, [_3 > 0.5 ? _3 - 1 : _3, p2 > 0.5 ? p2 - 1 : p2, 0]), this._alignedProjMatrix = m2, n2 = t.aB(new Float64Array(16), this._pixelMatrix), !n2) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = n2, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e2 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
            return t.aH(i2, i2, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e2 = t.as(1, this.center.lat) * this.worldSize;
            return xe2(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e2).toLngLat();
          }
          lngLatToCameraDepth(e2, i2) {
            const a2 = t.a9.fromLngLat(e2), r2 = [a2.x * this.worldSize, a2.y * this.worldSize, i2, 1];
            return t.aH(r2, r2, this._viewProjMatrix), r2[2] / r2[3];
          }
          getProjectionData(e2) {
            const { overscaledTileID: i2, aligned: a2, applyTerrainMatrix: r2 } = e2, o2 = this._helper.getMercatorTileCoordinates(i2), s2 = i2 ? this.calculatePosMatrix(i2, a2, true) : null;
            let n2;
            return n2 = i2 && i2.terrainRttPosMatrix32f && r2 ? i2.terrainRttPosMatrix32f : s2 || t.bi(), { mainMatrix: n2, tileMercatorCoords: o2, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: n2 };
          }
          isLocationOccluded(e2) {
            return false;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e2, t2, i2) {
            return 1;
          }
          transformLightDirection(e2) {
            return t.b1(e2);
          }
          getRayDirectionFromPixel(e2) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e2, i2, a2, r2) {
            const o2 = this.calculatePosMatrix(a2);
            let s2;
            r2 ? (s2 = [e2, i2, r2(e2, i2), 1], t.aH(s2, s2, o2)) : (s2 = [e2, i2, 0, 1], ot2(s2, s2, o2));
            const n2 = s2[3];
            return { point: new t.P(s2[0] / n2, s2[1] / n2), signedDistanceFromCamera: n2, isOccluded: false };
          }
          populateCache(e2) {
            for (const t2 of e2) this.calculatePosMatrix(t2);
          }
          getMatrixForModel(e2, i2) {
            const a2 = t.a9.fromLngLat(e2, i2), r2 = a2.meterInMercatorCoordinateUnits(), o2 = t.bj();
            return t.O(o2, o2, [a2.x, a2.y, a2.z]), t.bg(o2, o2, Math.PI), t.bh(o2, o2, Math.PI / 2), t.Q(o2, o2, [-r2, r2, r2]), o2;
          }
          getProjectionDataForCustomLayer(e2 = true) {
            const i2 = new t.a2(0, 0, 0, 0, 0), a2 = this.getProjectionData({ overscaledTileID: i2, applyGlobeMatrix: e2 }), r2 = ve2(i2, this.worldSize);
            t.S(r2, this._viewProjMatrix, r2), a2.tileMercatorCoords = [0, 0, 1, 1];
            const o2 = [t.a5, t.a5, this.worldSize / this._helper.pixelsPerMeter], s2 = t.bk();
            return t.Q(s2, r2, o2), a2.fallbackMatrix = s2, a2.mainMatrix = s2, a2;
          }
          getFastPathSimpleProjectionMatrix(e2) {
            return this.calculatePosMatrix(e2);
          }
        }
        function Ht2() {
          t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function Xt2(e2) {
          if (e2.useSlerp) if (e2.k < 1) {
            const i2 = t.bl(e2.startEulerAngles.roll, e2.startEulerAngles.pitch, e2.startEulerAngles.bearing), a2 = t.bl(e2.endEulerAngles.roll, e2.endEulerAngles.pitch, e2.endEulerAngles.bearing), r2 = new Float64Array(4);
            t.bm(r2, i2, a2, e2.k);
            const o2 = t.bn(r2);
            e2.tr.setRoll(o2.roll), e2.tr.setPitch(o2.pitch), e2.tr.setBearing(o2.bearing);
          } else e2.tr.setRoll(e2.endEulerAngles.roll), e2.tr.setPitch(e2.endEulerAngles.pitch), e2.tr.setBearing(e2.endEulerAngles.bearing);
          else e2.tr.setRoll(t.G.number(e2.startEulerAngles.roll, e2.endEulerAngles.roll, e2.k)), e2.tr.setPitch(t.G.number(e2.startEulerAngles.pitch, e2.endEulerAngles.pitch, e2.k)), e2.tr.setBearing(t.G.number(e2.startEulerAngles.bearing, e2.endEulerAngles.bearing, e2.k));
        }
        function Kt2(e2, i2, a2, r2, o2) {
          const s2 = o2.padding, n2 = me2(o2.worldSize, a2.getNorthWest()), l2 = me2(o2.worldSize, a2.getNorthEast()), c2 = me2(o2.worldSize, a2.getSouthEast()), h2 = me2(o2.worldSize, a2.getSouthWest()), u2 = t.ap(-r2), d2 = n2.rotate(u2), _3 = l2.rotate(u2), p2 = c2.rotate(u2), m2 = h2.rotate(u2), f3 = new t.P(Math.max(d2.x, _3.x, m2.x, p2.x), Math.max(d2.y, _3.y, m2.y, p2.y)), g2 = new t.P(Math.min(d2.x, _3.x, m2.x, p2.x), Math.min(d2.y, _3.y, m2.y, p2.y)), v2 = f3.sub(g2), x2 = (o2.width - (s2.left + s2.right + i2.left + i2.right)) / v2.x, b2 = (o2.height - (s2.top + s2.bottom + i2.top + i2.bottom)) / v2.y;
          if (b2 < 0 || x2 < 0) return void Ht2();
          const y3 = Math.min(t.at(o2.scale * Math.min(x2, b2)), e2.maxZoom), w3 = t.P.convert(e2.offset), T3 = new t.P((i2.left - i2.right) / 2, (i2.top - i2.bottom) / 2).rotate(t.ap(r2)), P3 = w3.add(T3).mult(o2.scale / t.aq(y3));
          return { center: fe2(o2.worldSize, n2.add(c2).div(2).sub(P3)), zoom: y3, bearing: r2 };
        }
        class Yt2 {
          get useGlobeControls() {
            return false;
          }
          handlePanInertia(e2, t2) {
            const i2 = e2.mag(), a2 = Math.abs(ge2(t2));
            return { easingOffset: e2.mult(Math.min(0.75 * a2 / i2, 1)), easingCenter: t2.center };
          }
          handleMapControlsRollPitchBearingZoom(e2, t2) {
            e2.bearingDelta && t2.setBearing(t2.bearing + e2.bearingDelta), e2.pitchDelta && t2.setPitch(t2.pitch + e2.pitchDelta), e2.rollDelta && t2.setRoll(t2.roll + e2.rollDelta), e2.zoomDelta && t2.setZoom(t2.zoom + e2.zoomDelta);
          }
          handleMapControlsPan(e2, t2, i2) {
            e2.around.distSqr(t2.centerPoint) < 0.01 || t2.setLocationAtPoint(i2, e2.around);
          }
          cameraForBoxAndBearing(e2, t2, i2, a2, r2) {
            return Kt2(e2, t2, i2, a2, r2);
          }
          handleJumpToCenterZoom(e2, i2) {
            e2.zoom !== (void 0 !== i2.zoom ? +i2.zoom : e2.zoom) && e2.setZoom(+i2.zoom), void 0 !== i2.center && e2.setCenter(t.V.convert(i2.center));
          }
          handleEaseTo(e2, i2) {
            const a2 = e2.zoom, r2 = e2.padding, o2 = { roll: e2.roll, pitch: e2.pitch, bearing: e2.bearing }, s2 = { roll: void 0 === i2.roll ? e2.roll : i2.roll, pitch: void 0 === i2.pitch ? e2.pitch : i2.pitch, bearing: void 0 === i2.bearing ? e2.bearing : i2.bearing }, n2 = void 0 !== i2.zoom, l2 = !e2.isPaddingEqual(i2.padding);
            let c2 = false;
            const h2 = n2 ? +i2.zoom : e2.zoom;
            let u2 = e2.centerPoint.add(i2.offsetAsPoint);
            const d2 = e2.screenPointToLocation(u2), { center: _3, zoom: p2 } = e2.applyConstrain(t.V.convert(i2.center || d2), null != h2 ? h2 : a2);
            Zt2(e2, _3);
            const m2 = me2(e2.worldSize, d2), f3 = me2(e2.worldSize, _3).sub(m2), g2 = t.aq(p2 - a2);
            return c2 = p2 !== a2, { easeFunc: (n3) => {
              if (c2 && e2.setZoom(t.G.number(a2, p2, n3)), t.bo(o2, s2) || Xt2({ startEulerAngles: o2, endEulerAngles: s2, tr: e2, k: n3, useSlerp: o2.roll != s2.roll }), l2 && (e2.interpolatePadding(r2, i2.padding, n3), u2 = e2.centerPoint.add(i2.offsetAsPoint)), i2.around) e2.setLocationAtPoint(i2.around, i2.aroundPoint);
              else {
                const i3 = t.aq(e2.zoom - a2), r3 = p2 > a2 ? Math.min(2, g2) : Math.max(0.5, g2), o3 = Math.pow(r3, 1 - n3), s3 = fe2(e2.worldSize, m2.add(f3.mult(n3 * o3)).mult(i3));
                e2.setLocationAtPoint(e2.renderWorldCopies ? s3.wrap() : s3, u2);
              }
            }, isZooming: c2, elevationCenter: _3 };
          }
          handleFlyTo(e2, i2) {
            const a2 = void 0 !== i2.zoom, r2 = e2.zoom, o2 = e2.applyConstrain(t.V.convert(i2.center || i2.locationAtOffset), a2 ? +i2.zoom : r2), s2 = o2.center, n2 = o2.zoom;
            Zt2(e2, s2);
            const l2 = me2(e2.worldSize, i2.locationAtOffset), c2 = me2(e2.worldSize, s2).sub(l2), h2 = c2.mag(), u2 = t.aq(n2 - r2);
            let d2;
            if (void 0 !== i2.minZoom) {
              const a3 = Math.min(+i2.minZoom, r2, n2), o3 = e2.applyConstrain(s2, a3).zoom;
              d2 = t.aq(o3 - r2);
            }
            return { easeFunc: (i3, a3, o3, h3) => {
              e2.setZoom(1 === i3 ? n2 : r2 + t.at(a3));
              const u3 = 1 === i3 ? s2 : fe2(e2.worldSize, l2.add(c2.mult(o3)).mult(a3));
              e2.setLocationAtPoint(e2.renderWorldCopies ? u3.wrap() : u3, h3);
            }, scaleOfZoom: u2, targetCenter: s2, scaleOfMinZoom: d2, pixelPathLength: h2 };
          }
        }
        class Qt2 {
          constructor(e2, t2, i2) {
            this.blendFunction = e2, this.blendColor = t2, this.mask = i2;
          }
        }
        Qt2.Replace = [1, 0], Qt2.disabled = new Qt2(Qt2.Replace, t.bp.transparent, [false, false, false, false]), Qt2.unblended = new Qt2(Qt2.Replace, t.bp.transparent, [true, true, true, true]), Qt2.alphaBlended = new Qt2([1, 771], t.bp.transparent, [true, true, true, true]);
        const Jt2 = 2305;
        class ei2 {
          constructor(e2, t2, i2) {
            this.enable = e2, this.mode = t2, this.frontFace = i2;
          }
        }
        ei2.disabled = new ei2(false, 1029, Jt2), ei2.backCCW = new ei2(true, 1029, Jt2), ei2.frontCCW = new ei2(true, 1028, Jt2);
        class ti2 {
          constructor(e2, t2, i2) {
            this.func = e2, this.mask = t2, this.range = i2;
          }
        }
        ti2.ReadOnly = false, ti2.ReadWrite = true, ti2.disabled = new ti2(519, ti2.ReadOnly, [0, 1]);
        const ii2 = 7680;
        class ai2 {
          constructor(e2, t2, i2, a2, r2, o2) {
            this.test = e2, this.ref = t2, this.mask = i2, this.fail = a2, this.depthFail = r2, this.pass = o2;
          }
        }
        ai2.disabled = new ai2({ func: 519, mask: 0 }, 0, 0, ii2, ii2, ii2);
        const ri2 = /* @__PURE__ */ new WeakMap();
        function oi2(e2) {
          var t2;
          if (ri2.has(e2)) return ri2.get(e2);
          {
            const i2 = null === (t2 = e2.getParameter(e2.VERSION)) || void 0 === t2 ? void 0 : t2.startsWith("WebGL 2.0");
            return ri2.set(e2, i2), i2;
          }
        }
        class si2 {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e2) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e2;
            const i2 = e2.context, a2 = i2.gl;
            this._texFormat = a2.RGBA, this._texType = a2.UNSIGNED_BYTE;
            const r2 = new t.aW();
            r2.emplaceBack(-1, -1), r2.emplaceBack(2, -1), r2.emplaceBack(-1, 2);
            const o2 = new t.aY();
            o2.emplaceBack(0, 1, 2), this._fullscreenTriangle = new kt2(i2.createVertexBuffer(r2, Ft2.members), i2.createIndexBuffer(o2), t.aX.simpleSegment(0, 0, r2.length, o2.length)), this._resultBuffer = new Uint8Array(4), i2.activeTexture.set(a2.TEXTURE1);
            const s2 = a2.createTexture();
            a2.bindTexture(a2.TEXTURE_2D, s2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, a2.NEAREST), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, a2.NEAREST), a2.texImage2D(a2.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i2.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(s2), oi2(a2) && (this._pbo = a2.createBuffer(), a2.bindBuffer(a2.PIXEL_PACK_BUFFER, this._pbo), a2.bufferData(a2.PIXEL_PACK_BUFFER, 4, a2.STREAM_READ), a2.bindBuffer(a2.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e2 = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e2.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e2, t2) {
            const i2 = this._updateCount;
            return this._readbackQueue ? i2 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i2 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e2, t2), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e2 = this._cachedRenderContext.context, t2 = e2.gl;
            e2.activeTexture.set(t2.TEXTURE1), t2.bindTexture(t2.TEXTURE_2D, this._fbo.colorAttachment.get()), e2.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e2, i2) {
            const a2 = this._cachedRenderContext.context, r2 = a2.gl;
            if (this._bindFramebuffer(), a2.viewport.set([0, 0, this._texWidth, this._texHeight]), a2.clear({ color: t.bp.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(a2, r2.TRIANGLES, ti2.disabled, ai2.disabled, Qt2.unblended, ei2.disabled, /* @__PURE__ */ ((e3, t2) => ({ u_input: e3, u_output_expected: t2 }))(e2, i2), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && oi2(r2)) {
              r2.bindBuffer(r2.PIXEL_PACK_BUFFER, this._pbo), r2.readBuffer(r2.COLOR_ATTACHMENT0), r2.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null);
              const e3 = r2.fenceSync(r2.SYNC_GPU_COMMANDS_COMPLETE, 0);
              r2.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: e3 };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e2 = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && oi2(e2)) {
              const i2 = e2.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i2 === e2.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (i2 === e2.TIMEOUT_EXPIRED) return;
              e2.bindBuffer(e2.PIXEL_PACK_BUFFER, this._pbo), e2.getBufferSubData(e2.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e2.bindBuffer(e2.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e2.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = si2._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e2) {
            let t2 = 0;
            return t2 += e2[0] / 256, t2 += e2[1] / 65536, t2 += e2[2] / 16777216, e2[3] < 127 && (t2 = -t2), t2 / 128;
          }
        }
        const ni2 = t.a5 / 128;
        function li2(e2, i2) {
          const a2 = void 0 !== e2.granularity ? Math.max(e2.granularity, 1) : 1, r2 = a2 + (e2.generateBorders ? 2 : 0), o2 = a2 + (e2.extendToNorthPole || e2.generateBorders ? 1 : 0) + (e2.extendToSouthPole || e2.generateBorders ? 1 : 0), s2 = r2 + 1, n2 = o2 + 1, l2 = e2.generateBorders ? -1 : 0, c2 = e2.generateBorders || e2.extendToNorthPole ? -1 : 0, h2 = a2 + (e2.generateBorders ? 1 : 0), u2 = a2 + (e2.generateBorders || e2.extendToSouthPole ? 1 : 0), d2 = s2 * n2, _3 = r2 * o2 * 6, p2 = s2 * n2 > 65536;
          if (p2 && "16bit" === i2) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const m2 = p2 || "32bit" === i2, f3 = new Int16Array(2 * d2);
          let g2 = 0;
          for (let i3 = c2; i3 <= u2; i3++) for (let r3 = l2; r3 <= h2; r3++) {
            let o3 = r3 / a2 * t.a5;
            -1 === r3 && (o3 = -ni2), r3 === a2 + 1 && (o3 = t.a5 + ni2);
            let s3 = i3 / a2 * t.a5;
            -1 === i3 && (s3 = e2.extendToNorthPole ? t.br : -ni2), i3 === a2 + 1 && (s3 = e2.extendToSouthPole ? t.bs : t.a5 + ni2), f3[g2++] = o3, f3[g2++] = s3;
          }
          const v2 = m2 ? new Uint32Array(_3) : new Uint16Array(_3);
          let x2 = 0;
          for (let e3 = 0; e3 < o2; e3++) for (let t2 = 0; t2 < r2; t2++) {
            const i3 = t2 + 1 + e3 * s2, a3 = t2 + (e3 + 1) * s2, r3 = t2 + 1 + (e3 + 1) * s2;
            v2[x2++] = t2 + e3 * s2, v2[x2++] = a3, v2[x2++] = i3, v2[x2++] = i3, v2[x2++] = a3, v2[x2++] = r3;
          }
          return { vertices: f3.buffer.slice(0), indices: v2.buffer.slice(0), uses32bitIndices: m2 };
        }
        const ci2 = new t.aV({ fill: new t.bt(128, 2), line: new t.bt(512, 0), tile: new t.bt(128, 32), stencil: new t.bt(128, 1), circle: 3 });
        class hi2 {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return true;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return At2.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return At2.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return ci2;
          }
          get useGlobeControls() {
            return true;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e2) {
            this._errorMeasurement || (this._errorMeasurement = new si2(e2));
            const i2 = t.X(this._errorQueryLatitudeDegrees), a2 = 2 * Math.atan(Math.exp(Math.PI - i2 * Math.PI * 2)) - 0.5 * Math.PI, r2 = this._errorMeasurement.updateErrorLoop(i2, a2), o2 = c();
            r2 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = r2, this._errorMeasurementLastChangeTime = o2);
            const s2 = Math.min(Math.max((o2 - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = t.bu(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bv(s2));
          }
          _getMeshKey(e2) {
            return `${e2.granularity.toString(36)}_${e2.generateBorders ? "b" : ""}${e2.extendToNorthPole ? "n" : ""}${e2.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e2, t2, i2, a2, r2) {
            const o2 = ("stencil" === r2 ? ci2.stencil : ci2.tile).getGranularityForZoomLevel(t2.z);
            return this._getMesh(e2, { granularity: o2, generateBorders: i2, extendToNorthPole: 0 === t2.y && a2, extendToSouthPole: t2.y === (1 << t2.z) - 1 && a2 });
          }
          _getMesh(e2, i2) {
            const a2 = this._getMeshKey(i2);
            if (a2 in this._tileMeshCache) return this._tileMeshCache[a2];
            const r2 = (function(e3, i3) {
              const a3 = li2(i3, "16bit"), r3 = t.aW.deserialize({ arrayBuffer: a3.vertices, length: a3.vertices.byteLength / 2 / 2 }), o2 = t.aY.deserialize({ arrayBuffer: a3.indices, length: a3.indices.byteLength / 2 / 3 });
              return new kt2(e3.createVertexBuffer(r3, Ft2.members), e3.createIndexBuffer(o2), t.aX.simpleSegment(0, 0, r3.length, o2.length));
            })(e2, i2);
            return this._tileMeshCache[a2] = r2, r2;
          }
          recalculate(e2) {
          }
          hasTransition() {
            const e2 = c();
            let t2 = false;
            return t2 = t2 || (e2 - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, t2 = t2 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t2;
          }
          setErrorQueryLatitudeDegrees(e2) {
            this._errorQueryLatitudeDegrees = e2;
          }
        }
        const ui2 = new t.t({ type: new t.D(t.u.projection.type) });
        class di2 extends t.E {
          constructor(e2) {
            super(), this._transitionable = new t.x(ui2, void 0), this.setProjection(e2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.H(0)), this._mercatorProjection = new jt2(), this._verticalPerspectiveProjection = new hi2();
          }
          get transitionState() {
            const e2 = this.properties.get("type");
            if ("string" == typeof e2 && "mercator" === e2) return 0;
            if ("string" == typeof e2 && "vertical-perspective" === e2) return 1;
            if (e2 instanceof t.bw) {
              if ("vertical-perspective" === e2.from && "mercator" === e2.to) return 1 - e2.transition;
              if ("mercator" === e2.from && "vertical-perspective" === e2.to) return e2.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e2) {
            this._mercatorProjection.updateGPUdependent(e2), this._verticalPerspectiveProjection.updateGPUdependent(e2);
          }
          getMeshFromTileID(e2, t2, i2, a2, r2) {
            return this.currentProjection.getMeshFromTileID(e2, t2, i2, a2, r2);
          }
          setProjection(e2) {
            this._transitionable.setValue("type", (null == e2 ? void 0 : e2.type) || "mercator");
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          setErrorQueryLatitudeDegrees(e2) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e2), this._mercatorProjection.setErrorQueryLatitudeDegrees(e2);
          }
        }
        function _i2(e2) {
          const t2 = fi2(e2.worldSize, e2.center.lat);
          return 2 * Math.PI * t2;
        }
        function pi2(e2, i2, a2, r2, o2) {
          const s2 = 1 / (1 << o2), n2 = i2 / t.a5 * s2 + r2 * s2, l2 = t.by((e2 / t.a5 * s2 + a2 * s2) * Math.PI * 2 + Math.PI, 2 * Math.PI), c2 = 2 * Math.atan(Math.exp(Math.PI - n2 * Math.PI * 2)) - 0.5 * Math.PI, h2 = Math.cos(c2), u2 = new Float64Array(3);
          return u2[0] = Math.sin(l2) * h2, u2[1] = Math.sin(c2), u2[2] = Math.cos(l2) * h2, u2;
        }
        function mi2(e2) {
          return (function(e3, t2) {
            const i2 = Math.cos(t2), a2 = new Float64Array(3);
            return a2[0] = Math.sin(e3) * i2, a2[1] = Math.sin(t2), a2[2] = Math.cos(e3) * i2, a2;
          })(e2.lng * Math.PI / 180, e2.lat * Math.PI / 180);
        }
        function fi2(e2, t2) {
          return e2 / (2 * Math.PI) / Math.cos(t2 * Math.PI / 180);
        }
        function gi2(e2) {
          const i2 = Math.asin(e2[1]) / Math.PI * 180, a2 = Math.sqrt(e2[0] * e2[0] + e2[2] * e2[2]);
          if (a2 > 1e-6) {
            const r2 = e2[0] / a2, o2 = Math.acos(e2[2] / a2), s2 = (r2 > 0 ? o2 : -o2) / Math.PI * 180;
            return new t.V(t.W(s2, -180, 180), i2);
          }
          return new t.V(0, i2);
        }
        function vi2(e2) {
          return Math.cos(e2 * Math.PI / 180);
        }
        function xi(e2, i2) {
          const a2 = vi2(e2), r2 = vi2(i2);
          return t.at(r2 / a2);
        }
        function bi2(e2, i2) {
          const a2 = e2.rotate(i2.bearingInRadians), r2 = i2.zoom + xi(i2.center.lat, 0), o2 = t.bu(1 / vi2(i2.center.lat), 1 / vi2(Math.min(Math.abs(i2.center.lat), 60)), t.bx(r2, 7, 3, 0, 1)), s2 = 360 / _i2({ worldSize: i2.worldSize, center: { lat: i2.center.lat } });
          return new t.V(i2.center.lng - a2.x * s2 * o2, t.an(i2.center.lat + a2.y * s2, -t.ao, t.ao));
        }
        function yi2(e2) {
          const t2 = 0.5 * e2, i2 = Math.sin(t2), a2 = Math.cos(t2);
          return Math.log(i2 + a2) - Math.log(a2 - i2);
        }
        function wi2(e2, i2, a2, r2) {
          const o2 = e2.lat + a2 * r2;
          if (Math.abs(a2) > 1) {
            const s2 = (Math.sign(e2.lat + a2) !== Math.sign(e2.lat) ? -Math.abs(e2.lat) : Math.abs(e2.lat)) * Math.PI / 180, n2 = Math.abs(e2.lat + a2) * Math.PI / 180, l2 = yi2(s2 + r2 * (n2 - s2)), c2 = yi2(s2), h2 = yi2(n2);
            return new t.V(e2.lng + i2 * ((l2 - c2) / (h2 - c2)), o2);
          }
          return new t.V(e2.lng + i2 * r2, o2);
        }
        class Ti {
          constructor(e2) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = e2;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e2 = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e2, this._cache.clear(), this._hadAnyChanges = false;
          }
          getTileBoundingVolume(e2, t2, i2, a2) {
            const r2 = `${e2.z}_${e2.x}_${e2.y}_${(null == a2 ? void 0 : a2.terrain) ? "t" : ""}`, o2 = this._cache.get(r2);
            if (o2) return o2;
            const s2 = this._cachePrevious.get(r2);
            if (s2) return this._cache.set(r2, s2), s2;
            const n2 = this._boundingVolumeFactory(e2, t2, i2, a2);
            return this._cache.set(r2, n2), this._hadAnyChanges = true, n2;
          }
        }
        class Pi2 {
          constructor(e2, t2, i2, a2) {
            this.min = i2, this.max = a2, this.points = e2, this.planes = t2;
          }
          static fromAabb(e2, t2) {
            const i2 = [];
            for (let a2 = 0; a2 < 8; a2++) i2.push([1 & ~a2 ? e2[0] : t2[0], 1 == (a2 >> 1 & 1) ? t2[1] : e2[1], 1 == (a2 >> 2 & 1) ? t2[2] : e2[2]]);
            return new Pi2(i2, [[-1, 0, 0, t2[0]], [1, 0, 0, -e2[0]], [0, -1, 0, t2[1]], [0, 1, 0, -e2[1]], [0, 0, -1, t2[2]], [0, 0, 1, -e2[2]]], e2, t2);
          }
          static fromCenterSizeAngles(e2, i2, a2) {
            const r2 = t.bB([], a2[0], a2[1], a2[2]), o2 = t.bC([], [i2[0], 0, 0], r2), s2 = t.bC([], [0, i2[1], 0], r2), n2 = t.bC([], [0, 0, i2[2]], r2), l2 = [...e2], c2 = [...e2];
            for (let t2 = 0; t2 < 8; t2++) for (let i3 = 0; i3 < 3; i3++) {
              const a3 = e2[i3] + o2[i3] * (1 & ~t2 ? -1 : 1) + s2[i3] * (1 == (t2 >> 1 & 1) ? 1 : -1) + n2[i3] * (1 == (t2 >> 2 & 1) ? 1 : -1);
              l2[i3] = Math.min(l2[i3], a3), c2[i3] = Math.max(c2[i3], a3);
            }
            const h2 = [];
            for (let i3 = 0; i3 < 8; i3++) {
              const a3 = [...e2];
              t.b0(a3, a3, t.a$([], o2, 1 & ~i3 ? -1 : 1)), t.b0(a3, a3, t.a$([], s2, 1 == (i3 >> 1 & 1) ? 1 : -1)), t.b0(a3, a3, t.a$([], n2, 1 == (i3 >> 2 & 1) ? 1 : -1)), h2.push(a3);
            }
            return new Pi2(h2, [[...o2, -t.b5(o2, h2[0])], [...s2, -t.b5(s2, h2[0])], [...n2, -t.b5(n2, h2[0])], [-o2[0], -o2[1], -o2[2], -t.b5(o2, h2[7])], [-s2[0], -s2[1], -s2[2], -t.b5(s2, h2[7])], [-n2[0], -n2[1], -n2[2], -t.b5(n2, h2[7])]], l2, c2);
          }
          intersectsFrustum(e2) {
            let t2 = true;
            const i2 = this.points.length, a2 = this.planes.length, r2 = e2.planes.length, o2 = e2.points.length;
            for (let a3 = 0; a3 < r2; a3++) {
              const r3 = e2.planes[a3];
              let o3 = 0;
              for (let e3 = 0; e3 < i2; e3++) {
                const t3 = this.points[e3];
                r3[0] * t3[0] + r3[1] * t3[1] + r3[2] * t3[2] + r3[3] >= 0 && o3++;
              }
              if (0 === o3) return 0;
              o3 < i2 && (t2 = false);
            }
            if (t2) return 2;
            for (let t3 = 0; t3 < a2; t3++) {
              const i3 = this.planes[t3];
              let a3 = 0;
              for (let t4 = 0; t4 < o2; t4++) {
                const r3 = e2.points[t4];
                i3[0] * r3[0] + i3[1] * r3[1] + i3[2] * r3[2] + i3[3] >= 0 && a3++;
              }
              if (0 === a3) return 0;
            }
            return 1;
          }
          intersectsPlane(e2) {
            const t2 = this.points.length;
            let i2 = 0;
            for (let a2 = 0; a2 < t2; a2++) {
              const t3 = this.points[a2];
              e2[0] * t3[0] + e2[1] * t3[1] + e2[2] * t3[2] + e2[3] >= 0 && i2++;
            }
            return i2 === t2 ? 2 : 0 === i2 ? 0 : 1;
          }
        }
        function Ci(e2, t2, i2) {
          const a2 = e2 - t2;
          return a2 < 0 ? -a2 : Math.max(0, a2 - i2);
        }
        function Ii2(e2, t2, i2, a2, r2) {
          const o2 = e2 - i2;
          let s2;
          return s2 = o2 < 0 ? Math.min(-o2, 1 + o2 - r2) : o2 > 1 ? Math.min(Math.max(o2 - r2, 0), 1 - o2) : 0, Math.max(s2, Ci(t2, a2, r2));
        }
        class Mi {
          constructor() {
            this._boundingVolumeCache = new Ti(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e2, t2, i2, a2) {
            const r2 = 1 << i2.z, o2 = 1 / r2, s2 = i2.x / r2, n2 = i2.y / r2;
            let l2 = 2;
            return l2 = Math.min(l2, Ii2(e2, t2, s2, n2, o2)), l2 = Math.min(l2, Ii2(e2, t2, s2 + 0.5, -n2 - o2, o2)), l2 = Math.min(l2, Ii2(e2, t2, s2 + 0.5, 2 - n2 - o2, o2)), l2;
          }
          getWrap(e2, t2, i2) {
            const a2 = 1 << t2.z, r2 = 1 / a2, o2 = t2.x / a2, s2 = Ci(e2.x, o2, r2), n2 = Ci(e2.x, o2 - 1, r2), l2 = Ci(e2.x, o2 + 1, r2), c2 = Math.min(s2, n2, l2);
            return c2 === l2 ? 1 : c2 === n2 ? -1 : 0;
          }
          allowVariableZoom(e2, t2) {
            return Ce2(e2, t2) > 4;
          }
          allowWorldCopies() {
            return false;
          }
          getTileBoundingVolume(e2, t2, i2, a2) {
            return this._boundingVolumeCache.getTileBoundingVolume(e2, t2, i2, a2);
          }
          _computeTileBoundingVolume(e2, i2, a2, r2) {
            var o2, s2;
            let n2 = 0, l2 = 0;
            if (null == r2 ? void 0 : r2.terrain) {
              const c2 = new t.a2(e2.z, i2, e2.z, e2.x, e2.y), h2 = r2.terrain.getMinMaxElevation(c2);
              n2 = null !== (o2 = h2.minElevation) && void 0 !== o2 ? o2 : Math.min(0, a2), l2 = null !== (s2 = h2.maxElevation) && void 0 !== s2 ? s2 : Math.max(0, a2);
            }
            if (n2 /= t.bE, l2 /= t.bE, n2 += 1, l2 += 1, e2.z <= 0) return Pi2.fromAabb([-l2, -l2, -l2], [l2, l2, l2]);
            if (1 === e2.z) return Pi2.fromAabb([0 === e2.x ? -l2 : 0, 0 === e2.y ? 0 : -l2, -l2], [0 === e2.x ? 0 : l2, 0 === e2.y ? l2 : 0, l2]);
            {
              const i3 = [pi2(0, 0, e2.x, e2.y, e2.z), pi2(t.a5, 0, e2.x, e2.y, e2.z), pi2(t.a5, t.a5, e2.x, e2.y, e2.z), pi2(0, t.a5, e2.x, e2.y, e2.z)], a3 = [];
              for (const e3 of i3) a3.push(t.a$([], e3, l2));
              if (l2 !== n2) for (const e3 of i3) a3.push(t.a$([], e3, n2));
              0 === e2.y && a3.push([0, 1, 0]), e2.y === (1 << e2.z) - 1 && a3.push([0, -1, 0]);
              const r3 = [1, 1, 1], o3 = [-1, -1, -1];
              for (const e3 of a3) for (let t2 = 0; t2 < 3; t2++) r3[t2] = Math.min(r3[t2], e3[t2]), o3[t2] = Math.max(o3[t2], e3[t2]);
              const s3 = pi2(t.a5 / 2, t.a5 / 2, e2.x, e2.y, e2.z), c2 = t.b4([], [0, 1, 0], s3);
              t.b3(c2, c2);
              const h2 = t.b4([], s3, c2);
              t.b3(h2, h2);
              const u2 = t.b4([], i3[2], i3[1]);
              t.b3(u2, u2);
              const d2 = t.b4([], i3[0], i3[3]);
              t.b3(d2, d2), a3.push(t.a$([], s3, l2)), e2.y >= (1 << e2.z) / 2 && a3.push(t.a$([], pi2(t.a5 / 2, 0, e2.x, e2.y, e2.z), l2)), e2.y < (1 << e2.z) / 2 && a3.push(t.a$([], pi2(t.a5 / 2, t.a5, e2.x, e2.y, e2.z), l2));
              const _3 = Ei(s3, a3), p2 = Ei(h2, a3), m2 = [-s3[0], -s3[1], -s3[2], _3.max], f3 = [s3[0], s3[1], s3[2], -_3.min], g2 = [-h2[0], -h2[1], -h2[2], p2.max], v2 = [h2[0], h2[1], h2[2], -p2.min], x2 = [...u2, 0], b2 = [...d2, 0], y3 = [];
              return 0 === e2.y ? y3.push(t.bD(b2, x2, m2), t.bD(b2, x2, f3)) : y3.push(t.bD(g2, x2, m2), t.bD(g2, x2, f3), t.bD(g2, b2, m2), t.bD(g2, b2, f3)), e2.y === (1 << e2.z) - 1 ? y3.push(t.bD(b2, x2, m2), t.bD(b2, x2, f3)) : y3.push(t.bD(v2, x2, m2), t.bD(v2, x2, f3), t.bD(v2, b2, m2), t.bD(v2, b2, f3)), new Pi2(y3, [m2, f3, g2, v2, x2, b2], r3, o3);
            }
          }
        }
        function Ei(e2, i2) {
          let a2 = 1 / 0, r2 = -1 / 0;
          for (const o2 of i2) {
            const i3 = t.b5(e2, o2);
            a2 = Math.min(a2, i3), r2 = Math.max(r2, i3);
          }
          return { min: a2, max: r2 };
        }
        class Si2 {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e2) {
            this._helper.setMinZoom(e2);
          }
          setMaxZoom(e2) {
            this._helper.setMaxZoom(e2);
          }
          setMinPitch(e2) {
            this._helper.setMinPitch(e2);
          }
          setMaxPitch(e2) {
            this._helper.setMaxPitch(e2);
          }
          setRenderWorldCopies(e2) {
            this._helper.setRenderWorldCopies(e2);
          }
          setBearing(e2) {
            this._helper.setBearing(e2);
          }
          setPitch(e2) {
            this._helper.setPitch(e2);
          }
          setRoll(e2) {
            this._helper.setRoll(e2);
          }
          setFov(e2) {
            this._helper.setFov(e2);
          }
          setZoom(e2) {
            this._helper.setZoom(e2);
          }
          setCenter(e2) {
            this._helper.setCenter(e2);
          }
          setElevation(e2) {
            this._helper.setElevation(e2);
          }
          setMinElevationForCurrentTile(e2) {
            this._helper.setMinElevationForCurrentTile(e2);
          }
          setPadding(e2) {
            this._helper.setPadding(e2);
          }
          interpolatePadding(e2, t2, i2) {
            return this._helper.interpolatePadding(e2, t2, i2);
          }
          isPaddingEqual(e2) {
            return this._helper.isPaddingEqual(e2);
          }
          resize(e2, t2) {
            this._helper.resize(e2, t2);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e2) {
            this._helper.setMaxBounds(e2);
          }
          setConstrainOverride(e2) {
            this._helper.setConstrainOverride(e2);
          }
          overrideNearFarZ(e2, t2) {
            this._helper.overrideNearFarZ(e2, t2);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e2) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e2) {
          }
          constructor(e2) {
            this._cachedClippingPlane = t.bF(), this._projectionMatrix = t.bj(), this._globeViewProjMatrix32f = t.bi(), this._globeViewProjMatrixNoCorrection = t.bj(), this._globeViewProjMatrixNoCorrectionInverted = t.bj(), this._globeProjMatrixInverted = t.bj(), this._cameraPosition = t.bz(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (e3, i2) => {
              const a2 = t.an(e3.lat, -t.ao, t.ao), r2 = t.an(+i2, this.minZoom + xi(0, a2), this.maxZoom);
              return { center: new t.V(e3.lng, a2), zoom: r2 };
            }, this.applyConstrain = (e3, t2) => this._helper.applyConstrain(e3, t2), this._helper = new Ut2({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (e3, t2) => this.defaultConstrain(e3, t2) }, e2), this._coveringTilesDetailsProvider = new Mi();
          }
          clone() {
            const e2 = new Si2();
            return e2.apply(this, false), e2;
          }
          apply(e2, t2, i2) {
            this._globeLatitudeErrorCorrectionRadians = i2 || 0, this._helper.apply(e2, t2);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e2 = t.bz();
            return e2[0] = this._cameraPosition[0], e2[1] = this._cameraPosition[1], e2[2] = this._cameraPosition[2], e2;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e2) {
            const { overscaledTileID: t2, applyGlobeMatrix: i2 } = e2, a2 = this._helper.getMercatorTileCoordinates(t2);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: a2, clippingPlane: this._cachedClippingPlane, projectionTransition: i2 ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e2) {
            const i2 = this.pitchInRadians, a2 = this.cameraToCenterDistance / e2, r2 = Math.sin(i2) * a2, o2 = Math.cos(i2) * a2 + 1, s2 = 1 / Math.sqrt(r2 * r2 + o2 * o2) * 1;
            let n2 = -r2, l2 = o2;
            const c2 = Math.sqrt(n2 * n2 + l2 * l2);
            n2 /= c2, l2 /= c2;
            const h2 = [0, n2, l2];
            t.bG(h2, h2, [0, 0, 0], -this.bearingInRadians), t.bH(h2, h2, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), t.bI(h2, h2, [0, 0, 0], this.center.lng * Math.PI / 180);
            const u2 = 1 / t.b7(h2);
            return t.a$(h2, h2, u2), [...h2, -s2 * u2];
          }
          isLocationOccluded(e2) {
            return !this.isSurfacePointVisible(mi2(e2));
          }
          transformLightDirection(e2) {
            const i2 = this._helper._center.lng * Math.PI / 180, a2 = this._helper._center.lat * Math.PI / 180, r2 = Math.cos(a2), o2 = [Math.sin(i2) * r2, Math.sin(a2), Math.cos(i2) * r2], s2 = [o2[2], 0, -o2[0]], n2 = [0, 0, 0];
            t.b4(n2, s2, o2), t.b3(s2, s2), t.b3(n2, n2);
            const l2 = [0, 0, 0];
            return t.b3(l2, [s2[0] * e2[0] + n2[0] * e2[1] + o2[0] * e2[2], s2[1] * e2[0] + n2[1] * e2[1] + o2[1] * e2[2], s2[2] * e2[0] + n2[2] * e2[1] + o2[2] * e2[2]]), l2;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e2, i2, a2) {
            const r2 = (function(e3, i3, a3) {
              const r3 = 1 / (1 << a3.z);
              return new t.a9(e3 / t.a5 * r3 + a3.x * r3, i3 / t.a5 * r3 + a3.y * r3);
            })(e2, i2, a2.canonical), o2 = (s2 = r2.y, [t.by(r2.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s2 * Math.PI * 2)) - 0.5 * Math.PI]);
            var s2;
            return this.getCircleRadiusCorrection() / Math.cos(o2[1]);
          }
          projectTileCoordinates(e2, i2, a2, r2) {
            const o2 = a2.canonical, s2 = pi2(e2, i2, o2.x, o2.y, o2.z), n2 = 1 + (r2 ? r2(e2, i2) : 0) / t.bE, l2 = [s2[0] * n2, s2[1] * n2, s2[2] * n2, 1];
            t.aH(l2, l2, this._globeViewProjMatrixNoCorrection);
            const c2 = this._cachedClippingPlane, h2 = c2[0] * s2[0] + c2[1] * s2[1] + c2[2] * s2[2] + c2[3] < 0;
            return { point: new t.P(l2[0] / l2[3], l2[1] / l2[3]), signedDistanceFromCamera: l2[3], isOccluded: h2 };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e2 = fi2(this.worldSize, this.center.lat), i2 = t.bk(), a2 = t.bk();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e2), t.be(i2, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const r2 = this.centerOffset;
            i2[8] = 2 * -r2.x / this._helper._width, i2[9] = 2 * r2.y / this._helper._height, this._projectionMatrix = t.bf(i2), this._globeProjMatrixInverted = t.bk(), t.aB(this._globeProjMatrixInverted, i2), t.O(i2, i2, [0, 0, -this.cameraToCenterDistance]), t.bg(i2, i2, this.rollInRadians), t.bh(i2, i2, -this.pitchInRadians), t.bg(i2, i2, this.bearingInRadians), t.O(i2, i2, [0, 0, -e2]);
            const o2 = t.bz();
            o2[0] = e2, o2[1] = e2, o2[2] = e2, t.bh(a2, i2, this.center.lat * Math.PI / 180), t.bJ(a2, a2, -this.center.lng * Math.PI / 180), t.Q(a2, a2, o2), this._globeViewProjMatrixNoCorrection = a2, t.bh(i2, i2, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bJ(i2, i2, -this.center.lng * Math.PI / 180), t.Q(i2, i2, o2), this._globeViewProjMatrix32f = new Float32Array(i2), this._globeViewProjMatrixNoCorrectionInverted = t.bk(), t.aB(this._globeViewProjMatrixNoCorrectionInverted, a2);
            const s2 = t.bz();
            this._cameraPosition = t.bz(), this._cameraPosition[2] = this.cameraToCenterDistance / e2, t.bG(this._cameraPosition, this._cameraPosition, s2, -this.rollInRadians), t.bH(this._cameraPosition, this._cameraPosition, s2, this.pitchInRadians), t.bG(this._cameraPosition, this._cameraPosition, s2, -this.bearingInRadians), t.b0(this._cameraPosition, this._cameraPosition, [0, 0, 1]), t.bH(this._cameraPosition, this._cameraPosition, s2, -this.center.lat * Math.PI / 180), t.bI(this._cameraPosition, this._cameraPosition, s2, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e2);
            const n2 = t.bf(this._globeViewProjMatrixNoCorrectionInverted);
            t.Q(n2, n2, [1, 1, -1]), this._cachedFrustum = Wt2.fromInvProjectionMatrix(n2, 1, 0, this._cachedClippingPlane, true);
          }
          calculateFogMatrix(e2) {
            t.w("calculateFogMatrix is not supported on globe projection.");
            const i2 = t.bk();
            return t.ar(i2), i2;
          }
          getVisibleUnwrappedCoordinates(e2) {
            return [new t.bc(0, e2)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e2) {
            e2 && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e2, i2) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const a2 = mi2(e2);
            t.a$(a2, a2, 1 + i2 / t.bE);
            const r2 = t.bF();
            return t.aH(r2, [a2[0], a2[1], a2[2], 1], this._globeViewProjMatrixNoCorrection), r2[2] / r2[3];
          }
          populateCache(e2) {
          }
          getBounds() {
            const e2 = 0.5 * this.width, i2 = 0.5 * this.height, a2 = [new t.P(0, 0), new t.P(e2, 0), new t.P(this.width, 0), new t.P(this.width, i2), new t.P(this.width, this.height), new t.P(e2, this.height), new t.P(0, this.height), new t.P(0, i2)], r2 = [];
            for (const e3 of a2) r2.push(this.unprojectScreenPoint(e3));
            let o2 = 0, s2 = 0, n2 = 0, l2 = 0;
            const c2 = this.center;
            for (const e3 of r2) {
              const i3 = t.bK(c2.lng, e3.lng), a3 = t.bK(c2.lat, e3.lat);
              i3 < s2 && (s2 = i3), i3 > o2 && (o2 = i3), a3 < l2 && (l2 = a3), a3 > n2 && (n2 = a3);
            }
            const h2 = [c2.lng + s2, c2.lat + l2, c2.lng + o2, c2.lat + n2];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (h2[3] = 90, h2[0] = -180, h2[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (h2[1] = -90, h2[0] = -180, h2[2] = 180), new $2(h2);
          }
          calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2);
          }
          setLocationAtPoint(e2, i2) {
            const a2 = mi2(this.unprojectScreenPoint(i2)), r2 = mi2(e2), o2 = t.bz();
            t.bL(o2);
            const s2 = t.bz();
            t.bI(s2, a2, o2, -this.center.lng * Math.PI / 180), t.bH(s2, s2, o2, this.center.lat * Math.PI / 180);
            const n2 = r2[0] * r2[0] + r2[2] * r2[2], l2 = s2[0] * s2[0];
            if (n2 < l2) return;
            const c2 = Math.sqrt(n2 - l2), h2 = -c2, u2 = t.bM(r2[0], r2[2], s2[0], c2), d2 = t.bM(r2[0], r2[2], s2[0], h2), _3 = t.bz();
            t.bI(_3, r2, o2, -u2);
            const p2 = t.bM(_3[1], _3[2], s2[1], s2[2]), m2 = t.bz();
            t.bI(m2, r2, o2, -d2);
            const f3 = t.bM(m2[1], m2[2], s2[1], s2[2]), g2 = 0.5 * Math.PI, v2 = p2 >= -g2 && p2 <= g2, x2 = f3 >= -g2 && f3 <= g2;
            let b2, y3;
            if (v2 && x2) {
              const e3 = this.center.lng * Math.PI / 180, i3 = this.center.lat * Math.PI / 180;
              t.bN(u2, e3) + t.bN(p2, i3) < t.bN(d2, e3) + t.bN(f3, i3) ? (b2 = u2, y3 = p2) : (b2 = d2, y3 = f3);
            } else if (v2) b2 = u2, y3 = p2;
            else {
              if (!x2) return;
              b2 = d2, y3 = f3;
            }
            const w3 = b2 / Math.PI * 180, T3 = y3 / Math.PI * 180, P3 = this.center.lat;
            this.setCenter(new t.V(w3, t.an(T3, -90, 90))), this.setZoom(this.zoom + xi(P3, this.center.lat));
          }
          locationToScreenPoint(e2, i2) {
            const a2 = mi2(e2);
            if (i2) {
              const r2 = i2.getElevationForLngLatZoom(e2, this._helper._tileZoom);
              t.a$(a2, a2, 1 + r2 / t.bE);
            }
            return this._projectSurfacePointToScreen(a2);
          }
          _projectSurfacePointToScreen(e2) {
            const i2 = t.bF();
            return t.aH(i2, [...e2, 1], this._globeViewProjMatrixNoCorrection), i2[0] /= i2[3], i2[1] /= i2[3], new t.P((0.5 * i2[0] + 0.5) * this.width, (0.5 * -i2[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e2, i2) {
            if (i2) {
              const t2 = i2.pointCoordinate(e2);
              if (t2) return t2;
            }
            return t.a9.fromLngLat(this.unprojectScreenPoint(e2));
          }
          screenPointToLocation(e2, t2) {
            var i2;
            return null === (i2 = this.screenPointToMercatorCoordinate(e2, t2)) || void 0 === i2 ? void 0 : i2.toLngLat();
          }
          isPointOnMapSurface(e2, t2) {
            const i2 = this._cameraPosition, a2 = this.getRayDirectionFromPixel(e2);
            return !!this.rayPlanetIntersection(i2, a2);
          }
          getRayDirectionFromPixel(e2) {
            const i2 = t.bF();
            i2[0] = e2.x / this.width * 2 - 1, i2[1] = -1 * (e2.y / this.height * 2 - 1), i2[2] = 1, i2[3] = 1, t.aH(i2, i2, this._globeViewProjMatrixNoCorrectionInverted), i2[0] /= i2[3], i2[1] /= i2[3], i2[2] /= i2[3];
            const a2 = t.bz();
            a2[0] = i2[0] - this._cameraPosition[0], a2[1] = i2[1] - this._cameraPosition[1], a2[2] = i2[2] - this._cameraPosition[2];
            const r2 = t.bz();
            return t.b3(r2, a2), r2;
          }
          isSurfacePointVisible(e2) {
            const t2 = this._cachedClippingPlane;
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] >= 0;
          }
          isSurfacePointOnScreen(e2) {
            if (!this.isSurfacePointVisible(e2)) return false;
            const i2 = t.bF();
            return t.aH(i2, [...e2, 1], this._globeViewProjMatrixNoCorrection), i2[0] /= i2[3], i2[1] /= i2[3], i2[2] /= i2[3], i2[0] > -1 && i2[0] < 1 && i2[1] > -1 && i2[1] < 1 && i2[2] > -1 && i2[2] < 1;
          }
          rayPlanetIntersection(e2, i2) {
            const a2 = t.b5(e2, i2), r2 = t.bz(), o2 = t.bz();
            t.a$(o2, i2, a2), t.b2(r2, e2, o2);
            const s2 = 1 - t.b5(r2, r2);
            if (s2 < 0) return null;
            const n2 = t.b5(e2, e2) - 1, l2 = -a2 + (a2 < 0 ? 1 : -1) * Math.sqrt(s2), c2 = n2 / l2, h2 = l2;
            return { tMin: Math.min(c2, h2), tMax: Math.max(c2, h2) };
          }
          unprojectScreenPoint(e2) {
            const i2 = this._cameraPosition, a2 = this.getRayDirectionFromPixel(e2), r2 = this.rayPlanetIntersection(i2, a2);
            if (r2) {
              const e3 = t.bz();
              t.b0(e3, i2, [a2[0] * r2.tMin, a2[1] * r2.tMin, a2[2] * r2.tMin]);
              const o3 = t.bz();
              return t.b3(o3, e3), gi2(o3);
            }
            const o2 = this._cachedClippingPlane, s2 = o2[0] * a2[0] + o2[1] * a2[1] + o2[2] * a2[2], n2 = -t.bb(o2, i2) / s2, l2 = t.bz();
            if (n2 > 0) t.b0(l2, i2, [a2[0] * n2, a2[1] * n2, a2[2] * n2]);
            else {
              const e3 = t.bz();
              t.b0(e3, i2, [2 * a2[0], 2 * a2[1], 2 * a2[2]]);
              const r3 = t.bb(this._cachedClippingPlane, e3);
              t.b2(l2, e3, [this._cachedClippingPlane[0] * r3, this._cachedClippingPlane[1] * r3, this._cachedClippingPlane[2] * r3]);
            }
            const c2 = (function(e3) {
              const i3 = t.bz();
              return i3[0] = e3[0] * -e3[3], i3[1] = e3[1] * -e3[3], i3[2] = e3[2] * -e3[3], { center: i3, radius: Math.sqrt(1 - e3[3] * e3[3]) };
            })(o2);
            return gi2((function(e3, i3, a3) {
              const r3 = t.bz();
              t.b2(r3, a3, e3);
              const o3 = t.bz();
              return t.bA(o3, e3, r3, i3 / t.b9(r3)), o3;
            })(c2.center, c2.radius, l2));
          }
          getMatrixForModel(e2, i2) {
            const a2 = t.V.convert(e2), r2 = 1 / t.bE, o2 = t.bj();
            return t.bJ(o2, o2, a2.lng / 180 * Math.PI), t.bh(o2, o2, -a2.lat / 180 * Math.PI), t.O(o2, o2, [0, 0, 1 + i2 / t.bE]), t.bh(o2, o2, 0.5 * Math.PI), t.Q(o2, o2, [r2, r2, r2]), o2;
          }
          getProjectionDataForCustomLayer(e2 = true) {
            const i2 = this.getProjectionData({ overscaledTileID: new t.a2(0, 0, 0, 0, 0), applyGlobeMatrix: e2 });
            return i2.tileMercatorCoords = [0, 0, 1, 1], i2;
          }
          getFastPathSimpleProjectionMatrix(e2) {
          }
        }
        class zi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e2) {
            this._helper.setMinZoom(e2);
          }
          setMaxZoom(e2) {
            this._helper.setMaxZoom(e2);
          }
          setMinPitch(e2) {
            this._helper.setMinPitch(e2);
          }
          setMaxPitch(e2) {
            this._helper.setMaxPitch(e2);
          }
          setRenderWorldCopies(e2) {
            this._helper.setRenderWorldCopies(e2);
          }
          setBearing(e2) {
            this._helper.setBearing(e2);
          }
          setPitch(e2) {
            this._helper.setPitch(e2);
          }
          setRoll(e2) {
            this._helper.setRoll(e2);
          }
          setFov(e2) {
            this._helper.setFov(e2);
          }
          setZoom(e2) {
            this._helper.setZoom(e2);
          }
          setCenter(e2) {
            this._helper.setCenter(e2);
          }
          setElevation(e2) {
            this._helper.setElevation(e2);
          }
          setMinElevationForCurrentTile(e2) {
            this._helper.setMinElevationForCurrentTile(e2);
          }
          setPadding(e2) {
            this._helper.setPadding(e2);
          }
          interpolatePadding(e2, t2, i2) {
            return this._helper.interpolatePadding(e2, t2, i2);
          }
          isPaddingEqual(e2) {
            return this._helper.isPaddingEqual(e2);
          }
          resize(e2, t2, i2 = true) {
            this._helper.resize(e2, t2, i2);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e2) {
            this._helper.setMaxBounds(e2);
          }
          setConstrainOverride(e2) {
            this._helper.setConstrainOverride(e2);
          }
          overrideNearFarZ(e2, t2) {
            this._helper.overrideNearFarZ(e2, t2);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e2) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e2, t2) {
            this._globeness = e2, this._globeLatitudeErrorCorrectionRadians = t2, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor(e2) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (e3, t2) => this.currentTransform.defaultConstrain(e3, t2), this.applyConstrain = (e3, t2) => this._helper.applyConstrain(e3, t2), this._helper = new Ut2({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (e3, t2) => this.defaultConstrain(e3, t2) }, e2), this._globeness = 1, this._mercatorTransform = new $t2(), this._verticalPerspectiveTransform = new Si2();
          }
          clone() {
            const e2 = new zi();
            return e2._globeness = this._globeness, e2._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e2.apply(this, false), e2;
          }
          apply(e2, t2) {
            this._helper.apply(e2, t2), this._mercatorTransform.apply(this, false), this._verticalPerspectiveTransform.apply(this, false, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e2) {
            const t2 = this._mercatorTransform.getProjectionData(e2), i2 = this._verticalPerspectiveTransform.getProjectionData(e2);
            return { mainMatrix: this.isGlobeRendering ? i2.mainMatrix : t2.mainMatrix, clippingPlane: i2.clippingPlane, tileMercatorCoords: i2.tileMercatorCoords, projectionTransition: e2.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: t2.fallbackMatrix };
          }
          isLocationOccluded(e2) {
            return this.currentTransform.isLocationOccluded(e2);
          }
          transformLightDirection(e2) {
            return this.currentTransform.transformLightDirection(e2);
          }
          getPixelScale() {
            return t.bu(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return t.bu(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e2, i2, a2) {
            const r2 = this._mercatorTransform.getPitchedTextCorrection(e2, i2, a2), o2 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e2, i2, a2);
            return t.bu(r2, o2, this._globeness);
          }
          projectTileCoordinates(e2, t2, i2, a2) {
            return this.currentTransform.projectTileCoordinates(e2, t2, i2, a2);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, false, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e2) {
            return this.currentTransform.calculateFogMatrix(e2);
          }
          getVisibleUnwrappedCoordinates(e2) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e2);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e2) {
            this._mercatorTransform.recalculateZoomAndCenter(e2), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e2);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e2, t2) {
            return this.currentTransform.lngLatToCameraDepth(e2, t2);
          }
          populateCache(e2) {
            this._mercatorTransform.populateCache(e2), this._verticalPerspectiveTransform.populateCache(e2);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2);
          }
          setLocationAtPoint(e2, t2) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e2, t2), void this.apply(this._mercatorTransform, false);
            this._verticalPerspectiveTransform.setLocationAtPoint(e2, t2), this.apply(this._verticalPerspectiveTransform, false);
          }
          locationToScreenPoint(e2, t2) {
            return this.currentTransform.locationToScreenPoint(e2, t2);
          }
          screenPointToMercatorCoordinate(e2, t2) {
            return this.currentTransform.screenPointToMercatorCoordinate(e2, t2);
          }
          screenPointToLocation(e2, t2) {
            return this.currentTransform.screenPointToLocation(e2, t2);
          }
          isPointOnMapSurface(e2, t2) {
            return this.currentTransform.isPointOnMapSurface(e2, t2);
          }
          getRayDirectionFromPixel(e2) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e2);
          }
          getMatrixForModel(e2, t2) {
            return this.currentTransform.getMatrixForModel(e2, t2);
          }
          getProjectionDataForCustomLayer(e2 = true) {
            const t2 = this._mercatorTransform.getProjectionDataForCustomLayer(e2);
            if (!this.isGlobeRendering) return t2;
            const i2 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e2);
            return i2.fallbackMatrix = t2.mainMatrix, i2;
          }
          getFastPathSimpleProjectionMatrix(e2) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e2);
          }
        }
        class Ri {
          get useGlobeControls() {
            return true;
          }
          handlePanInertia(e2, i2) {
            const a2 = bi2(e2, i2);
            return Math.abs(a2.lng - i2.center.lng) > 180 && (a2.lng = i2.center.lng + 179.5 * Math.sign(a2.lng - i2.center.lng)), { easingCenter: a2, easingOffset: new t.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e2, i2) {
            const a2 = e2.around, r2 = i2.screenPointToLocation(a2);
            e2.bearingDelta && i2.setBearing(i2.bearing + e2.bearingDelta), e2.pitchDelta && i2.setPitch(i2.pitch + e2.pitchDelta), e2.rollDelta && i2.setRoll(i2.roll + e2.rollDelta);
            const o2 = i2.zoom;
            e2.zoomDelta && i2.setZoom(i2.zoom + e2.zoomDelta);
            const s2 = i2.zoom - o2;
            if (0 === s2) return;
            const n2 = t.bK(i2.center.lng, r2.lng), l2 = n2 / (Math.abs(n2 / 180) + 1), c2 = t.bK(i2.center.lat, r2.lat), h2 = i2.getRayDirectionFromPixel(a2), u2 = i2.cameraPosition, d2 = -1 * t.b5(u2, h2), _3 = t.bz();
            t.b0(_3, u2, [h2[0] * d2, h2[1] * d2, h2[2] * d2]);
            const p2 = t.b7(_3) - 1, m2 = Math.exp(0.5 * -Math.max(p2 - 0.3, 0)), f3 = fi2(i2.worldSize, i2.center.lat) / Math.min(i2.width, i2.height), g2 = t.bx(f3, 0.9, 0.5, 1, 0.25), v2 = (1 - t.aq(-s2)) * Math.min(m2, g2), x2 = i2.center.lat, b2 = i2.zoom, y3 = new t.V(i2.center.lng + l2 * v2, t.an(i2.center.lat + c2 * v2, -t.ao, t.ao));
            i2.setLocationAtPoint(r2, a2);
            const w3 = i2.center, T3 = t.bx(Math.abs(n2), 45, 85, 0, 1), P3 = t.bx(f3, 0.75, 0.35, 0, 1), C2 = Math.pow(Math.max(T3, P3), 0.25), I3 = t.bK(w3.lng, y3.lng), M3 = t.bK(w3.lat, y3.lat);
            i2.setCenter(new t.V(w3.lng + I3 * C2, w3.lat + M3 * C2).wrap()), i2.setZoom(b2 + xi(x2, i2.center.lat));
          }
          handleMapControlsPan(e2, t2, i2) {
            if (!e2.panDelta) return;
            const a2 = t2.center.lat, r2 = t2.zoom;
            t2.setCenter(bi2(e2.panDelta, t2).wrap()), t2.setZoom(r2 + xi(a2, t2.center.lat));
          }
          cameraForBoxAndBearing(e2, i2, a2, r2, o2) {
            const s2 = Kt2(e2, i2, a2, r2, o2), n2 = i2.left / o2.width * 2 - 1, l2 = (o2.width - i2.right) / o2.width * 2 - 1, c2 = i2.top / o2.height * -2 + 1, h2 = (o2.height - i2.bottom) / o2.height * -2 + 1, u2 = t.bK(a2.getWest(), a2.getEast()) < 0, d2 = u2 ? a2.getEast() : a2.getWest(), _3 = u2 ? a2.getWest() : a2.getEast(), p2 = Math.max(a2.getNorth(), a2.getSouth()), m2 = Math.min(a2.getNorth(), a2.getSouth()), f3 = d2 + 0.5 * t.bK(d2, _3), g2 = p2 + 0.5 * t.bK(p2, m2), v2 = o2.clone();
            v2.setCenter(s2.center), v2.setBearing(s2.bearing), v2.setPitch(0), v2.setRoll(0), v2.setZoom(s2.zoom);
            const x2 = v2.modelViewProjectionMatrix, b2 = [mi2(a2.getNorthWest()), mi2(a2.getNorthEast()), mi2(a2.getSouthWest()), mi2(a2.getSouthEast()), mi2(new t.V(_3, g2)), mi2(new t.V(d2, g2)), mi2(new t.V(f3, p2)), mi2(new t.V(f3, m2))], y3 = mi2(s2.center);
            let w3 = Number.POSITIVE_INFINITY;
            for (const e3 of b2) n2 < 0 && (w3 = Ri.getLesserNonNegativeNonNull(w3, Ri.solveVectorScale(e3, y3, x2, "x", n2))), l2 > 0 && (w3 = Ri.getLesserNonNegativeNonNull(w3, Ri.solveVectorScale(e3, y3, x2, "x", l2))), c2 > 0 && (w3 = Ri.getLesserNonNegativeNonNull(w3, Ri.solveVectorScale(e3, y3, x2, "y", c2))), h2 < 0 && (w3 = Ri.getLesserNonNegativeNonNull(w3, Ri.solveVectorScale(e3, y3, x2, "y", h2)));
            if (Number.isFinite(w3) && 0 !== w3) return s2.zoom = v2.zoom + t.at(w3), s2;
            Ht2();
          }
          handleJumpToCenterZoom(e2, i2) {
            const a2 = e2.center.lat, r2 = e2.applyConstrain(i2.center ? t.V.convert(i2.center) : e2.center, e2.zoom).center;
            e2.setCenter(r2.wrap());
            const o2 = void 0 !== i2.zoom ? +i2.zoom : e2.zoom + xi(a2, r2.lat);
            e2.zoom !== o2 && e2.setZoom(o2);
          }
          handleEaseTo(e2, i2) {
            const a2 = e2.zoom, r2 = e2.center, o2 = e2.padding, s2 = { roll: e2.roll, pitch: e2.pitch, bearing: e2.bearing }, n2 = { roll: void 0 === i2.roll ? e2.roll : i2.roll, pitch: void 0 === i2.pitch ? e2.pitch : i2.pitch, bearing: void 0 === i2.bearing ? e2.bearing : i2.bearing }, l2 = void 0 !== i2.zoom, c2 = !e2.isPaddingEqual(i2.padding);
            let h2 = false;
            const u2 = i2.center ? t.V.convert(i2.center) : r2, d2 = e2.applyConstrain(u2, a2).center;
            Zt2(e2, d2);
            const _3 = e2.clone();
            _3.setCenter(d2), _3.setZoom(l2 ? +i2.zoom : a2 + xi(r2.lat, u2.lat)), _3.setBearing(i2.bearing);
            const p2 = new t.P(t.an(e2.centerPoint.x + i2.offsetAsPoint.x, 0, e2.width), t.an(e2.centerPoint.y + i2.offsetAsPoint.y, 0, e2.height));
            _3.setLocationAtPoint(d2, p2);
            const m2 = (i2.offset && i2.offsetAsPoint.mag()) > 0 ? _3.center : d2, f3 = l2 ? +i2.zoom : a2 + xi(r2.lat, m2.lat), g2 = a2 + xi(r2.lat, 0), v2 = f3 + xi(m2.lat, 0), x2 = t.bK(r2.lng, m2.lng), b2 = t.bK(r2.lat, m2.lat), y3 = t.aq(v2 - g2);
            return h2 = f3 !== a2, { easeFunc: (a3) => {
              if (t.bo(s2, n2) || Xt2({ startEulerAngles: s2, endEulerAngles: n2, tr: e2, k: a3, useSlerp: s2.roll != n2.roll }), c2 && e2.interpolatePadding(o2, i2.padding, a3), i2.around) t.w("Easing around a point is not supported under globe projection."), e2.setLocationAtPoint(i2.around, i2.aroundPoint);
              else {
                const t2 = v2 > g2 ? Math.min(2, y3) : Math.max(0.5, y3), i3 = Math.pow(t2, 1 - a3), o3 = wi2(r2, x2, b2, a3 * i3);
                e2.setCenter(o3.wrap());
              }
              if (h2) {
                const i3 = t.G.number(g2, v2, a3) + xi(0, e2.center.lat);
                e2.setZoom(i3);
              }
            }, isZooming: h2, elevationCenter: m2 };
          }
          handleFlyTo(e2, i2) {
            const a2 = void 0 !== i2.zoom, r2 = e2.center, o2 = e2.zoom, s2 = e2.padding, n2 = !e2.isPaddingEqual(i2.padding), l2 = e2.applyConstrain(t.V.convert(i2.center || i2.locationAtOffset), o2).center, c2 = a2 ? +i2.zoom : e2.zoom + xi(e2.center.lat, l2.lat), h2 = e2.clone();
            h2.setCenter(l2), h2.setZoom(c2), h2.setBearing(i2.bearing);
            const u2 = new t.P(t.an(e2.centerPoint.x + i2.offsetAsPoint.x, 0, e2.width), t.an(e2.centerPoint.y + i2.offsetAsPoint.y, 0, e2.height));
            h2.setLocationAtPoint(l2, u2);
            const d2 = h2.center;
            Zt2(e2, d2);
            const _3 = (function(e3, i3, a3) {
              const r3 = mi2(i3), o3 = mi2(a3), s3 = t.b5(r3, o3), n3 = Math.acos(s3), l3 = _i2(e3);
              return n3 / (2 * Math.PI) * l3;
            })(e2, r2, d2), p2 = o2 + xi(r2.lat, 0), m2 = c2 + xi(d2.lat, 0), f3 = t.aq(m2 - p2);
            let g2;
            if ("number" == typeof i2.minZoom) {
              const a3 = +i2.minZoom + xi(d2.lat, 0), r3 = Math.min(a3, p2, m2) + xi(0, d2.lat), o3 = e2.applyConstrain(d2, r3).zoom + xi(d2.lat, 0);
              g2 = t.aq(o3 - p2);
            }
            const v2 = t.bK(r2.lng, d2.lng), x2 = t.bK(r2.lat, d2.lat);
            return { easeFunc: (a3, o3, l3, h3) => {
              const u3 = wi2(r2, v2, x2, l3);
              n2 && e2.interpolatePadding(s2, i2.padding, a3);
              const _4 = 1 === a3 ? d2 : u3;
              e2.setCenter(_4.wrap());
              const m3 = p2 + t.at(o3);
              e2.setZoom(1 === a3 ? c2 : m3 + xi(0, _4.lat));
            }, scaleOfZoom: f3, targetCenter: d2, scaleOfMinZoom: g2, pixelPathLength: _3 };
          }
          static solveVectorScale(e2, t2, i2, a2, r2) {
            const o2 = "x" === a2 ? [i2[0], i2[4], i2[8], i2[12]] : [i2[1], i2[5], i2[9], i2[13]], s2 = [i2[3], i2[7], i2[11], i2[15]], n2 = e2[0] * o2[0] + e2[1] * o2[1] + e2[2] * o2[2], l2 = e2[0] * s2[0] + e2[1] * s2[1] + e2[2] * s2[2], c2 = t2[0] * o2[0] + t2[1] * o2[1] + t2[2] * o2[2], h2 = t2[0] * s2[0] + t2[1] * s2[1] + t2[2] * s2[2];
            return c2 + r2 * l2 === n2 + r2 * h2 || s2[3] * (n2 - c2) + o2[3] * (h2 - l2) + n2 * h2 == c2 * l2 ? null : (c2 + o2[3] - r2 * h2 - r2 * s2[3]) / (c2 - n2 - r2 * h2 + r2 * l2);
          }
          static getLesserNonNegativeNonNull(e2, t2) {
            return null !== t2 && t2 >= 0 && t2 < e2 ? t2 : e2;
          }
        }
        class Di2 {
          constructor(e2) {
            this._globe = e2, this._mercatorCameraHelper = new Yt2(), this._verticalPerspectiveCameraHelper = new Ri();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e2, t2) {
            return this.currentHelper.handlePanInertia(e2, t2);
          }
          handleMapControlsRollPitchBearingZoom(e2, t2) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e2, t2);
          }
          handleMapControlsPan(e2, t2, i2) {
            this.currentHelper.handleMapControlsPan(e2, t2, i2);
          }
          cameraForBoxAndBearing(e2, t2, i2, a2, r2) {
            return this.currentHelper.cameraForBoxAndBearing(e2, t2, i2, a2, r2);
          }
          handleJumpToCenterZoom(e2, t2) {
            this.currentHelper.handleJumpToCenterZoom(e2, t2);
          }
          handleEaseTo(e2, t2) {
            return this.currentHelper.handleEaseTo(e2, t2);
          }
          handleFlyTo(e2, t2) {
            return this.currentHelper.handleFlyTo(e2, t2);
          }
        }
        const Ai = (e2, i2) => t.B(e2, i2 && i2.filter(((e3) => "source.canvas" !== e3.identifier))), Li = t.bO();
        class ki extends t.E {
          constructor(e2, i2 = {}) {
            var a2, r2;
            super(), this._rtlPluginLoaded = () => {
              for (const e3 in this.tileManagers) {
                const t2 = this.tileManagers[e3].getSource().type;
                "vector" !== t2 && "geojson" !== t2 || this.tileManagers[e3].reload();
              }
            }, this.map = e2, this.dispatcher = new N(j2(), e2._getMapId()), this.dispatcher.registerMessageHandler("GG", ((e3, t2) => this.getGlyphs(e3, t2))), this.dispatcher.registerMessageHandler("GI", ((e3, t2) => this.getImages(e3, t2))), this.dispatcher.registerMessageHandler("GDA", ((e3, t2) => this.getDashes(e3, t2))), this.imageManager = new w2(), this.imageManager.setEventedParent(this);
            const o2 = (null === (a2 = e2._container) || void 0 === a2 ? void 0 : a2.lang) || "undefined" != typeof document && (null === (r2 = document.documentElement) || void 0 === r2 ? void 0 : r2.lang) || void 0;
            this.glyphManager = new M2(e2._requestManager, i2.localIdeographFontFamily, o2), this.lineAtlas = new A(256, 512), this.crossTileSymbolIndex = new Rt2(), this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", t.bP()), ce2().on(se2, this._rtlPluginLoaded), this.on("data", ((e3) => {
              if ("source" !== e3.dataType || "metadata" !== e3.sourceDataType) return;
              const t2 = this.tileManagers[e3.sourceId];
              if (!t2) return;
              const i3 = t2.getSource();
              if (i3 && i3.vectorLayerIds) for (const e4 in this._layers) {
                const t3 = this._layers[e4];
                t3.source === i3.id && this._validateLayer(t3);
              }
            }));
          }
          _setInitialValues() {
            var e2;
            this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new t.bQ(), this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = false, this._changed = false, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = false, this._updatedPaintProps = {}, this._layerOrderChanged = false, this.crossTileSymbolIndex = new ((null === (e2 = this.crossTileSymbolIndex) || void 0 === e2 ? void 0 : e2.constructor) || Object)(), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0;
          }
          setGlobalStateProperty(e2, i2) {
            var a2, r2, o2;
            this._checkLoaded();
            const s2 = null === i2 ? null !== (o2 = null === (r2 = null === (a2 = this.stylesheet.state) || void 0 === a2 ? void 0 : a2[e2]) || void 0 === r2 ? void 0 : r2.default) && void 0 !== o2 ? o2 : null : i2;
            if (t.bR(s2, this._globalState[e2])) return this;
            this._globalState[e2] = s2, this._applyGlobalStateChanges([e2]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e2) {
            this._checkLoaded();
            const i2 = [];
            for (const a2 in e2) !t.bR(this._globalState[a2], e2[a2].default) && (i2.push(a2), this._globalState[a2] = e2[a2].default);
            this._applyGlobalStateChanges(i2);
          }
          _applyGlobalStateChanges(e2) {
            if (0 === e2.length) return;
            const t2 = /* @__PURE__ */ new Set(), i2 = {};
            for (const a2 of e2) {
              i2[a2] = this._globalState[a2];
              for (const e3 in this._layers) {
                const i3 = this._layers[e3], r2 = i3.getLayoutAffectingGlobalStateRefs(), o2 = i3.getPaintAffectingGlobalStateRefs(), s2 = i3.getVisibilityAffectingGlobalStateRefs();
                if (r2.has(a2) && t2.add(i3.source), o2.has(a2)) for (const { name: e4, value: t3 } of o2.get(a2)) this._updatePaintProperty(i3, e4, t3);
                (null == s2 ? void 0 : s2.has(a2)) && (i3.recalculateVisibility(), this._updateLayer(i3));
              }
            }
            this.dispatcher.broadcast("UGS", i2);
            for (const e3 in this.tileManagers) t2.has(e3) && (this._reloadSource(e3), this._changed = true);
          }
          loadURL(e2, i2 = {}, a2) {
            this.fire(new t.l("dataloading", { dataType: "style" })), i2.validate = "boolean" != typeof i2.validate || i2.validate;
            const r2 = this.map._requestManager.transformRequest(e2, "Style");
            this._loadStyleRequest = new AbortController();
            const o2 = this._loadStyleRequest;
            t.j(r2, this._loadStyleRequest).then(((e3) => {
              this._loadStyleRequest = null, this._load(e3.data, i2, a2);
            })).catch(((e3) => {
              this._loadStyleRequest = null, e3 && !o2.signal.aborted && this.fire(new t.k(e3));
            }));
          }
          loadJSON(e2, i2 = {}, a2) {
            this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), n.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, i2.validate = false !== i2.validate, this._load(e2, i2, a2);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new t.l("dataloading", { dataType: "style" })), this._load(Li, { validate: false });
          }
          _load(e2, i2, a2) {
            var r2, o2;
            let s2 = i2.transformStyle ? i2.transformStyle(a2, e2) : e2;
            if (!i2.validate || !Ai(this, t.C(s2))) {
              s2 = Object.assign({}, s2), this._loaded = true, this.stylesheet = s2;
              for (const e3 in s2.sources) this.addSource(e3, s2.sources[e3], { validate: false });
              s2.sprite ? this._loadSprite(s2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(s2.glyphs), this._createLayers(), this.light = new z2(this.stylesheet.light), this._setProjectionInternal((null === (r2 = this.stylesheet.projection) || void 0 === r2 ? void 0 : r2.type) || "mercator"), this.sky = new D2(this.stylesheet.sky), this.map.setTerrain(null !== (o2 = this.stylesheet.terrain) && void 0 !== o2 ? o2 : null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
            }
          }
          _createLayers() {
            var e2, i2, a2;
            const r2 = t.bS(this.stylesheet.layers);
            this.setGlobalState(null !== (e2 = this.stylesheet.state) && void 0 !== e2 ? e2 : null), this.dispatcher.broadcast("SL", r2), this._order = r2.map(((e3) => e3.id)), this._layers = {}, this._serializedLayers = null;
            for (const e3 of r2) {
              const r3 = t.bT(e3, this._globalState);
              if (r3.setEventedParent(this, { layer: { id: e3.id } }), this._layers[e3.id] = r3, t.bU(r3) && this.tileManagers[r3.source]) {
                const t2 = null !== (a2 = null === (i2 = e3.paint) || void 0 === i2 ? void 0 : i2["raster-fade-duration"]) && void 0 !== a2 ? a2 : r3.paint.get("raster-fade-duration");
                this.tileManagers[r3.source].setRasterFadeDuration(t2);
              }
            }
          }
          _loadSprite(e2, i2 = false, a2 = void 0) {
            this.imageManager.setLoaded(false);
            const r2 = new AbortController();
            let o2;
            this._spriteRequest = r2, (function(e3, i3, a3, r3) {
              return t._(this, void 0, void 0, (function* () {
                const o3 = x(e3), s2 = a3 > 1 ? "@2x" : "", l2 = {}, c2 = {};
                for (const { id: e4, url: a4 } of o3) {
                  const o4 = i3.transformRequest(b(a4, s2, ".json"), "SpriteJSON");
                  l2[e4] = t.j(o4, r3);
                  const n2 = i3.transformRequest(b(a4, s2, ".png"), "SpriteImage");
                  c2[e4] = g.getImage(n2, r3);
                }
                return yield Promise.all([...Object.values(l2), ...Object.values(c2)]), (function(e4, i4) {
                  return t._(this, void 0, void 0, (function* () {
                    const t2 = {};
                    for (const a4 in e4) {
                      t2[a4] = {};
                      const r4 = n.getImageCanvasContext((yield i4[a4]).data), o4 = (yield e4[a4]).data;
                      for (const e5 in o4) {
                        const { width: i5, height: s3, x: n2, y: l3, sdf: c3, pixelRatio: h2, stretchX: u2, stretchY: d2, content: _3, textFitWidth: p2, textFitHeight: m2 } = o4[e5];
                        t2[a4][e5] = { data: null, pixelRatio: h2, sdf: c3, stretchX: u2, stretchY: d2, content: _3, textFitWidth: p2, textFitHeight: m2, spriteData: { width: i5, height: s3, x: n2, y: l3, context: r4 } };
                      }
                    }
                    return t2;
                  }));
                })(l2, c2);
              }));
            })(e2, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((e3) => {
              if (this._spriteRequest = null, e3) for (const t2 in e3) {
                this._spritesImagesIds[t2] = [];
                const a3 = this._spritesImagesIds[t2] ? this._spritesImagesIds[t2].filter(((t3) => !(t3 in e3))) : [];
                for (const e4 of a3) this.imageManager.removeImage(e4), this._changedImages[e4] = true;
                for (const a4 in e3[t2]) {
                  const r3 = "default" === t2 ? a4 : `${t2}:${a4}`;
                  this._spritesImagesIds[t2].push(r3), r3 in this.imageManager.images ? this.imageManager.updateImage(r3, e3[t2][a4], false) : this.imageManager.addImage(r3, e3[t2][a4]), i2 && (this._changedImages[r3] = true);
                }
              }
            })).catch(((e3) => {
              this._spriteRequest = null, o2 = e3, r2.signal.aborted || this.fire(new t.k(o2));
            })).finally((() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i2 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), a2 && a2(o2);
            }));
          }
          _unloadSprite() {
            for (const e2 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e2), this._changedImages[e2] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
          }
          _validateLayer(e2) {
            const i2 = this.tileManagers[e2.source];
            if (!i2) return;
            const a2 = e2.sourceLayer;
            if (!a2) return;
            const r2 = i2.getSource();
            ("geojson" === r2.type || r2.vectorLayerIds && -1 === r2.vectorLayerIds.indexOf(a2)) && this.fire(new t.k(new Error(`Source layer "${a2}" does not exist on source "${r2.id}" as specified by style layer "${e2.id}".`)));
          }
          loaded() {
            if (!this._loaded) return false;
            if (Object.keys(this._updatedSources).length) return false;
            for (const e2 in this.tileManagers) if (!this.tileManagers[e2].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e2, i2 = false) {
            const a2 = this._serializedAllLayers();
            if (!e2 || 0 === e2.length) return Object.values(i2 ? t.bV(a2) : a2);
            const r2 = [];
            for (const o2 of e2) if (a2[o2]) {
              const e3 = i2 ? t.bV(a2[o2]) : a2[o2];
              r2.push(e3);
            }
            return r2;
          }
          _serializedAllLayers() {
            let e2 = this._serializedLayers;
            if (e2) return e2;
            e2 = this._serializedLayers = {};
            const t2 = Object.keys(this._layers);
            for (const i2 of t2) {
              const t3 = this._layers[i2];
              "custom" !== t3.type && (e2[i2] = t3.serialize());
            }
            return e2;
          }
          hasTransitions() {
            var e2, t2, i2;
            if (null === (e2 = this.light) || void 0 === e2 ? void 0 : e2.hasTransition()) return true;
            if (null === (t2 = this.sky) || void 0 === t2 ? void 0 : t2.hasTransition()) return true;
            if (null === (i2 = this.projection) || void 0 === i2 ? void 0 : i2.hasTransition()) return true;
            for (const e3 in this.tileManagers) if (this.tileManagers[e3].hasTransition()) return true;
            for (const e3 in this._layers) if (this._layers[e3].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e2) {
            if (!this._loaded) return;
            const i2 = this._changed;
            if (i2) {
              const t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
              (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
              for (const e3 in this._updatedSources) {
                const t3 = this._updatedSources[e3];
                if ("reload" === t3) this._reloadSource(e3);
                else {
                  if ("clear" !== t3) throw new Error(`Invalid action ${t3}`);
                  this._clearSource(e3);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const t3 in this._updatedPaintProps) this._layers[t3].updateTransitions(e2);
              this.light.updateTransitions(e2), this.sky.updateTransitions(e2), this._resetUpdates();
            }
            const a2 = {};
            for (const e3 in this.tileManagers) {
              const t2 = this.tileManagers[e3];
              a2[e3] = t2.used, t2.used = false;
            }
            for (const t2 of this._order) {
              const i3 = this._layers[t2];
              i3.recalculate(e2, this._availableImages), !i3.isHidden(e2.zoom) && i3.source && (this.tileManagers[i3.source].used = true);
            }
            for (const e3 in a2) {
              const i3 = this.tileManagers[e3];
              !!a2[e3] != !!i3.used && i3.fire(new t.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
            }
            this.light.recalculate(e2), this.sky.recalculate(e2), this.projection.recalculate(e2), this.z = e2.zoom, i2 && this.fire(new t.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e2 = Object.keys(this._changedImages);
            if (e2.length) {
              for (const t2 in this.tileManagers) this.tileManagers[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e2 in this.tileManagers) this.tileManagers[e2].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(e2, t2) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e2, false), removedIds: t2 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e2, i2 = {}) {
            var a2;
            this._checkLoaded();
            const r2 = this.serialize();
            if (e2 = i2.transformStyle ? i2.transformStyle(r2, e2) : e2, (null === (a2 = i2.validate) || void 0 === a2 || a2) && Ai(this, t.C(e2))) return false;
            (e2 = t.bV(e2)).layers = t.bS(e2.layers);
            const o2 = t.bW(r2, e2), s2 = this._getOperationsToPerform(o2);
            if (s2.unimplemented.length > 0) throw new Error(`Unimplemented: ${s2.unimplemented.join(", ")}.`);
            if (0 === s2.operations.length) return false;
            for (const e3 of s2.operations) e3();
            return this.stylesheet = e2, this._serializedLayers = null, this.fire(new t.l("style.load", { style: this })), true;
          }
          _getOperationsToPerform(e2) {
            const t2 = [], i2 = [];
            for (const a2 of e2) switch (a2.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                t2.push((() => this.addLayer.apply(this, a2.args)));
                break;
              case "removeLayer":
                t2.push((() => this.removeLayer.apply(this, a2.args)));
                break;
              case "setPaintProperty":
                t2.push((() => this.setPaintProperty.apply(this, a2.args)));
                break;
              case "setLayoutProperty":
                t2.push((() => this.setLayoutProperty.apply(this, a2.args)));
                break;
              case "setFilter":
                t2.push((() => this.setFilter.apply(this, a2.args)));
                break;
              case "addSource":
                t2.push((() => this.addSource.apply(this, a2.args)));
                break;
              case "removeSource":
                t2.push((() => this.removeSource.apply(this, a2.args)));
                break;
              case "setLayerZoomRange":
                t2.push((() => this.setLayerZoomRange.apply(this, a2.args)));
                break;
              case "setLight":
                t2.push((() => this.setLight.apply(this, a2.args)));
                break;
              case "setGeoJSONSourceData":
                t2.push((() => this.setGeoJSONSourceData.apply(this, a2.args)));
                break;
              case "setGlyphs":
                t2.push((() => this.setGlyphs.apply(this, a2.args)));
                break;
              case "setSprite":
                t2.push((() => this.setSprite.apply(this, a2.args)));
                break;
              case "setTerrain":
                t2.push((() => this.map.setTerrain.apply(this, a2.args)));
                break;
              case "setSky":
                t2.push((() => this.setSky.apply(this, a2.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, a2.args);
                break;
              case "setGlobalState":
                t2.push((() => this.setGlobalState.apply(this, a2.args)));
                break;
              case "setTransition":
                t2.push((() => {
                }));
                break;
              default:
                i2.push(a2.command);
            }
            return { operations: t2, unimplemented: i2 };
          }
          addImage(e2, i2) {
            if (this.getImage(e2)) return this.fire(new t.k(new Error(`An image named "${e2}" already exists.`)));
            this.imageManager.addImage(e2, i2), this._afterImageUpdated(e2);
          }
          updateImage(e2, t2) {
            this.imageManager.updateImage(e2, t2);
          }
          getImage(e2) {
            return this.imageManager.getImage(e2);
          }
          removeImage(e2) {
            if (!this.getImage(e2)) return this.fire(new t.k(new Error(`An image named "${e2}" does not exist.`)));
            this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
          }
          _afterImageUpdated(e2) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e2, i2, a2 = {}) {
            if (this._checkLoaded(), void 0 !== this.tileManagers[e2]) throw new Error(`Source "${e2}" already exists.`);
            if (!i2.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.C.source, `sources.${e2}`, i2, null, a2)) return;
            this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
            const r2 = this.tileManagers[e2] = new ke2(e2, i2, this.dispatcher);
            r2.style = this, r2.setEventedParent(this, (() => ({ isSourceLoaded: r2.loaded(), source: r2.serialize(), sourceId: e2 }))), r2.onAdd(this.map), this._changed = true;
          }
          removeSource(e2) {
            if (this._checkLoaded(), void 0 === this.tileManagers[e2]) throw new Error("There is no source with this ID");
            for (const i3 in this._layers) if (this._layers[i3].source === e2) return this.fire(new t.k(new Error(`Source "${e2}" cannot be removed while layer "${i3}" is using it.`)));
            const i2 = this.tileManagers[e2];
            delete this.tileManagers[e2], delete this._updatedSources[e2], i2.fire(new t.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(e2, t2) {
            if (this._checkLoaded(), void 0 === this.tileManagers[e2]) throw new Error(`There is no source with this ID=${e2}`);
            const i2 = this.tileManagers[e2].getSource();
            if ("geojson" !== i2.type) throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
            i2.setData(t2), this._changed = true;
          }
          getSource(e2) {
            return this.tileManagers[e2] && this.tileManagers[e2].getSource();
          }
          addLayer(e2, i2, a2 = {}) {
            this._checkLoaded();
            const r2 = e2.id;
            if (this.getLayer(r2)) return void this.fire(new t.k(new Error(`Layer "${r2}" already exists on this map.`)));
            let o2;
            if ("custom" === e2.type) {
              if (Ai(this, t.bX(e2))) return;
              o2 = t.bT(e2, this._globalState);
            } else {
              if ("source" in e2 && "object" == typeof e2.source && (this.addSource(r2, e2.source), e2 = t.bV(e2), e2 = t.e(e2, { source: r2 })), this._validate(t.C.layer, `layers.${r2}`, e2, { arrayIndex: -1 }, a2)) return;
              o2 = t.bT(e2, this._globalState), this._validateLayer(o2), o2.setEventedParent(this, { layer: { id: r2 } });
            }
            const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
            if (i2 && -1 === s2) this.fire(new t.k(new Error(`Cannot add layer "${r2}" before non-existing layer "${i2}".`)));
            else {
              if (this._order.splice(s2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = o2, this._removedLayers[r2] && o2.source && "custom" !== o2.type) {
                const e3 = this._removedLayers[r2];
                delete this._removedLayers[r2], e3.type !== o2.type ? this._updatedSources[o2.source] = "clear" : (this._updatedSources[o2.source] = "reload", this.tileManagers[o2.source].pause());
              }
              this._updateLayer(o2), o2.onAdd && o2.onAdd(this.map);
            }
          }
          moveLayer(e2, i2) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e2]) return void this.fire(new t.k(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
            if (e2 === i2) return;
            const a2 = this._order.indexOf(e2);
            this._order.splice(a2, 1);
            const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
            i2 && -1 === r2 ? this.fire(new t.k(new Error(`Cannot move layer "${e2}" before non-existing layer "${i2}".`))) : (this._order.splice(r2, 0, e2), this._layerOrderChanged = true);
          }
          removeLayer(e2) {
            this._checkLoaded();
            const i2 = this._layers[e2];
            if (!i2) return void this.fire(new t.k(new Error(`Cannot remove non-existing layer "${e2}".`)));
            i2.setEventedParent(null);
            const a2 = this._order.indexOf(e2);
            this._order.splice(a2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i2, delete this._layers[e2], this._serializedLayers && delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i2.onRemove && i2.onRemove(this.map);
          }
          getLayer(e2) {
            return this._layers[e2];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e2) {
            return e2 in this._layers;
          }
          setLayerZoomRange(e2, i2, a2) {
            this._checkLoaded();
            const r2 = this.getLayer(e2);
            r2 ? r2.minzoom === i2 && r2.maxzoom === a2 || (null != i2 && (r2.minzoom = i2), null != a2 && (r2.maxzoom = a2), this._updateLayer(r2)) : this.fire(new t.k(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
          }
          setFilter(e2, i2, a2 = {}) {
            this._checkLoaded();
            const r2 = this.getLayer(e2);
            if (r2) {
              if (!t.bR(r2.filter, i2)) return null == i2 ? (r2.setFilter(void 0), void this._updateLayer(r2)) : void (this._validate(t.C.filter, `layers.${r2.id}.filter`, i2, null, a2) || (r2.setFilter(t.bV(i2)), this._updateLayer(r2)));
            } else this.fire(new t.k(new Error(`Cannot filter non-existing layer "${e2}".`)));
          }
          getFilter(e2) {
            return t.bV(this.getLayer(e2).filter);
          }
          setLayoutProperty(e2, i2, a2, r2 = {}) {
            this._checkLoaded();
            const o2 = this.getLayer(e2);
            o2 ? t.bR(o2.getLayoutProperty(i2), a2) || (o2.setLayoutProperty(i2, a2, r2), this._updateLayer(o2)) : this.fire(new t.k(new Error(`Cannot style non-existing layer "${e2}".`)));
          }
          getLayoutProperty(e2, i2) {
            const a2 = this.getLayer(e2);
            if (a2) return a2.getLayoutProperty(i2);
            this.fire(new t.k(new Error(`Cannot get style of non-existing layer "${e2}".`)));
          }
          setPaintProperty(e2, i2, a2, r2 = {}) {
            this._checkLoaded();
            const o2 = this.getLayer(e2);
            o2 ? t.bR(o2.getPaintProperty(i2), a2) || this._updatePaintProperty(o2, i2, a2, r2) : this.fire(new t.k(new Error(`Cannot style non-existing layer "${e2}".`)));
          }
          _updatePaintProperty(e2, i2, a2, r2 = {}) {
            e2.setPaintProperty(i2, a2, r2) && this._updateLayer(e2), t.bU(e2) && "raster-fade-duration" === i2 && this.tileManagers[e2.source].setRasterFadeDuration(a2), this._changed = true, this._updatedPaintProps[e2.id] = true, this._serializedLayers = null;
          }
          getPaintProperty(e2, t2) {
            return this.getLayer(e2).getPaintProperty(t2);
          }
          setFeatureState(e2, i2) {
            this._checkLoaded();
            const a2 = e2.source, r2 = e2.sourceLayer, o2 = this.tileManagers[a2];
            if (void 0 === o2) return void this.fire(new t.k(new Error(`The source '${a2}' does not exist in the map's style.`)));
            const s2 = o2.getSource().type;
            "geojson" === s2 && r2 ? this.fire(new t.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s2 || r2 ? (void 0 === e2.id && this.fire(new t.k(new Error("The feature id parameter must be provided."))), o2.setFeatureState(r2, e2.id, i2)) : this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e2, i2) {
            this._checkLoaded();
            const a2 = e2.source, r2 = this.tileManagers[a2];
            if (void 0 === r2) return void this.fire(new t.k(new Error(`The source '${a2}' does not exist in the map's style.`)));
            const o2 = r2.getSource().type, s2 = "vector" === o2 ? e2.sourceLayer : void 0;
            "vector" !== o2 || s2 ? i2 && "string" != typeof e2.id && "number" != typeof e2.id ? this.fire(new t.k(new Error("A feature id is required to remove its specific state property."))) : r2.removeFeatureState(s2, e2.id, i2) : this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e2) {
            this._checkLoaded();
            const i2 = e2.source, a2 = e2.sourceLayer, r2 = this.tileManagers[i2];
            if (void 0 !== r2) return "vector" !== r2.getSource().type || a2 ? (void 0 === e2.id && this.fire(new t.k(new Error("The feature id parameter must be provided."))), r2.getFeatureState(a2, e2.id)) : void this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new t.k(new Error(`The source '${i2}' does not exist in the map's style.`)));
          }
          getTransition() {
            return t.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e2 = t.bY(this.tileManagers, ((e3) => e3.serialize())), i2 = this._serializeByIds(this._order, true), a2 = this.map.getTerrain() || void 0, r2 = this.stylesheet;
            return t.bZ({ version: r2.version, name: r2.name, metadata: r2.metadata, light: r2.light, sky: r2.sky, center: r2.center, zoom: r2.zoom, bearing: r2.bearing, pitch: r2.pitch, sprite: r2.sprite, glyphs: r2.glyphs, transition: r2.transition, projection: r2.projection, sources: e2, layers: i2, terrain: a2 }, ((e3) => void 0 !== e3));
          }
          _updateLayer(e2) {
            this._updatedLayers[e2.id] = true, e2.source && !this._updatedSources[e2.source] && "raster" !== this.tileManagers[e2.source].getSource().type && (this._updatedSources[e2.source] = "reload", this.tileManagers[e2.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(e2) {
            const t2 = (e3) => "fill-extrusion" === this._layers[e3].type, i2 = {}, a2 = [];
            for (let r3 = this._order.length - 1; r3 >= 0; r3--) {
              const o2 = this._order[r3];
              if (t2(o2)) {
                i2[o2] = r3;
                for (const t3 of e2) {
                  const e3 = t3[o2];
                  if (e3) for (const t4 of e3) a2.push(t4);
                }
              }
            }
            a2.sort(((e3, t3) => t3.intersectionZ - e3.intersectionZ));
            const r2 = [];
            for (let o2 = this._order.length - 1; o2 >= 0; o2--) {
              const s2 = this._order[o2];
              if (t2(s2)) for (let e3 = a2.length - 1; e3 >= 0; e3--) {
                const t3 = a2[e3].feature;
                if (i2[t3.layer.id] < o2) break;
                r2.push(t3), a2.pop();
              }
              else for (const t3 of e2) {
                const e3 = t3[s2];
                if (e3) for (const t4 of e3) r2.push(t4.feature);
              }
            }
            return r2;
          }
          queryRenderedFeatures(e2, i2, a2) {
            i2 && i2.filter && this._validate(t.C.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
            const r2 = {};
            if (i2 && i2.layers) {
              if (!(Array.isArray(i2.layers) || i2.layers instanceof Set)) return this.fire(new t.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const e3 of i2.layers) {
                const i3 = this._layers[e3];
                if (!i3) return this.fire(new t.k(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
                r2[i3.source] = true;
              }
            }
            const o2 = [];
            i2.availableImages = this._availableImages;
            const s2 = this._serializedAllLayers(), n2 = i2.layers instanceof Set ? i2.layers : Array.isArray(i2.layers) ? new Set(i2.layers) : null, l2 = Object.assign(Object.assign({}, i2), { layers: n2, globalState: this._globalState });
            for (const t2 in this.tileManagers) i2.layers && !r2[t2] || o2.push(U2(this.tileManagers[t2], this._layers, s2, e2, l2, a2, this.map.terrain ? (e3, t3, i3) => this.map.terrain.getElevation(e3, t3, i3) : void 0));
            return this.placement && o2.push((function(e3, t2, i3, a3, r3, o3, s3) {
              const n3 = {}, l3 = o3.queryRenderedSymbols(a3), c2 = [];
              for (const e4 of Object.keys(l3).map(Number)) c2.push(s3[e4]);
              c2.sort(V2);
              for (const i4 of c2) {
                const a4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], t2, i4.bucketIndex, i4.sourceLayerIndex, { filterSpec: r3.filter, globalState: r3.globalState }, r3.layers, r3.availableImages, e3);
                for (const e4 in a4) {
                  const t3 = n3[e4] = n3[e4] || [], r4 = a4[e4];
                  r4.sort(((e5, t4) => {
                    const a5 = i4.featureSortOrder;
                    if (a5) {
                      const i5 = a5.indexOf(e5.featureIndex);
                      return a5.indexOf(t4.featureIndex) - i5;
                    }
                    return t4.featureIndex - e5.featureIndex;
                  }));
                  for (const e5 of r4) t3.push(e5);
                }
              }
              return (function(e4, t3, i4) {
                for (const a4 in e4) for (const r4 of e4[a4]) q2(r4, i4[t3[a4].source]);
                return e4;
              })(n3, e3, i3);
            })(this._layers, s2, this.tileManagers, e2, l2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o2);
          }
          querySourceFeatures(e2, i2) {
            (null == i2 ? void 0 : i2.filter) && this._validate(t.C.filter, "querySourceFeatures.filter", i2.filter, null, i2);
            const a2 = this.tileManagers[e2];
            return a2 ? (function(e3, t2) {
              const i3 = e3.getRenderableIds().map(((t3) => e3.getTileByID(t3))), a3 = [], r2 = {};
              for (let e4 = 0; e4 < i3.length; e4++) {
                const o2 = i3[e4], s2 = o2.tileID.canonical.key;
                r2[s2] || (r2[s2] = true, o2.querySourceFeatures(a3, t2));
              }
              return a3;
            })(a2, i2 ? Object.assign(Object.assign({}, i2), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e2, i2 = {}) {
            this._checkLoaded();
            const a2 = this.light.getLight();
            let r2 = false;
            for (const i3 in e2) if (!t.bR(e2[i3], a2[i3])) {
              r2 = true;
              break;
            }
            if (!r2) return;
            const o2 = { now: c(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e2, i2), this.light.updateTransitions(o2);
          }
          getProjection() {
            var e2;
            return null === (e2 = this.stylesheet) || void 0 === e2 ? void 0 : e2.projection;
          }
          setProjection(e2) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e2.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e2, this._setProjectionInternal(e2.type);
          }
          getSky() {
            var e2;
            return null === (e2 = this.stylesheet) || void 0 === e2 ? void 0 : e2.sky;
          }
          setSky(e2, i2 = {}) {
            this._checkLoaded();
            const a2 = this.getSky();
            let r2 = false;
            if (!e2 && !a2) return;
            if (e2 && !a2) r2 = true;
            else if (!e2 && a2) r2 = true;
            else for (const i3 in e2) if (!t.bR(e2[i3], a2[i3])) {
              r2 = true;
              break;
            }
            if (!r2) return;
            const o2 = { now: c(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e2, this.sky.setSky(e2, i2), this.sky.updateTransitions(o2);
          }
          _setProjectionInternal(e2) {
            const i2 = (function(e3, i3) {
              const a2 = { constrainOverride: i3 };
              if (Array.isArray(e3)) {
                const t2 = new di2({ type: e3 });
                return { projection: t2, transform: new zi(a2), cameraHelper: new Di2(t2) };
              }
              switch (e3) {
                case "mercator":
                  return { projection: new jt2(), transform: new $t2(a2), cameraHelper: new Yt2() };
                case "globe": {
                  const e4 = new di2({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: e4, transform: new zi(a2), cameraHelper: new Di2(e4) };
                }
                case "vertical-perspective":
                  return { projection: new hi2(), transform: new Si2(a2), cameraHelper: new Ri() };
                default:
                  return t.w(`Unknown projection name: ${e3}. Falling back to mercator projection.`), { projection: new jt2(), transform: new $t2(a2), cameraHelper: new Yt2() };
              }
            })(e2, this.map.transformConstrain);
            this.projection = i2.projection, this.map.migrateProjection(i2.transform, i2.cameraHelper);
            for (const e3 in this.tileManagers) this.tileManagers[e3].reload();
          }
          _validate(e2, i2, a2, r2, o2 = {}) {
            return (!o2 || false !== o2.validate) && Ai(this, e2.call(t.C, t.e({ key: i2, style: this.serialize(), value: a2, styleSpec: t.u }, r2)));
          }
          _remove(e2 = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ce2().off(se2, this._rtlPluginLoaded);
            for (const e3 in this._layers) this._layers[e3].setEventedParent(null);
            for (const e3 in this.tileManagers) {
              const t2 = this.tileManagers[e3];
              t2.setEventedParent(null), t2.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e2 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e2);
          }
          _clearSource(e2) {
            this.tileManagers[e2].clearTiles();
          }
          _reloadSource(e2) {
            this.tileManagers[e2].resume(), this.tileManagers[e2].reload();
          }
          _updateSources(e2) {
            for (const t2 in this.tileManagers) this.tileManagers[t2].update(e2, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e2 in this.tileManagers) this._reloadSource(e2);
          }
          _updatePlacement(e2, t2, i2, a2, r2 = false) {
            let o2 = false, s2 = false;
            const n2 = {};
            for (const t3 of this._order) {
              const i3 = this._layers[t3];
              if ("symbol" !== i3.type) continue;
              if (!n2[i3.source]) {
                const e3 = this.tileManagers[i3.source];
                n2[i3.source] = e3.getRenderableIds(true).map(((t4) => e3.getTileByID(t4))).sort(((e4, t4) => t4.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t4.tileID) ? -1 : 1)));
              }
              const a3 = this.crossTileSymbolIndex.addLayer(i3, n2[i3.source], e2.center.lng);
              o2 = o2 || a3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((r2 = r2 || this._layerOrderChanged || 0 === i2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(c(), e2.zoom)) && (this.pauseablePlacement = new It2(e2, this.map.terrain, this._order, r2, t2, i2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, n2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(c()), s2 = true), o2 && this.pauseablePlacement.placement.setStale()), s2 || o2) for (const e3 of this._order) {
              const t3 = this._layers[e3];
              "symbol" === t3.type && this.placement.updateLayerOpacities(t3, n2[t3.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(c());
          }
          _releaseSymbolFadeTiles() {
            for (const e2 in this.tileManagers) this.tileManagers[e2].releaseSymbolFadeTiles();
          }
          getImages(e2, i2) {
            return t._(this, void 0, void 0, (function* () {
              const e3 = yield this.imageManager.getImages(i2.icons);
              this._updateTilesForChangedImages();
              const t2 = this.tileManagers[i2.source];
              return t2 && t2.setDependencies(i2.tileID.key, i2.type, i2.icons), e3;
            }));
          }
          getGlyphs(e2, i2) {
            return t._(this, void 0, void 0, (function* () {
              const e3 = yield this.glyphManager.getGlyphs(i2.stacks), t2 = this.tileManagers[i2.source];
              return t2 && t2.setDependencies(i2.tileID.key, i2.type, [""]), e3;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e2, i2 = {}) {
            this._checkLoaded(), e2 && this._validate(t.C.glyphs, "glyphs", e2, null, i2) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e2, this.glyphManager.entries = {}, this.glyphManager.setURL(e2));
          }
          getDashes(e2, i2) {
            return t._(this, void 0, void 0, (function* () {
              const e3 = {};
              for (const [t2, a2] of Object.entries(i2.dashes)) e3[t2] = this.lineAtlas.getDash(a2.dasharray, a2.round);
              return e3;
            }));
          }
          addSprite(e2, i2, a2 = {}, r2) {
            this._checkLoaded();
            const o2 = [{ id: e2, url: i2 }], s2 = [...x(this.stylesheet.sprite), ...o2];
            this._validate(t.C.sprite, "sprite", s2, null, a2) || (this.stylesheet.sprite = s2, this._loadSprite(o2, true, r2));
          }
          removeSprite(e2) {
            this._checkLoaded();
            const i2 = x(this.stylesheet.sprite);
            if (i2.find(((t2) => t2.id === e2))) {
              if (this._spritesImagesIds[e2]) for (const t2 of this._spritesImagesIds[e2]) this.imageManager.removeImage(t2), this._changedImages[t2] = true;
              i2.splice(i2.findIndex(((t2) => t2.id === e2)), 1), this.stylesheet.sprite = i2.length > 0 ? i2 : void 0, delete this._spritesImagesIds[e2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
            } else this.fire(new t.k(new Error(`Sprite "${e2}" doesn't exists on this map.`)));
          }
          getSprite() {
            return x(this.stylesheet.sprite);
          }
          setSprite(e2, i2 = {}, a2) {
            this._checkLoaded(), e2 && this._validate(t.C.sprite, "sprite", e2, null, i2) || (this.stylesheet.sprite = e2, e2 ? this._loadSprite(e2, true, a2) : (this._unloadSprite(), a2 && a2(null)));
          }
          destroy() {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null);
            for (const e2 in this.tileManagers) {
              const t2 = this.tileManagers[e2];
              t2.setEventedParent(null), t2.onRemove(this.map);
            }
            this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy();
            for (const e2 in this._layers) {
              const t2 = this._layers[e2];
              t2.setEventedParent(null), t2.onRemove && t2.onRemove(this.map);
            }
            this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(true), this._listeners = {}, this._oneTimeListeners = {};
          }
        }
        var Fi = t.aU([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class Bi2 {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
            this.context = e2;
            let c2 = this.boundPaintVertexBuffers.length !== a2.length;
            for (let e3 = 0; !c2 && e3 < a2.length; e3++) this.boundPaintVertexBuffers[e3] !== a2[e3] && (c2 = true);
            !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || c2 || this.boundIndexBuffer !== r2 || this.boundVertexOffset !== o2 || this.boundDynamicVertexBuffer !== s2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l2 ? this.freshBind(t2, i2, a2, r2, o2, s2, n2, l2) : (e2.bindVertexArray.set(this.vao), s2 && s2.bind(), r2 && r2.dynamicDraw && r2.bind(), n2 && n2.bind(), l2 && l2.bind());
          }
          freshBind(e2, t2, i2, a2, r2, o2, s2, n2) {
            const l2 = e2.numAttributes, c2 = this.context, h2 = c2.gl;
            this.vao && this.destroy(), this.vao = c2.createVertexArray(), c2.bindVertexArray.set(this.vao), this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = a2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffer = o2, this.boundDynamicVertexBuffer2 = s2, this.boundDynamicVertexBuffer3 = n2, t2.enableAttributes(h2, e2);
            for (const t3 of i2) t3.enableAttributes(h2, e2);
            o2 && o2.enableAttributes(h2, e2), s2 && s2.enableAttributes(h2, e2), n2 && n2.enableAttributes(h2, e2), t2.bind(), t2.setVertexAttribPointers(h2, e2, r2);
            for (const t3 of i2) t3.bind(), t3.setVertexAttribPointers(h2, e2, r2);
            o2 && (o2.bind(), o2.setVertexAttribPointers(h2, e2, r2)), a2 && a2.bind(), s2 && (s2.bind(), s2.setVertexAttribPointers(h2, e2, r2)), n2 && (n2.bind(), n2.setVertexAttribPointers(h2, e2, r2)), c2.currentNumAttributes = l2;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Oi = (e2, i2, a2, r2, o2) => ({ u_texture: 0, u_ele_delta: e2, u_fog_matrix: i2, u_fog_color: a2 ? a2.properties.get("fog-color") : t.bp.white, u_fog_ground_blend: a2 ? a2.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: o2 ? 0 : a2 ? a2.calculateFogBlendOpacity(r2) : 0, u_horizon_color: a2 ? a2.properties.get("horizon-color") : t.bp.white, u_horizon_fog_blend: a2 ? a2.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: o2 ? 1 : 0 }), ji2 = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function Ni2(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2.length; i2++) {
            if (null === e2[i2]) continue;
            const a2 = e2[i2].split(" ");
            t2.push(a2.pop());
          }
          return t2;
        }
        class Zi2 {
          constructor(e2, i2, a2, r2, o2, s2, n2, l2, c2 = []) {
            const h2 = e2.gl;
            this.program = h2.createProgram();
            const u2 = Ni2(i2.staticAttributes), d2 = a2 ? a2.getBinderAttributes() : [], _3 = u2.concat(d2), p2 = At2.prelude.staticUniforms ? Ni2(At2.prelude.staticUniforms) : [], m2 = n2.staticUniforms ? Ni2(n2.staticUniforms) : [], f3 = i2.staticUniforms ? Ni2(i2.staticUniforms) : [], g2 = a2 ? a2.getBinderUniforms() : [], v2 = p2.concat(m2).concat(f3).concat(g2), x2 = [];
            for (const e3 of v2) x2.indexOf(e3) < 0 && x2.push(e3);
            const b2 = a2 ? a2.defines() : [];
            oi2(h2) && b2.unshift("#version 300 es"), o2 && b2.push("#define OVERDRAW_INSPECTOR;"), s2 && b2.push("#define TERRAIN3D;"), l2 && b2.push(l2), c2 && b2.push(...c2);
            let y3 = b2.concat(At2.prelude.fragmentSource, n2.fragmentSource, i2.fragmentSource).join("\n"), w3 = b2.concat(At2.prelude.vertexSource, n2.vertexSource, i2.vertexSource).join("\n");
            oi2(h2) || (y3 = (function(e3) {
              return e3.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(y3), w3 = (function(e3) {
              return e3.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(w3));
            const T3 = h2.createShader(h2.FRAGMENT_SHADER);
            if (h2.isContextLost()) return void (this.failedToCreate = true);
            if (h2.shaderSource(T3, y3), h2.compileShader(T3), !h2.getShaderParameter(T3, h2.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${h2.getShaderInfoLog(T3)}`);
            h2.attachShader(this.program, T3);
            const P3 = h2.createShader(h2.VERTEX_SHADER);
            if (h2.isContextLost()) return void (this.failedToCreate = true);
            if (h2.shaderSource(P3, w3), h2.compileShader(P3), !h2.getShaderParameter(P3, h2.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${h2.getShaderInfoLog(P3)}`);
            h2.attachShader(this.program, P3), this.attributes = {};
            const C2 = {};
            this.numAttributes = _3.length;
            for (let e3 = 0; e3 < this.numAttributes; e3++) _3[e3] && (h2.bindAttribLocation(this.program, e3, _3[e3]), this.attributes[_3[e3]] = e3);
            if (h2.linkProgram(this.program), !h2.getProgramParameter(this.program, h2.LINK_STATUS)) throw new Error(`Program failed to link: ${h2.getProgramInfoLog(this.program)}`);
            h2.deleteShader(P3), h2.deleteShader(T3);
            for (let e3 = 0; e3 < x2.length; e3++) {
              const t2 = x2[e3];
              if (t2 && !C2[t2]) {
                const e4 = h2.getUniformLocation(this.program, t2);
                e4 && (C2[t2] = e4);
              }
            }
            this.fixedUniforms = r2(e2, C2), this.terrainUniforms = ((e3, i3) => ({ u_depth: new t.b_(e3, i3.u_depth), u_terrain: new t.b_(e3, i3.u_terrain), u_terrain_dim: new t.bq(e3, i3.u_terrain_dim), u_terrain_matrix: new t.c0(e3, i3.u_terrain_matrix), u_terrain_unpack: new t.c1(e3, i3.u_terrain_unpack), u_terrain_exaggeration: new t.bq(e3, i3.u_terrain_exaggeration) }))(e2, C2), this.projectionUniforms = ((e3, i3) => ({ u_projection_matrix: new t.c0(e3, i3.u_projection_matrix), u_projection_tile_mercator_coords: new t.c1(e3, i3.u_projection_tile_mercator_coords), u_projection_clipping_plane: new t.c1(e3, i3.u_projection_clipping_plane), u_projection_transition: new t.bq(e3, i3.u_projection_transition), u_projection_fallback_matrix: new t.c0(e3, i3.u_projection_fallback_matrix) }))(e2, C2), this.binderUniforms = a2 ? a2.getUniforms(e2, C2) : [];
          }
          draw(e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _3, p2, m2, f3, g2, v2) {
            const x2 = e2.gl;
            if (this.failedToCreate) return;
            if (e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(a2), e2.setColorMode(r2), e2.setCullFace(o2), n2) {
              e2.activeTexture.set(x2.TEXTURE2), x2.bindTexture(x2.TEXTURE_2D, n2.depthTexture), e2.activeTexture.set(x2.TEXTURE3), x2.bindTexture(x2.TEXTURE_2D, n2.texture);
              for (const e3 in this.terrainUniforms) this.terrainUniforms[e3].set(n2[e3]);
            }
            if (l2) for (const e3 in l2) this.projectionUniforms[ji2[e3]].set(l2[e3]);
            if (s2) for (const e3 in this.fixedUniforms) this.fixedUniforms[e3].set(s2[e3]);
            m2 && m2.setUniforms(e2, this.binderUniforms, _3, { zoom: p2 });
            let b2 = 0;
            switch (t2) {
              case x2.LINES:
                b2 = 2;
                break;
              case x2.TRIANGLES:
                b2 = 3;
                break;
              case x2.LINE_STRIP:
                b2 = 1;
            }
            for (const i3 of d2.get()) {
              const a3 = i3.vaos || (i3.vaos = {});
              (a3[c2] || (a3[c2] = new Bi2())).bind(e2, this, h2, m2 ? m2.getPaintVertexBuffers() : [], u2, i3.vertexOffset, f3, g2, v2), x2.drawElements(t2, i3.primitiveLength * b2, x2.UNSIGNED_SHORT, i3.primitiveOffset * b2 * 2);
            }
          }
        }
        function Gi2(e2, i2, a2) {
          const r2 = 1 / t.aN(a2, 1, i2.transform.tileZoom), o2 = Math.pow(2, a2.tileID.overscaledZ), s2 = a2.tileSize * Math.pow(2, i2.transform.tileZoom) / o2, n2 = s2 * (a2.tileID.canonical.x + a2.tileID.wrap * o2), l2 = s2 * a2.tileID.canonical.y;
          return { u_image: 0, u_texsize: a2.imageAtlasTexture.size, u_scale: [r2, e2.fromScale, e2.toScale], u_fade: e2.t, u_pixel_coord_upper: [n2 >> 16, l2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & l2] };
        }
        const Ui2 = (e2, i2, a2, r2) => {
          const o2 = e2.style.light, s2 = o2.properties.get("position"), n2 = [s2.x, s2.y, s2.z], l2 = t.c4();
          "viewport" === o2.properties.get("anchor") && t.c5(l2, e2.transform.bearingInRadians), t.c6(n2, n2, l2);
          const c2 = e2.transform.transformLightDirection(n2), h2 = o2.properties.get("color");
          return { u_lightpos: n2, u_lightpos_globe: c2, u_lightintensity: o2.properties.get("intensity"), u_lightcolor: [h2.r, h2.g, h2.b], u_vertical_gradient: +i2, u_opacity: a2, u_fill_translate: r2 };
        }, Vi2 = (e2, i2, a2, r2, o2, s2, n2) => t.e(Ui2(e2, i2, a2, r2), Gi2(s2, e2, n2), { u_height_factor: -Math.pow(2, o2.overscaledZ) / n2.tileSize / 8 }), qi2 = (e2, i2, a2, r2) => t.e(Gi2(i2, e2, a2), { u_fill_translate: r2 }), Wi2 = (e2, t2) => ({ u_world: e2, u_fill_translate: t2 }), $i = (e2, i2, a2, r2, o2) => t.e(qi2(e2, i2, a2, o2), { u_world: r2 }), Hi2 = (e2, i2, a2, r2, o2) => {
          const s2 = e2.transform;
          let n2, l2, c2 = 0;
          if ("map" === a2.paint.get("circle-pitch-alignment")) {
            const e3 = t.aN(i2, 1, s2.zoom);
            n2 = true, l2 = [e3, e3], c2 = e3 / (t.a5 * Math.pow(2, i2.tileID.overscaledZ)) * 2 * Math.PI * o2;
          } else n2 = false, l2 = s2.pixelsToGLUnits;
          return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +("map" === a2.paint.get("circle-pitch-scale")), u_pitch_with_map: +n2, u_device_pixel_ratio: e2.pixelRatio, u_extrude_scale: l2, u_globe_extrude_scale: c2, u_translate: r2 };
        }, Xi2 = (e2) => ({ u_pixel_extrude_scale: [1 / e2.width, 1 / e2.height] }), Ki2 = (e2) => ({ u_viewport_size: [e2.width, e2.height] }), Yi2 = (e2, t2 = 1) => ({ u_color: e2, u_overlay: 0, u_overlay_scale: t2 }), Qi2 = (e2, i2, a2, r2) => {
          const o2 = t.aN(e2, 1, i2) / (t.a5 * Math.pow(2, e2.tileID.overscaledZ)) * 2 * Math.PI * r2;
          return { u_extrude_scale: t.aN(e2, 1, i2), u_intensity: a2, u_globe_extrude_scale: o2 };
        }, Ji2 = (e2, i2, a2, r2) => {
          const o2 = t.N();
          t.c7(o2, 0, e2.width, e2.height, 0, 0, 1);
          const s2 = e2.context.gl;
          return { u_matrix: o2, u_world: [s2.drawingBufferWidth, s2.drawingBufferHeight], u_image: a2, u_color_ramp: r2, u_opacity: i2.paint.get("heatmap-opacity") };
        }, ea2 = (e2, t2, i2) => {
          const a2 = i2.paint.get("hillshade-accent-color");
          let r2;
          switch (i2.paint.get("hillshade-method")) {
            case "basic":
              r2 = 4;
              break;
            case "combined":
              r2 = 1;
              break;
            case "igor":
              r2 = 2;
              break;
            case "multidirectional":
              r2 = 3;
              break;
            default:
              r2 = 0;
          }
          const o2 = i2.getIlluminationProperties();
          for (let t3 = 0; t3 < o2.directionRadians.length; t3++) "viewport" === i2.paint.get("hillshade-illumination-anchor") && (o2.directionRadians[t3] += e2.transform.bearingInRadians);
          return { u_image: 0, u_latrange: ia2(0, t2.tileID), u_exaggeration: i2.paint.get("hillshade-exaggeration"), u_altitudes: o2.altitudeRadians, u_azimuths: o2.directionRadians, u_accent: a2, u_method: r2, u_highlights: o2.highlightColor, u_shadows: o2.shadowColor };
        }, ta2 = (e2, i2) => {
          const a2 = i2.stride, r2 = t.N();
          return t.c7(r2, 0, t.a5, -t.a5, 0, 0, 1), t.O(r2, r2, [0, -t.a5, 0]), { u_matrix: r2, u_image: 1, u_dimension: [a2, a2], u_zoom: e2.overscaledZ, u_unpack: i2.getUnpackVector() };
        };
        function ia2(e2, i2) {
          const a2 = Math.pow(2, i2.canonical.z), r2 = i2.canonical.y;
          return [new t.a9(0, r2 / a2).toLngLat().lat, new t.a9(0, (r2 + 1) / a2).toLngLat().lat];
        }
        const aa2 = (e2, t2, i2 = 0) => ({ u_image: 0, u_unpack: t2.getUnpackVector(), u_dimension: [t2.stride, t2.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: i2, u_opacity: e2.paint.get("color-relief-opacity") }), ra2 = (e2, i2, a2, r2) => {
          const o2 = e2.transform;
          return { u_translation: ha2(e2, i2, a2), u_ratio: r2 / t.aN(i2, 1, o2.zoom), u_device_pixel_ratio: e2.pixelRatio, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]] };
        }, oa2 = (e2, i2, a2, r2, o2) => t.e(ra2(e2, i2, a2, r2), { u_image: 0, u_image_height: o2 }), sa2 = (e2, i2, a2, r2, o2) => {
          const s2 = e2.transform, n2 = ca2(i2, s2);
          return { u_translation: ha2(e2, i2, a2), u_texsize: i2.imageAtlasTexture.size, u_ratio: r2 / t.aN(i2, 1, s2.zoom), u_device_pixel_ratio: e2.pixelRatio, u_image: 0, u_scale: [n2, o2.fromScale, o2.toScale], u_fade: o2.t, u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]] };
        }, na2 = (e2, i2, a2, r2, o2) => {
          const s2 = ca2(i2, e2.transform);
          return t.e(ra2(e2, i2, a2, r2), { u_tileratio: s2, u_crossfade_from: o2.fromScale, u_crossfade_to: o2.toScale, u_image: 0, u_mix: o2.t, u_lineatlas_width: e2.lineAtlas.width, u_lineatlas_height: e2.lineAtlas.height });
        }, la2 = (e2, i2, a2, r2, o2, s2) => {
          const n2 = ca2(i2, e2.transform);
          return t.e(ra2(e2, i2, a2, r2), { u_image: 0, u_image_height: s2, u_tileratio: n2, u_crossfade_from: o2.fromScale, u_crossfade_to: o2.toScale, u_image_dash: 1, u_mix: o2.t, u_lineatlas_width: e2.lineAtlas.width, u_lineatlas_height: e2.lineAtlas.height });
        };
        function ca2(e2, i2) {
          return 1 / t.aN(e2, 1, i2.tileZoom);
        }
        function ha2(e2, i2, a2) {
          return t.aO(e2.transform, i2, a2.paint.get("line-translate"), a2.paint.get("line-translate-anchor"));
        }
        const ua2 = (e2, t2, i2, a2, r2) => {
          return { u_tl_parent: e2, u_scale_parent: t2, u_buffer_scale: 1, u_fade_t: i2.mix, u_opacity: i2.opacity * a2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a2.paint.get("raster-brightness-min"), u_brightness_high: a2.paint.get("raster-brightness-max"), u_saturation_factor: (s2 = a2.paint.get("raster-saturation"), s2 > 0 ? 1 - 1 / (1.001 - s2) : -s2), u_contrast_factor: (o2 = a2.paint.get("raster-contrast"), o2 > 0 ? 1 / (1 - o2) : 1 + o2), u_spin_weights: da2(a2.paint.get("raster-hue-rotate")), u_coords_top: [r2[0].x, r2[0].y, r2[1].x, r2[1].y], u_coords_bottom: [r2[3].x, r2[3].y, r2[2].x, r2[2].y] };
          var o2, s2;
        };
        function da2(e2) {
          e2 *= Math.PI / 180;
          const t2 = Math.sin(e2), i2 = Math.cos(e2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
        }
        const _a2 = (e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2) => {
          const _3 = s2.transform;
          return { u_is_size_zoom_constant: +("constant" === e2 || "source" === e2), u_is_size_feature_constant: +("constant" === e2 || "camera" === e2), u_size_t: t2 ? t2.uSizeT : 0, u_size: t2 ? t2.uSize : 0, u_camera_to_center_distance: _3.cameraToCenterDistance, u_pitch: _3.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: _3.width / _3.height, u_fade_change: s2.options.fadeDuration ? s2.symbolFadeChange : 1, u_label_plane_matrix: n2, u_coord_matrix: l2, u_is_text: +h2, u_pitch_with_map: +a2, u_is_along_line: r2, u_is_variable_anchor: o2, u_texsize: u2, u_texture: 0, u_translation: c2, u_pitched_scale: d2 };
        }, pa2 = (e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _3, p2) => {
          const m2 = n2.transform;
          return t.e(_a2(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, p2), { u_gamma_scale: r2 ? Math.cos(m2.pitch * Math.PI / 180) * m2.cameraToCenterDistance : 1, u_device_pixel_ratio: n2.pixelRatio, u_is_halo: 1 });
        }, ma2 = (e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _3) => t.e(pa2(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, true, u2, 0, _3), { u_texsize_icon: d2, u_texture_icon: 1 }), fa2 = (e2, t2) => ({ u_opacity: e2, u_color: t2 }), ga2 = (e2, i2, a2, r2, o2) => t.e((function(e3, i3, a3, r3) {
          const o3 = a3.imageManager.getPattern(e3.from.toString()), s2 = a3.imageManager.getPattern(e3.to.toString()), { width: n2, height: l2 } = a3.imageManager.getPixelSize(), c2 = Math.pow(2, r3.tileID.overscaledZ), h2 = r3.tileSize * Math.pow(2, a3.transform.tileZoom) / c2, u2 = h2 * (r3.tileID.canonical.x + r3.tileID.wrap * c2), d2 = h2 * r3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: o3.tl, u_pattern_br_a: o3.br, u_pattern_tl_b: s2.tl, u_pattern_br_b: s2.br, u_texsize: [n2, l2], u_mix: i3.t, u_pattern_size_a: o3.displaySize, u_pattern_size_b: s2.displaySize, u_scale_a: i3.fromScale, u_scale_b: i3.toScale, u_tile_units_to_pixels: 1 / t.aN(r3, 1, a3.transform.tileZoom), u_pixel_coord_upper: [u2 >> 16, d2 >> 16], u_pixel_coord_lower: [65535 & u2, 65535 & d2] };
        })(a2, o2, i2, r2), { u_opacity: e2 }), va2 = (e2, t2) => {
        }, xa2 = { fillExtrusion: (e2, i2) => ({ u_lightpos: new t.c2(e2, i2.u_lightpos), u_lightpos_globe: new t.c2(e2, i2.u_lightpos_globe), u_lightintensity: new t.bq(e2, i2.u_lightintensity), u_lightcolor: new t.c2(e2, i2.u_lightcolor), u_vertical_gradient: new t.bq(e2, i2.u_vertical_gradient), u_opacity: new t.bq(e2, i2.u_opacity), u_fill_translate: new t.c3(e2, i2.u_fill_translate) }), fillExtrusionPattern: (e2, i2) => ({ u_lightpos: new t.c2(e2, i2.u_lightpos), u_lightpos_globe: new t.c2(e2, i2.u_lightpos_globe), u_lightintensity: new t.bq(e2, i2.u_lightintensity), u_lightcolor: new t.c2(e2, i2.u_lightcolor), u_vertical_gradient: new t.bq(e2, i2.u_vertical_gradient), u_height_factor: new t.bq(e2, i2.u_height_factor), u_opacity: new t.bq(e2, i2.u_opacity), u_fill_translate: new t.c3(e2, i2.u_fill_translate), u_image: new t.b_(e2, i2.u_image), u_texsize: new t.c3(e2, i2.u_texsize), u_pixel_coord_upper: new t.c3(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.c3(e2, i2.u_pixel_coord_lower), u_scale: new t.c2(e2, i2.u_scale), u_fade: new t.bq(e2, i2.u_fade) }), fill: (e2, i2) => ({ u_fill_translate: new t.c3(e2, i2.u_fill_translate) }), fillPattern: (e2, i2) => ({ u_image: new t.b_(e2, i2.u_image), u_texsize: new t.c3(e2, i2.u_texsize), u_pixel_coord_upper: new t.c3(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.c3(e2, i2.u_pixel_coord_lower), u_scale: new t.c2(e2, i2.u_scale), u_fade: new t.bq(e2, i2.u_fade), u_fill_translate: new t.c3(e2, i2.u_fill_translate) }), fillOutline: (e2, i2) => ({ u_world: new t.c3(e2, i2.u_world), u_fill_translate: new t.c3(e2, i2.u_fill_translate) }), fillOutlinePattern: (e2, i2) => ({ u_world: new t.c3(e2, i2.u_world), u_image: new t.b_(e2, i2.u_image), u_texsize: new t.c3(e2, i2.u_texsize), u_pixel_coord_upper: new t.c3(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.c3(e2, i2.u_pixel_coord_lower), u_scale: new t.c2(e2, i2.u_scale), u_fade: new t.bq(e2, i2.u_fade), u_fill_translate: new t.c3(e2, i2.u_fill_translate) }), circle: (e2, i2) => ({ u_camera_to_center_distance: new t.bq(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.b_(e2, i2.u_scale_with_map), u_pitch_with_map: new t.b_(e2, i2.u_pitch_with_map), u_extrude_scale: new t.c3(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.bq(e2, i2.u_device_pixel_ratio), u_globe_extrude_scale: new t.bq(e2, i2.u_globe_extrude_scale), u_translate: new t.c3(e2, i2.u_translate) }), collisionBox: (e2, i2) => ({ u_pixel_extrude_scale: new t.c3(e2, i2.u_pixel_extrude_scale) }), collisionCircle: (e2, i2) => ({ u_viewport_size: new t.c3(e2, i2.u_viewport_size) }), debug: (e2, i2) => ({ u_color: new t.b$(e2, i2.u_color), u_overlay: new t.b_(e2, i2.u_overlay), u_overlay_scale: new t.bq(e2, i2.u_overlay_scale) }), depth: va2, clippingMask: va2, heatmap: (e2, i2) => ({ u_extrude_scale: new t.bq(e2, i2.u_extrude_scale), u_intensity: new t.bq(e2, i2.u_intensity), u_globe_extrude_scale: new t.bq(e2, i2.u_globe_extrude_scale) }), heatmapTexture: (e2, i2) => ({ u_matrix: new t.c0(e2, i2.u_matrix), u_world: new t.c3(e2, i2.u_world), u_image: new t.b_(e2, i2.u_image), u_color_ramp: new t.b_(e2, i2.u_color_ramp), u_opacity: new t.bq(e2, i2.u_opacity) }), hillshade: (e2, i2) => ({ u_image: new t.b_(e2, i2.u_image), u_latrange: new t.c3(e2, i2.u_latrange), u_exaggeration: new t.bq(e2, i2.u_exaggeration), u_altitudes: new t.c9(e2, i2.u_altitudes), u_azimuths: new t.c9(e2, i2.u_azimuths), u_accent: new t.b$(e2, i2.u_accent), u_method: new t.b_(e2, i2.u_method), u_shadows: new t.c8(e2, i2.u_shadows), u_highlights: new t.c8(e2, i2.u_highlights) }), hillshadePrepare: (e2, i2) => ({ u_matrix: new t.c0(e2, i2.u_matrix), u_image: new t.b_(e2, i2.u_image), u_dimension: new t.c3(e2, i2.u_dimension), u_zoom: new t.bq(e2, i2.u_zoom), u_unpack: new t.c1(e2, i2.u_unpack) }), colorRelief: (e2, i2) => ({ u_image: new t.b_(e2, i2.u_image), u_unpack: new t.c1(e2, i2.u_unpack), u_dimension: new t.c3(e2, i2.u_dimension), u_elevation_stops: new t.b_(e2, i2.u_elevation_stops), u_color_stops: new t.b_(e2, i2.u_color_stops), u_color_ramp_size: new t.b_(e2, i2.u_color_ramp_size), u_opacity: new t.bq(e2, i2.u_opacity) }), line: (e2, i2) => ({ u_translation: new t.c3(e2, i2.u_translation), u_ratio: new t.bq(e2, i2.u_ratio), u_device_pixel_ratio: new t.bq(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.c3(e2, i2.u_units_to_pixels) }), lineGradient: (e2, i2) => ({ u_translation: new t.c3(e2, i2.u_translation), u_ratio: new t.bq(e2, i2.u_ratio), u_device_pixel_ratio: new t.bq(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.c3(e2, i2.u_units_to_pixels), u_image: new t.b_(e2, i2.u_image), u_image_height: new t.bq(e2, i2.u_image_height) }), linePattern: (e2, i2) => ({ u_translation: new t.c3(e2, i2.u_translation), u_texsize: new t.c3(e2, i2.u_texsize), u_ratio: new t.bq(e2, i2.u_ratio), u_device_pixel_ratio: new t.bq(e2, i2.u_device_pixel_ratio), u_image: new t.b_(e2, i2.u_image), u_units_to_pixels: new t.c3(e2, i2.u_units_to_pixels), u_scale: new t.c2(e2, i2.u_scale), u_fade: new t.bq(e2, i2.u_fade) }), lineSDF: (e2, i2) => ({ u_translation: new t.c3(e2, i2.u_translation), u_ratio: new t.bq(e2, i2.u_ratio), u_device_pixel_ratio: new t.bq(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.c3(e2, i2.u_units_to_pixels), u_image: new t.b_(e2, i2.u_image), u_mix: new t.bq(e2, i2.u_mix), u_tileratio: new t.bq(e2, i2.u_tileratio), u_crossfade_from: new t.bq(e2, i2.u_crossfade_from), u_crossfade_to: new t.bq(e2, i2.u_crossfade_to), u_lineatlas_width: new t.bq(e2, i2.u_lineatlas_width), u_lineatlas_height: new t.bq(e2, i2.u_lineatlas_height) }), lineGradientSDF: (e2, i2) => ({ u_translation: new t.c3(e2, i2.u_translation), u_ratio: new t.bq(e2, i2.u_ratio), u_device_pixel_ratio: new t.bq(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.c3(e2, i2.u_units_to_pixels), u_image: new t.b_(e2, i2.u_image), u_image_height: new t.bq(e2, i2.u_image_height), u_tileratio: new t.bq(e2, i2.u_tileratio), u_crossfade_from: new t.bq(e2, i2.u_crossfade_from), u_crossfade_to: new t.bq(e2, i2.u_crossfade_to), u_image_dash: new t.b_(e2, i2.u_image_dash), u_mix: new t.bq(e2, i2.u_mix), u_lineatlas_width: new t.bq(e2, i2.u_lineatlas_width), u_lineatlas_height: new t.bq(e2, i2.u_lineatlas_height) }), raster: (e2, i2) => ({ u_tl_parent: new t.c3(e2, i2.u_tl_parent), u_scale_parent: new t.bq(e2, i2.u_scale_parent), u_buffer_scale: new t.bq(e2, i2.u_buffer_scale), u_fade_t: new t.bq(e2, i2.u_fade_t), u_opacity: new t.bq(e2, i2.u_opacity), u_image0: new t.b_(e2, i2.u_image0), u_image1: new t.b_(e2, i2.u_image1), u_brightness_low: new t.bq(e2, i2.u_brightness_low), u_brightness_high: new t.bq(e2, i2.u_brightness_high), u_saturation_factor: new t.bq(e2, i2.u_saturation_factor), u_contrast_factor: new t.bq(e2, i2.u_contrast_factor), u_spin_weights: new t.c2(e2, i2.u_spin_weights), u_coords_top: new t.c1(e2, i2.u_coords_top), u_coords_bottom: new t.c1(e2, i2.u_coords_bottom) }), symbolIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.b_(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.b_(e2, i2.u_is_size_feature_constant), u_size_t: new t.bq(e2, i2.u_size_t), u_size: new t.bq(e2, i2.u_size), u_camera_to_center_distance: new t.bq(e2, i2.u_camera_to_center_distance), u_pitch: new t.bq(e2, i2.u_pitch), u_rotate_symbol: new t.b_(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.bq(e2, i2.u_aspect_ratio), u_fade_change: new t.bq(e2, i2.u_fade_change), u_label_plane_matrix: new t.c0(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.c0(e2, i2.u_coord_matrix), u_is_text: new t.b_(e2, i2.u_is_text), u_pitch_with_map: new t.b_(e2, i2.u_pitch_with_map), u_is_along_line: new t.b_(e2, i2.u_is_along_line), u_is_variable_anchor: new t.b_(e2, i2.u_is_variable_anchor), u_texsize: new t.c3(e2, i2.u_texsize), u_texture: new t.b_(e2, i2.u_texture), u_translation: new t.c3(e2, i2.u_translation), u_pitched_scale: new t.bq(e2, i2.u_pitched_scale) }), symbolSDF: (e2, i2) => ({ u_is_size_zoom_constant: new t.b_(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.b_(e2, i2.u_is_size_feature_constant), u_size_t: new t.bq(e2, i2.u_size_t), u_size: new t.bq(e2, i2.u_size), u_camera_to_center_distance: new t.bq(e2, i2.u_camera_to_center_distance), u_pitch: new t.bq(e2, i2.u_pitch), u_rotate_symbol: new t.b_(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.bq(e2, i2.u_aspect_ratio), u_fade_change: new t.bq(e2, i2.u_fade_change), u_label_plane_matrix: new t.c0(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.c0(e2, i2.u_coord_matrix), u_is_text: new t.b_(e2, i2.u_is_text), u_pitch_with_map: new t.b_(e2, i2.u_pitch_with_map), u_is_along_line: new t.b_(e2, i2.u_is_along_line), u_is_variable_anchor: new t.b_(e2, i2.u_is_variable_anchor), u_texsize: new t.c3(e2, i2.u_texsize), u_texture: new t.b_(e2, i2.u_texture), u_gamma_scale: new t.bq(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.bq(e2, i2.u_device_pixel_ratio), u_is_halo: new t.b_(e2, i2.u_is_halo), u_translation: new t.c3(e2, i2.u_translation), u_pitched_scale: new t.bq(e2, i2.u_pitched_scale) }), symbolTextAndIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.b_(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.b_(e2, i2.u_is_size_feature_constant), u_size_t: new t.bq(e2, i2.u_size_t), u_size: new t.bq(e2, i2.u_size), u_camera_to_center_distance: new t.bq(e2, i2.u_camera_to_center_distance), u_pitch: new t.bq(e2, i2.u_pitch), u_rotate_symbol: new t.b_(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.bq(e2, i2.u_aspect_ratio), u_fade_change: new t.bq(e2, i2.u_fade_change), u_label_plane_matrix: new t.c0(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.c0(e2, i2.u_coord_matrix), u_is_text: new t.b_(e2, i2.u_is_text), u_pitch_with_map: new t.b_(e2, i2.u_pitch_with_map), u_is_along_line: new t.b_(e2, i2.u_is_along_line), u_is_variable_anchor: new t.b_(e2, i2.u_is_variable_anchor), u_texsize: new t.c3(e2, i2.u_texsize), u_texsize_icon: new t.c3(e2, i2.u_texsize_icon), u_texture: new t.b_(e2, i2.u_texture), u_texture_icon: new t.b_(e2, i2.u_texture_icon), u_gamma_scale: new t.bq(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.bq(e2, i2.u_device_pixel_ratio), u_is_halo: new t.b_(e2, i2.u_is_halo), u_translation: new t.c3(e2, i2.u_translation), u_pitched_scale: new t.bq(e2, i2.u_pitched_scale) }), background: (e2, i2) => ({ u_opacity: new t.bq(e2, i2.u_opacity), u_color: new t.b$(e2, i2.u_color) }), backgroundPattern: (e2, i2) => ({ u_opacity: new t.bq(e2, i2.u_opacity), u_image: new t.b_(e2, i2.u_image), u_pattern_tl_a: new t.c3(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.c3(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.c3(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.c3(e2, i2.u_pattern_br_b), u_texsize: new t.c3(e2, i2.u_texsize), u_mix: new t.bq(e2, i2.u_mix), u_pattern_size_a: new t.c3(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.c3(e2, i2.u_pattern_size_b), u_scale_a: new t.bq(e2, i2.u_scale_a), u_scale_b: new t.bq(e2, i2.u_scale_b), u_pixel_coord_upper: new t.c3(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.c3(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.bq(e2, i2.u_tile_units_to_pixels) }), terrain: (e2, i2) => ({ u_texture: new t.b_(e2, i2.u_texture), u_ele_delta: new t.bq(e2, i2.u_ele_delta), u_fog_matrix: new t.c0(e2, i2.u_fog_matrix), u_fog_color: new t.b$(e2, i2.u_fog_color), u_fog_ground_blend: new t.bq(e2, i2.u_fog_ground_blend), u_fog_ground_blend_opacity: new t.bq(e2, i2.u_fog_ground_blend_opacity), u_horizon_color: new t.b$(e2, i2.u_horizon_color), u_horizon_fog_blend: new t.bq(e2, i2.u_horizon_fog_blend), u_is_globe_mode: new t.bq(e2, i2.u_is_globe_mode) }), terrainDepth: (e2, i2) => ({ u_ele_delta: new t.bq(e2, i2.u_ele_delta) }), terrainCoords: (e2, i2) => ({ u_texture: new t.b_(e2, i2.u_texture), u_terrain_coords_id: new t.bq(e2, i2.u_terrain_coords_id), u_ele_delta: new t.bq(e2, i2.u_ele_delta) }), projectionErrorMeasurement: (e2, i2) => ({ u_input: new t.bq(e2, i2.u_input), u_output_expected: new t.bq(e2, i2.u_output_expected) }), atmosphere: (e2, i2) => ({ u_sun_pos: new t.c2(e2, i2.u_sun_pos), u_atmosphere_blend: new t.bq(e2, i2.u_atmosphere_blend), u_globe_position: new t.c2(e2, i2.u_globe_position), u_globe_radius: new t.bq(e2, i2.u_globe_radius), u_inv_proj_matrix: new t.c0(e2, i2.u_inv_proj_matrix) }), sky: (e2, i2) => ({ u_sky_color: new t.b$(e2, i2.u_sky_color), u_horizon_color: new t.b$(e2, i2.u_horizon_color), u_horizon: new t.c3(e2, i2.u_horizon), u_horizon_normal: new t.c3(e2, i2.u_horizon_normal), u_sky_horizon_blend: new t.bq(e2, i2.u_sky_horizon_blend), u_sky_blend: new t.bq(e2, i2.u_sky_blend) }) };
        class ba2 {
          constructor(e2, t2, i2) {
            this.context = e2;
            const a2 = e2.gl;
            this.buffer = a2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), a2.bufferData(a2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e2) {
            const t2 = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const ya2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class wa2 {
          constructor(e2, t2, i2, a2) {
            this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = a2, this.context = e2;
            const r2 = e2.gl;
            this.buffer = r2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e2) {
            if (e2.length !== this.length) throw new Error(`Length of new data is ${e2.length}, which doesn't match current length of ${this.length}`);
            const t2 = this.context.gl;
            this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
          }
          enableAttributes(e2, t2) {
            for (let i2 = 0; i2 < this.attributes.length; i2++) {
              const a2 = t2.attributes[this.attributes[i2].name];
              void 0 !== a2 && e2.enableVertexAttribArray(a2);
            }
          }
          setVertexAttribPointers(e2, t2, i2) {
            for (let a2 = 0; a2 < this.attributes.length; a2++) {
              const r2 = this.attributes[a2], o2 = t2.attributes[r2.name];
              void 0 !== o2 && e2.vertexAttribPointer(o2, r2.components, e2[ya2[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Ta2 {
          constructor(e2) {
            this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e2) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Pa2 extends Ta2 {
          getDefault() {
            return t.bp.transparent;
          }
          set(e2) {
            const t2 = this.current;
            (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
          }
        }
        class Ca2 extends Ta2 {
          getDefault() {
            return 1;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
          }
        }
        class Ia2 extends Ta2 {
          getDefault() {
            return 0;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
          }
        }
        class Ma2 extends Ta2 {
          getDefault() {
            return [true, true, true, true];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class Ea2 extends Ta2 {
          getDefault() {
            return true;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
          }
        }
        class Sa2 extends Ta2 {
          getDefault() {
            return 255;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
          }
        }
        class za2 extends Ta2 {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e2) {
            const t2 = this.current;
            (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
          }
        }
        class Ra2 extends Ta2 {
          getDefault() {
            const e2 = this.gl;
            return [e2.KEEP, e2.KEEP, e2.KEEP];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
          }
        }
        class Da2 extends Ta2 {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
          }
        }
        class Aa2 extends Ta2 {
          getDefault() {
            return [0, 1];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
          }
        }
        class La2 extends Ta2 {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
          }
        }
        class ka2 extends Ta2 {
          getDefault() {
            return this.gl.LESS;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
          }
        }
        class Fa2 extends Ta2 {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
          }
        }
        class Ba2 extends Ta2 {
          getDefault() {
            const e2 = this.gl;
            return [e2.ONE, e2.ZERO];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
          }
        }
        class Oa2 extends Ta2 {
          getDefault() {
            return t.bp.transparent;
          }
          set(e2) {
            const t2 = this.current;
            (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
          }
        }
        class ja2 extends Ta2 {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
          }
        }
        class Na2 extends Ta2 {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
          }
        }
        class Za2 extends Ta2 {
          getDefault() {
            return this.gl.BACK;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
          }
        }
        class Ga2 extends Ta2 {
          getDefault() {
            return this.gl.CCW;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
          }
        }
        class Ua2 extends Ta2 {
          getDefault() {
            return null;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
          }
        }
        class Va2 extends Ta2 {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
          }
        }
        class qa2 extends Ta2 {
          getDefault() {
            const e2 = this.gl;
            return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class Wa2 extends Ta2 {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class $a2 extends Ta2 {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class Ha2 extends Ta2 {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
          }
        }
        class Xa extends Ta2 {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class Ka2 extends Ta2 {
          getDefault() {
            return null;
          }
          set(e2) {
            const t2 = this.gl;
            t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class Ya2 extends Ta2 {
          getDefault() {
            return null;
          }
          set(e2) {
            var t2;
            if (e2 === this.current && !this.dirty) return;
            const i2 = this.gl;
            oi2(i2) ? i2.bindVertexArray(e2) : null === (t2 = i2.getExtension("OES_vertex_array_object")) || void 0 === t2 || t2.bindVertexArrayOES(e2), this.current = e2, this.dirty = false;
          }
        }
        class Qa2 extends Ta2 {
          getDefault() {
            return 4;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
          }
        }
        class Ja2 extends Ta2 {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
          }
        }
        class er2 extends Ta2 {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
          }
        }
        class tr2 extends Ta2 {
          constructor(e2, t2) {
            super(e2), this.context = e2, this.parent = t2;
          }
          getDefault() {
            return null;
          }
        }
        class ir2 extends tr2 {
          setDirty() {
            this.dirty = true;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
          }
        }
        class ar2 extends tr2 {
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferRenderbuffer(t2.FRAMEBUFFER, t2.DEPTH_ATTACHMENT, t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class rr2 extends tr2 {
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferRenderbuffer(t2.FRAMEBUFFER, t2.DEPTH_STENCIL_ATTACHMENT, t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        const or2 = "Framebuffer is not complete";
        class sr2 {
          constructor(e2, t2, i2, a2, r2) {
            this.context = e2, this.width = t2, this.height = i2;
            const o2 = e2.gl, s2 = this.framebuffer = o2.createFramebuffer();
            if (this.colorAttachment = new ir2(e2, s2), a2) this.depthAttachment = r2 ? new rr2(e2, s2) : new ar2(e2, s2);
            else if (r2) throw new Error("Stencil cannot be set without depth");
            if (o2.checkFramebufferStatus(o2.FRAMEBUFFER) !== o2.FRAMEBUFFER_COMPLETE) throw new Error(or2);
          }
          destroy() {
            const e2 = this.context.gl, t2 = this.colorAttachment.get();
            if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
              const t3 = this.depthAttachment.get();
              t3 && e2.deleteRenderbuffer(t3);
            }
            e2.deleteFramebuffer(this.framebuffer);
          }
        }
        class nr2 {
          constructor(e2) {
            var t2, i2;
            if (this.gl = e2, this.clearColor = new Pa2(this), this.clearDepth = new Ca2(this), this.clearStencil = new Ia2(this), this.colorMask = new Ma2(this), this.depthMask = new Ea2(this), this.stencilMask = new Sa2(this), this.stencilFunc = new za2(this), this.stencilOp = new Ra2(this), this.stencilTest = new Da2(this), this.depthRange = new Aa2(this), this.depthTest = new La2(this), this.depthFunc = new ka2(this), this.blend = new Fa2(this), this.blendFunc = new Ba2(this), this.blendColor = new Oa2(this), this.blendEquation = new ja2(this), this.cullFace = new Na2(this), this.cullFaceSide = new Za2(this), this.frontFace = new Ga2(this), this.program = new Ua2(this), this.activeTexture = new Va2(this), this.viewport = new qa2(this), this.bindFramebuffer = new Wa2(this), this.bindRenderbuffer = new $a2(this), this.bindTexture = new Ha2(this), this.bindVertexBuffer = new Xa(this), this.bindElementBuffer = new Ka2(this), this.bindVertexArray = new Ya2(this), this.pixelStoreUnpack = new Qa2(this), this.pixelStoreUnpackPremultiplyAlpha = new Ja2(this), this.pixelStoreUnpackFlipY = new er2(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), oi2(e2)) {
              this.HALF_FLOAT = e2.HALF_FLOAT;
              const a2 = e2.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = null !== (t2 = e2.RGBA16F) && void 0 !== t2 ? t2 : null == a2 ? void 0 : a2.RGBA16F_EXT, this.RGB16F = null !== (i2 = e2.RGB16F) && void 0 !== i2 ? i2 : null == a2 ? void 0 : a2.RGB16F_EXT, e2.getExtension("EXT_color_buffer_float");
            } else {
              e2.getExtension("EXT_color_buffer_half_float"), e2.getExtension("OES_texture_half_float_linear");
              const t3 = e2.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = null == t3 ? void 0 : t3.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e2, t2) {
            return new ba2(this, e2, t2);
          }
          createVertexBuffer(e2, t2, i2) {
            return new wa2(this, e2, t2, i2);
          }
          createRenderbuffer(e2, t2, i2) {
            const a2 = this.gl, r2 = a2.createRenderbuffer();
            return this.bindRenderbuffer.set(r2), a2.renderbufferStorage(a2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), r2;
          }
          createFramebuffer(e2, t2, i2, a2) {
            return new sr2(this, e2, t2, i2, a2);
          }
          clear({ color: e2, depth: t2, stencil: i2 }) {
            const a2 = this.gl;
            let r2 = 0;
            e2 && (r2 |= a2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== t2 && (r2 |= a2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (r2 |= a2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), a2.clear(r2);
          }
          setCullFace(e2) {
            false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
          }
          setDepthMode(e2) {
            e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
          }
          setStencilMode(e2) {
            e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e2) {
            t.bR(e2.blendFunction, Qt2.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
          }
          createVertexArray() {
            var e2;
            return oi2(this.gl) ? this.gl.createVertexArray() : null === (e2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e2 ? void 0 : e2.createVertexArrayOES();
          }
          deleteVertexArray(e2) {
            var t2;
            return oi2(this.gl) ? this.gl.deleteVertexArray(e2) : null === (t2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t2 ? void 0 : t2.deleteVertexArrayOES(e2);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let lr2;
        function cr2(e2, i2, a2, r2, o2) {
          const s2 = e2.context, n2 = e2.transform, l2 = s2.gl, c2 = e2.useProgram("collisionBox"), h2 = [];
          let u2 = 0, d2 = 0;
          for (let t2 = 0; t2 < r2.length; t2++) {
            const _4 = r2[t2], p3 = i2.getTile(_4).getBucket(a2);
            if (!p3) continue;
            const m3 = o2 ? p3.textCollisionBox : p3.iconCollisionBox, f4 = p3.collisionCircleArray;
            f4.length > 0 && (h2.push({ circleArray: f4, circleOffset: d2, coord: _4 }), u2 += f4.length / 4, d2 = u2), m3 && c2.draw(s2, l2.LINES, ti2.disabled, ai2.disabled, e2.colorModeForRenderPass(), ei2.disabled, Xi2(e2.transform), e2.style.map.terrain && e2.style.map.terrain.getTerrainData(_4), n2.getProjectionData({ overscaledTileID: _4, applyGlobeMatrix: true, applyTerrainMatrix: true }), a2.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, null, e2.transform.zoom, null, null, m3.collisionVertexBuffer);
          }
          if (!o2 || !h2.length) return;
          const _3 = e2.useProgram("collisionCircle"), p2 = new t.ca();
          p2.resize(4 * u2), p2._trim();
          let m2 = 0;
          for (const e3 of h2) for (let t2 = 0; t2 < e3.circleArray.length / 4; t2++) {
            const i3 = 4 * t2, a3 = e3.circleArray[i3 + 0], r3 = e3.circleArray[i3 + 1], o3 = e3.circleArray[i3 + 2], s3 = e3.circleArray[i3 + 3];
            p2.emplace(m2++, a3, r3, o3, s3, 0), p2.emplace(m2++, a3, r3, o3, s3, 1), p2.emplace(m2++, a3, r3, o3, s3, 2), p2.emplace(m2++, a3, r3, o3, s3, 3);
          }
          (!lr2 || lr2.length < 2 * u2) && (lr2 = (function(e3) {
            const i3 = 2 * e3, a3 = new t.cc();
            a3.resize(i3), a3._trim();
            for (let e4 = 0; e4 < i3; e4++) {
              const t2 = 6 * e4;
              a3.uint16[t2 + 0] = 4 * e4 + 0, a3.uint16[t2 + 1] = 4 * e4 + 1, a3.uint16[t2 + 2] = 4 * e4 + 2, a3.uint16[t2 + 3] = 4 * e4 + 2, a3.uint16[t2 + 4] = 4 * e4 + 3, a3.uint16[t2 + 5] = 4 * e4 + 0;
            }
            return a3;
          })(u2));
          const f3 = s2.createIndexBuffer(lr2, true), g2 = s2.createVertexBuffer(p2, t.cb.members, true);
          for (const i3 of h2) {
            const r3 = Ki2(e2.transform);
            _3.draw(s2, l2.TRIANGLES, ti2.disabled, ai2.disabled, e2.colorModeForRenderPass(), ei2.disabled, r3, e2.style.map.terrain && e2.style.map.terrain.getTerrainData(i3.coord), null, a2.id, g2, f3, t.aX.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
          }
          g2.destroy(), f3.destroy();
        }
        const hr2 = t.ar(new Float32Array(16));
        function ur2(e2, i2, a2, r2, o2, s2) {
          const { horizontalAlign: n2, verticalAlign: l2 } = t.aS(e2);
          return new t.P((-(n2 - 0.5) * i2 / o2 + r2[0]) * s2, (-(l2 - 0.5) * a2 / o2 + r2[1]) * s2);
        }
        function dr2(e2, i2, a2, r2, o2, s2) {
          const n2 = i2.tileAnchorPoint.add(new t.P(i2.translation[0], i2.translation[1]));
          if (i2.pitchWithMap) {
            let e3 = r2.mult(s2);
            a2 || (e3 = e3.rotate(-o2));
            const t2 = n2.add(e3);
            return Ge2(t2.x, t2.y, i2.pitchedLabelPlaneMatrix, i2.getElevation).point;
          }
          if (a2) {
            const t2 = Ye(i2.tileAnchorPoint.x + 1, i2.tileAnchorPoint.y, i2).point.sub(e2), a3 = Math.atan(t2.y / t2.x) + (t2.x < 0 ? Math.PI : 0);
            return e2.add(r2.rotate(a3));
          }
          return e2.add(r2);
        }
        function _r2(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2) {
          const _3 = e2.text.placedSymbolArray, p2 = e2.text.dynamicLayoutVertexArray, m2 = e2.icon.dynamicLayoutVertexArray, f3 = {};
          p2.clear();
          for (let m3 = 0; m3 < _3.length; m3++) {
            const g2 = _3.get(m3), v2 = g2.hidden || !g2.crossTileID || e2.allowVerticalPlacement && !g2.placedOrientation ? null : r2[g2.crossTileID];
            if (v2) {
              const r3 = new t.P(g2.anchorX, g2.anchorY), _4 = { getElevation: d2, width: o2.width, height: o2.height, pitchedLabelPlaneMatrix: s2, pitchWithMap: a2, transform: o2, tileAnchorPoint: r3, translation: h2, unwrappedTileID: u2 }, m4 = a2 ? Je(r3.x, r3.y, _4) : Ye(r3.x, r3.y, _4), x2 = Ue2(o2.cameraToCenterDistance, m4.signedDistanceFromCamera);
              let b2 = t.aA(e2.textSizeData, l2, g2) * x2 / t.aM;
              a2 && (b2 *= e2.tilePixelRatio / n2);
              const { width: y3, height: w3, anchor: T3, textOffset: P3, textBoxScale: C2 } = v2, I3 = ur2(T3, y3, w3, P3, C2, b2), M3 = o2.getPitchedTextCorrection(r3.x + h2[0], r3.y + h2[1], u2), E2 = dr2(m4.point, _4, i2, I3, -o2.bearingInRadians, M3), S3 = e2.allowVerticalPlacement && g2.placedOrientation === t.az.vertical ? Math.PI / 2 : 0;
              for (let e3 = 0; e3 < g2.numGlyphs; e3++) t.aG(p2, E2, S3);
              c2 && g2.associatedIconIndex >= 0 && (f3[g2.associatedIconIndex] = { shiftedAnchor: E2, angle: S3 });
            } else rt2(g2.numGlyphs, p2);
          }
          if (c2) {
            m2.clear();
            const i3 = e2.icon.placedSymbolArray;
            for (let e3 = 0; e3 < i3.length; e3++) {
              const a3 = i3.get(e3);
              if (a3.hidden) rt2(a3.numGlyphs, m2);
              else {
                const i4 = f3[e3];
                if (i4) for (let e4 = 0; e4 < a3.numGlyphs; e4++) t.aG(m2, i4.shiftedAnchor, i4.angle);
                else rt2(a3.numGlyphs, m2);
              }
            }
            e2.icon.dynamicLayoutVertexBuffer.updateData(m2);
          }
          e2.text.dynamicLayoutVertexBuffer.updateData(p2);
        }
        function pr2(e2, t2, i2) {
          return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
        }
        function mr2(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _3) {
          const p2 = e2.context, m2 = p2.gl, f3 = e2.transform, g2 = "map" === l2, v2 = "map" === c2, x2 = "viewport" !== l2 && "point" !== a2.layout.get("symbol-placement"), b2 = g2 && !v2 && !x2, y3 = !a2.layout.get("symbol-sort-key").isConstant();
          let w3 = false;
          const T3 = e2.getDepthModeForSublayer(0, ti2.ReadOnly), P3 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C2 = [], I3 = f3.getCircleRadiusCorrection();
          for (const l3 of r2) {
            const r3 = i2.getTile(l3), c3 = r3.getBucket(a2);
            if (!c3) continue;
            const u3 = o2 ? c3.text : c3.icon;
            if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices) continue;
            const d3 = u3.programConfigurations.get(a2.id), p3 = o2 || c3.sdfIcons, T4 = o2 ? c3.textSizeData : c3.iconSizeData, M3 = v2 || 0 !== f3.pitch, E2 = e2.useProgram(pr2(p3, o2, c3), d3), S3 = t.ay(T4, f3.zoom), z3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(l3);
            let R3, D3, A2, L3, k3 = [0, 0], F3 = null;
            if (o2) D3 = r3.glyphAtlasTexture, A2 = m2.LINEAR, R3 = r3.glyphAtlasTexture.size, c3.iconsInText && (k3 = r3.imageAtlasTexture.size, F3 = r3.imageAtlasTexture, L3 = M3 || e2.options.rotating || e2.options.zooming || "composite" === T4.kind || "camera" === T4.kind ? m2.LINEAR : m2.NEAREST);
            else {
              const t2 = 1 !== a2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
              D3 = r3.imageAtlasTexture, A2 = p3 || e2.options.rotating || e2.options.zooming || t2 || M3 ? m2.LINEAR : m2.NEAREST, R3 = r3.imageAtlasTexture.size;
            }
            const B3 = t.aN(r3, 1, e2.transform.zoom), O3 = je2(g2, e2.transform, B3), j3 = t.N();
            t.aB(j3, O3);
            const N2 = Ne2(v2, g2, e2.transform, B3), Z3 = t.aO(f3, r3, s2, n2), G3 = f3.getProjectionData({ overscaledTileID: l3, applyGlobeMatrix: !_3, applyTerrainMatrix: true }), U3 = P3 && c3.hasTextData(), V3 = "none" !== a2.layout.get("icon-text-fit") && U3 && c3.hasIconData();
            if (x2) {
              const t2 = e2.style.map.terrain ? (t3, i4) => e2.style.map.terrain.getElevation(l3, t3, i4) : null, i3 = "map" === a2.layout.get("text-rotation-alignment");
              qe2(c3, e2, o2, O3, j3, v2, h2, i3, l3.toUnwrapped(), f3.width, f3.height, Z3, t2);
            }
            const q3 = o2 && P3 || V3, W3 = x2 || q3 ? hr2 : v2 ? O3 : e2.transform.clipSpaceToPixelsMatrix, $3 = p3 && 0 !== a2.paint.get(o2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let H3;
            H3 = p3 ? c3.iconsInText ? ma2(T4.kind, S3, b2, v2, x2, q3, e2, W3, N2, Z3, R3, k3, I3) : pa2(T4.kind, S3, b2, v2, x2, q3, e2, W3, N2, Z3, o2, R3, 0, I3) : _a2(T4.kind, S3, b2, v2, x2, q3, e2, W3, N2, Z3, o2, R3, I3);
            const X2 = { program: E2, buffers: u3, uniformValues: H3, projectionData: G3, atlasTexture: D3, atlasTextureIcon: F3, atlasInterpolation: A2, atlasInterpolationIcon: L3, isSDF: p3, hasHalo: $3 };
            if (y3 && c3.canOverlap) {
              w3 = true;
              const e3 = u3.segments.get();
              for (const i3 of e3) C2.push({ segments: new t.aX([i3]), sortKey: i3.sortKey, state: X2, terrainData: z3 });
            } else C2.push({ segments: u3.segments, sortKey: 0, state: X2, terrainData: z3 });
          }
          w3 && C2.sort(((e3, t2) => e3.sortKey - t2.sortKey));
          for (const t2 of C2) {
            const i3 = t2.state;
            if (p2.activeTexture.set(m2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, m2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (p2.activeTexture.set(m2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, m2.CLAMP_TO_EDGE)), i3.isSDF) {
              const r3 = i3.uniformValues;
              i3.hasHalo && (r3.u_is_halo = 1, fr2(i3.buffers, t2.segments, a2, e2, i3.program, T3, u2, d2, r3, i3.projectionData, t2.terrainData)), r3.u_is_halo = 0;
            }
            fr2(i3.buffers, t2.segments, a2, e2, i3.program, T3, u2, d2, i3.uniformValues, i3.projectionData, t2.terrainData);
          }
        }
        function fr2(e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2) {
          const u2 = a2.context;
          r2.draw(u2, u2.gl.TRIANGLES, o2, s2, n2, ei2.backCCW, l2, h2, c2, i2.id, e2.layoutVertexBuffer, e2.indexBuffer, t2, i2.paint, a2.transform.zoom, e2.programConfigurations.get(i2.id), e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer);
        }
        function gr2(e2, i2, a2, r2, o2) {
          const s2 = e2.context, n2 = s2.gl, l2 = ai2.disabled, c2 = new Qt2([n2.ONE, n2.ONE], t.bp.transparent, [true, true, true, true]), h2 = i2.getBucket(a2);
          if (!h2) return;
          const u2 = r2.key;
          let d2 = a2.heatmapFbos.get(u2);
          d2 || (d2 = xr(s2, i2.tileSize, i2.tileSize), a2.heatmapFbos.set(u2, d2)), s2.bindFramebuffer.set(d2.framebuffer), s2.viewport.set([0, 0, i2.tileSize, i2.tileSize]), s2.clear({ color: t.bp.transparent });
          const _3 = h2.programConfigurations.get(a2.id), p2 = e2.useProgram("heatmap", _3, !o2), m2 = e2.transform.getProjectionData({ overscaledTileID: i2.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), f3 = e2.style.map.terrain.getTerrainData(r2);
          p2.draw(s2, n2.TRIANGLES, ti2.disabled, l2, c2, ei2.disabled, Qi2(i2, e2.transform.zoom, a2.paint.get("heatmap-intensity"), 1), f3, m2, a2.id, h2.layoutVertexBuffer, h2.indexBuffer, h2.segments, a2.paint, e2.transform.zoom, _3);
        }
        function vr2(e2, t2, i2, a2, r2) {
          const o2 = e2.context, s2 = o2.gl, n2 = e2.transform;
          o2.setColorMode(e2.colorModeForRenderPass());
          const l2 = br2(o2, t2), c2 = i2.key, h2 = t2.heatmapFbos.get(c2);
          if (!h2) return;
          o2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, h2.colorAttachment.get()), o2.activeTexture.set(s2.TEXTURE1), l2.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
          const u2 = n2.getProjectionData({ overscaledTileID: i2, applyTerrainMatrix: r2, applyGlobeMatrix: !a2 });
          e2.useProgram("heatmapTexture").draw(o2, s2.TRIANGLES, ti2.disabled, ai2.disabled, e2.colorModeForRenderPass(), ei2.disabled, Ji2(e2, t2, 0, 1), null, u2, t2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments, t2.paint, n2.zoom), h2.destroy(), t2.heatmapFbos.delete(c2);
        }
        function xr(e2, t2, i2) {
          var a2, r2;
          const o2 = e2.gl, s2 = o2.createTexture();
          o2.bindTexture(o2.TEXTURE_2D, s2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, o2.LINEAR), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, o2.LINEAR);
          const n2 = null !== (a2 = e2.HALF_FLOAT) && void 0 !== a2 ? a2 : o2.UNSIGNED_BYTE, l2 = null !== (r2 = e2.RGBA16F) && void 0 !== r2 ? r2 : o2.RGBA;
          o2.texImage2D(o2.TEXTURE_2D, 0, l2, t2, i2, 0, o2.RGBA, n2, null);
          const c2 = e2.createFramebuffer(t2, i2, false, false);
          return c2.colorAttachment.set(s2), c2;
        }
        function br2(e2, i2) {
          return i2.colorRampTexture || (i2.colorRampTexture = new t.T(e2, i2.colorRamp, e2.gl.RGBA)), i2.colorRampTexture;
        }
        function yr2(e2, i2, a2, r2, o2, s2, n2, l2) {
          let c2 = 256;
          if (o2.stepInterpolant) {
            const r3 = i2.getSource().maxzoom, o3 = n2.canonical.z === r3 ? Math.ceil(1 << e2.transform.maxZoom - n2.canonical.z) : 1;
            c2 = t.an(t.ce(s2.maxLineLength / t.a5 * 1024 * o3), 256, a2.maxTextureSize);
          }
          return l2.gradient = t.cf({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: c2, image: l2.gradient || void 0, clips: s2.lineClipsArray }), l2.texture ? l2.texture.update(l2.gradient) : l2.texture = new t.T(a2, l2.gradient, r2.RGBA), l2.version = o2.gradientVersion, l2.texture;
        }
        function wr2(e2, t2, i2, a2, r2) {
          e2.activeTexture.set(t2.TEXTURE0), i2.imageAtlasTexture.bind(t2.LINEAR, t2.CLAMP_TO_EDGE), a2.updatePaintBuffers(r2);
        }
        function Tr2(e2, t2, i2, a2, r2, o2) {
          (r2 || e2.lineAtlas.dirty) && (t2.activeTexture.set(i2.TEXTURE0), e2.lineAtlas.bind(t2)), a2.updatePaintBuffers(o2);
        }
        function Pr2(e2, t2, i2, a2, r2, o2, s2) {
          const n2 = o2.gradients[r2.id];
          let l2 = n2.texture;
          r2.gradientVersion !== n2.version && (l2 = yr2(e2, t2, i2, a2, r2, o2, s2, n2)), i2.activeTexture.set(a2.TEXTURE0), l2.bind(r2.stepInterpolant ? a2.NEAREST : a2.LINEAR, a2.CLAMP_TO_EDGE);
        }
        function Cr2(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
          const c2 = o2.gradients[r2.id];
          let h2 = c2.texture;
          r2.gradientVersion !== c2.version && (h2 = yr2(e2, t2, i2, a2, r2, o2, s2, c2)), i2.activeTexture.set(a2.TEXTURE0), h2.bind(r2.stepInterpolant ? a2.NEAREST : a2.LINEAR, a2.CLAMP_TO_EDGE), i2.activeTexture.set(a2.TEXTURE1), e2.lineAtlas.bind(i2), n2.updatePaintBuffers(l2);
        }
        function Ir2(e2, t2, i2, a2, r2) {
          if (!i2 || !a2 || !a2.imageAtlas) return;
          const o2 = a2.imageAtlas.patternPositions;
          let s2 = o2[i2.to.toString()], n2 = o2[i2.from.toString()];
          if (!s2 && n2 && (s2 = n2), !n2 && s2 && (n2 = s2), !s2 || !n2) {
            const e3 = r2.getPaintProperty(t2);
            s2 = o2[e3], n2 = o2[e3];
          }
          s2 && n2 && e2.setConstantPatternPositions(s2, n2);
        }
        function Mr2(e2, i2, a2, r2, o2, s2, n2, l2) {
          const c2 = e2.context.gl, h2 = "fill-pattern", u2 = a2.paint.get(h2), d2 = u2 && u2.constantOr(1), _3 = a2.getCrossfadeParameters();
          let p2, m2, f3, g2, v2;
          const x2 = e2.transform, b2 = a2.paint.get("fill-translate"), y3 = a2.paint.get("fill-translate-anchor");
          n2 ? (m2 = d2 && !a2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p2 = c2.LINES) : (m2 = d2 ? "fillPattern" : "fill", p2 = c2.TRIANGLES);
          const w3 = u2.constantOr(null);
          for (const u3 of r2) {
            const r3 = i2.getTile(u3);
            if (d2 && !r3.patternsLoaded()) continue;
            const T3 = r3.getBucket(a2);
            if (!T3) continue;
            const P3 = T3.programConfigurations.get(a2.id), C2 = e2.useProgram(m2, P3), I3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(u3);
            d2 && (e2.context.activeTexture.set(c2.TEXTURE0), r3.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), P3.updatePaintBuffers(_3)), Ir2(P3, h2, w3, r3, a2);
            const M3 = x2.getProjectionData({ overscaledTileID: u3, applyGlobeMatrix: !l2, applyTerrainMatrix: true }), E2 = t.aO(x2, r3, b2, y3);
            if (n2) {
              g2 = T3.indexBuffer2, v2 = T3.segments2;
              const t2 = [c2.drawingBufferWidth, c2.drawingBufferHeight];
              f3 = "fillOutlinePattern" === m2 && d2 ? $i(e2, _3, r3, t2, E2) : Wi2(t2, E2);
            } else g2 = T3.indexBuffer, v2 = T3.segments, f3 = d2 ? qi2(e2, _3, r3, E2) : { u_fill_translate: E2 };
            const S3 = e2.stencilModeForClipping(u3);
            C2.draw(e2.context, p2, o2, S3, s2, ei2.backCCW, f3, I3, M3, a2.id, T3.layoutVertexBuffer, g2, v2, a2.paint, e2.transform.zoom, P3);
          }
        }
        function Er2(e2, i2, a2, r2, o2, s2, n2, l2) {
          const c2 = e2.context, h2 = c2.gl, u2 = "fill-extrusion-pattern", d2 = a2.paint.get(u2), _3 = d2.constantOr(1), p2 = a2.getCrossfadeParameters(), m2 = a2.paint.get("fill-extrusion-opacity"), f3 = d2.constantOr(null), g2 = e2.transform;
          for (const d3 of r2) {
            const r3 = i2.getTile(d3), v2 = r3.getBucket(a2);
            if (!v2) continue;
            const x2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(d3), b2 = v2.programConfigurations.get(a2.id), y3 = e2.useProgram(_3 ? "fillExtrusionPattern" : "fillExtrusion", b2);
            _3 && (e2.context.activeTexture.set(h2.TEXTURE0), r3.imageAtlasTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), b2.updatePaintBuffers(p2));
            const w3 = g2.getProjectionData({ overscaledTileID: d3, applyGlobeMatrix: !l2, applyTerrainMatrix: true });
            Ir2(b2, u2, f3, r3, a2);
            const T3 = t.aO(g2, r3, a2.paint.get("fill-extrusion-translate"), a2.paint.get("fill-extrusion-translate-anchor")), P3 = a2.paint.get("fill-extrusion-vertical-gradient"), C2 = _3 ? Vi2(e2, P3, m2, T3, d3, p2, r3) : Ui2(e2, P3, m2, T3);
            y3.draw(c2, c2.gl.TRIANGLES, o2, s2, n2, ei2.backCCW, C2, x2, w3, a2.id, v2.layoutVertexBuffer, v2.indexBuffer, v2.segments, a2.paint, e2.transform.zoom, b2, e2.style.map.terrain && v2.centroidVertexBuffer);
          }
        }
        function Sr2(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
          var c2;
          const h2 = e2.style.projection, u2 = e2.context, d2 = e2.transform, _3 = u2.gl, p2 = [`#define NUM_ILLUMINATION_SOURCES ${i2.paint.get("hillshade-highlight-color").values.length}`], m2 = e2.useProgram("hillshade", null, false, p2), f3 = !e2.options.moving;
          for (const p3 of a2) {
            const a3 = t2.getTile(p3), g2 = a3.fbo;
            if (!g2) continue;
            const v2 = h2.getMeshFromTileID(u2, p3.canonical, n2, true, "raster"), x2 = null === (c2 = e2.style.map.terrain) || void 0 === c2 ? void 0 : c2.getTerrainData(p3);
            u2.activeTexture.set(_3.TEXTURE0), _3.bindTexture(_3.TEXTURE_2D, g2.colorAttachment.get());
            const b2 = d2.getProjectionData({ overscaledTileID: p3, aligned: f3, applyGlobeMatrix: !l2, applyTerrainMatrix: true });
            m2.draw(u2, _3.TRIANGLES, o2, r2[p3.overscaledZ], s2, ei2.backCCW, ea2(e2, a3, i2), x2, b2, i2.id, v2.vertexBuffer, v2.indexBuffer, v2.segments);
          }
        }
        function zr2(e2, i2, a2, r2, o2, s2, n2, l2, c2) {
          var h2;
          const u2 = e2.style.projection, d2 = e2.context, _3 = e2.transform, p2 = d2.gl, m2 = e2.useProgram("colorRelief"), f3 = !e2.options.moving;
          let g2 = true, v2 = 0;
          for (const x2 of r2) {
            const r3 = i2.getTile(x2), b2 = r3.dem;
            if (g2) {
              const e3 = p2.getParameter(p2.MAX_TEXTURE_SIZE), { elevationTexture: t2, colorTexture: i3 } = a2.getColorRampTextures(d2, e3, b2.getUnpackVector());
              d2.activeTexture.set(p2.TEXTURE1), t2.bind(p2.NEAREST, p2.CLAMP_TO_EDGE), d2.activeTexture.set(p2.TEXTURE4), i3.bind(p2.LINEAR, p2.CLAMP_TO_EDGE), g2 = false, v2 = t2.size[0];
            }
            if (!b2 || !b2.data) continue;
            const y3 = b2.stride, w3 = b2.getPixels();
            if (d2.activeTexture.set(p2.TEXTURE0), d2.pixelStoreUnpackPremultiplyAlpha.set(false), r3.demTexture = r3.demTexture || e2.getTileTexture(y3), r3.demTexture) {
              const e3 = r3.demTexture;
              e3.update(w3, { premultiply: false }), e3.bind(p2.LINEAR, p2.CLAMP_TO_EDGE);
            } else r3.demTexture = new t.T(d2, w3, p2.RGBA, { premultiply: false }), r3.demTexture.bind(p2.LINEAR, p2.CLAMP_TO_EDGE);
            const T3 = u2.getMeshFromTileID(d2, x2.canonical, l2, true, "raster"), P3 = null === (h2 = e2.style.map.terrain) || void 0 === h2 ? void 0 : h2.getTerrainData(x2), C2 = _3.getProjectionData({ overscaledTileID: x2, aligned: f3, applyGlobeMatrix: !c2, applyTerrainMatrix: true });
            m2.draw(d2, p2.TRIANGLES, s2, o2[x2.overscaledZ], n2, ei2.backCCW, aa2(a2, r3.dem, v2), P3, C2, a2.id, T3.vertexBuffer, T3.indexBuffer, T3.segments);
          }
        }
        const Rr2 = [new t.P(0, 0), new t.P(t.a5, 0), new t.P(t.a5, t.a5), new t.P(0, t.a5)];
        function Dr2(e2, t2, i2, a2, r2, o2, s2, n2, l2 = false, c2 = false) {
          const h2 = a2[a2.length - 1].overscaledZ, u2 = e2.context, d2 = u2.gl, _3 = e2.useProgram("raster"), p2 = e2.transform, m2 = e2.style.projection, f3 = e2.colorModeForRenderPass(), g2 = !e2.options.moving, v2 = i2.paint.get("raster-opacity"), x2 = i2.paint.get("raster-resampling"), b2 = i2.paint.get("raster-fade-duration"), y3 = !!e2.style.map.terrain;
          for (const w3 of a2) {
            const a3 = e2.getDepthModeForSublayer(w3.overscaledZ - h2, 1 === v2 ? ti2.ReadWrite : ti2.ReadOnly, d2.LESS), T3 = t2.getTile(w3), P3 = "nearest" === x2 ? d2.NEAREST : d2.LINEAR;
            u2.activeTexture.set(d2.TEXTURE0), T3.texture.bind(P3, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), u2.activeTexture.set(d2.TEXTURE1);
            const { parentTile: C2, parentScaleBy: I3, parentTopLeft: M3, fadeValues: E2 } = Ar2(T3, t2, b2, y3);
            T3.fadeOpacity = E2.tileOpacity, C2 ? (C2.fadeOpacity = E2.parentTileOpacity, C2.texture.bind(P3, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST)) : T3.texture.bind(P3, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), T3.texture.useMipmap && u2.extTextureFilterAnisotropic && e2.transform.pitch > 20 && d2.texParameterf(d2.TEXTURE_2D, u2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u2.extTextureFilterAnisotropicMax);
            const S3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(w3), z3 = p2.getProjectionData({ overscaledTileID: w3, aligned: g2, applyGlobeMatrix: !c2, applyTerrainMatrix: true }), R3 = ua2(M3, I3, E2.fadeMix, i2, n2), D3 = m2.getMeshFromTileID(u2, w3.canonical, o2, s2, "raster");
            _3.draw(u2, d2.TRIANGLES, a3, r2 ? r2[w3.overscaledZ] : ai2.disabled, f3, l2 ? ei2.frontCCW : ei2.backCCW, R3, S3, z3, i2.id, D3.vertexBuffer, D3.indexBuffer, D3.segments);
          }
        }
        function Ar2(e2, i2, a2, r2) {
          const o2 = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
          if (0 === a2 || r2) return o2;
          if (e2.fadingParentID) {
            const r3 = i2.getLoadedTile(e2.fadingParentID);
            if (!r3) return o2;
            const s2 = Math.pow(2, r3.tileID.overscaledZ - e2.tileID.overscaledZ), n2 = [e2.tileID.canonical.x * s2 % 1, e2.tileID.canonical.y * s2 % 1], l2 = (function(e3, i3, a3) {
              const r4 = c(), o3 = (r4 - i3.timeAdded) / a3, s3 = e3.fadingDirection === ue2.Incoming, n3 = t.an((r4 - e3.timeAdded) / a3, 0, 1), l3 = t.an(1 - o3, 0, 1), h2 = s3 ? n3 : l3;
              return { tileOpacity: h2, parentTileOpacity: s3 ? l3 : n3, fadeMix: { opacity: 1, mix: 1 - h2 } };
            })(e2, r3, a2);
            return { parentTile: r3, parentScaleBy: s2, parentTopLeft: n2, fadeValues: l2 };
          }
          if (e2.selfFading) {
            const i3 = (function(e3, i4) {
              const a3 = (c() - e3.timeAdded) / i4, r3 = t.an(a3, 0, 1);
              return { tileOpacity: r3, fadeMix: { opacity: r3, mix: 0 } };
            })(e2, a2);
            return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: i3 };
          }
          return o2;
        }
        const Lr2 = new t.bp(1, 0, 0, 1), kr = new t.bp(0, 1, 0, 1), Fr2 = new t.bp(0, 0, 1, 1), Br2 = new t.bp(1, 0, 1, 1), Or2 = new t.bp(0, 1, 1, 1);
        function jr2(e2, t2, i2, a2) {
          Zr2(e2, 0, t2 + i2 / 2, e2.transform.width, i2, a2);
        }
        function Nr2(e2, t2, i2, a2) {
          Zr2(e2, t2 - i2 / 2, 0, i2, e2.transform.height, a2);
        }
        function Zr2(e2, t2, i2, a2, r2, o2) {
          const s2 = e2.context, n2 = s2.gl;
          n2.enable(n2.SCISSOR_TEST), n2.scissor(t2 * e2.pixelRatio, i2 * e2.pixelRatio, a2 * e2.pixelRatio, r2 * e2.pixelRatio), s2.clear({ color: o2 }), n2.disable(n2.SCISSOR_TEST);
        }
        function Gr2(e2, i2, a2) {
          const r2 = e2.context, o2 = r2.gl, s2 = e2.useProgram("debug"), n2 = ti2.disabled, l2 = ai2.disabled, c2 = e2.colorModeForRenderPass(), h2 = "$debug", u2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(a2);
          r2.activeTexture.set(o2.TEXTURE0);
          const d2 = i2.getTileByID(a2.key).latestRawTileData, _3 = Math.floor((d2 && d2.byteLength || 0) / 1024), p2 = i2.getTile(a2).tileSize, m2 = 512 / Math.min(p2, 512) * (a2.overscaledZ / e2.transform.zoom) * 0.5;
          let f3 = a2.canonical.toString();
          a2.overscaledZ !== a2.canonical.z && (f3 += ` => ${a2.overscaledZ}`), (function(e3, t2) {
            e3.initDebugOverlayCanvas();
            const i3 = e3.debugOverlayCanvas, a3 = e3.context.gl, r3 = e3.debugOverlayCanvas.getContext("2d");
            r3.clearRect(0, 0, i3.width, i3.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(t2, 5, 5), r3.strokeText(t2, 5, 5), e3.debugOverlayTexture.update(i3), e3.debugOverlayTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
          })(e2, `${f3} ${_3}kB`);
          const g2 = e2.transform.getProjectionData({ overscaledTileID: a2, applyGlobeMatrix: true, applyTerrainMatrix: true });
          s2.draw(r2, o2.TRIANGLES, n2, l2, Qt2.alphaBlended, ei2.disabled, Yi2(t.bp.transparent, m2), null, g2, h2, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), s2.draw(r2, o2.LINE_STRIP, n2, l2, c2, ei2.disabled, Yi2(t.bp.red), u2, g2, h2, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
        }
        function Ur2(e2, t2, i2, a2) {
          const { isRenderingGlobe: r2 } = a2, o2 = e2.context, s2 = o2.gl, n2 = e2.transform, l2 = e2.colorModeForRenderPass(), c2 = e2.getDepthModeFor3D(), h2 = e2.useProgram("terrain");
          o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, e2.width, e2.height]);
          for (const a3 of i2) {
            const i3 = t2.getTerrainMesh(a3.tileID), u2 = e2.renderToTexture.getTexture(a3), d2 = t2.getTerrainData(a3.tileID);
            o2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, u2.texture);
            const _3 = t2.getMeshFrameDelta(n2.zoom), p2 = n2.calculateFogMatrix(a3.tileID.toUnwrapped()), m2 = Oi(_3, p2, e2.style.sky, n2.pitch, r2), f3 = n2.getProjectionData({ overscaledTileID: a3.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
            h2.draw(o2, s2.TRIANGLES, c2, ai2.disabled, l2, ei2.backCCW, m2, d2, f3, "terrain", i3.vertexBuffer, i3.indexBuffer, i3.segments);
          }
        }
        function Vr2(e2, i2) {
          if (!i2.mesh) {
            const a2 = new t.aW();
            a2.emplaceBack(-1, -1), a2.emplaceBack(1, -1), a2.emplaceBack(1, 1), a2.emplaceBack(-1, 1);
            const r2 = new t.aY();
            r2.emplaceBack(0, 1, 2), r2.emplaceBack(0, 2, 3), i2.mesh = new kt2(e2.createVertexBuffer(a2, Ft2.members), e2.createIndexBuffer(r2), t.aX.simpleSegment(0, 0, a2.length, r2.length));
          }
          return i2.mesh;
        }
        class qr2 {
          constructor(e2, i2) {
            this.context = new nr2(e2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t.ar(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ke2.maxOverzooming + ke2.maxUnderzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Rt2();
          }
          resize(e2, t2, i2) {
            if (this.width = Math.floor(e2 * i2), this.height = Math.floor(t2 * i2), this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e3 of this.style._order) this.style._layers[e3].resize();
          }
          setup() {
            const e2 = this.context, i2 = new t.aW();
            i2.emplaceBack(0, 0), i2.emplaceBack(t.a5, 0), i2.emplaceBack(0, t.a5), i2.emplaceBack(t.a5, t.a5), this.tileExtentBuffer = e2.createVertexBuffer(i2, Ft2.members), this.tileExtentSegments = t.aX.simpleSegment(0, 0, 4, 2);
            const a2 = new t.aW();
            a2.emplaceBack(0, 0), a2.emplaceBack(t.a5, 0), a2.emplaceBack(0, t.a5), a2.emplaceBack(t.a5, t.a5), this.debugBuffer = e2.createVertexBuffer(a2, Ft2.members), this.debugSegments = t.aX.simpleSegment(0, 0, 4, 5);
            const r2 = new t.ch();
            r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(t.a5, 0, t.a5, 0), r2.emplaceBack(0, t.a5, 0, t.a5), r2.emplaceBack(t.a5, t.a5, t.a5, t.a5), this.rasterBoundsBuffer = e2.createVertexBuffer(r2, Fi.members), this.rasterBoundsSegments = t.aX.simpleSegment(0, 0, 4, 2);
            const o2 = new t.aW();
            o2.emplaceBack(0, 0), o2.emplaceBack(t.a5, 0), o2.emplaceBack(0, t.a5), o2.emplaceBack(t.a5, t.a5), this.rasterBoundsBufferPosOnly = e2.createVertexBuffer(o2, Ft2.members), this.rasterBoundsSegmentsPosOnly = t.aX.simpleSegment(0, 0, 4, 5);
            const s2 = new t.aW();
            s2.emplaceBack(0, 0), s2.emplaceBack(1, 0), s2.emplaceBack(0, 1), s2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(s2, Ft2.members), this.viewportSegments = t.aX.simpleSegment(0, 0, 4, 2);
            const n2 = new t.ci();
            n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
            const l2 = new t.aY();
            l2.emplaceBack(1, 0, 2), l2.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(l2);
            const c2 = this.context.gl;
            this.stencilClearMode = new ai2({ func: c2.ALWAYS, mask: 0 }, 0, 255, c2.ZERO, c2.ZERO, c2.ZERO), this.tileExtentMesh = new kt2(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e2 = this.context, i2 = e2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const a2 = t.N();
            t.c7(a2, 0, this.width, this.height, 0, 0, 1), t.Q(a2, a2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]);
            const r2 = { mainMatrix: a2, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: a2 };
            this.useProgram("clippingMask", null, true).draw(e2, i2.TRIANGLES, ti2.disabled, this.stencilClearMode, Qt2.disabled, ei2.disabled, null, null, r2, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e2, t2, i2) {
            if (this.currentStencilSource === e2.source || !e2.isTileClipped() || !t2 || !t2.length) return;
            this.currentStencilSource = e2.source, this.nextStencilID + t2.length > 256 && this.clearStencil();
            const a2 = this.context;
            a2.setColorMode(Qt2.disabled), a2.setDepthMode(ti2.disabled);
            const r2 = {};
            for (const e3 of t2) r2[e3.key] = this.nextStencilID++;
            this._renderTileMasks(r2, t2, i2, true), this._renderTileMasks(r2, t2, i2, false), this._tileClippingMaskIDs = r2;
          }
          _renderTileMasks(e2, t2, i2, a2) {
            const r2 = this.context, o2 = r2.gl, s2 = this.style.projection, n2 = this.transform, l2 = this.useProgram("clippingMask");
            for (const c2 of t2) {
              const t3 = e2[c2.key], h2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c2), u2 = s2.getMeshFromTileID(this.context, c2.canonical, a2, true, "stencil"), d2 = n2.getProjectionData({ overscaledTileID: c2, applyGlobeMatrix: !i2, applyTerrainMatrix: true });
              l2.draw(r2, o2.TRIANGLES, ti2.disabled, new ai2({ func: o2.ALWAYS, mask: 0 }, t3, 255, o2.KEEP, o2.KEEP, o2.REPLACE), Qt2.disabled, i2 ? ei2.disabled : ei2.backCCW, null, h2, d2, "$clipping", u2.vertexBuffer, u2.indexBuffer, u2.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e2 = this.context, t2 = e2.gl, i2 = this.style.projection, a2 = this.transform, r2 = this.useProgram("depth"), o2 = this.getDepthModeFor3D(), s2 = Ie2(a2, { tileSize: a2.tileSize });
            for (const n2 of s2) {
              const s3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n2), l2 = i2.getMeshFromTileID(this.context, n2.canonical, true, true, "raster"), c2 = a2.getProjectionData({ overscaledTileID: n2, applyGlobeMatrix: true, applyTerrainMatrix: true });
              r2.draw(e2, t2.TRIANGLES, o2, ai2.disabled, Qt2.disabled, ei2.backCCW, null, s3, c2, "$clipping", l2.vertexBuffer, l2.indexBuffer, l2.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e2 = this.nextStencilID++, t2 = this.context.gl;
            return new ai2({ func: t2.NOTEQUAL, mask: 255 }, e2, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
          }
          stencilModeForClipping(e2) {
            const t2 = this.context.gl;
            return new ai2({ func: t2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, t2.KEEP, t2.KEEP, t2.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e2) {
            const t2 = this.context.gl, i2 = e2.sort(((e3, t3) => t3.overscaledZ - e3.overscaledZ)), a2 = i2[i2.length - 1].overscaledZ, r2 = i2[0].overscaledZ - a2 + 1;
            if (r2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + r2 > 256 && this.clearStencil();
              const e3 = {};
              for (let i3 = 0; i3 < r2; i3++) e3[i3 + a2] = new ai2({ func: t2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
              return this.nextStencilID += r2, [e3, i2];
            }
            return [{ [a2]: ai2.disabled }, i2];
          }
          stencilConfigForOverlapTwoPass(e2) {
            const t2 = this.context.gl, i2 = e2.sort(((e3, t3) => t3.overscaledZ - e3.overscaledZ)), a2 = i2[i2.length - 1].overscaledZ, r2 = i2[0].overscaledZ - a2 + 1;
            if (this.clearStencil(), r2 > 1) {
              const e3 = {}, o2 = {};
              for (let i3 = 0; i3 < r2; i3++) e3[i3 + a2] = new ai2({ func: t2.GREATER, mask: 255 }, r2 + 1 + i3, 255, t2.KEEP, t2.KEEP, t2.REPLACE), o2[i3 + a2] = new ai2({ func: t2.GREATER, mask: 255 }, 1 + i3, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
              return this.nextStencilID = 2 * r2 + 1, [e3, o2, i2];
            }
            return this.nextStencilID = 3, [{ [a2]: new ai2({ func: t2.GREATER, mask: 255 }, 2, 255, t2.KEEP, t2.KEEP, t2.REPLACE) }, { [a2]: new ai2({ func: t2.GREATER, mask: 255 }, 1, 255, t2.KEEP, t2.KEEP, t2.REPLACE) }, i2];
          }
          colorModeForRenderPass() {
            const e2 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i2 = 1 / 8;
              return new Qt2([e2.CONSTANT_COLOR, e2.ONE], new t.bp(i2, i2, i2, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? Qt2.unblended : Qt2.alphaBlended;
          }
          getDepthModeForSublayer(e2, t2, i2) {
            if (!this.opaquePassEnabledForLayer()) return ti2.disabled;
            const a2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
            return new ti2(i2 || this.context.gl.LEQUAL, t2, [a2, a2]);
          }
          getDepthModeFor3D() {
            return new ti2(this.context.gl.LEQUAL, ti2.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e2, i2) {
            var a2, r2;
            this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(c()), this.imageManager.beginFrame();
            const o2 = this.style._order, s2 = this.style.tileManagers, n2 = {}, l2 = {}, h2 = {}, u2 = { isRenderingToTexture: false, isRenderingGlobe: (null === (a2 = e2.projection) || void 0 === a2 ? void 0 : a2.transitionState) > 0 };
            for (const e3 in s2) {
              const t2 = s2[e3];
              t2.used && t2.prepare(this.context), n2[e3] = t2.getVisibleCoordinates(false), l2[e3] = n2[e3].slice().reverse(), h2[e3] = t2.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e3 = 0; e3 < o2.length; e3++) if (this.style._layers[o2[e3]].is3D()) {
              this.opaquePassCutoff = e3;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const e3 of o2) {
              const t2 = this.style._layers[e3];
              if (!t2.hasOffscreenPass() || t2.isHidden(this.transform.zoom)) continue;
              const i3 = l2[t2.source];
              ("custom" === t2.type || i3.length) && this.renderLayer(this, s2[t2.source], t2, i3, u2);
            }
            if (null === (r2 = this.style.projection) || void 0 === r2 || r2.updateGPUdependent({ context: this.context, useProgram: (e3) => this.useProgram(e3) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.bp.black : t.bp.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(e3, t2) {
              const i3 = e3.context, a3 = i3.gl, r3 = ((e4, t3, i4) => {
                const a4 = Math.cos(t3.rollInRadians), r4 = Math.sin(t3.rollInRadians), o4 = ge2(t3), s4 = t3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                return { u_sky_color: e4.properties.get("sky-color"), u_horizon_color: e4.properties.get("horizon-color"), u_horizon: [(t3.width / 2 - o4 * r4) * i4, (t3.height / 2 + o4 * a4) * i4], u_horizon_normal: [-r4, a4], u_sky_horizon_blend: e4.properties.get("sky-horizon-blend") * t3.height / 2 * i4, u_sky_blend: s4 };
              })(t2, e3.style.map.transform, e3.pixelRatio), o3 = new ti2(a3.LEQUAL, ti2.ReadWrite, [0, 1]), s3 = ai2.disabled, n3 = e3.colorModeForRenderPass(), l3 = e3.useProgram("sky"), c2 = Vr2(i3, t2);
              l3.draw(i3, a3.TRIANGLES, o3, s3, n3, ei2.disabled, r3, null, void 0, "sky", c2.vertexBuffer, c2.indexBuffer, c2.segments);
            })(this, this.style.sky), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const e3 = this.style._layers[o2[this.currentLayer]], t2 = s2[e3.source], i3 = n2[e3.source];
              this._renderTileClippingMasks(e3, i3, false), this.renderLayer(this, t2, e3, i3, u2);
            }
            this.renderPass = "translucent";
            let d2 = false;
            for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
              const e3 = this.style._layers[o2[this.currentLayer]], t2 = s2[e3.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(e3, u2)) continue;
              this.opaquePassEnabledForLayer() || d2 || (d2 = true, u2.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const i3 = ("symbol" === e3.type ? h2 : l2)[e3.source];
              this._renderTileClippingMasks(e3, n2[e3.source], !!this.renderToTexture), this.renderLayer(this, t2, e3, i3, u2);
            }
            if (u2.isRenderingGlobe && (function(e3, i3, a3) {
              const r3 = e3.context, o3 = r3.gl, s3 = e3.useProgram("atmosphere"), n3 = new ti2(o3.LEQUAL, ti2.ReadOnly, [0, 1]), l3 = e3.transform, c2 = (function(e4, i4) {
                const a4 = e4.properties.get("position"), r4 = [-a4.x, -a4.y, -a4.z], o4 = t.ar(new Float64Array(16));
                return "map" === e4.properties.get("anchor") && (t.bg(o4, o4, i4.rollInRadians), t.bh(o4, o4, -i4.pitchInRadians), t.bg(o4, o4, i4.bearingInRadians), t.bh(o4, o4, i4.center.lat * Math.PI / 180), t.bJ(o4, o4, -i4.center.lng * Math.PI / 180)), t.cg(r4, r4, o4), r4;
              })(a3, e3.transform), h3 = l3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), u3 = i3.properties.get("atmosphere-blend") * h3.projectionTransition;
              if (0 === u3) return;
              const d3 = fi2(l3.worldSize, l3.center.lat), _3 = l3.inverseProjectionMatrix, p2 = new Float64Array(4);
              p2[3] = 1, t.aH(p2, p2, l3.modelViewProjectionMatrix), p2[0] /= p2[3], p2[1] /= p2[3], p2[2] /= p2[3], p2[3] = 1, t.aH(p2, p2, _3), p2[0] /= p2[3], p2[1] /= p2[3], p2[2] /= p2[3], p2[3] = 1;
              const m2 = /* @__PURE__ */ ((e4, t2, i4, a4, r4) => ({ u_sun_pos: e4, u_atmosphere_blend: t2, u_globe_position: i4, u_globe_radius: a4, u_inv_proj_matrix: r4 }))(c2, u3, [p2[0], p2[1], p2[2]], d3, _3), f3 = Vr2(r3, i3);
              s3.draw(r3, o3.TRIANGLES, n3, ai2.disabled, Qt2.alphaBlended, ei2.disabled, m2, null, null, "atmosphere", f3.vertexBuffer, f3.indexBuffer, f3.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const e3 = (function(e4, t2) {
                let i3 = null;
                const a3 = Object.values(e4._layers).flatMap(((i4) => i4.source && !i4.isHidden(t2) ? [e4.tileManagers[i4.source]] : [])), r3 = a3.filter(((e5) => "vector" === e5.getSource().type)), o3 = a3.filter(((e5) => "vector" !== e5.getSource().type)), s3 = (e5) => {
                  (!i3 || i3.getSource().maxzoom < e5.getSource().maxzoom) && (i3 = e5);
                };
                return r3.forEach(((e5) => s3(e5))), i3 || o3.forEach(((e5) => s3(e5))), i3;
              })(this.style, this.transform.zoom);
              e3 && (function(e4, t2, i3) {
                for (let a3 = 0; a3 < i3.length; a3++) Gr2(e4, t2, i3[a3]);
              })(this, e3, e3.getVisibleCoordinates());
            }
            this.options.showPadding && (function(e3) {
              const t2 = e3.transform.padding;
              jr2(e3, e3.transform.height - (t2.top || 0), 3, Lr2), jr2(e3, t2.bottom || 0, 3, kr), Nr2(e3, t2.left || 0, 3, Fr2), Nr2(e3, e3.transform.width - (t2.right || 0), 3, Br2);
              const i3 = e3.transform.centerPoint;
              !(function(e4, t3, i4, a3) {
                Zr2(e4, t3 - 1, i4 - 10, 2, 20, a3), Zr2(e4, t3 - 10, i4 - 1, 20, 2, a3);
              })(e3, i3.x, e3.transform.height - i3.y, Or2);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e2) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const i2 = this.terrainFacilitator.matrix, a2 = this.transform.modelViewProjectionMatrix;
            let r2 = this.terrainFacilitator.dirty;
            r2 || (r2 = e2 ? !t.cj(i2, a2) : !t.ck(i2, a2)), r2 || (r2 = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), r2 && (t.cl(i2, a2), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, (function(e3, i3) {
              const a3 = e3.context, r3 = a3.gl, o2 = e3.transform, s2 = Qt2.unblended, n2 = new ti2(r3.LEQUAL, ti2.ReadWrite, [0, 1]), l2 = i3.tileManager.getRenderableTiles(), c2 = e3.useProgram("terrainDepth");
              a3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), a3.viewport.set([0, 0, e3.width / devicePixelRatio, e3.height / devicePixelRatio]), a3.clear({ color: t.bp.transparent, depth: 1 });
              for (const e4 of l2) {
                const t2 = i3.getTerrainMesh(e4.tileID), l3 = i3.getTerrainData(e4.tileID), h2 = o2.getProjectionData({ overscaledTileID: e4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), u2 = { u_ele_delta: i3.getMeshFrameDelta(o2.zoom) };
                c2.draw(a3, r3.TRIANGLES, n2, ai2.disabled, s2, ei2.backCCW, u2, l3, h2, "terrain", t2.vertexBuffer, t2.indexBuffer, t2.segments);
              }
              a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, e3.width, e3.height]);
            })(this, this.style.map.terrain), (function(e3, i3) {
              const a3 = e3.context, r3 = a3.gl, o2 = e3.transform, s2 = Qt2.unblended, n2 = new ti2(r3.LEQUAL, ti2.ReadWrite, [0, 1]), l2 = i3.getCoordsTexture(), c2 = i3.tileManager.getRenderableTiles(), h2 = e3.useProgram("terrainCoords");
              a3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), a3.viewport.set([0, 0, e3.width / devicePixelRatio, e3.height / devicePixelRatio]), a3.clear({ color: t.bp.transparent, depth: 1 }), i3.coordsIndex = [];
              for (const e4 of c2) {
                const t2 = i3.getTerrainMesh(e4.tileID), c3 = i3.getTerrainData(e4.tileID);
                a3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, l2.texture);
                const u2 = { u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i3.getMeshFrameDelta(o2.zoom) }, d2 = o2.getProjectionData({ overscaledTileID: e4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                h2.draw(a3, r3.TRIANGLES, n2, ai2.disabled, s2, ei2.backCCW, u2, c3, d2, "terrain", t2.vertexBuffer, t2.indexBuffer, t2.segments), i3.coordsIndex.push(e4.tileID.key);
              }
              a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, e3.width, e3.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(e2, i2, a2, r2, o2) {
            a2.isHidden(this.transform.zoom) || ("background" === a2.type || "custom" === a2.type || (r2 || []).length) && (this.id = a2.id, t.cm(a2) ? (function(e3, i3, a3, r3, o3, s2) {
              if ("translucent" !== e3.renderPass) return;
              const { isRenderingToTexture: n2 } = s2, l2 = ai2.disabled, c2 = e3.colorModeForRenderPass();
              (a3._unevaluatedLayout.hasValue("text-variable-anchor") || a3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(e4, i4, a4, r4, o4, s3, n3, l3, c3) {
                const h2 = i4.transform, u2 = i4.style.map.terrain, d2 = "map" === o4, _3 = "map" === s3;
                for (const o5 of e4) {
                  const e5 = r4.getTile(o5), s4 = e5.getBucket(a4);
                  if (!s4 || !s4.text || !s4.text.segments.get().length) continue;
                  const p2 = t.ay(s4.textSizeData, h2.zoom), m2 = t.aN(e5, 1, i4.transform.zoom), f3 = je2(d2, i4.transform, m2), g2 = "none" !== a4.layout.get("icon-text-fit") && s4.hasIconData();
                  if (p2) {
                    const i5 = Math.pow(2, h2.zoom - e5.tileID.overscaledZ), a5 = u2 ? (e6, t2) => u2.getElevation(o5, e6, t2) : null;
                    _r2(s4, d2, _3, c3, h2, f3, i5, p2, g2, t.aO(h2, e5, n3, l3), o5.toUnwrapped(), a5);
                  }
                }
              })(r3, e3, a3, i3, a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), o3), 0 !== a3.paint.get("icon-opacity").constantOr(1) && mr2(e3, i3, a3, r3, false, a3.paint.get("icon-translate"), a3.paint.get("icon-translate-anchor"), a3.layout.get("icon-rotation-alignment"), a3.layout.get("icon-pitch-alignment"), a3.layout.get("icon-keep-upright"), l2, c2, n2), 0 !== a3.paint.get("text-opacity").constantOr(1) && mr2(e3, i3, a3, r3, true, a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.layout.get("text-keep-upright"), l2, c2, n2), i3.map.showCollisionBoxes && (cr2(e3, i3, a3, r3, true), cr2(e3, i3, a3, r3, false));
            })(e2, i2, a2, r2, this.style.placement.variableOffsets, o2) : t.cn(a2) ? (function(e3, i3, a3, r3, o3) {
              if ("translucent" !== e3.renderPass) return;
              const { isRenderingToTexture: s2 } = o3, n2 = a3.paint.get("circle-opacity"), l2 = a3.paint.get("circle-stroke-width"), c2 = a3.paint.get("circle-stroke-opacity"), h2 = !a3.layout.get("circle-sort-key").isConstant();
              if (0 === n2.constantOr(1) && (0 === l2.constantOr(1) || 0 === c2.constantOr(1))) return;
              const u2 = e3.context, d2 = u2.gl, _3 = e3.transform, p2 = e3.getDepthModeForSublayer(0, ti2.ReadOnly), m2 = ai2.disabled, f3 = e3.colorModeForRenderPass(), g2 = [], v2 = _3.getCircleRadiusCorrection();
              for (let o4 = 0; o4 < r3.length; o4++) {
                const n3 = r3[o4], l3 = i3.getTile(n3), c3 = l3.getBucket(a3);
                if (!c3) continue;
                const u3 = a3.paint.get("circle-translate"), d3 = a3.paint.get("circle-translate-anchor"), p3 = t.aO(_3, l3, u3, d3), m3 = c3.programConfigurations.get(a3.id), f4 = e3.useProgram("circle", m3), x2 = c3.layoutVertexBuffer, b2 = c3.indexBuffer, y3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(n3), w3 = { programConfiguration: m3, program: f4, layoutVertexBuffer: x2, indexBuffer: b2, uniformValues: Hi2(e3, l3, a3, p3, v2), terrainData: y3, projectionData: _3.getProjectionData({ overscaledTileID: n3, applyGlobeMatrix: !s2, applyTerrainMatrix: true }) };
                if (h2) {
                  const e4 = c3.segments.get();
                  for (const i4 of e4) g2.push({ segments: new t.aX([i4]), sortKey: i4.sortKey, state: w3 });
                } else g2.push({ segments: c3.segments, sortKey: 0, state: w3 });
              }
              h2 && g2.sort(((e4, t2) => e4.sortKey - t2.sortKey));
              for (const t2 of g2) {
                const { programConfiguration: i4, program: r4, layoutVertexBuffer: o4, indexBuffer: s3, uniformValues: n3, terrainData: l3, projectionData: c3 } = t2.state;
                r4.draw(u2, d2.TRIANGLES, p2, m2, f3, ei2.backCCW, n3, l3, c3, a3.id, o4, s3, t2.segments, a3.paint, e3.transform.zoom, i4);
              }
            })(e2, i2, a2, r2, o2) : t.co(a2) ? (function(e3, i3, a3, r3, o3) {
              if (0 === a3.paint.get("heatmap-opacity")) return;
              const s2 = e3.context, { isRenderingToTexture: n2, isRenderingGlobe: l2 } = o3;
              if (e3.style.map.terrain) {
                for (const t2 of r3) {
                  const r4 = i3.getTile(t2);
                  i3.hasRenderableParent(t2) || ("offscreen" === e3.renderPass ? gr2(e3, r4, a3, t2, l2) : "translucent" === e3.renderPass && vr2(e3, a3, t2, n2, l2));
                }
                s2.viewport.set([0, 0, e3.width, e3.height]);
              } else "offscreen" === e3.renderPass ? (function(e4, i4, a4, r4) {
                const o4 = e4.context, s3 = o4.gl, n3 = e4.transform, l3 = ai2.disabled, c2 = new Qt2([s3.ONE, s3.ONE], t.bp.transparent, [true, true, true, true]);
                (function(e5, i5, a5) {
                  const r5 = e5.gl;
                  e5.activeTexture.set(r5.TEXTURE1), e5.viewport.set([0, 0, i5.width / 4, i5.height / 4]);
                  let o5 = a5.heatmapFbos.get(t.cd);
                  o5 ? (r5.bindTexture(r5.TEXTURE_2D, o5.colorAttachment.get()), e5.bindFramebuffer.set(o5.framebuffer)) : (o5 = xr(e5, i5.width / 4, i5.height / 4), a5.heatmapFbos.set(t.cd, o5));
                })(o4, e4, a4), o4.clear({ color: t.bp.transparent });
                for (let t2 = 0; t2 < r4.length; t2++) {
                  const h2 = r4[t2];
                  if (i4.hasRenderableParent(h2)) continue;
                  const u2 = i4.getTile(h2), d2 = u2.getBucket(a4);
                  if (!d2) continue;
                  const _3 = d2.programConfigurations.get(a4.id), p2 = e4.useProgram("heatmap", _3), m2 = n3.getProjectionData({ overscaledTileID: h2, applyGlobeMatrix: true, applyTerrainMatrix: false }), f3 = n3.getCircleRadiusCorrection();
                  p2.draw(o4, s3.TRIANGLES, ti2.disabled, l3, c2, ei2.backCCW, Qi2(u2, n3.zoom, a4.paint.get("heatmap-intensity"), f3), null, m2, a4.id, d2.layoutVertexBuffer, d2.indexBuffer, d2.segments, a4.paint, n3.zoom, _3);
                }
                o4.viewport.set([0, 0, e4.width, e4.height]);
              })(e3, i3, a3, r3) : "translucent" === e3.renderPass && (function(e4, i4) {
                const a4 = e4.context, r4 = a4.gl;
                a4.setColorMode(e4.colorModeForRenderPass());
                const o4 = i4.heatmapFbos.get(t.cd);
                o4 && (a4.activeTexture.set(r4.TEXTURE0), r4.bindTexture(r4.TEXTURE_2D, o4.colorAttachment.get()), a4.activeTexture.set(r4.TEXTURE1), br2(a4, i4).bind(r4.LINEAR, r4.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(a4, r4.TRIANGLES, ti2.disabled, ai2.disabled, e4.colorModeForRenderPass(), ei2.disabled, Ji2(e4, i4, 0, 1), null, null, i4.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i4.paint, e4.transform.zoom));
              })(e3, a3);
            })(e2, i2, a2, r2, o2) : t.cp(a2) ? (function(e3, t2, i3, a3, r3) {
              if ("translucent" !== e3.renderPass) return;
              const { isRenderingToTexture: o3 } = r3, s2 = i3.paint.get("line-opacity"), n2 = i3.paint.get("line-width");
              if (0 === s2.constantOr(1) || 0 === n2.constantOr(1)) return;
              const l2 = e3.getDepthModeForSublayer(0, ti2.ReadOnly), c2 = e3.colorModeForRenderPass(), h2 = i3.paint.get("line-dasharray"), u2 = h2.constantOr(1), d2 = i3.paint.get("line-pattern"), _3 = d2.constantOr(1), p2 = i3.paint.get("line-gradient"), m2 = i3.getCrossfadeParameters();
              let f3;
              f3 = _3 ? "linePattern" : u2 && p2 ? "lineGradientSDF" : u2 ? "lineSDF" : p2 ? "lineGradient" : "line";
              const g2 = e3.context, v2 = g2.gl, x2 = e3.transform;
              let b2 = true;
              for (const r4 of a3) {
                const a4 = t2.getTile(r4);
                if (_3 && !a4.patternsLoaded()) continue;
                const s3 = a4.getBucket(i3);
                if (!s3) continue;
                const n3 = s3.programConfigurations.get(i3.id), y3 = e3.context.program.get(), w3 = e3.useProgram(f3, n3), T3 = b2 || w3.program !== y3, P3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(r4), C2 = d2.constantOr(null), I3 = h2 && h2.constantOr(null);
                if (C2 && a4.imageAtlas) {
                  const e4 = a4.imageAtlas, t3 = e4.patternPositions[C2.to.toString()], i4 = e4.patternPositions[C2.from.toString()];
                  t3 && i4 && n3.setConstantPatternPositions(t3, i4);
                } else if (I3) {
                  const t3 = "round" === i3.layout.get("line-cap"), a5 = e3.lineAtlas.getDash(I3.to, t3), r5 = e3.lineAtlas.getDash(I3.from, t3);
                  n3.setConstantDashPositions(a5, r5);
                }
                const M3 = x2.getProjectionData({ overscaledTileID: r4, applyGlobeMatrix: !o3, applyTerrainMatrix: true }), E2 = x2.getPixelScale();
                let S3;
                _3 ? (S3 = sa2(e3, a4, i3, E2, m2), wr2(g2, v2, a4, n3, m2)) : u2 && p2 ? (S3 = la2(e3, a4, i3, E2, m2, s3.lineClipsArray.length), Cr2(e3, t2, g2, v2, i3, s3, r4, n3, m2)) : u2 ? (S3 = na2(e3, a4, i3, E2, m2), Tr2(e3, g2, v2, n3, T3, m2)) : p2 ? (S3 = oa2(e3, a4, i3, E2, s3.lineClipsArray.length), Pr2(e3, t2, g2, v2, i3, s3, r4)) : S3 = ra2(e3, a4, i3, E2);
                const z3 = e3.stencilModeForClipping(r4);
                w3.draw(g2, v2.TRIANGLES, l2, z3, c2, ei2.disabled, S3, P3, M3, i3.id, s3.layoutVertexBuffer, s3.indexBuffer, s3.segments, i3.paint, e3.transform.zoom, n3, s3.layoutVertexBuffer2), b2 = false;
              }
            })(e2, i2, a2, r2, o2) : t.cq(a2) ? (function(e3, i3, a3, r3, o3) {
              const s2 = a3.paint.get("fill-color"), n2 = a3.paint.get("fill-opacity");
              if (0 === n2.constantOr(1)) return;
              const { isRenderingToTexture: l2 } = o3, c2 = e3.colorModeForRenderPass(), h2 = a3.paint.get("fill-pattern"), u2 = e3.opaquePassEnabledForLayer() && !h2.constantOr(1) && 1 === s2.constantOr(t.bp.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
              if (e3.renderPass === u2) {
                const t2 = e3.getDepthModeForSublayer(1, "opaque" === e3.renderPass ? ti2.ReadWrite : ti2.ReadOnly);
                Mr2(e3, i3, a3, r3, t2, c2, false, l2);
              }
              if ("translucent" === e3.renderPass && a3.paint.get("fill-antialias")) {
                const t2 = e3.getDepthModeForSublayer(a3.getPaintProperty("fill-outline-color") ? 2 : 0, ti2.ReadOnly);
                Mr2(e3, i3, a3, r3, t2, c2, true, l2);
              }
            })(e2, i2, a2, r2, o2) : t.cr(a2) ? (function(e3, t2, i3, a3, r3) {
              const o3 = i3.paint.get("fill-extrusion-opacity");
              if (0 === o3) return;
              const { isRenderingToTexture: s2 } = r3;
              if ("translucent" === e3.renderPass) {
                const r4 = new ti2(e3.context.gl.LEQUAL, ti2.ReadWrite, e3.depthRangeFor3D);
                if (1 !== o3 || i3.paint.get("fill-extrusion-pattern").constantOr(1)) Er2(e3, t2, i3, a3, r4, ai2.disabled, Qt2.disabled, s2), Er2(e3, t2, i3, a3, r4, e3.stencilModeFor3D(), e3.colorModeForRenderPass(), s2);
                else {
                  const o4 = e3.colorModeForRenderPass();
                  Er2(e3, t2, i3, a3, r4, ai2.disabled, o4, s2);
                }
              }
            })(e2, i2, a2, r2, o2) : t.cs(a2) ? (function(e3, i3, a3, r3, o3) {
              if ("offscreen" !== e3.renderPass && "translucent" !== e3.renderPass) return;
              const { isRenderingToTexture: s2 } = o3, n2 = e3.context, l2 = e3.style.projection.useSubdivision, c2 = e3.getDepthModeForSublayer(0, ti2.ReadOnly), h2 = e3.colorModeForRenderPass();
              if ("offscreen" === e3.renderPass) !(function(e4, i4, a4, r4, o4, s3, n3) {
                const l3 = e4.context, c3 = l3.gl;
                for (const h3 of a4) {
                  const a5 = i4.getTile(h3), u2 = a5.dem;
                  if (!u2 || !u2.data) continue;
                  if (!a5.needsHillshadePrepare) continue;
                  const d2 = u2.dim, _3 = u2.stride, p2 = u2.getPixels();
                  if (l3.activeTexture.set(c3.TEXTURE1), l3.pixelStoreUnpackPremultiplyAlpha.set(false), a5.demTexture = a5.demTexture || e4.getTileTexture(_3), a5.demTexture) {
                    const e5 = a5.demTexture;
                    e5.update(p2, { premultiply: false }), e5.bind(c3.NEAREST, c3.CLAMP_TO_EDGE);
                  } else a5.demTexture = new t.T(l3, p2, c3.RGBA, { premultiply: false }), a5.demTexture.bind(c3.NEAREST, c3.CLAMP_TO_EDGE);
                  l3.activeTexture.set(c3.TEXTURE0);
                  let m2 = a5.fbo;
                  if (!m2) {
                    const e5 = new t.T(l3, { width: d2, height: d2, data: null }, c3.RGBA);
                    e5.bind(c3.LINEAR, c3.CLAMP_TO_EDGE), m2 = a5.fbo = l3.createFramebuffer(d2, d2, true, false), m2.colorAttachment.set(e5.texture);
                  }
                  l3.bindFramebuffer.set(m2.framebuffer), l3.viewport.set([0, 0, d2, d2]), e4.useProgram("hillshadePrepare").draw(l3, c3.TRIANGLES, o4, s3, n3, ei2.disabled, ta2(a5.tileID, u2), null, null, r4.id, e4.rasterBoundsBuffer, e4.quadTriangleIndexBuffer, e4.rasterBoundsSegments), a5.needsHillshadePrepare = false;
                }
              })(e3, i3, r3, a3, c2, ai2.disabled, h2), n2.viewport.set([0, 0, e3.width, e3.height]);
              else if ("translucent" === e3.renderPass) if (l2) {
                const [t2, o4, n3] = e3.stencilConfigForOverlapTwoPass(r3);
                Sr2(e3, i3, a3, n3, t2, c2, h2, false, s2), Sr2(e3, i3, a3, n3, o4, c2, h2, true, s2);
              } else {
                const [t2, o4] = e3.getStencilConfigForOverlapAndUpdateStencilID(r3);
                Sr2(e3, i3, a3, o4, t2, c2, h2, false, s2);
              }
            })(e2, i2, a2, r2, o2) : t.ct(a2) ? (function(e3, t2, i3, a3, r3) {
              if ("translucent" !== e3.renderPass) return;
              if (!a3.length) return;
              const { isRenderingToTexture: o3 } = r3, s2 = e3.style.projection.useSubdivision, n2 = e3.getDepthModeForSublayer(0, ti2.ReadOnly), l2 = e3.colorModeForRenderPass();
              if (s2) {
                const [r4, s3, c2] = e3.stencilConfigForOverlapTwoPass(a3);
                zr2(e3, t2, i3, c2, r4, n2, l2, false, o3), zr2(e3, t2, i3, c2, s3, n2, l2, true, o3);
              } else {
                const [r4, s3] = e3.getStencilConfigForOverlapAndUpdateStencilID(a3);
                zr2(e3, t2, i3, s3, r4, n2, l2, false, o3);
              }
            })(e2, i2, a2, r2, o2) : t.bU(a2) ? (function(e3, t2, i3, a3, r3) {
              if ("translucent" !== e3.renderPass) return;
              if (0 === i3.paint.get("raster-opacity")) return;
              if (!a3.length) return;
              const { isRenderingToTexture: o3 } = r3, s2 = t2.getSource(), n2 = e3.style.projection.useSubdivision;
              if (s2 instanceof te2) Dr2(e3, t2, i3, a3, null, false, false, s2.tileCoords, s2.flippedWindingOrder, o3);
              else if (n2) {
                const [r4, s3, n3] = e3.stencilConfigForOverlapTwoPass(a3);
                Dr2(e3, t2, i3, n3, r4, false, true, Rr2, false, o3), Dr2(e3, t2, i3, n3, s3, true, true, Rr2, false, o3);
              } else {
                const [r4, s3] = e3.getStencilConfigForOverlapAndUpdateStencilID(a3);
                Dr2(e3, t2, i3, s3, r4, false, true, Rr2, false, o3);
              }
            })(e2, i2, a2, r2, o2) : t.cu(a2) ? (function(e3, t2, i3, a3, r3) {
              const o3 = i3.paint.get("background-color"), s2 = i3.paint.get("background-opacity");
              if (0 === s2) return;
              const { isRenderingToTexture: n2 } = r3, l2 = e3.context, c2 = l2.gl, h2 = e3.style.projection, u2 = e3.transform, d2 = u2.tileSize, _3 = i3.paint.get("background-pattern");
              if (e3.isPatternMissing(_3)) return;
              const p2 = !_3 && 1 === o3.a && 1 === s2 && e3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (e3.renderPass !== p2) return;
              const m2 = ai2.disabled, f3 = e3.getDepthModeForSublayer(0, "opaque" === p2 ? ti2.ReadWrite : ti2.ReadOnly), g2 = e3.colorModeForRenderPass(), v2 = e3.useProgram(_3 ? "backgroundPattern" : "background"), x2 = a3 || Ie2(u2, { tileSize: d2, terrain: e3.style.map.terrain });
              _3 && (l2.activeTexture.set(c2.TEXTURE0), e3.imageManager.bind(e3.context));
              const b2 = i3.getCrossfadeParameters();
              for (const t3 of x2) {
                const a4 = u2.getProjectionData({ overscaledTileID: t3, applyGlobeMatrix: !n2, applyTerrainMatrix: true }), r4 = _3 ? ga2(s2, e3, _3, { tileID: t3, tileSize: d2 }, b2) : fa2(s2, o3), p3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(t3), x3 = h2.getMeshFromTileID(l2, t3.canonical, false, true, "raster");
                v2.draw(l2, c2.TRIANGLES, f3, m2, g2, ei2.backCCW, r4, p3, a4, i3.id, x3.vertexBuffer, x3.indexBuffer, x3.segments);
              }
            })(e2, 0, a2, r2, o2) : t.cv(a2) && (function(e3, t2, i3, a3) {
              const { isRenderingGlobe: r3 } = a3, o3 = e3.context, s2 = i3.implementation, n2 = e3.style.projection, l2 = e3.transform, c2 = l2.getProjectionDataForCustomLayer(r3), h2 = { farZ: l2.farZ, nearZ: l2.nearZ, fov: l2.fov * Math.PI / 180, modelViewProjectionMatrix: l2.modelViewProjectionMatrix, projectionMatrix: l2.projectionMatrix, shaderData: { variantName: n2.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${n2.shaderPreludeCode.vertexSource}`, define: n2.shaderDefine }, defaultProjectionData: c2 }, u2 = s2.renderingMode ? s2.renderingMode : "2d";
              if ("offscreen" === e3.renderPass) {
                const t3 = s2.prerender;
                t3 && (e3.setCustomLayerDefaults(), o3.setColorMode(e3.colorModeForRenderPass()), t3.call(s2, o3.gl, h2), o3.setDirty(), e3.setBaseState());
              } else if ("translucent" === e3.renderPass) {
                e3.setCustomLayerDefaults(), o3.setColorMode(e3.colorModeForRenderPass()), o3.setStencilMode(ai2.disabled);
                const t3 = "3d" === u2 ? e3.getDepthModeFor3D() : e3.getDepthModeForSublayer(0, ti2.ReadOnly);
                o3.setDepthMode(t3), s2.render(o3.gl, h2), o3.setDirty(), e3.setBaseState(), o3.bindFramebuffer.set(null);
              }
            })(e2, 0, a2, o2));
          }
          saveTileTexture(e2) {
            const t2 = this._tileTextures[e2.size[0]];
            t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
          }
          getTileTexture(e2) {
            const t2 = this._tileTextures[e2];
            return t2 && t2.length > 0 ? t2.pop() : null;
          }
          isPatternMissing(e2) {
            if (!e2) return false;
            if (!e2.from || !e2.to) return true;
            const t2 = this.imageManager.getPattern(e2.from.toString()), i2 = this.imageManager.getPattern(e2.to.toString());
            return !t2 || !i2;
          }
          useProgram(e2, t2, i2 = false, a2 = []) {
            this.cache = this.cache || {};
            const r2 = !!this.style.map.terrain, o2 = this.style.projection, s2 = i2 ? At2.projectionMercator : o2.shaderPreludeCode, n2 = i2 ? Bt2 : o2.shaderDefine, l2 = e2 + (t2 ? t2.cacheKey : "") + `/${i2 ? Ot2 : o2.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (r2 ? "/terrain" : "") + (a2 ? `/${a2.join("/")}` : "");
            return this.cache[l2] || (this.cache[l2] = new Zi2(this.context, At2[e2], t2, xa2[e2], this._showOverdrawInspector, r2, s2, n2, a2)), this.cache[l2];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e2 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            var e2, t2;
            if (this._tileTextures) {
              for (const e3 in this._tileTextures) {
                const t3 = this._tileTextures[e3];
                if (t3) for (const e4 of t3) e4.destroy();
              }
              this._tileTextures = {};
            }
            if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && (null === (e2 = this.tileExtentMesh.vertexBuffer) || void 0 === e2 || e2.destroy()), this.tileExtentMesh && (null === (t2 = this.tileExtentMesh.indexBuffer) || void 0 === t2 || t2.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) {
              for (const e3 in this.cache) {
                const t3 = this.cache[e3];
                t3 && t3.program && this.context.gl.deleteProgram(t3.program);
              }
              this.cache = {};
            }
            this.context && this.context.setDefault();
          }
          overLimit() {
            const { drawingBufferWidth: e2, drawingBufferHeight: t2 } = this.context.gl;
            return this.width !== e2 || this.height !== t2;
          }
        }
        function Wr2(e2, t2) {
          let i2, a2 = false, r2 = null, o2 = null;
          const s2 = () => {
            r2 = null, a2 && (e2.apply(o2, i2), r2 = setTimeout(s2, t2), a2 = false);
          };
          return (...e3) => (a2 = true, o2 = this, i2 = e3, r2 || s2(), r2);
        }
        class $r2 {
          constructor(e2) {
            this._getCurrentHash = () => {
              const e3 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let t2;
                return e3.split("&").map(((e4) => e4.split("="))).forEach(((e4) => {
                  e4[0] === this._hashName && (t2 = e4);
                })), (t2 && t2[1] || "").split("/");
              }
              return e3.split("/");
            }, this._onHashChange = () => {
              const e3 = this._getCurrentHash();
              if (!this._isValidHash(e3)) return false;
              const t2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e3[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+e3[2], +e3[1]], zoom: +e3[0], bearing: t2, pitch: +(e3[4] || 0) }), true;
            }, this._updateHashUnthrottled = () => {
              const e3 = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, e3);
            }, this._removeHash = () => {
              const e3 = this._getCurrentHash();
              if (0 === e3.length) return;
              const t2 = e3.join("/");
              let i2 = t2;
              i2.split("&").length > 0 && (i2 = i2.split("&")[0]), this._hashName && (i2 = `${this._hashName}=${t2}`);
              let a2 = window.location.hash.replace(i2, "");
              a2.startsWith("#&") ? a2 = a2.slice(0, 1) + a2.slice(2) : "#" === a2 && (a2 = "");
              let r2 = window.location.href.replace(/(#.+)?$/, a2);
              r2 = r2.replace("&&", "&"), window.history.replaceState(window.history.state, null, r2);
            }, this._updateHash = Wr2(this._updateHashUnthrottled, 300), this._hashName = e2 && encodeURIComponent(e2);
          }
          addTo(e2) {
            return this._map = e2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e2) {
            const t2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, a2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), r2 = Math.pow(10, a2), o2 = Math.round(t2.lng * r2) / r2, s2 = Math.round(t2.lat * r2) / r2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
            let c2 = "";
            if (c2 += e2 ? `/${o2}/${s2}/${i2}` : `${i2}/${s2}/${o2}`, (n2 || l2) && (c2 += "/" + Math.round(10 * n2) / 10), l2 && (c2 += `/${Math.round(l2)}`), this._hashName) {
              const e3 = this._hashName;
              let t3 = false;
              const i3 = window.location.hash.slice(1).split("&").map(((i4) => {
                const a3 = i4.split("=")[0];
                return a3 === e3 ? (t3 = true, `${a3}=${c2}`) : i4;
              })).filter(((e4) => e4));
              return t3 || i3.push(`${e3}=${c2}`), `#${i3.join("&")}`;
            }
            return `#${c2}`;
          }
          _isValidHash(e2) {
            if (e2.length < 3 || e2.some(isNaN)) return false;
            try {
              new t.V(+e2[2], +e2[1]);
            } catch (e3) {
              return false;
            }
            const i2 = +e2[0], a2 = +(e2[3] || 0), r2 = +(e2[4] || 0);
            return i2 >= this._map.getMinZoom() && i2 <= this._map.getMaxZoom() && a2 >= -180 && a2 <= 180 && r2 >= this._map.getMinPitch() && r2 <= this._map.getMaxPitch();
          }
        }
        const Hr2 = { linearity: 0.3, easing: t.cw(0, 0, 0.3, 1) }, Xr2 = t.e({ deceleration: 2500, maxSpeed: 1400 }, Hr2), Kr2 = t.e({ deceleration: 20, maxSpeed: 1400 }, Hr2), Yr2 = t.e({ deceleration: 1e3, maxSpeed: 360 }, Hr2), Qr2 = t.e({ deceleration: 1e3, maxSpeed: 90 }, Hr2), Jr2 = t.e({ deceleration: 1e3, maxSpeed: 360 }, Hr2);
        class eo2 {
          constructor(e2) {
            this._map = e2, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: c(), settings: e2 });
          }
          _drainInertiaBuffer() {
            const e2 = this._inertiaBuffer, t2 = c();
            for (; e2.length > 0 && t2 - e2[0].time > 160; ) e2.shift();
          }
          _onMoveEnd(e2) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i2 = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new t.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e3 } of this._inertiaBuffer) i2.zoom += e3.zoomDelta || 0, i2.bearing += e3.bearingDelta || 0, i2.pitch += e3.pitchDelta || 0, i2.roll += e3.rollDelta || 0, e3.panDelta && i2.pan._add(e3.panDelta), e3.around && (i2.around = e3.around), e3.pinchAround && (i2.pinchAround = e3.pinchAround);
            const a2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r2 = {};
            if (i2.pan.mag()) {
              const o2 = io2(i2.pan.mag(), a2, t.e({}, Xr2, e2 || {})), s2 = i2.pan.mult(o2.amount / i2.pan.mag()), n2 = this._map.cameraHelper.handlePanInertia(s2, this._map.transform);
              r2.center = n2.easingCenter, r2.offset = n2.easingOffset, to2(r2, o2);
            }
            if (i2.zoom) {
              const e3 = io2(i2.zoom, a2, Kr2);
              r2.zoom = this._map.transform.zoom + e3.amount, to2(r2, e3);
            }
            if (i2.bearing) {
              const e3 = io2(i2.bearing, a2, Yr2);
              r2.bearing = this._map.transform.bearing + t.an(e3.amount, -179, 179), to2(r2, e3);
            }
            if (i2.pitch) {
              const e3 = io2(i2.pitch, a2, Qr2);
              r2.pitch = this._map.transform.pitch + e3.amount, to2(r2, e3);
            }
            if (i2.roll) {
              const e3 = io2(i2.roll, a2, Jr2);
              r2.roll = this._map.transform.roll + t.an(e3.amount, -179, 179), to2(r2, e3);
            }
            if (r2.zoom || r2.bearing) {
              const e3 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
              r2.around = e3 ? this._map.unproject(e3) : this._map.getCenter();
            }
            return this.clear(), t.e(r2, { noMoveStart: true });
          }
        }
        function to2(e2, t2) {
          (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
        }
        function io2(e2, i2, a2) {
          const { maxSpeed: r2, linearity: o2, deceleration: s2 } = a2, n2 = t.an(e2 * o2 / (i2 / 1e3), -r2, r2), l2 = Math.abs(n2) / (s2 * o2);
          return { easing: a2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
        }
        class ao2 extends t.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, i2, a2, r2 = {}) {
            a2 = a2 instanceof MouseEvent ? a2 : new MouseEvent(e2, a2);
            const o2 = h.mousePos(i2.getCanvas(), a2), s2 = i2.unproject(o2);
            super(e2, t.e({ point: o2, lngLat: s2, originalEvent: a2 }, r2)), this._defaultPrevented = false, this.target = i2;
          }
        }
        class ro2 extends t.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, i2, a2) {
            const r2 = "touchend" === e2 ? a2.changedTouches : a2.touches, o2 = h.touchPos(i2.getCanvasContainer(), r2), s2 = o2.map(((e3) => i2.unproject(e3))), n2 = o2.reduce(((e3, t2, i3, a3) => e3.add(t2.div(a3.length))), new t.P(0, 0));
            super(e2, { points: o2, point: n2, lngLats: s2, lngLat: i2.unproject(n2), originalEvent: a2 }), this._defaultPrevented = false;
          }
        }
        class oo2 extends t.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, t2, i2) {
            super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
          }
        }
        class so2 {
          constructor(e2, t2) {
            this._map = e2, this._clickTolerance = t2.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e2) {
            return this._firePreventable(new oo2(e2.type, this._map, e2));
          }
          mousedown(e2, t2) {
            return this._mousedownPos = t2, this._firePreventable(new ao2(e2.type, this._map, e2));
          }
          mouseup(e2) {
            this._map.fire(new ao2(e2.type, this._map, e2));
          }
          click(e2, t2) {
            this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || this._map.fire(new ao2(e2.type, this._map, e2));
          }
          dblclick(e2) {
            return this._firePreventable(new ao2(e2.type, this._map, e2));
          }
          mouseover(e2) {
            this._map.fire(new ao2(e2.type, this._map, e2));
          }
          mouseout(e2) {
            this._map.fire(new ao2(e2.type, this._map, e2));
          }
          touchstart(e2) {
            return this._firePreventable(new ro2(e2.type, this._map, e2));
          }
          touchmove(e2) {
            this._map.fire(new ro2(e2.type, this._map, e2));
          }
          touchend(e2) {
            this._map.fire(new ro2(e2.type, this._map, e2));
          }
          touchcancel(e2) {
            this._map.fire(new ro2(e2.type, this._map, e2));
          }
          _firePreventable(e2) {
            if (this._map.fire(e2), e2.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class no2 {
          constructor(e2) {
            this._map = e2;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(e2) {
            this._map.fire(new ao2(e2.type, this._map, e2));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ao2("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e2) {
            this._delayContextMenu ? this._contextMenuEvent = e2 : this._ignoreContextMenu || this._map.fire(new ao2(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class lo2 {
          constructor(e2) {
            this._map = e2;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e2) {
            return this.transform.screenPointToLocation(t.P.convert(e2), this._map.terrain);
          }
        }
        class co2 {
          constructor(e2, t2) {
            this._map = e2, this._tr = new lo2(e2), this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e2, t2) {
            this.isEnabled() && e2.shiftKey && 0 === e2.button && (h.disableDrag(), this._startPos = this._lastPos = t2, this._active = true);
          }
          mousemoveWindow(e2, t2) {
            if (!this._active) return;
            const i2 = t2;
            if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance) return;
            const a2 = this._startPos;
            this._lastPos = i2, this._box || (this._box = h.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e2));
            const r2 = Math.min(a2.x, i2.x), o2 = Math.max(a2.x, i2.x), s2 = Math.min(a2.y, i2.y), n2 = Math.max(a2.y, i2.y);
            h.setTransform(this._box, `translate(${r2}px,${s2}px)`), this._box.style.width = o2 - r2 + "px", this._box.style.height = n2 - s2 + "px";
          }
          mouseupWindow(e2, i2) {
            if (!this._active) return;
            if (0 !== e2.button) return;
            const a2 = this._startPos, r2 = i2;
            if (this.reset(), h.suppressClick(), a2.x !== r2.x || a2.y !== r2.y) return this._map.fire(new t.l("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (e3) => e3.fitScreenCoordinates(a2, r2, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e2);
          }
          keydown(e2) {
            this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (h.remove(this._box), this._box = null), h.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e2, i2) {
            return this._map.fire(new t.l(e2, { originalEvent: i2 }));
          }
        }
        function ho2(e2, t2) {
          if (e2.length !== t2.length) throw new Error(`The number of touches and points are not equal - touches ${e2.length}, points ${t2.length}`);
          const i2 = {};
          for (let a2 = 0; a2 < e2.length; a2++) i2[e2[a2].identifier] = t2[a2];
          return i2;
        }
        class uo2 {
          constructor(e2) {
            this.reset(), this.numTouches = e2.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e2, i2, a2) {
            (this.centroid || a2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), a2.length === this.numTouches && (this.centroid = (function(e3) {
              const i3 = new t.P(0, 0);
              for (const t2 of e3) i3._add(t2);
              return i3.div(e3.length);
            })(i2), this.touches = ho2(a2, i2)));
          }
          touchmove(e2, t2, i2) {
            if (this.aborted || !this.centroid) return;
            const a2 = ho2(i2, t2);
            for (const e3 in this.touches) {
              const t3 = a2[e3];
              (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
            }
          }
          touchend(e2, t2, i2) {
            if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
              const e3 = !this.aborted && this.centroid;
              if (this.reset(), e3) return e3;
            }
          }
        }
        class _o2 {
          constructor(e2) {
            this.singleTap = new uo2(e2), this.numTaps = e2.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e2, t2, i2) {
            this.singleTap.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            this.singleTap.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            const a2 = this.singleTap.touchend(e2, t2, i2);
            if (a2) {
              const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(a2) < 30;
              if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = a2, this.count === this.numTaps) return this.reset(), a2;
            }
          }
        }
        class po {
          constructor(e2) {
            this._tr = new lo2(e2), this._zoomIn = new _o2({ numTouches: 1, numTaps: 2 }), this._zoomOut = new _o2({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e2, t2, i2) {
            this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            const a2 = this._zoomIn.touchend(e2, t2, i2), r2 = this._zoomOut.touchend(e2, t2, i2), o2 = this._tr;
            return a2 ? (this._active = true, e2.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: o2.zoom + 1, around: o2.unproject(a2) }, { originalEvent: e2 }) }) : r2 ? (this._active = true, e2.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: o2.zoom - 1, around: o2.unproject(r2) }, { originalEvent: e2 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class mo2 {
          constructor(e2) {
            this._enabled = !!e2.enable, this._moveStateManager = e2.moveStateManager, this._clickTolerance = e2.clickTolerance || 1, this._moveFunction = e2.move, this._activateOnStart = !!e2.activateOnStart, e2.assignEvents(this), this.reset();
          }
          reset(e2) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e2);
          }
          _move(...e2) {
            const t2 = this._moveFunction(...e2);
            if (t2.bearingDelta || t2.pitchDelta || t2.rollDelta || t2.around || t2.panDelta) return this._active = true, t2;
          }
          dragStart(e2, t2) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e2) && (this._moveStateManager.startMove(e2), this._lastPoint = Array.isArray(t2) ? t2[0] : t2, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(e2, t2) {
            if (!this.isEnabled()) return;
            const i2 = this._lastPoint;
            if (!i2) return;
            if (e2.preventDefault(), !this._moveStateManager.isValidMoveEvent(e2)) return void this.reset(e2);
            const a2 = Array.isArray(t2) ? t2[0] : t2;
            return !this._moved && a2.dist(i2) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = a2, this._move(i2, a2));
          }
          dragEnd(e2) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e2) && (this._moved && h.suppressClick(), this.reset(e2));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const fo2 = 0, go2 = 2, vo2 = { [fo2]: 1, [go2]: 2 };
        class xo2 {
          constructor(e2) {
            this._correctEvent = e2.checkCorrectEvent;
          }
          startMove(e2) {
            const t2 = h.mouseButton(e2);
            this._eventButton = t2;
          }
          endMove(e2) {
            delete this._eventButton;
          }
          isValidStartEvent(e2) {
            return this._correctEvent(e2);
          }
          isValidMoveEvent(e2) {
            return !(function(e3, t2) {
              const i2 = vo2[t2];
              return void 0 === e3.buttons || (e3.buttons & i2) !== i2;
            })(e2, this._eventButton);
          }
          isValidEndEvent(e2) {
            return h.mouseButton(e2) === this._eventButton;
          }
        }
        class bo2 {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e2) {
            return 1 === e2.targetTouches.length;
          }
          _isSameTouchEvent(e2) {
            return e2.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e2) {
            this._firstTouch = e2.targetTouches[0].identifier;
          }
          endMove(e2) {
            delete this._firstTouch;
          }
          isValidStartEvent(e2) {
            return this._isOneFingerTouch(e2);
          }
          isValidMoveEvent(e2) {
            return this._isOneFingerTouch(e2) && this._isSameTouchEvent(e2);
          }
          isValidEndEvent(e2) {
            return this._isOneFingerTouch(e2) && this._isSameTouchEvent(e2);
          }
        }
        class yo2 {
          constructor(e2 = new xo2({ checkCorrectEvent: () => true }), t2 = new bo2()) {
            this.mouseMoveStateManager = e2, this.oneFingerTouchMoveStateManager = t2;
          }
          _executeRelevantHandler(e2, t2, i2) {
            return e2 instanceof MouseEvent ? t2(e2) : "undefined" != typeof TouchEvent && e2 instanceof TouchEvent ? i2(e2) : void 0;
          }
          startMove(e2) {
            this._executeRelevantHandler(e2, ((e3) => this.mouseMoveStateManager.startMove(e3)), ((e3) => this.oneFingerTouchMoveStateManager.startMove(e3)));
          }
          endMove(e2) {
            this._executeRelevantHandler(e2, ((e3) => this.mouseMoveStateManager.endMove(e3)), ((e3) => this.oneFingerTouchMoveStateManager.endMove(e3)));
          }
          isValidStartEvent(e2) {
            return this._executeRelevantHandler(e2, ((e3) => this.mouseMoveStateManager.isValidStartEvent(e3)), ((e3) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e3)));
          }
          isValidMoveEvent(e2) {
            return this._executeRelevantHandler(e2, ((e3) => this.mouseMoveStateManager.isValidMoveEvent(e3)), ((e3) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e3)));
          }
          isValidEndEvent(e2) {
            return this._executeRelevantHandler(e2, ((e3) => this.mouseMoveStateManager.isValidEndEvent(e3)), ((e3) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e3)));
          }
        }
        const wo2 = (e2) => {
          e2.mousedown = e2.dragStart, e2.mousemoveWindow = e2.dragMove, e2.mouseup = e2.dragEnd, e2.contextmenu = (e3) => {
            e3.preventDefault();
          };
        };
        class To2 {
          constructor(e2, t2) {
            this._clickTolerance = e2.clickTolerance || 1, this._map = t2, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new t.P(0, 0);
          }
          _shouldBePrevented(e2) {
            return e2 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e2, t2, i2) {
            return this._calculateTransform(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            if (this._active) {
              if (!this._shouldBePrevented(i2.length)) return e2.preventDefault(), this._calculateTransform(e2, t2, i2);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e2);
            }
          }
          touchend(e2, t2, i2) {
            this._calculateTransform(e2, t2, i2), this._active && this._shouldBePrevented(i2.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e2, i2, a2) {
            a2.length > 0 && (this._active = true);
            const r2 = ho2(a2, i2), o2 = new t.P(0, 0), s2 = new t.P(0, 0);
            let n2 = 0;
            for (const e3 in r2) {
              const t2 = r2[e3], i3 = this._touches[e3];
              i3 && (o2._add(t2), s2._add(t2.sub(i3)), n2++, r2[e3] = t2);
            }
            if (this._touches = r2, this._shouldBePrevented(n2) || !s2.mag()) return;
            const l2 = s2.div(n2);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: o2.div(n2), panDelta: l2 };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Po2 {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(e2, t2, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
          }
          touchmove(e2, t2, i2) {
            if (!this._firstTwoTouches) return;
            e2.preventDefault();
            const [a2, r2] = this._firstTwoTouches, o2 = Co2(i2, t2, a2), s2 = Co2(i2, t2, r2);
            if (!o2 || !s2) return;
            const n2 = this._aroundCenter ? null : o2.add(s2).div(2);
            return this._move([o2, s2], n2, e2);
          }
          touchend(e2, t2, i2) {
            if (!this._firstTwoTouches) return;
            const [a2, r2] = this._firstTwoTouches, o2 = Co2(i2, t2, a2), s2 = Co2(i2, t2, r2);
            o2 && s2 || (this._active && h.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e2) {
            this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Co2(e2, t2, i2) {
          for (let a2 = 0; a2 < e2.length; a2++) if (e2[a2].identifier === i2) return t2[a2];
        }
        function Io2(e2, t2) {
          return Math.log(e2 / t2) / Math.LN2;
        }
        class Mo2 extends Po2 {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e2) {
            this._startDistance = this._distance = e2[0].dist(e2[1]);
          }
          _move(e2, t2) {
            const i2 = this._distance;
            if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(Io2(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Io2(this._distance, i2), pinchAround: t2 };
          }
        }
        function Eo2(e2, t2) {
          return 180 * e2.angleWith(t2) / Math.PI;
        }
        class So2 extends Po2 {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e2) {
            this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
          }
          _move(e2, t2, i2) {
            const a2 = this._vector;
            if (this._vector = e2[0].sub(e2[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: Eo2(this._vector, a2), pinchAround: t2 };
          }
          _isBelowThreshold(e2) {
            this._minDiameter = Math.min(this._minDiameter, e2.mag());
            const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = Eo2(e2, this._startVector);
            return Math.abs(i2) < t2;
          }
        }
        function zo2(e2) {
          return Math.abs(e2.y) > Math.abs(e2.x);
        }
        class Ro2 extends Po2 {
          constructor(e2) {
            super(), this._currentTouchCount = 0, this._map = e2;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e2, t2, i2) {
            super.touchstart(e2, t2, i2), this._currentTouchCount = i2.length;
          }
          _start(e2) {
            this._lastPoints = e2, zo2(e2[0].sub(e2[1])) && (this._valid = false);
          }
          _move(e2, t2, i2) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const a2 = e2[0].sub(this._lastPoints[0]), r2 = e2[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(a2, r2, i2.timeStamp), this._valid ? (this._lastPoints = e2, this._active = true, { pitchDelta: (a2.y + r2.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e2, t2, i2) {
            if (void 0 !== this._valid) return this._valid;
            const a2 = e2.mag() >= 2, r2 = t2.mag() >= 2;
            if (!a2 && !r2) return;
            if (!a2 || !r2) return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            const o2 = e2.y > 0 == t2.y > 0;
            return zo2(e2) && zo2(t2) && o2;
          }
        }
        const Do2 = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Ao2 {
          constructor(e2) {
            this._tr = new lo2(e2);
            const t2 = Do2;
            this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(e2) {
            if (e2.altKey || e2.ctrlKey || e2.metaKey) return;
            let t2 = 0, i2 = 0, a2 = 0, r2 = 0, o2 = 0;
            switch (e2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t2 = -1;
                break;
              case 37:
                e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r2 = -1);
                break;
              case 39:
                e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r2 = 1);
                break;
              case 38:
                e2.shiftKey ? a2 = 1 : (e2.preventDefault(), o2 = -1);
                break;
              case 40:
                e2.shiftKey ? a2 = -1 : (e2.preventDefault(), o2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i2 = 0, a2 = 0), { cameraAnimation: (s2) => {
              const n2 = this._tr;
              s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Lo2, zoom: t2 ? Math.round(n2.zoom) + t2 * (e2.shiftKey ? 2 : 1) : n2.zoom, bearing: n2.bearing + i2 * this._bearingStep, pitch: n2.pitch + a2 * this._pitchStep, offset: [-r2 * this._panStep, -o2 * this._panStep], center: n2.center }, { originalEvent: e2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Lo2(e2) {
          return e2 * (2 - e2);
        }
        const ko2 = 4.000244140625, Fo2 = 1 / 450;
        class Bo2 {
          constructor(e2, t2) {
            this._onTimeout = (e3) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
            }, this._map = e2, this._tr = new lo2(e2), this._triggerRenderFrame = t2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Fo2;
          }
          setZoomRate(e2) {
            this._defaultZoomRate = e2;
          }
          setWheelZoomRate(e2) {
            this._wheelZoomRate = e2;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e2) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(e2) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e2.ctrlKey || this._map.cooperativeGestures.isBypassed(e2));
          }
          wheel(e2) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e2)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e2);
            let t2 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
            const i2 = c(), a2 = i2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = i2, 0 !== t2 && t2 % ko2 == 0 ? this._type = "wheel" : 0 !== t2 && Math.abs(t2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = t2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(a2 * t2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t2 += this._lastValue)), e2.shiftKey && t2 && (t2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= t2, this._active || this._start(e2)), e2.preventDefault();
          }
          _start(e2) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i2 = h.mousePos(this._map.getCanvas(), e2), a2 = this._tr;
            this._aroundPoint = this._aroundCenter ? a2.transform.locationToScreenPoint(t.V.convert(a2.center)) : i2, this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId) return;
            if (this._frameId = null, !this.isActive()) return;
            const e2 = this._tr.transform;
            if ("number" == typeof this._lastExpectedZoom) {
              const t2 = e2.zoom - this._lastExpectedZoom;
              "number" == typeof this._startZoom && (this._startZoom += t2), "number" == typeof this._targetZoom && (this._targetZoom += t2);
            }
            if (0 !== this._delta) {
              const i3 = "wheel" === this._type && Math.abs(this._delta) > ko2 ? this._wheelZoomRate : this._defaultZoomRate;
              let a3 = 2 / (1 + Math.exp(-Math.abs(this._delta * i3)));
              this._delta < 0 && 0 !== a3 && (a3 = 1 / a3);
              const r3 = "number" != typeof this._targetZoom ? e2.scale : t.aq(this._targetZoom);
              this._targetZoom = e2.applyConstrain(e2.getCameraLngLat(), t.at(r3 * a3)).zoom, "wheel" === this._type && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i2 = "number" != typeof this._targetZoom ? e2.zoom : this._targetZoom, a2 = this._startZoom, r2 = this._easing;
            let o2, s2 = false;
            if ("wheel" === this._type && a2 && r2) {
              const e3 = c() - this._lastWheelEventTime, n2 = Math.min((e3 + 5) / 200, 1), l2 = r2(n2);
              o2 = t.G.number(a2, i2, l2), n2 < 1 ? this._frameId || (this._frameId = true) : s2 = true;
            } else o2 = i2, s2 = true;
            return this._active = true, s2 && (this._active = false, this._finishTimeout = setTimeout((() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = o2, { noInertia: true, needsRenderFrame: !s2, zoomDelta: o2 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e2) {
            let i2 = t.cy;
            if (this._prevEase) {
              const e3 = this._prevEase, a2 = (c() - e3.start) / e3.duration, r2 = e3.easing(a2 + 0.01) - e3.easing(a2), o2 = 0.27 / Math.sqrt(r2 * r2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - o2 * o2);
              i2 = t.cw(o2, s2, 0.25, 1);
            }
            return this._prevEase = { start: c(), duration: e2, easing: i2 }, i2;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Oo2 {
          constructor(e2, t2) {
            this._clickZoom = e2, this._tapZoom = t2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class jo2 {
          constructor(e2) {
            this._tr = new lo2(e2), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(e2, t2) {
            return e2.preventDefault(), { cameraAnimation: (i2) => {
              i2.easeTo({ duration: 300, zoom: this._tr.zoom + (e2.shiftKey ? -1 : 1), around: this._tr.unproject(t2) }, { originalEvent: e2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class No2 {
          constructor() {
            this._tap = new _o2({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e2, t2, i2) {
            if (!this._swipePoint) if (this._tapTime) {
              const a2 = t2[0], r2 = e2.timeStamp - this._tapTime < 500, o2 = this._tapPoint.dist(a2) < 30;
              r2 && o2 ? i2.length > 0 && (this._swipePoint = a2, this._swipeTouch = i2[0].identifier) : this.reset();
            } else this._tap.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch) return;
                const a2 = t2[0], r2 = a2.y - this._swipePoint.y;
                return this._swipePoint = a2, e2.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
              }
            } else this._tap.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            if (this._tapTime) this._swipePoint && 0 === i2.length && this.reset();
            else {
              const a2 = this._tap.touchend(e2, t2, i2);
              a2 && (this._tapTime = e2.timeStamp, this._tapPoint = a2);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Zo2 {
          constructor(e2, t2, i2) {
            this._el = e2, this._mousePan = t2, this._touchPan = i2;
          }
          enable(e2) {
            this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Go2 {
          constructor(e2, t2, i2, a2) {
            this._pitchWithRotate = e2.pitchWithRotate, this._rollEnabled = e2.rollEnabled, this._mouseRotate = t2, this._mousePitch = i2, this._mouseRoll = a2;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Uo2 {
          constructor(e2, t2, i2, a2) {
            this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = a2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e2) {
            this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Vo2 {
          constructor(e2, t2) {
            this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e2, this._options = t2, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e2 = this._map.getCanvasContainer();
            e2.classList.add("maplibregl-cooperative-gestures"), this._container = h.create("div", "maplibregl-cooperative-gesture-screen", e2);
            let t2 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            "metaKey" === this._bypassKey && (t2 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const i2 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), a2 = document.createElement("div");
            a2.className = "maplibregl-desktop-message", a2.textContent = t2, this._container.appendChild(a2);
            const r2 = document.createElement("div");
            r2.className = "maplibregl-mobile-message", r2.textContent = i2, this._container.appendChild(r2), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (h.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e2) {
            return e2[this._bypassKey];
          }
          notifyGestureBlocked(e2, i2) {
            this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", { gestureType: e2, originalEvent: i2 })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const qo2 = (e2) => e2.zoom || e2.drag || e2.roll || e2.pitch || e2.rotate;
        class Wo2 extends t.l {
        }
        function $o2(e2) {
          return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta || e2.rollDelta;
        }
        class Ho2 {
          constructor(e2, i2) {
            this.handleWindowEvent = (e3) => {
              this.handleEvent(e3, `${e3.type}Window`);
            }, this.handleEvent = (e3, i3) => {
              if ("blur" === e3.type) return void this.stop(true);
              this._updatingCamera = true;
              const a3 = "renderFrame" === e3.type ? void 0 : e3, r2 = { needsRenderFrame: false }, o2 = {}, s2 = {};
              for (const { handlerName: n3, handler: l3, allowed: c2 } of this._handlers) {
                if (!l3.isEnabled()) continue;
                let u2;
                if (this._blockedByActive(s2, c2, n3)) l3.reset();
                else if (l3[i3 || e3.type]) {
                  if (t.cz(e3, i3 || e3.type)) {
                    const t2 = h.mousePos(this._map.getCanvas(), e3);
                    u2 = l3[i3 || e3.type](e3, t2);
                  } else if (t.cA(e3, i3 || e3.type)) {
                    const t2 = this._getMapTouches(e3.touches), a4 = h.touchPos(this._map.getCanvas(), t2);
                    u2 = l3[i3 || e3.type](e3, a4, t2);
                  } else t.cB(i3 || e3.type) || (u2 = l3[i3 || e3.type](e3));
                  this.mergeHandlerResult(r2, o2, u2, n3, a3), u2 && u2.needsRenderFrame && this._triggerRenderFrame();
                }
                (u2 || l3.isActive()) && (s2[n3] = l3);
              }
              const n2 = {};
              for (const e4 in this._previousActiveHandlers) s2[e4] || (n2[e4] = a3);
              this._previousActiveHandlers = s2, (Object.keys(n2).length || $o2(r2)) && (this._changes.push([r2, o2, n2]), this._triggerRenderFrame()), (Object.keys(s2).length || $o2(r2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: l2 } = r2;
              l2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], l2(this._map));
            }, this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new eo2(e2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i2);
            const a2 = this._el;
            this._listeners = [[a2, "touchstart", { passive: true }], [a2, "touchmove", { passive: false }], [a2, "touchend", void 0], [a2, "touchcancel", void 0], [a2, "mousedown", void 0], [a2, "mousemove", void 0], [a2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [a2, "mouseover", void 0], [a2, "mouseout", void 0], [a2, "dblclick", void 0], [a2, "click", void 0], [a2, "keydown", { capture: false }], [a2, "keyup", void 0], [a2, "wheel", { passive: false }], [a2, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [e3, t2, i3] of this._listeners) h.addEventListener(e3, t2, e3 === document ? this.handleWindowEvent : this.handleEvent, i3);
          }
          destroy() {
            for (const [e2, t2, i2] of this._listeners) h.removeEventListener(e2, t2, e2 === document ? this.handleWindowEvent : this.handleEvent, i2);
          }
          _addDefaultHandlers(e2) {
            const i2 = this._map, a2 = i2.getCanvasContainer();
            this._add("mapEvent", new so2(i2, e2));
            const r2 = i2.boxZoom = new co2(i2, e2);
            this._add("boxZoom", r2), e2.interactive && e2.boxZoom && r2.enable();
            const o2 = i2.cooperativeGestures = new Vo2(i2, e2.cooperativeGestures);
            this._add("cooperativeGestures", o2), e2.cooperativeGestures && o2.enable();
            const s2 = new po(i2), n2 = new jo2(i2);
            i2.doubleClickZoom = new Oo2(n2, s2), this._add("tapZoom", s2), this._add("clickZoom", n2), e2.interactive && e2.doubleClickZoom && i2.doubleClickZoom.enable();
            const l2 = new No2();
            this._add("tapDragZoom", l2);
            const c2 = i2.touchPitch = new Ro2(i2);
            this._add("touchPitch", c2), e2.interactive && e2.touchPitch && i2.touchPitch.enable(e2.touchPitch);
            const u2 = () => i2.project(i2.getCenter()), d2 = (function({ enable: e3, clickTolerance: i3, aroundCenter: a3 = true, minPixelCenterThreshold: r3 = 100, rotateDegreesPerPixelMoved: o3 = 0.8 }, s3) {
              const n3 = new xo2({ checkCorrectEvent: (e4) => 0 === h.mouseButton(e4) && e4.ctrlKey || 2 === h.mouseButton(e4) && !e4.ctrlKey });
              return new mo2({ clickTolerance: i3, move: (e4, i4) => {
                const n4 = s3();
                if (a3 && Math.abs(n4.y - e4.y) > r3) return { bearingDelta: t.cx(new t.P(e4.x, i4.y), i4, n4) };
                let l3 = (i4.x - e4.x) * o3;
                return a3 && i4.y < n4.y && (l3 = -l3), { bearingDelta: l3 };
              }, moveStateManager: n3, enable: e3, assignEvents: wo2 });
            })(e2, u2), _3 = (function({ enable: e3, clickTolerance: t2, pitchDegreesPerPixelMoved: i3 = -0.5 }) {
              const a3 = new xo2({ checkCorrectEvent: (e4) => 0 === h.mouseButton(e4) && e4.ctrlKey || 2 === h.mouseButton(e4) });
              return new mo2({ clickTolerance: t2, move: (e4, t3) => ({ pitchDelta: (t3.y - e4.y) * i3 }), moveStateManager: a3, enable: e3, assignEvents: wo2 });
            })(e2), p2 = (function({ enable: e3, clickTolerance: t2, rollDegreesPerPixelMoved: i3 = 0.3 }, a3) {
              const r3 = new xo2({ checkCorrectEvent: (e4) => 2 === h.mouseButton(e4) && e4.ctrlKey });
              return new mo2({ clickTolerance: t2, move: (e4, t3) => {
                const r4 = a3();
                let o3 = (t3.x - e4.x) * i3;
                return t3.y < r4.y && (o3 = -o3), { rollDelta: o3 };
              }, moveStateManager: r3, enable: e3, assignEvents: wo2 });
            })(e2, u2);
            i2.dragRotate = new Go2(e2, d2, _3, p2), this._add("mouseRotate", d2, ["mousePitch"]), this._add("mousePitch", _3, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p2, ["mousePitch"]), e2.interactive && e2.dragRotate && i2.dragRotate.enable();
            const m2 = (function({ enable: e3, clickTolerance: t2 }) {
              const i3 = new xo2({ checkCorrectEvent: (e4) => 0 === h.mouseButton(e4) && !e4.ctrlKey });
              return new mo2({ clickTolerance: t2, move: (e4, t3) => ({ around: t3, panDelta: t3.sub(e4) }), activateOnStart: true, moveStateManager: i3, enable: e3, assignEvents: wo2 });
            })(e2), f3 = new To2(e2, i2);
            i2.dragPan = new Zo2(a2, m2, f3), this._add("mousePan", m2), this._add("touchPan", f3, ["touchZoom", "touchRotate"]), e2.interactive && e2.dragPan && i2.dragPan.enable(e2.dragPan);
            const g2 = new So2(), v2 = new Mo2();
            i2.touchZoomRotate = new Uo2(a2, v2, g2, l2), this._add("touchRotate", g2, ["touchPan", "touchZoom"]), this._add("touchZoom", v2, ["touchPan", "touchRotate"]), e2.interactive && e2.touchZoomRotate && i2.touchZoomRotate.enable(e2.touchZoomRotate), this._add("blockableMapEvent", new no2(i2));
            const x2 = i2.scrollZoom = new Bo2(i2, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", x2, ["mousePan"]), e2.interactive && e2.scrollZoom && i2.scrollZoom.enable(e2.scrollZoom);
            const b2 = i2.keyboard = new Ao2(i2);
            this._add("keyboard", b2), e2.interactive && e2.keyboard && i2.keyboard.enable();
          }
          _add(e2, t2, i2) {
            this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
          }
          stop(e2) {
            if (!this._updatingCamera) {
              for (const { handler: e3 } of this._handlers) e3.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e2 } of this._handlers) if (e2.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(qo2(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(e2, t2, i2) {
            for (const a2 in e2) if (a2 !== i2 && (!t2 || t2.indexOf(a2) < 0)) return true;
            return false;
          }
          _getMapTouches(e2) {
            const t2 = [];
            for (const i2 of e2) this._el.contains(i2.target) && t2.push(i2);
            return t2;
          }
          mergeHandlerResult(e2, i2, a2, r2, o2) {
            if (!a2) return;
            t.e(e2, a2);
            const s2 = { handlerName: r2, originalEvent: a2.originalEvent || o2 };
            void 0 !== a2.zoomDelta && (i2.zoom = s2), void 0 !== a2.panDelta && (i2.drag = s2), void 0 !== a2.rollDelta && (i2.roll = s2), void 0 !== a2.pitchDelta && (i2.pitch = s2), void 0 !== a2.bearingDelta && (i2.rotate = s2);
          }
          _applyChanges() {
            const e2 = {}, i2 = {}, a2 = {};
            for (const [r2, o2, s2] of this._changes) r2.panDelta && (e2.panDelta = (e2.panDelta || new t.P(0, 0))._add(r2.panDelta)), r2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + r2.zoomDelta), r2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + r2.bearingDelta), r2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + r2.pitchDelta), r2.rollDelta && (e2.rollDelta = (e2.rollDelta || 0) + r2.rollDelta), void 0 !== r2.around && (e2.around = r2.around), void 0 !== r2.pinchAround && (e2.pinchAround = r2.pinchAround), r2.noInertia && (e2.noInertia = r2.noInertia), t.e(i2, o2), t.e(a2, s2);
            this._updateMapTransform(e2, i2, a2), this._changes = [];
          }
          _updateMapTransform(e2, t2, i2) {
            const a2 = this._map, r2 = a2._getTransformForUpdate(), o2 = a2.terrain;
            if (!($o2(e2) || o2 && this._terrainMovement)) return this._fireEvents(t2, i2, true);
            a2._stop(true);
            let { panDelta: s2, zoomDelta: n2, bearingDelta: l2, pitchDelta: c2, rollDelta: h2, around: u2, pinchAround: d2 } = e2;
            void 0 !== d2 && (u2 = d2), u2 = u2 || a2.transform.centerPoint, o2 && !r2.isPointOnMapSurface(u2) && (u2 = r2.centerPoint);
            const _3 = { panDelta: s2, zoomDelta: n2, rollDelta: h2, pitchDelta: c2, bearingDelta: l2, around: u2 };
            this._map.cameraHelper.useGlobeControls && !r2.isPointOnMapSurface(u2) && (u2 = r2.centerPoint);
            const p2 = u2.distSqr(r2.centerPoint) < 0.01 ? r2.center : r2.screenPointToLocation(s2 ? u2.sub(s2) : u2);
            this._handleMapControls({ terrain: o2, tr: r2, deltasForHelper: _3, preZoomAroundLoc: p2, combinedEventsInProgress: t2, panDelta: s2 }), a2._applyUpdatedTransform(r2), this._map._update(), e2.noInertia || this._inertia.record(e2), this._fireEvents(t2, i2, true);
          }
          _handleMapControls({ terrain: e2, tr: t2, deltasForHelper: i2, preZoomAroundLoc: a2, combinedEventsInProgress: r2, panDelta: o2 }) {
            const s2 = this._map.cameraHelper;
            if (s2.handleMapControlsRollPitchBearingZoom(i2, t2), e2) return s2.useGlobeControls ? (this._terrainMovement || !r2.drag && !r2.zoom || (this._terrainMovement = true, this._map._elevationFreeze = true), void s2.handleMapControlsPan(i2, t2, a2)) : this._terrainMovement || !r2.drag && !r2.zoom ? void (r2.drag && this._terrainMovement && o2 ? t2.setCenter(t2.screenPointToLocation(t2.centerPoint.sub(o2))) : s2.handleMapControlsPan(i2, t2, a2)) : (this._terrainMovement = true, this._map._elevationFreeze = true, void s2.handleMapControlsPan(i2, t2, a2));
            s2.handleMapControlsPan(i2, t2, a2);
          }
          _fireEvents(e2, i2, a2) {
            const r2 = qo2(this._eventsInProgress), o2 = qo2(e2), s2 = {};
            for (const t2 in e2) {
              const { originalEvent: i3 } = e2[t2];
              this._eventsInProgress[t2] || (s2[`${t2}start`] = i3), this._eventsInProgress[t2] = e2[t2];
            }
            !r2 && o2 && this._fireEvent("movestart", o2.originalEvent);
            for (const e3 in s2) this._fireEvent(e3, s2[e3]);
            o2 && this._fireEvent("move", o2.originalEvent);
            for (const t2 in e2) {
              const { originalEvent: i3 } = e2[t2];
              this._fireEvent(t2, i3);
            }
            const l2 = {};
            let c2;
            for (const e3 in this._eventsInProgress) {
              const { handlerName: t2, originalEvent: a3 } = this._eventsInProgress[e3];
              this._handlersById[t2].isActive() || (delete this._eventsInProgress[e3], c2 = i2[t2] || a3, l2[`${e3}end`] = c2);
            }
            for (const e3 in l2) this._fireEvent(e3, l2[e3]);
            const h2 = qo2(this._eventsInProgress), u2 = (r2 || o2) && !h2;
            if (u2 && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const e3 = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && e3.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e3);
            }
            if (a2 && u2) {
              this._updatingCamera = true;
              const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e4) => 0 !== e4 && -this._bearingSnap < e4 && e4 < this._bearingSnap;
              !e3 || !e3.essential && n.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: c2 })), i3(this._map.getBearing()) && this._map.resetNorth()) : (i3(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), e3.freezeElevation = true, this._map.easeTo(e3, { originalEvent: c2 })), this._updatingCamera = false;
            }
          }
          _fireEvent(e2, i2) {
            this._map.fire(new t.l(e2, i2 ? { originalEvent: i2 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e2) => {
              delete this._frameId, this.handleEvent(new Wo2("renderFrame", { timeStamp: e2 })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class Xo2 extends t.E {
          constructor(e2, t2, i2) {
            super(), this._renderFrameCallback = () => {
              const e3 = Math.min((c() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i2.bearingSnap, this.cameraHelper = t2, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(e2, t2) {
            e2.apply(this.transform, true), this.transform = e2, this.cameraHelper = t2;
          }
          getCenter() {
            return new t.V(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e2, t2) {
            return this.jumpTo({ center: e2 }, t2);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e2, t2) {
            return this.jumpTo({ elevation: e2 }, t2), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e2) {
            this._centerClampedToGround = e2;
          }
          panBy(e2, i2, a2) {
            return e2 = t.P.convert(e2).mult(-1), this.panTo(this.transform.center, t.e({ offset: e2 }, i2), a2);
          }
          panTo(e2, i2, a2) {
            return this.easeTo(t.e({ center: e2 }, i2), a2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e2, t2) {
            return this.jumpTo({ zoom: e2 }, t2), this;
          }
          zoomTo(e2, i2, a2) {
            return this.easeTo(t.e({ zoom: e2 }, i2), a2);
          }
          zoomIn(e2, t2) {
            return this.zoomTo(this.getZoom() + 1, e2, t2), this;
          }
          zoomOut(e2, t2) {
            return this.zoomTo(this.getZoom() - 1, e2, t2), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e2, i2) {
            return e2 != this.transform.fov && (this.transform.setFov(e2), this.fire(new t.l("movestart", i2)).fire(new t.l("move", i2)).fire(new t.l("moveend", i2))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e2, t2) {
            return this.jumpTo({ bearing: e2 }, t2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e2, t2) {
            return this.jumpTo({ padding: e2 }, t2), this;
          }
          rotateTo(e2, i2, a2) {
            return this.easeTo(t.e({ bearing: e2 }, i2), a2);
          }
          resetNorth(e2, i2) {
            return this.rotateTo(0, t.e({ duration: 1e3 }, e2), i2), this;
          }
          resetNorthPitch(e2, i2) {
            return this.easeTo(t.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e2), i2), this;
          }
          snapToNorth(e2, t2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e2, t2) {
            return this.jumpTo({ pitch: e2 }, t2), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e2, t2) {
            return this.jumpTo({ roll: e2 }, t2), this;
          }
          cameraForBounds(e2, t2) {
            e2 = $2.convert(e2).adjustAntiMeridian();
            const i2 = t2 && t2.bearing || 0;
            return this._cameraForBoxAndBearing(e2.getNorthWest(), e2.getSouthEast(), i2, t2);
          }
          _cameraForBoxAndBearing(e2, i2, a2, r2) {
            const o2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (r2 = t.e({ padding: o2, offset: [0, 0], maxZoom: this.transform.maxZoom }, r2)).padding) {
              const e3 = r2.padding;
              r2.padding = { top: e3, bottom: e3, right: e3, left: e3 };
            }
            const s2 = t.e(o2, r2.padding);
            r2.padding = s2;
            const n2 = this.transform, l2 = new $2(e2, i2);
            return this.cameraHelper.cameraForBoxAndBearing(r2, s2, l2, a2, n2);
          }
          fitBounds(e2, t2, i2) {
            return this._fitInternal(this.cameraForBounds(e2, t2), t2, i2);
          }
          fitScreenCoordinates(e2, i2, a2, r2, o2) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e2)), this.transform.screenPointToLocation(t.P.convert(i2)), a2, r2), r2, o2);
          }
          _fitInternal(e2, i2, a2) {
            return e2 ? (delete (i2 = t.e(e2, i2)).padding, i2.linear ? this.easeTo(i2, a2) : this.flyTo(i2, a2)) : this;
          }
          jumpTo(e2, i2) {
            this.stop();
            const a2 = this._getTransformForUpdate();
            let r2 = false, o2 = false, s2 = false;
            const n2 = a2.zoom;
            this.cameraHelper.handleJumpToCenterZoom(a2, e2);
            const l2 = a2.zoom !== n2;
            return "elevation" in e2 && a2.elevation !== +e2.elevation && a2.setElevation(+e2.elevation), "bearing" in e2 && a2.bearing !== +e2.bearing && (r2 = true, a2.setBearing(+e2.bearing)), "pitch" in e2 && a2.pitch !== +e2.pitch && (o2 = true, a2.setPitch(+e2.pitch)), "roll" in e2 && a2.roll !== +e2.roll && (s2 = true, a2.setRoll(+e2.roll)), null == e2.padding || a2.isPaddingEqual(e2.padding) || a2.setPadding(e2.padding), this._applyUpdatedTransform(a2), this.fire(new t.l("movestart", i2)).fire(new t.l("move", i2)), l2 && this.fire(new t.l("zoomstart", i2)).fire(new t.l("zoom", i2)).fire(new t.l("zoomend", i2)), r2 && this.fire(new t.l("rotatestart", i2)).fire(new t.l("rotate", i2)).fire(new t.l("rotateend", i2)), o2 && this.fire(new t.l("pitchstart", i2)).fire(new t.l("pitch", i2)).fire(new t.l("pitchend", i2)), s2 && this.fire(new t.l("rollstart", i2)).fire(new t.l("roll", i2)).fire(new t.l("rollend", i2)), this.fire(new t.l("moveend", i2));
          }
          calculateCameraOptionsFromTo(e2, i2, a2, r2 = 0) {
            const o2 = t.a9.fromLngLat(e2, i2), s2 = t.a9.fromLngLat(a2, r2), n2 = s2.x - o2.x, l2 = s2.y - o2.y, c2 = s2.z - o2.z, h2 = Math.hypot(n2, l2, c2);
            if (0 === h2) throw new Error("Can't calculate camera options with same From and To");
            const u2 = Math.hypot(n2, l2), d2 = t.at(this.transform.cameraToCenterDistance / h2 / this.transform.tileSize), _3 = 180 * Math.atan2(n2, -l2) / Math.PI;
            let p2 = 180 * Math.acos(u2 / h2) / Math.PI;
            return p2 = c2 < 0 ? 90 - p2 : 90 + p2, { center: s2.toLngLat(), elevation: r2, zoom: d2, pitch: p2, bearing: _3 };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e2, t2, i2, a2, r2) {
            const o2 = this.transform.calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2);
            return { center: o2.center, elevation: o2.elevation, zoom: o2.zoom, bearing: i2, pitch: a2, roll: r2 };
          }
          easeTo(e2, i2) {
            this._stop(false, e2.easeId), (false === (e2 = t.e({ offset: [0, 0], duration: 500, easing: t.cy }, e2)).animate || !e2.essential && n.prefersReducedMotion) && (e2.duration = 0);
            const a2 = this._getTransformForUpdate(), r2 = this.getBearing(), o2 = a2.pitch, s2 = a2.roll, l2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, r2) : r2, c2 = "pitch" in e2 ? +e2.pitch : o2, h2 = "roll" in e2 ? this._normalizeBearing(e2.roll, s2) : s2, u2 = "padding" in e2 ? e2.padding : a2.padding, d2 = t.P.convert(e2.offset);
            let _3, p2;
            e2.around && (_3 = t.V.convert(e2.around), p2 = a2.locationToScreenPoint(_3));
            const m2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, f3 = this.cameraHelper.handleEaseTo(a2, { bearing: l2, pitch: c2, roll: h2, padding: u2, around: _3, aroundPoint: p2, offsetAsPoint: d2, offset: e2.offset, zoom: e2.zoom, center: e2.center });
            return this._rotating = this._rotating || r2 !== l2, this._pitching = this._pitching || c2 !== o2, this._rolling = this._rolling || h2 !== s2, this._padding = !a2.isPaddingEqual(u2), this._zooming = this._zooming || f3.isZooming, this._easeId = e2.easeId, this._prepareEase(i2, e2.noMoveStart, m2), this.terrain && this._prepareElevation(f3.elevationCenter), this._ease(((t2) => {
              f3.easeFunc(t2), this.terrain && !e2.freezeElevation && this._updateElevation(t2), this._applyUpdatedTransform(a2), this._fireMoveEvents(i2);
            }), ((t2) => {
              this.terrain && e2.freezeElevation && this._finalizeElevation(), this._afterEase(i2, t2);
            }), e2), this;
          }
          _prepareEase(e2, i2, a2 = {}) {
            this._moving = true, i2 || a2.moving || this.fire(new t.l("movestart", e2)), this._zooming && !a2.zooming && this.fire(new t.l("zoomstart", e2)), this._rotating && !a2.rotating && this.fire(new t.l("rotatestart", e2)), this._pitching && !a2.pitching && this.fire(new t.l("pitchstart", e2)), this._rolling && !a2.rolling && this.fire(new t.l("rollstart", e2));
          }
          _prepareElevation(e2) {
            this._elevationCenter = e2, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e2, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e2) {
            void 0 !== this._elevationStart && void 0 !== this._elevationCenter || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const i2 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e2 < 1 && i2 !== this._elevationTarget) {
              const t2 = this._elevationTarget - this._elevationStart;
              this._elevationStart += e2 * (t2 - (i2 - (t2 * e2 + this._elevationStart)) / (1 - e2)), this._elevationTarget = i2;
            }
            this.transform.setElevation(t.G.number(this._elevationStart, this._elevationTarget, e2));
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e2) {
            if (!this.terrain && e2.elevation >= 0 && e2.pitch <= 90) return {};
            const t2 = e2.getCameraLngLat(), i2 = e2.getCameraAltitude(), a2 = this.terrain ? this.terrain.getElevationForLngLatZoom(t2, e2.zoom) : 0;
            if (i2 < a2) {
              const i3 = this.calculateCameraOptionsFromTo(t2, a2, e2.center, e2.elevation);
              return { pitch: i3.pitch, zoom: i3.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e2) {
            const t2 = [];
            if (t2.push(((e3) => this._elevateCameraIfInsideTerrain(e3))), this.transformCameraUpdate && t2.push(((e3) => this.transformCameraUpdate(e3))), !t2.length) return;
            const i2 = e2.clone();
            for (const e3 of t2) {
              const t3 = i2.clone(), { center: a2, zoom: r2, roll: o2, pitch: s2, bearing: n2, elevation: l2 } = e3(t3);
              a2 && t3.setCenter(a2), void 0 !== l2 && t3.setElevation(l2), void 0 !== r2 && t3.setZoom(r2), void 0 !== o2 && t3.setRoll(o2), void 0 !== s2 && t3.setPitch(s2), void 0 !== n2 && t3.setBearing(n2), i2.apply(t3, false);
            }
            this.transform.apply(i2, false);
          }
          _fireMoveEvents(e2) {
            this.fire(new t.l("move", e2)), this._zooming && this.fire(new t.l("zoom", e2)), this._rotating && this.fire(new t.l("rotate", e2)), this._pitching && this.fire(new t.l("pitch", e2)), this._rolling && this.fire(new t.l("roll", e2));
          }
          _afterEase(e2, i2) {
            if (this._easeId && i2 && this._easeId === i2) return;
            delete this._easeId;
            const a2 = this._zooming, r2 = this._rotating, o2 = this._pitching, s2 = this._rolling;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, a2 && this.fire(new t.l("zoomend", e2)), r2 && this.fire(new t.l("rotateend", e2)), o2 && this.fire(new t.l("pitchend", e2)), s2 && this.fire(new t.l("rollend", e2)), this.fire(new t.l("moveend", e2));
          }
          flyTo(e2, i2) {
            if (!e2.essential && n.prefersReducedMotion) {
              const a3 = t.U(e2, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(a3, i2);
            }
            this.stop(), e2 = t.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.cy }, e2);
            const a2 = this._getTransformForUpdate(), r2 = a2.bearing, o2 = a2.pitch, s2 = a2.roll, l2 = a2.padding, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, r2) : r2, h2 = "pitch" in e2 ? +e2.pitch : o2, u2 = "roll" in e2 ? this._normalizeBearing(e2.roll, s2) : s2, d2 = "padding" in e2 ? e2.padding : a2.padding, _3 = t.P.convert(e2.offset);
            let p2 = a2.centerPoint.add(_3);
            const m2 = a2.screenPointToLocation(p2), f3 = this.cameraHelper.handleFlyTo(a2, { bearing: c2, pitch: h2, roll: u2, padding: d2, locationAtOffset: m2, offsetAsPoint: _3, center: e2.center, minZoom: e2.minZoom, zoom: e2.zoom });
            let g2 = e2.curve;
            const v2 = Math.max(a2.width, a2.height), x2 = v2 / f3.scaleOfZoom, b2 = f3.pixelPathLength;
            "number" == typeof f3.scaleOfMinZoom && (g2 = Math.sqrt(v2 / f3.scaleOfMinZoom / b2 * 2));
            const y3 = g2 * g2;
            function w3(e3) {
              const t2 = (x2 * x2 - v2 * v2 + (e3 ? -1 : 1) * y3 * y3 * b2 * b2) / (2 * (e3 ? x2 : v2) * y3 * b2);
              return Math.log(Math.sqrt(t2 * t2 + 1) - t2);
            }
            function T3(e3) {
              return (Math.exp(e3) - Math.exp(-e3)) / 2;
            }
            function P3(e3) {
              return (Math.exp(e3) + Math.exp(-e3)) / 2;
            }
            const C2 = w3(false);
            let I3 = function(e3) {
              return P3(C2) / P3(C2 + g2 * e3);
            }, M3 = function(e3) {
              return v2 * ((P3(C2) * (T3(t2 = C2 + g2 * e3) / P3(t2)) - T3(C2)) / y3) / b2;
              var t2;
            }, E2 = (w3(true) - C2) / g2;
            if (Math.abs(b2) < 2e-6 || !isFinite(E2)) {
              if (Math.abs(v2 - x2) < 1e-6) return this.easeTo(e2, i2);
              const t2 = x2 < v2 ? -1 : 1;
              E2 = Math.abs(Math.log(x2 / v2)) / g2, M3 = () => 0, I3 = (e3) => Math.exp(t2 * g2 * e3);
            }
            return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * E2 / ("screenSpeed" in e2 ? +e2.screenSpeed / g2 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = r2 !== c2, this._pitching = h2 !== o2, this._rolling = u2 !== s2, this._padding = !a2.isPaddingEqual(d2), this._prepareEase(i2, false), this.terrain && this._prepareElevation(f3.targetCenter), this._ease(((n2) => {
              const m3 = n2 * E2, g3 = 1 / I3(m3), v6 = M3(m3);
              this._rotating && a2.setBearing(t.G.number(r2, c2, n2)), this._pitching && a2.setPitch(t.G.number(o2, h2, n2)), this._rolling && a2.setRoll(t.G.number(s2, u2, n2)), this._padding && (a2.interpolatePadding(l2, d2, n2), p2 = a2.centerPoint.add(_3)), f3.easeFunc(n2, g3, v6, p2), this.terrain && !e2.freezeElevation && this._updateElevation(n2), this._applyUpdatedTransform(a2), this._fireMoveEvents(i2);
            }), (() => {
              this.terrain && e2.freezeElevation && this._finalizeElevation(), this._afterEase(i2);
            }), e2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e2, t2) {
            var i2;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const e3 = this._onEaseEnd;
              delete this._onEaseEnd, e3.call(this, t2);
            }
            return e2 || null === (i2 = this.handlers) || void 0 === i2 || i2.stop(false), this;
          }
          _ease(e2, t2, i2) {
            false === i2.animate || 0 === i2.duration ? (e2(1), t2()) : (this._easeStart = c(), this._easeOptions = i2, this._onEaseFrame = e2, this._onEaseEnd = t2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e2, i2) {
            e2 = t.W(e2, -180, 180);
            const a2 = Math.abs(e2 - i2);
            return Math.abs(e2 - 360 - i2) < a2 && (e2 -= 360), Math.abs(e2 + 360 - i2) < a2 && (e2 += 360), e2;
          }
          queryTerrainElevation(e2) {
            return this.terrain ? this.terrain.getElevationForLngLat(t.V.convert(e2), this.transform) : null;
          }
        }
        const Ko2 = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Yo2 {
          constructor(e2 = Ko2) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (e3) => {
              !e3 || "metadata" !== e3.sourceDataType && "visibility" !== e3.sourceDataType && "style" !== e3.dataType && "terrain" !== e3.type || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e2;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e2) {
            return this._map = e2, this._compact = this.options.compact, this._container = h.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = h.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = h.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            h.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e2, t2) {
            const i2 = this._map._getUIString(`AttributionControl.${t2}`);
            e2.title = i2, e2.setAttribute("aria-label", i2);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e2 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = e2.concat(this.options.customAttribution.map(((e3) => "string" != typeof e3 ? "" : e3))) : "string" == typeof this.options.customAttribution && e2.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const e3 = this._map.style.stylesheet;
              this.styleOwner = e3.owner, this.styleId = e3.id;
            }
            const t2 = this._map.style.tileManagers;
            for (const i3 in t2) {
              const a2 = t2[i3];
              if (a2.used || a2.usedForTerrain) {
                const t3 = a2.getSource();
                t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
              }
            }
            e2 = e2.filter(((e3) => String(e3).trim())), e2.sort(((e3, t3) => e3.length - t3.length)), e2 = e2.filter(((t3, i3) => {
              for (let a2 = i3 + 1; a2 < e2.length; a2++) if (e2[a2].indexOf(t3) >= 0) return false;
              return true;
            }));
            const i2 = e2.join(" | ");
            i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = h.sanitize(i2), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Qo2 {
          constructor(e2 = {}) {
            this._updateCompact = () => {
              const e3 = this._container.children;
              if (e3.length) {
                const t2 = e3[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && t2.classList.add("maplibregl-compact") : t2.classList.remove("maplibregl-compact");
              }
            }, this.options = e2;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e2) {
            this._map = e2, this._compact = this.options && this.options.compact, this._container = h.create("div", "maplibregl-ctrl");
            const t2 = h.create("a", "maplibregl-ctrl-logo");
            return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://maplibre.org/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            h.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Jo2 {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e2) {
            const t2 = ++this._id;
            return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
          }
          remove(e2) {
            const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
            for (const t3 of i2) if (t3.id === e2) return void (t3.cancelled = true);
          }
          run(e2 = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const t2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i2 of t2) if (!i2.cancelled && (i2.callback(e2), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var es2 = t.aU([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class ts2 extends t.E {
          constructor(e2) {
            super(), this._lastTilesetChange = c(), this.tileManager = e2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e2._source.tileSize * 2 ** this.deltaZoom, e2.usedForTerrain = true, e2.tileSize = this.tileSize;
          }
          destruct() {
            this.tileManager.usedForTerrain = false, this.tileManager.tileSize = null;
          }
          getSource() {
            return this.tileManager._source;
          }
          update(e2, i2) {
            this.tileManager.update(e2, i2), this._renderableTilesKeys = [];
            const a2 = {};
            for (const r2 of Ie2(e2, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2, calculateTileZoom: this.tileManager._source.calculateTileZoom })) a2[r2.key] = true, this._renderableTilesKeys.push(r2.key), this._tiles[r2.key] || (r2.terrainRttPosMatrix32f = new Float64Array(16), t.c7(r2.terrainRttPosMatrix32f, 0, t.a5, t.a5, 0, 0, 1), this._tiles[r2.key] = new de2(r2, this.tileSize), this._lastTilesetChange = c());
            for (const e3 in this._tiles) a2[e3] || delete this._tiles[e3];
          }
          freeRtt(e2) {
            for (const t2 in this._tiles) {
              const i2 = this._tiles[t2];
              (!e2 || i2.tileID.equals(e2) || i2.tileID.isChildOf(e2) || e2.isChildOf(i2.tileID)) && (i2.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((e2) => this.getTileByID(e2)));
          }
          getTileByID(e2) {
            return this._tiles[e2];
          }
          getTerrainCoords(e2, t2) {
            return t2 ? this._getTerrainCoordsForTileRanges(e2, t2) : this._getTerrainCoordsForRegularTile(e2);
          }
          _getTerrainCoordsForRegularTile(e2) {
            const i2 = {};
            for (const a2 of this._renderableTilesKeys) {
              const r2 = this._tiles[a2].tileID, o2 = e2.clone(), s2 = t.bk();
              if (r2.canonical.equals(e2.canonical)) t.c7(s2, 0, t.a5, t.a5, 0, 0, 1);
              else if (r2.canonical.isChildOf(e2.canonical)) {
                const i3 = r2.canonical.z - e2.canonical.z, a3 = r2.canonical.x - (r2.canonical.x >> i3 << i3), o3 = r2.canonical.y - (r2.canonical.y >> i3 << i3), n2 = t.a5 >> i3;
                t.c7(s2, 0, n2, n2, 0, 0, 1), t.O(s2, s2, [-a3 * n2, -o3 * n2, 0]);
              } else {
                if (!e2.canonical.isChildOf(r2.canonical)) continue;
                {
                  const i3 = e2.canonical.z - r2.canonical.z, a3 = e2.canonical.x - (e2.canonical.x >> i3 << i3), o3 = e2.canonical.y - (e2.canonical.y >> i3 << i3), n2 = t.a5 >> i3;
                  t.c7(s2, 0, t.a5, t.a5, 0, 0, 1), t.O(s2, s2, [a3 * n2, o3 * n2, 0]), t.Q(s2, s2, [1 / 2 ** i3, 1 / 2 ** i3, 0]);
                }
              }
              o2.terrainRttPosMatrix32f = new Float32Array(s2), i2[a2] = o2;
            }
            return i2;
          }
          _getTerrainCoordsForTileRanges(e2, i2) {
            const a2 = {};
            for (const r2 of this._renderableTilesKeys) {
              const o2 = this._tiles[r2].tileID;
              if (!this._isWithinTileRanges(o2, i2)) continue;
              const s2 = e2.clone(), n2 = t.bk();
              if (o2.canonical.z === e2.canonical.z) {
                const i3 = e2.canonical.x - o2.canonical.x + e2.wrap * (1 << e2.canonical.z), a3 = e2.canonical.y - o2.canonical.y;
                t.c7(n2, 0, t.a5, t.a5, 0, 0, 1), t.O(n2, n2, [i3 * t.a5, a3 * t.a5, 0]);
              } else if (o2.canonical.z > e2.canonical.z) {
                const i3 = o2.canonical.z - e2.canonical.z, a3 = o2.canonical.x - (o2.canonical.x >> i3 << i3) + e2.wrap * (1 << o2.canonical.z), r3 = o2.canonical.y - (o2.canonical.y >> i3 << i3), s3 = e2.canonical.x - (o2.canonical.x >> i3), l2 = e2.canonical.y - (o2.canonical.y >> i3), c2 = t.a5 >> i3;
                t.c7(n2, 0, c2, c2, 0, 0, 1), t.O(n2, n2, [-a3 * c2 + s3 * t.a5, -r3 * c2 + l2 * t.a5, 0]);
              } else {
                const i3 = e2.canonical.z - o2.canonical.z, a3 = e2.canonical.x - (e2.canonical.x >> i3 << i3) + e2.wrap * (1 << e2.canonical.z), r3 = e2.canonical.y - (e2.canonical.y >> i3 << i3), s3 = (e2.canonical.x >> i3) - o2.canonical.x, l2 = (e2.canonical.y >> i3) - o2.canonical.y, c2 = t.a5 << i3;
                t.c7(n2, 0, c2, c2, 0, 0, 1), t.O(n2, n2, [a3 * t.a5 + s3 * c2, r3 * t.a5 + l2 * c2, 0]);
              }
              s2.terrainRttPosMatrix32f = new Float32Array(n2), a2[r2] = s2;
            }
            return a2;
          }
          getSourceTile(e2, t2) {
            const i2 = this.tileManager._source;
            let a2 = e2.overscaledZ - this.deltaZoom;
            if (a2 > i2.maxzoom && (a2 = i2.maxzoom), a2 < i2.minzoom) return;
            this._sourceTileCache[e2.key] || (this._sourceTileCache[e2.key] = e2.scaledTo(a2).key);
            let r2 = this.findTileInCaches(this._sourceTileCache[e2.key]);
            if (!(null == r2 ? void 0 : r2.dem) && t2) for (; a2 >= i2.minzoom && !(null == r2 ? void 0 : r2.dem); ) r2 = this.findTileInCaches(e2.scaledTo(a2--).key);
            return r2;
          }
          findTileInCaches(e2) {
            let t2 = this.tileManager.getTileByID(e2);
            return t2 || (t2 = this.tileManager._outOfViewCache.getByKey(e2), t2);
          }
          anyTilesAfterTime(e2 = Date.now()) {
            return this._lastTilesetChange >= e2;
          }
          _isWithinTileRanges(e2, t2) {
            const i2 = t2[e2.canonical.z];
            return !!i2 && (e2.wrap > i2.minWrap || e2.wrap < i2.maxWrap || e2.canonical.x >= i2.minTileXWrapped && e2.canonical.x <= i2.maxTileXWrapped && e2.canonical.y >= i2.minTileY && e2.canonical.y <= i2.maxTileY);
          }
        }
        class is2 {
          constructor(e2, t2, i2) {
            this._meshCache = {}, this.painter = e2, this.tileManager = new ts2(t2), this.options = i2, this.exaggeration = "number" == typeof i2.exaggeration ? i2.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e2, i2, a2, r2 = t.a5) {
            var o2;
            if (!(i2 >= 0 && i2 < r2 && a2 >= 0 && a2 < r2)) return 0;
            const s2 = this.getTerrainData(e2), n2 = null === (o2 = s2.tile) || void 0 === o2 ? void 0 : o2.dem;
            if (!n2) return 0;
            const l2 = t.cC([], [i2 / r2 * t.a5, a2 / r2 * t.a5], s2.u_terrain_matrix), c2 = [l2[0] * n2.dim, l2[1] * n2.dim], h2 = Math.floor(c2[0]), u2 = Math.floor(c2[1]), d2 = c2[0] - h2, _3 = c2[1] - u2;
            return n2.get(h2, u2) * (1 - d2) * (1 - _3) + n2.get(h2 + 1, u2) * d2 * (1 - _3) + n2.get(h2, u2 + 1) * (1 - d2) * _3 + n2.get(h2 + 1, u2 + 1) * d2 * _3;
          }
          getElevationForLngLatZoom(e2, i2) {
            if (!t.cD(i2, e2.wrap())) return 0;
            const { tileID: a2, mercatorX: r2, mercatorY: o2 } = this._getOverscaledTileIDFromLngLatZoom(e2, i2);
            return this.getElevation(a2, r2 % t.a5, o2 % t.a5, t.a5);
          }
          getElevationForLngLat(e2, t2) {
            const i2 = Ie2(t2, { maxzoom: this.tileManager.maxzoom, minzoom: this.tileManager.minzoom, tileSize: 512, terrain: this });
            let a2 = 0;
            for (const e3 of i2) e3.canonical.z > a2 && (a2 = Math.min(e3.canonical.z, this.tileManager.maxzoom));
            return this.getElevationForLngLatZoom(e2, a2);
          }
          getElevation(e2, i2, a2, r2 = t.a5) {
            return this.getDEMElevation(e2, i2, a2, r2) * this.exaggeration;
          }
          getTerrainData(e2) {
            if (!this._emptyDemTexture) {
              const e3 = this.painter.context, i3 = new t.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new t.T(e3, i3, e3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new t.T(e3, new t.R({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ar([]);
            }
            const i2 = this.tileManager.getSourceTile(e2, true);
            if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
              const e3 = this.painter.context;
              i2.demTexture = this.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new t.T(e3, i2.dem.getPixels(), e3.gl.RGBA, { premultiply: false }), i2.demTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
            }
            const a2 = i2 && i2.toString() + i2.tileID.key + e2.key;
            if (a2 && !this._demMatrixCache[a2]) {
              const a3 = this.tileManager.getSource().maxzoom;
              let r2 = e2.canonical.z - i2.tileID.canonical.z;
              e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= a3 ? r2 = e2.canonical.z - a3 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const o2 = e2.canonical.x - (e2.canonical.x >> r2 << r2), s2 = e2.canonical.y - (e2.canonical.y >> r2 << r2), n2 = t.cE(new Float64Array(16), [1 / (t.a5 << r2), 1 / (t.a5 << r2), 0]);
              t.O(n2, n2, [o2 * t.a5, s2 * t.a5, 0]), this._demMatrixCache[e2.key] = { matrix: n2, coord: e2 };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: a2 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
          }
          getFramebuffer(e2) {
            const i2 = this.painter, a2 = i2.width / devicePixelRatio, r2 = i2.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === a2 && this._fbo.height === r2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new t.T(i2.context, { width: a2, height: r2, data: null }, i2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(i2.context.gl.NEAREST, i2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new t.T(i2.context, { width: a2, height: r2, data: null }, i2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(i2.context.gl.NEAREST, i2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i2.context.createFramebuffer(a2, r2, true, false), this._fbo.depthAttachment.set(i2.context.createRenderbuffer(i2.context.gl.DEPTH_COMPONENT16, a2, r2))), this._fbo.colorAttachment.set("coords" === e2 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e2 = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let e3 = 0, t2 = 0; e3 < this._coordsTextureSize; e3++) for (let a3 = 0; a3 < this._coordsTextureSize; a3++, t2 += 4) i2[t2 + 0] = 255 & a3, i2[t2 + 1] = 255 & e3, i2[t2 + 2] = a3 >> 8 << 4 | e3 >> 8, i2[t2 + 3] = 0;
            const a2 = new t.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), r2 = new t.T(e2, a2, e2.gl.RGBA, { premultiply: false });
            return r2.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = r2, r2;
          }
          pointCoordinate(e2) {
            this.painter.maybeDrawDepthAndCoords(true);
            const i2 = new Uint8Array(4), a2 = this.painter.context, r2 = a2.gl, o2 = Math.round(e2.x * this.painter.pixelRatio / devicePixelRatio), s2 = Math.round(e2.y * this.painter.pixelRatio / devicePixelRatio), n2 = Math.round(this.painter.height / devicePixelRatio);
            a2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r2.readPixels(o2, n2 - s2 - 1, 1, 1, r2.RGBA, r2.UNSIGNED_BYTE, i2), a2.bindFramebuffer.set(null);
            const l2 = i2[0] + (i2[2] >> 4 << 8), c2 = i2[1] + ((15 & i2[2]) << 8), h2 = this.coordsIndex[255 - i2[3]], u2 = h2 && this.tileManager.getTileByID(h2);
            if (!u2) return null;
            const d2 = this._coordsTextureSize, _3 = (1 << u2.tileID.canonical.z) * d2;
            return new t.a9((u2.tileID.canonical.x * d2 + l2) / _3 + u2.tileID.wrap, (u2.tileID.canonical.y * d2 + c2) / _3, this.getElevation(u2.tileID, l2, c2, d2));
          }
          depthAtPoint(e2) {
            const t2 = new Uint8Array(4), i2 = this.painter.context, a2 = i2.gl;
            return i2.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), a2.readPixels(e2.x, this.painter.height / devicePixelRatio - e2.y - 1, 1, 1, a2.RGBA, a2.UNSIGNED_BYTE, t2), i2.bindFramebuffer.set(null), (t2[0] / 16777216 + t2[1] / 65536 + t2[2] / 256 + t2[3]) / 256;
          }
          getTerrainMesh(e2) {
            var i2;
            const a2 = (null === (i2 = this.painter.style.projection) || void 0 === i2 ? void 0 : i2.transitionState) > 0, r2 = a2 && 0 === e2.canonical.y, o2 = a2 && e2.canonical.y === (1 << e2.canonical.z) - 1, s2 = `m_${r2 ? "n" : ""}_${o2 ? "s" : ""}`;
            if (this._meshCache[s2]) return this._meshCache[s2];
            const n2 = this.painter.context, l2 = new t.cF(), c2 = new t.aY(), h2 = this.meshSize, u2 = t.a5 / h2, d2 = h2 * h2;
            for (let e3 = 0; e3 <= h2; e3++) for (let t2 = 0; t2 <= h2; t2++) l2.emplaceBack(t2 * u2, e3 * u2, 0);
            for (let e3 = 0; e3 < d2; e3 += h2 + 1) for (let t2 = 0; t2 < h2; t2++) c2.emplaceBack(t2 + e3, h2 + t2 + e3 + 1, h2 + t2 + e3 + 2), c2.emplaceBack(t2 + e3, h2 + t2 + e3 + 2, t2 + e3 + 1);
            const _3 = l2.length, p2 = _3 + (h2 + 1), m2 = (h2 + 1) * h2, f3 = r2 ? t.br : 0, g2 = r2 ? 0 : 1, v2 = o2 ? t.bs : t.a5, x2 = o2 ? 0 : 1;
            for (let e3 = 0; e3 <= h2; e3++) l2.emplaceBack(e3 * u2, f3, g2);
            for (let e3 = 0; e3 <= h2; e3++) l2.emplaceBack(e3 * u2, v2, x2);
            for (let e3 = 0; e3 < h2; e3++) c2.emplaceBack(m2 + e3, p2 + e3, p2 + e3 + 1), c2.emplaceBack(m2 + e3, p2 + e3 + 1, m2 + e3 + 1), c2.emplaceBack(0 + e3, _3 + e3 + 1, _3 + e3), c2.emplaceBack(0 + e3, 0 + e3 + 1, _3 + e3 + 1);
            const b2 = l2.length, y3 = b2 + 2 * (h2 + 1);
            for (const e3 of [0, 1]) for (let i3 = 0; i3 <= h2; i3++) for (const a3 of [0, 1]) l2.emplaceBack(e3 * t.a5, i3 * u2, a3);
            for (let e3 = 0; e3 < 2 * h2; e3 += 2) c2.emplaceBack(b2 + e3, b2 + e3 + 1, b2 + e3 + 3), c2.emplaceBack(b2 + e3, b2 + e3 + 3, b2 + e3 + 2), c2.emplaceBack(y3 + e3, y3 + e3 + 3, y3 + e3 + 1), c2.emplaceBack(y3 + e3, y3 + e3 + 2, y3 + e3 + 3);
            const w3 = new kt2(n2.createVertexBuffer(l2, es2.members), n2.createIndexBuffer(c2), t.aX.simpleSegment(0, 0, l2.length, c2.length));
            return this._meshCache[s2] = w3, w3;
          }
          getMeshFrameDelta(e2) {
            return 2 * Math.PI * t.bE / Math.pow(2, Math.max(e2, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e2, i2) {
            var a2;
            if (!t.cD(i2, e2.wrap())) return 0;
            const { tileID: r2 } = this._getOverscaledTileIDFromLngLatZoom(e2, i2);
            return null !== (a2 = this.getMinMaxElevation(r2).minElevation) && void 0 !== a2 ? a2 : 0;
          }
          getMinMaxElevation(e2) {
            const t2 = this.getTerrainData(e2).tile, i2 = { minElevation: null, maxElevation: null };
            return t2 && t2.dem && (i2.minElevation = t2.dem.min * this.exaggeration, i2.maxElevation = t2.dem.max * this.exaggeration), i2;
          }
          _getOverscaledTileIDFromLngLatZoom(e2, i2) {
            const a2 = t.a9.fromLngLat(e2.wrap()), r2 = (1 << i2) * t.a5, o2 = a2.x * r2, s2 = a2.y * r2, n2 = Math.floor(o2 / t.a5), l2 = Math.floor(s2 / t.a5);
            return { tileID: new t.a2(i2, 0, i2, n2, l2), mercatorX: o2, mercatorY: s2 };
          }
        }
        class as2 {
          constructor(e2, t2, i2) {
            this._context = e2, this._size = t2, this._tileSize = i2, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e2 of this._objects) e2.texture.destroy(), e2.fbo.destroy();
          }
          _createObject(e2) {
            const i2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), a2 = new t.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return a2.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i2.colorAttachment.set(a2.texture), { id: e2, fbo: i2, texture: a2, stamp: -1, inUse: false };
          }
          getObjectForId(e2) {
            return this._objects[e2];
          }
          useObject(e2) {
            e2.inUse = true, this._recentlyUsed = this._recentlyUsed.filter(((t2) => e2.id !== t2)), this._recentlyUsed.push(e2.id);
          }
          stampObject(e2) {
            e2.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const e3 of this._recentlyUsed) if (!this._objects[e3].inUse) return this._objects[e3];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e2 = this._createObject(this._objects.length);
            return this._objects.push(e2), e2;
          }
          freeObject(e2) {
            e2.inUse = false;
          }
          freeAllObjects() {
            for (const e2 of this._objects) this.freeObject(e2);
          }
          isFull() {
            return !(this._objects.length < this._size) && false === this._objects.some(((e2) => !e2.inUse));
          }
        }
        const rs2 = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
        class os2 {
          constructor(e2, t2) {
            this.painter = e2, this.terrain = t2, this.pool = new as2(e2.context, 30, t2.tileManager.tileSize * t2.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e2) {
            return this.pool.getObjectForId(e2.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e2, t2) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e2._order.filter(((i2) => !e2._layers[i2].isHidden(t2))), this._coordsAscending = {};
            for (const t3 in e2.tileManagers) {
              this._coordsAscending[t3] = {};
              const i2 = e2.tileManagers[t3].getVisibleCoordinates(), a2 = e2.tileManagers[t3].getSource(), r2 = a2 instanceof te2 ? a2.terrainTileRanges : null;
              for (const e3 of i2) {
                const i3 = this.terrain.tileManager.getTerrainCoords(e3, r2);
                for (const e4 in i3) this._coordsAscending[t3][e4] || (this._coordsAscending[t3][e4] = []), this._coordsAscending[t3][e4].push(i3[e4]);
              }
            }
            this._coordsAscendingStr = {};
            for (const t3 of e2._order) {
              const i2 = e2._layers[t3], a2 = i2.source;
              if (rs2[i2.type] && !this._coordsAscendingStr[a2]) {
                this._coordsAscendingStr[a2] = {};
                for (const e3 in this._coordsAscending[a2]) this._coordsAscendingStr[a2][e3] = this._coordsAscending[a2][e3].map(((e4) => e4.key)).sort().join();
              }
            }
            for (const e3 of this._renderableTiles) for (const t3 in this._coordsAscendingStr) {
              const i2 = this._coordsAscendingStr[t3][e3.tileID.key];
              i2 && i2 !== e3.rttCoords[t3] && (e3.rtt = []);
            }
          }
          renderLayer(e2, i2) {
            if (e2.isHidden(this.painter.transform.zoom)) return false;
            const a2 = Object.assign(Object.assign({}, i2), { isRenderingToTexture: true }), r2 = e2.type, o2 = this.painter, s2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e2.id;
            if (rs2[r2] && (this._prevType && rs2[this._prevType] || this._stacks.push([]), this._prevType = r2, this._stacks[this._stacks.length - 1].push(e2.id), !s2)) return true;
            if (rs2[this._prevType] || rs2[r2] && s2) {
              this._prevType = r2;
              const e3 = this._stacks.length - 1, i3 = this._stacks[e3] || [];
              for (const r3 of this._renderableTiles) {
                if (this.pool.isFull() && (Ur2(this.painter, this.terrain, this._rttTiles, a2), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(r3), r3.rtt[e3]) {
                  const t2 = this.pool.getObjectForId(r3.rtt[e3].id);
                  if (t2.stamp === r3.rtt[e3].stamp) {
                    this.pool.useObject(t2);
                    continue;
                  }
                }
                const s3 = this.pool.getOrCreateFreeObject();
                this.pool.useObject(s3), this.pool.stampObject(s3), r3.rtt[e3] = { id: s3.id, stamp: s3.stamp }, o2.context.bindFramebuffer.set(s3.fbo.framebuffer), o2.context.clear({ color: t.bp.transparent, stencil: 0 }), o2.currentStencilSource = void 0;
                for (let e4 = 0; e4 < i3.length; e4++) {
                  const t2 = o2.style._layers[i3[e4]], n2 = t2.source ? this._coordsAscending[t2.source][r3.tileID.key] : [r3.tileID];
                  o2.context.viewport.set([0, 0, s3.fbo.width, s3.fbo.height]), o2._renderTileClippingMasks(t2, n2, true), o2.renderLayer(o2, o2.style.tileManagers[t2.source], t2, n2, a2), t2.source && (r3.rttCoords[t2.source] = this._coordsAscendingStr[t2.source][r3.tileID.key]);
                }
              }
              return Ur2(this.painter, this.terrain, this._rttTiles, a2), this._rttTiles = [], this.pool.freeAllObjects(), rs2[r2];
            }
            return false;
          }
        }
        const ss2 = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, ns2 = i, ls2 = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Ko2, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t.c.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, reduceMotion: void 0, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true, experimentalZoomLevelsToOverscale: void 0 }, cs2 = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
        class hs2 {
          constructor(e2, i2, a2 = false) {
            this.mousedown = (e3) => {
              this.startMove(e3, h.mousePos(this.element, e3)), h.addEventListener(window, "mousemove", this.mousemove), h.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (e3) => {
              this.move(e3, h.mousePos(this.element, e3));
            }, this.mouseup = (e3) => {
              this._rotatePitchHandler.dragEnd(e3), this.offTemp();
            }, this.touchstart = (e3) => {
              1 !== e3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = h.touchPos(this.element, e3.targetTouches)[0], this.startMove(e3, this._startPos), h.addEventListener(window, "touchmove", this.touchmove, { passive: false }), h.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (e3) => {
              1 !== e3.targetTouches.length ? this.reset() : (this._lastPos = h.touchPos(this.element, e3.targetTouches)[0], this.move(e3, this._lastPos));
            }, this.touchend = (e3) => {
              0 === e3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = i2;
            const r2 = new yo2();
            this._rotatePitchHandler = new mo2({ clickTolerance: 3, move: (e3, r3) => {
              const o2 = i2.getBoundingClientRect(), s2 = new t.P((o2.bottom - o2.top) / 2, (o2.right - o2.left) / 2);
              return { bearingDelta: t.cx(new t.P(e3.x, r3.y), r3, s2), pitchDelta: a2 ? -0.5 * (r3.y - e3.y) : void 0 };
            }, moveStateManager: r2, enable: true, assignEvents: () => {
            } }), this.map = e2, h.addEventListener(i2, "mousedown", this.mousedown), h.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), h.addEventListener(i2, "touchcancel", this.reset);
          }
          startMove(e2, t2) {
            this._rotatePitchHandler.dragStart(e2, t2), h.disableDrag();
          }
          move(e2, t2) {
            const i2 = this.map, { bearingDelta: a2, pitchDelta: r2 } = this._rotatePitchHandler.dragMove(e2, t2) || {};
            a2 && i2.setBearing(i2.getBearing() + a2), r2 && i2.setPitch(i2.getPitch() + r2);
          }
          off() {
            const e2 = this.element;
            h.removeEventListener(e2, "mousedown", this.mousedown), h.removeEventListener(e2, "touchstart", this.touchstart, { passive: false }), h.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), h.removeEventListener(window, "touchend", this.touchend), h.removeEventListener(e2, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            h.enableDrag(), h.removeEventListener(window, "mousemove", this.mousemove), h.removeEventListener(window, "mouseup", this.mouseup), h.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), h.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let us2;
        function ds2(e2, i2, a2, r2 = false) {
          if (r2 || !a2.getCoveringTilesDetailsProvider().allowWorldCopies()) return null == e2 ? void 0 : e2.wrap();
          const o2 = new t.V(e2.lng, e2.lat);
          if (e2 = new t.V(e2.lng, e2.lat), i2) {
            const r3 = new t.V(e2.lng - 360, e2.lat), o3 = new t.V(e2.lng + 360, e2.lat), s2 = a2.locationToScreenPoint(e2).distSqr(i2);
            a2.locationToScreenPoint(r3).distSqr(i2) < s2 ? e2 = r3 : a2.locationToScreenPoint(o3).distSqr(i2) < s2 && (e2 = o3);
          }
          for (; Math.abs(e2.lng - a2.center.lng) > 180; ) {
            const t2 = a2.locationToScreenPoint(e2);
            if (t2.x >= 0 && t2.y >= 0 && t2.x <= a2.width && t2.y <= a2.height) break;
            e2.lng > a2.center.lng ? e2.lng -= 360 : e2.lng += 360;
          }
          return e2.lng !== o2.lng && a2.isPointOnMapSurface(a2.locationToScreenPoint(e2)) ? e2 : o2;
        }
        const _s2 = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function ps2(e2, t2, i2) {
          const a2 = e2.classList;
          for (const e3 in _s2) a2.remove(`maplibregl-${i2}-anchor-${e3}`);
          a2.add(`maplibregl-${i2}-anchor-${t2}`);
        }
        class ms2 extends t.E {
          constructor(e2) {
            if (super(), this._onKeyPress = (e3) => {
              const t2 = e3.code, i2 = e3.charCode || e3.keyCode;
              "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
            }, this._onMapClick = (e3) => {
              const t2 = e3.originalEvent.target, i2 = this._element;
              this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
            }, this._update = (e3) => {
              if (!this._map) return;
              const t2 = this._map.loaded() && !this._map.isMoving();
              ("terrain" === (null == e3 ? void 0 : e3.type) || "render" === (null == e3 ? void 0 : e3.type) && !t2) && this._map.once("render", this._update), this._lngLat = ds2(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let i2 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? i2 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (i2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let a2 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a2 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e3 && "moveend" !== e3.type || (this._pos = this._pos.round()), h.setTransform(this._element, `${_s2[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a2} ${i2}`), n.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(e3 && "moveend" === e3.type);
              })).catch((() => {
              }));
            }, this._onMove = (e3) => {
              if (!this._isDragging) {
                const t2 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = e3.point.dist(this._pointerdownPos) >= t2;
              }
              this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (e3) => {
              this._element.contains(e3.originalEvent.target) && (e3.preventDefault(), this._positionDelta = e3.point.sub(this._pos).add(this._offset), this._pointerdownPos = e3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._subpixelPositioning = e2 && e2.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && "auto" !== e2.pitchAlignment ? e2.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e2 ? void 0 : e2.opacity, null == e2 ? void 0 : e2.opacityWhenCovered), e2 && e2.element) this._element = e2.element, this._offset = t.P.convert(e2 && e2.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = h.create("div");
              const i2 = h.createNS("http://www.w3.org/2000/svg", "svg"), a2 = 41, r2 = 27;
              i2.setAttributeNS(null, "display", "block"), i2.setAttributeNS(null, "height", `${a2}px`), i2.setAttributeNS(null, "width", `${r2}px`), i2.setAttributeNS(null, "viewBox", `0 0 ${r2} ${a2}`);
              const o2 = h.createNS("http://www.w3.org/2000/svg", "g");
              o2.setAttributeNS(null, "stroke", "none"), o2.setAttributeNS(null, "stroke-width", "1"), o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "fill-rule", "evenodd");
              const s2 = h.createNS("http://www.w3.org/2000/svg", "g");
              s2.setAttributeNS(null, "fill-rule", "nonzero");
              const n2 = h.createNS("http://www.w3.org/2000/svg", "g");
              n2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), n2.setAttributeNS(null, "fill", "#000000");
              const l2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const e3 of l2) {
                const t2 = h.createNS("http://www.w3.org/2000/svg", "ellipse");
                t2.setAttributeNS(null, "opacity", "0.04"), t2.setAttributeNS(null, "cx", "10.5"), t2.setAttributeNS(null, "cy", "5.80029008"), t2.setAttributeNS(null, "rx", e3.rx), t2.setAttributeNS(null, "ry", e3.ry), n2.appendChild(t2);
              }
              const c2 = h.createNS("http://www.w3.org/2000/svg", "g");
              c2.setAttributeNS(null, "fill", this._color);
              const u2 = h.createNS("http://www.w3.org/2000/svg", "path");
              u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c2.appendChild(u2);
              const d2 = h.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
              const _3 = h.createNS("http://www.w3.org/2000/svg", "path");
              _3.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_3);
              const p2 = h.createNS("http://www.w3.org/2000/svg", "g");
              p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
              const m2 = h.createNS("http://www.w3.org/2000/svg", "g");
              m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const f3 = h.createNS("http://www.w3.org/2000/svg", "circle");
              f3.setAttributeNS(null, "fill", "#000000"), f3.setAttributeNS(null, "opacity", "0.25"), f3.setAttributeNS(null, "cx", "5.5"), f3.setAttributeNS(null, "cy", "5.5"), f3.setAttributeNS(null, "r", "5.4999962");
              const g2 = h.createNS("http://www.w3.org/2000/svg", "circle");
              g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f3), m2.appendChild(g2), s2.appendChild(n2), s2.appendChild(c2), s2.appendChild(d2), s2.appendChild(p2), s2.appendChild(m2), i2.appendChild(s2), i2.setAttributeNS(null, "height", a2 * this._scale + "px"), i2.setAttributeNS(null, "width", r2 * this._scale + "px"), this._element.appendChild(i2), this._offset = t.P.convert(e2 && e2.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((e3) => {
              e3.preventDefault();
            })), this._element.addEventListener("mousedown", ((e3) => {
              e3.preventDefault();
            })), ps2(this._element, this._anchor, "marker"), e2 && e2.className) for (const t2 of e2.className.split(" ")) this._element.classList.add(t2);
            this._popup = null;
          }
          addTo(e2) {
            return this.remove(), this._map = e2, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e2._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._update), e2.on("moveend", this._update), e2.on("terrain", this._update), e2.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), h.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e2) {
            return this._lngLat = t.V.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
              if (!("offset" in e2.options)) {
                const t2 = 38.1, i2 = 13.5, a2 = Math.abs(i2) / Math.SQRT2;
                e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [a2, -1 * (t2 - i2 + a2)], "bottom-right": [-a2, -1 * (t2 - i2 + a2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
              }
              this._popup = e2, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e2) {
            return this._subpixelPositioning = e2, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e2 = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e2 ? (e2.isOpen() ? e2.remove() : (e2.setLngLat(this._lngLat), e2.addTo(this._map)), this) : this;
          }
          _updateOpacity(e2 = false) {
            var i2, a2;
            const r2 = null === (i2 = this._map) || void 0 === i2 ? void 0 : i2.terrain, o2 = this._map.transform.isLocationOccluded(this._lngLat);
            if (!r2 || o2) {
              const e3 = o2 ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== e3 && (this._element.style.opacity = e3));
            }
            if (e2) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const s2 = this._map, n2 = s2.terrain.depthAtPoint(this._pos), l2 = s2.terrain.getElevationForLngLat(this._lngLat, s2.transform);
            if (s2.transform.lngLatToCameraDepth(this._lngLat, l2) - n2 < 6e-3) return void (this._element.style.opacity = this._opacity);
            const c2 = -this._offset.y / s2.transform.pixelsPerMeter, h2 = Math.sin(s2.getPitch() * Math.PI / 180) * c2, u2 = s2.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), d2 = s2.transform.lngLatToCameraDepth(this._lngLat, l2 + h2) - u2 > 6e-3;
            (null === (a2 = this._popup) || void 0 === a2 ? void 0 : a2.isOpen()) && d2 && this._popup.remove(), this._element.style.opacity = d2 ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e2) {
            return this._offset = t.P.convert(e2), this._update(), this;
          }
          addClassName(e2) {
            this._element.classList.add(e2);
          }
          removeClassName(e2) {
            this._element.classList.remove(e2);
          }
          toggleClassName(e2) {
            return this._element.classList.toggle(e2);
          }
          setDraggable(e2) {
            return this._draggable = !!e2, this._map && (e2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e2) {
            return this._rotation = e2 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e2) {
            return this._rotationAlignment = e2 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e2) {
            return this._pitchAlignment = e2 && "auto" !== e2 ? e2 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e2, t2) {
            return (void 0 === this._opacity || void 0 === e2 && void 0 === t2) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e2 && (this._opacity = e2), void 0 !== t2 && (this._opacityWhenCovered = t2), this._map && this._updateOpacity(true), this;
          }
        }
        const fs2 = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let gs2 = 0, vs2 = false;
        const xs2 = { maxWidth: 100, unit: "metric" };
        function bs2(e2, t2, i2) {
          const a2 = i2 && i2.maxWidth || 100, r2 = e2._container.clientHeight / 2, o2 = e2._container.clientWidth / 2, s2 = e2.unproject([o2 - a2 / 2, r2]), n2 = e2.unproject([o2 + a2 / 2, r2]), l2 = Math.round(e2.project(n2).x - e2.project(s2).x), c2 = Math.min(a2, l2, e2._container.clientWidth), h2 = s2.distanceTo(n2);
          if (i2 && "imperial" === i2.unit) {
            const i3 = 3.2808 * h2;
            i3 > 5280 ? ys2(t2, c2, i3 / 5280, e2._getUIString("ScaleControl.Miles")) : ys2(t2, c2, i3, e2._getUIString("ScaleControl.Feet"));
          } else i2 && "nautical" === i2.unit ? ys2(t2, c2, h2 / 1852, e2._getUIString("ScaleControl.NauticalMiles")) : h2 >= 1e3 ? ys2(t2, c2, h2 / 1e3, e2._getUIString("ScaleControl.Kilometers")) : ys2(t2, c2, h2, e2._getUIString("ScaleControl.Meters"));
        }
        function ys2(e2, t2, i2, a2) {
          const r2 = (function(e3) {
            const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
            let i3 = e3 / t3;
            return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : (function(e4) {
              const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
              return Math.round(e4 * t4) / t4;
            })(i3), t3 * i3;
          })(i2);
          e2.style.width = t2 * (r2 / i2) + "px", e2.innerHTML = `${r2}&nbsp;${a2}`;
        }
        const ws2 = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0, padding: void 0 }, Ts2 = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Ps2(e2) {
          if (e2) {
            if ("number" == typeof e2) {
              const i2 = Math.round(Math.abs(e2) / Math.SQRT2);
              return { center: new t.P(0, 0), top: new t.P(0, e2), "top-left": new t.P(i2, i2), "top-right": new t.P(-i2, i2), bottom: new t.P(0, -e2), "bottom-left": new t.P(i2, -i2), "bottom-right": new t.P(-i2, -i2), left: new t.P(e2, 0), right: new t.P(-e2, 0) };
            }
            if (e2 instanceof t.P || Array.isArray(e2)) {
              const i2 = t.P.convert(e2);
              return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
            }
            return { center: t.P.convert(e2.center || [0, 0]), top: t.P.convert(e2.top || [0, 0]), "top-left": t.P.convert(e2["top-left"] || [0, 0]), "top-right": t.P.convert(e2["top-right"] || [0, 0]), bottom: t.P.convert(e2.bottom || [0, 0]), "bottom-left": t.P.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t.P.convert(e2["bottom-right"] || [0, 0]), left: t.P.convert(e2.left || [0, 0]), right: t.P.convert(e2.right || [0, 0]) };
          }
          return Ps2(new t.P(0, 0));
        }
        const Cs2 = i;
        e.AJAXError = t.cI, e.Event = t.l, e.Evented = t.E, e.LngLat = t.V, e.MercatorCoordinate = t.a9, e.Point = t.P, e.addProtocol = t.cJ, e.config = t.c, e.removeProtocol = t.cK, e.AttributionControl = Yo2, e.BoxZoomHandler = co2, e.CanvasSource = ae2, e.CooperativeGesturesHandler = Vo2, e.DoubleClickZoomHandler = Oo2, e.DragPanHandler = Zo2, e.DragRotateHandler = Go2, e.EdgeInsets = Nt2, e.FullscreenControl = class extends t.E {
          constructor(e2 = {}) {
            super(), this._onFullscreenChange = () => {
              var e3;
              let t2 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; null === (e3 = null == t2 ? void 0 : t2.shadowRoot) || void 0 === e3 ? void 0 : e3.fullscreenElement; ) t2 = t2.shadowRoot.fullscreenElement;
              t2 === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(e2) {
            return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            h.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const e2 = this._fullscreenButton = h.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            h.create("span", "maplibregl-ctrl-icon", e2).setAttribute("aria-hidden", "true"), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const e2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.title = e2;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, e.GeoJSONSource = ee2, e.GeolocateControl = class extends t.E {
          constructor(e2) {
            super(), this._onSuccess = (e3) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e3)) return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e3)), this._finish();
              }
            }, this._updateCamera = (e3) => {
              const i2 = new t.V(e3.coords.longitude, e3.coords.latitude), a2 = e3.coords.accuracy, r2 = this._map.getBearing(), o2 = t.e({ bearing: r2 }, this.options.fitBoundsOptions), s2 = $2.fromLngLat(i2, a2);
              this._map.fitBounds(s2, o2, { geolocateSource: true });
            }, this._updateMarker = (e3) => {
              if (e3) {
                const i2 = new t.V(e3.coords.longitude, e3.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e3.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (e3) => {
              if (this._map) {
                if (1 === e3.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === e3.code && vs2) return;
                  this._setErrorState();
                }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e3)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((e3) => e3.preventDefault())), this._geolocateButton = h.create("button", "maplibregl-ctrl-geolocate", this._container), h.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (e3) => {
              if (this._map) {
                if (false === e3) {
                  t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
                } else {
                  const e4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = h.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ms2({ element: this._dotElement }), this._circleElement = h.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ms2({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", ((e4) => {
                  const i2 = (null == e4 ? void 0 : e4[0]) instanceof ResizeObserverEntry;
                  e4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || i2 || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
                }));
              }
            }, this.options = t.e({}, fs2, e2);
          }
          onAdd(e2) {
            return this._map = e2, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return t._(this, arguments, void 0, (function* (e3 = false) {
                if (void 0 !== us2 && !e3) return us2;
                if (void 0 === window.navigator.permissions) return us2 = !!window.navigator.geolocation, us2;
                try {
                  const e4 = yield window.navigator.permissions.query({ name: "geolocation" });
                  us2 = "denied" !== e4.state;
                } catch (e4) {
                  us2 = !!window.navigator.geolocation;
                }
                return us2;
              }));
            })().then(((e3) => this._finishSetupUI(e3))), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), h.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, gs2 = 0, vs2 = false;
          }
          _isOutOfMapMaxBounds(e2) {
            const t2 = this._map.getMaxBounds(), i2 = e2.coords;
            return t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const e2 = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && e2)) return;
            const t2 = this._map.project(e2), i2 = this._map.unproject([t2.x + 100, t2.y]), a2 = e2.distanceTo(i2) / 100, r2 = 2 * this._accuracy / a2;
            this._circleElement.style.width = `${r2.toFixed(2)}px`, this._circleElement.style.height = `${r2.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return t.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  gs2--, vs2 = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let e2;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), gs2++, gs2 > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, vs2 = true) : (e2 = this.options.positionOptions, vs2 = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e2);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, e.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var e2;
              const t2 = null === (e2 = this._map.getProjection()) || void 0 === e2 ? void 0 : e2.type;
              this._map.setProjection("mercator" !== t2 && t2 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var e2;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e2 = this._map.getProjection()) || void 0 === e2 ? void 0 : e2.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(e2) {
            return this._map = e2, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = h.create("button", "maplibregl-ctrl-globe", this._container), h.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            h.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, e.Hash = $r2, e.ImageSource = te2, e.KeyboardHandler = Ao2, e.LngLatBounds = $2, e.LogoControl = Qo2, e.Map = class extends Xo2 {
          constructor(e2) {
            var i2, a2;
            t.cG.mark(t.cH.create);
            const r2 = Object.assign(Object.assign(Object.assign({}, ls2), e2), { canvasContextAttributes: Object.assign(Object.assign({}, ls2.canvasContextAttributes), e2.canvasContextAttributes) });
            if (null != r2.minZoom && null != r2.maxZoom && r2.minZoom > r2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != r2.minPitch && null != r2.maxPitch && r2.minPitch > r2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != r2.minPitch && r2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (null != r2.maxPitch && r2.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const o2 = new $t2(), s2 = new Yt2();
            if (void 0 !== r2.minZoom && o2.setMinZoom(r2.minZoom), void 0 !== r2.maxZoom && o2.setMaxZoom(r2.maxZoom), void 0 !== r2.minPitch && o2.setMinPitch(r2.minPitch), void 0 !== r2.maxPitch && o2.setMaxPitch(r2.maxPitch), void 0 !== r2.renderWorldCopies && o2.setRenderWorldCopies(r2.renderWorldCopies), null !== r2.transformConstrain && o2.setConstrainOverride(r2.transformConstrain), super(o2, s2, { bearingSnap: r2.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Jo2(), this._controls = [], this._mapId = t.af(), this._lostContextStyle = { style: null, images: null }, this._contextLost = (e3) => {
              e3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy();
              for (const e4 of Object.values(this.style._layers)) if ("custom" === e4.type && console.warn(`Custom layer with id '${e4.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), e4._listeners) for (const [t2] of Object.entries(e4._listeners)) console.warn(`Custom layer with id '${e4.id}' had event listeners for event '${t2}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`);
              this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new t.l("webglcontextlost", { originalEvent: e3 }));
            }, this._contextRestored = (e3) => {
              this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: false }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._lostContextStyle = { style: null, images: null }, this._setupPainter(), this.resize(), this._update(), this._resizeInternal(), this.fire(new t.l("webglcontextrestored", { originalEvent: e3 }));
            }, this._onMapScroll = (e3) => {
              if (e3.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = r2.interactive, this._maxTileCacheSize = r2.maxTileCacheSize, this._maxTileCacheZoomLevels = r2.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, r2.canvasContextAttributes), this._trackResize = true === r2.trackResize, this._bearingSnap = r2.bearingSnap, this._centerClampedToGround = r2.centerClampedToGround, this._refreshExpiredTiles = true === r2.refreshExpiredTiles, this._fadeDuration = r2.fadeDuration, this._crossSourceCollisions = true === r2.crossSourceCollisions, this._collectResourceTiming = true === r2.collectResourceTiming, this._locale = Object.assign(Object.assign({}, ss2), r2.locale), this._clickTolerance = r2.clickTolerance, this._overridePixelRatio = r2.pixelRatio, this._maxCanvasSize = r2.maxCanvasSize, this._zoomLevelsToOverscale = r2.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = r2.transformCameraUpdate, this.transformConstrain = r2.transformConstrain, this.cancelPendingTileRequestsWhileZooming = true === r2.cancelPendingTileRequestsWhileZooming, void 0 !== r2.reduceMotion && (n.prefersReducedMotion = r2.reduceMotion), this._imageQueueHandle = g.addThrottleControl((() => this.isMoving())), this._requestManager = new v(r2.transformRequest), "string" == typeof r2.container) {
              if (this._container = document.getElementById(r2.container), !this._container) throw new Error(`Container '${r2.container}' not found.`);
            } else {
              if (!(r2.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = r2.container;
            }
            if (r2.maxBounds && this.setMaxBounds(r2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(false))), this.on("moveend", (() => this._update(false))), this.on("zoom", (() => this._update(true))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            })), this.once("idle", (() => {
              this._idleTriggered = true;
            })), "undefined" != typeof window) {
              addEventListener("online", this._onWindowOnline, false);
              let e3 = false;
              const t2 = Wr2(((e4) => {
                this._trackResize && !this._removed && (this.resize(e4), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((i3) => {
                e3 ? t2(i3) : e3 = true;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new Ho2(this, r2), this._hash = r2.hash && new $r2("string" == typeof r2.hash && r2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: r2.center, elevation: r2.elevation, zoom: r2.zoom, bearing: r2.bearing, pitch: r2.pitch, roll: r2.roll }), r2.bounds && (this.resize(), this.fitBounds(r2.bounds, t.e({}, r2.fitBoundsOptions, { duration: 0 }))));
            const l2 = "string" == typeof r2.style || !("globe" === (null === (a2 = null === (i2 = r2.style) || void 0 === i2 ? void 0 : i2.projection) || void 0 === a2 ? void 0 : a2.type));
            this.resize(null, l2), this._localIdeographFontFamily = r2.localIdeographFontFamily, this._validateStyle = r2.validateStyle, r2.style && this.setStyle(r2.style, { localIdeographFontFamily: r2.localIdeographFontFamily }), r2.attributionControl && this.addControl(new Yo2("boolean" == typeof r2.attributionControl ? void 0 : r2.attributionControl)), r2.maplibreLogo && this.addControl(new Qo2(), r2.logoPosition), this.on("style.load", (() => {
              if (l2 || this._resizeTransform(), this.transform.unmodified) {
                const e3 = t.U(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(e3);
              }
            })), this.on("data", ((e3) => {
              this._update("style" === e3.dataType), this.fire(new t.l(`${e3.dataType}data`, e3));
            })), this.on("dataloading", ((e3) => {
              this.fire(new t.l(`${e3.dataType}dataloading`, e3));
            })), this.on("dataabort", ((e3) => {
              this.fire(new t.l("sourcedataabort", e3));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(e2, t2) {
            return this.style.setGlobalStateProperty(e2, t2), this._update(true);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(e2, i2) {
            if (void 0 === i2 && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd) return this.fire(new t.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a2 = e2.onAdd(this);
            this._controls.push(e2);
            const r2 = this._controlPositions[i2];
            return -1 !== i2.indexOf("bottom") ? r2.insertBefore(a2, r2.firstChild) : r2.appendChild(a2), this;
          }
          removeControl(e2) {
            if (!e2 || !e2.onRemove) return this.fire(new t.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i2 = this._controls.indexOf(e2);
            return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
          }
          hasControl(e2) {
            return this._controls.indexOf(e2) > -1;
          }
          coveringTiles(e2) {
            return Ie2(this.transform, e2);
          }
          calculateCameraOptionsFromTo(e2, t2, i2, a2) {
            return null == a2 && this.terrain && (a2 = this.terrain.getElevationForLngLat(i2, this.transform)), super.calculateCameraOptionsFromTo(e2, t2, i2, a2);
          }
          resize(e2, i2 = true) {
            if (null !== this._lostContextStyle.style) return this;
            this._resizeInternal(i2);
            const a2 = !this._moving;
            return a2 && (this.stop(), this.fire(new t.l("movestart", e2)).fire(new t.l("move", e2))), this.fire(new t.l("resize", e2)), a2 && this.fire(new t.l("moveend", e2)), this;
          }
          _resizeInternal(e2 = true) {
            const [t2, i2] = this._containerDimensions(), a2 = this._getClampedPixelRatio(t2, i2);
            if (this._resizeCanvas(t2, i2, a2), this.painter.resize(t2, i2, a2), this.painter.overLimit()) {
              const e3 = this.painter.context.gl;
              this._maxCanvasSize = [e3.drawingBufferWidth, e3.drawingBufferHeight];
              const a3 = this._getClampedPixelRatio(t2, i2);
              this._resizeCanvas(t2, i2, a3), this.painter.resize(t2, i2, a3);
            }
            this._resizeTransform(e2);
          }
          _resizeTransform(e2 = true) {
            var t2;
            const [i2, a2] = this._containerDimensions();
            this.transform.resize(i2, a2, e2), null === (t2 = this._requestedCameraState) || void 0 === t2 || t2.resize(i2, a2, e2);
          }
          _getClampedPixelRatio(e2, t2) {
            const { 0: i2, 1: a2 } = this._maxCanvasSize, r2 = this.getPixelRatio(), o2 = e2 * r2, s2 = t2 * r2;
            return Math.min(o2 > i2 ? i2 / o2 : 1, s2 > a2 ? a2 / s2 : 1) * r2;
          }
          getPixelRatio() {
            var e2;
            return null !== (e2 = this._overridePixelRatio) && void 0 !== e2 ? e2 : devicePixelRatio;
          }
          setPixelRatio(e2) {
            this._overridePixelRatio = e2, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(e2) {
            return this.transform.setMaxBounds($2.convert(e2)), this._update();
          }
          setMinZoom(e2) {
            if ((e2 = null == e2 ? -2 : e2) >= -2 && e2 <= this.transform.maxZoom) {
              const t2 = this._getTransformForUpdate();
              return t2.setMinZoom(e2), this._applyUpdatedTransform(t2), this._update(), this;
            }
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(e2) {
            if ((e2 = null == e2 ? 22 : e2) >= this.transform.minZoom) {
              const t2 = this._getTransformForUpdate();
              return t2.setMaxZoom(e2), this._applyUpdatedTransform(t2), this._update(), this;
            }
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(e2) {
            if ((e2 = null == e2 ? 0 : e2) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (e2 >= 0 && e2 <= this.transform.maxPitch) return this.transform.setMinPitch(e2), this._update(), this.getPitch() < e2 && this.setPitch(e2), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(e2) {
            if ((e2 = null == e2 ? 60 : e2) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (e2 >= this.transform.minPitch) return this.transform.setMaxPitch(e2), this._update(), this.getPitch() > e2 && this.setPitch(e2), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e2) {
            return this.transform.setRenderWorldCopies(e2), this._update();
          }
          setTransformConstrain(e2) {
            return this.transform.setConstrainOverride(e2), this._update();
          }
          project(e2) {
            return this.transform.locationToScreenPoint(t.V.convert(e2), this.style && this.terrain);
          }
          unproject(e2) {
            return this.transform.screenPointToLocation(t.P.convert(e2), this.terrain);
          }
          isMoving() {
            var e2;
            return this._moving || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isMoving());
          }
          isZooming() {
            var e2;
            return this._zooming || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isZooming());
          }
          isRotating() {
            var e2;
            return this._rotating || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isRotating());
          }
          _createDelegatedListener(e2, t2, i2) {
            if ("mouseenter" === e2 || "mouseover" === e2) {
              let a2 = false;
              const r2 = (r3) => {
                const o2 = t2.filter(((e3) => this.getLayer(e3))), s2 = 0 !== o2.length ? this.queryRenderedFeatures(r3.point, { layers: o2 }) : [];
                s2.length ? a2 || (a2 = true, i2.call(this, new ao2(e2, this, r3.originalEvent, { features: s2 }))) : a2 = false;
              };
              return { layers: t2, listener: i2, delegates: { mousemove: r2, mouseout: () => {
                a2 = false;
              } } };
            }
            if ("mouseleave" === e2 || "mouseout" === e2) {
              let a2 = false;
              const r2 = (r3) => {
                const o3 = t2.filter(((e3) => this.getLayer(e3)));
                (0 !== o3.length ? this.queryRenderedFeatures(r3.point, { layers: o3 }) : []).length ? a2 = true : a2 && (a2 = false, i2.call(this, new ao2(e2, this, r3.originalEvent)));
              }, o2 = (t3) => {
                a2 && (a2 = false, i2.call(this, new ao2(e2, this, t3.originalEvent)));
              };
              return { layers: t2, listener: i2, delegates: { mousemove: r2, mouseout: o2 } };
            }
            {
              const a2 = (e3) => {
                const a3 = t2.filter(((e4) => this.getLayer(e4))), r2 = 0 !== a3.length ? this.queryRenderedFeatures(e3.point, { layers: a3 }) : [];
                r2.length && (e3.features = r2, i2.call(this, e3), delete e3.features);
              };
              return { layers: t2, listener: i2, delegates: { [e2]: a2 } };
            }
          }
          _saveDelegatedListener(e2, t2) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(t2);
          }
          _removeDelegatedListener(e2, t2, i2) {
            if (!this._delegatedListeners || !this._delegatedListeners[e2]) return;
            const a2 = this._delegatedListeners[e2];
            for (let e3 = 0; e3 < a2.length; e3++) {
              const r2 = a2[e3];
              if (r2.listener === i2 && r2.layers.length === t2.length && r2.layers.every(((e4) => t2.includes(e4)))) {
                for (const e4 in r2.delegates) this.off(e4, r2.delegates[e4]);
                return void a2.splice(e3, 1);
              }
            }
          }
          on(e2, t2, i2) {
            if (void 0 === i2) return super.on(e2, t2);
            const a2 = "string" == typeof t2 ? [t2] : t2, r2 = this._createDelegatedListener(e2, a2, i2);
            this._saveDelegatedListener(e2, r2);
            for (const e3 in r2.delegates) this.on(e3, r2.delegates[e3]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(e2, a2, i2);
            } };
          }
          once(e2, t2, i2) {
            if (void 0 === i2) return super.once(e2, t2);
            const a2 = "string" == typeof t2 ? [t2] : t2, r2 = this._createDelegatedListener(e2, a2, i2);
            for (const t3 in r2.delegates) {
              const o2 = r2.delegates[t3];
              r2.delegates[t3] = (...t4) => {
                this._removeDelegatedListener(e2, a2, i2), o2(...t4);
              };
            }
            this._saveDelegatedListener(e2, r2);
            for (const e3 in r2.delegates) this.once(e3, r2.delegates[e3]);
            return this;
          }
          off(e2, t2, i2) {
            return void 0 === i2 ? super.off(e2, t2) : (this._removeDelegatedListener(e2, "string" == typeof t2 ? [t2] : t2, i2), this);
          }
          queryRenderedFeatures(e2, i2) {
            if (!this.style) return [];
            let a2;
            const r2 = e2 instanceof t.P || Array.isArray(e2), o2 = r2 ? e2 : [[0, 0], [this.transform.width, this.transform.height]];
            if (i2 = i2 || (r2 ? {} : e2) || {}, o2 instanceof t.P || "number" == typeof o2[0]) a2 = [t.P.convert(o2)];
            else {
              const e3 = t.P.convert(o2[0]), i3 = t.P.convert(o2[1]);
              a2 = [e3, new t.P(i3.x, e3.y), i3, new t.P(e3.x, i3.y), e3];
            }
            return this.style.queryRenderedFeatures(a2, i2, this.transform);
          }
          querySourceFeatures(e2, t2) {
            return this.style.querySourceFeatures(e2, t2);
          }
          setStyle(e2, i2) {
            return false !== (i2 = t.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
          }
          setTransformRequest(e2) {
            return this._requestManager.setTransformRequest(e2), this;
          }
          _getUIString(e2) {
            const t2 = this._locale[e2];
            if (null == t2) throw new Error(`Missing UI string '${e2}'`);
            return t2;
          }
          _updateStyle(e2, t2) {
            var i2, a2;
            if (t2.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(e2, t2)));
            const r2 = this.style && t2.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!e2)), e2 ? (this.style = new ki(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e2 ? this.style.loadURL(e2, t2, r2) : this.style.loadJSON(e2, t2, r2), this) : (null === (a2 = null === (i2 = this.style) || void 0 === i2 ? void 0 : i2.projection) || void 0 === a2 || a2.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new ki(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(e2, i2) {
            if ("string" == typeof e2) {
              const a2 = this._requestManager.transformRequest(e2, "Style");
              t.j(a2, new AbortController()).then(((e3) => {
                this._updateDiff(e3.data, i2);
              })).catch(((e3) => {
                e3 && this.fire(new t.k(e3));
              }));
            } else "object" == typeof e2 && this._updateDiff(e2, i2);
          }
          _updateDiff(e2, i2) {
            try {
              this.style.setState(e2, i2) && this._update(true);
            } catch (a2) {
              t.w(`Unable to perform style diff: ${a2.message || a2.error || a2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i2);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          _getStyleAndImages() {
            return this.style ? { style: this.style.serialize(), images: this.style.imageManager.cloneImages() } : { style: null, images: {} };
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
          }
          addSource(e2, t2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
          }
          isSourceLoaded(e2) {
            const i2 = this.style && this.style.tileManagers[e2];
            if (void 0 !== i2) return i2.loaded();
            this.fire(new t.k(new Error(`There is no tile manager with ID '${e2}'`)));
          }
          setTerrain(e2) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e2) {
              const i2 = this.style.tileManagers[e2.source];
              if (!i2) throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
              null === this.terrain && i2.reload();
              for (const i3 in this.style._layers) {
                const a2 = this.style._layers[i3];
                "hillshade" === a2.type && a2.source === e2.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), "color-relief" === a2.type && a2.source === e2.source && t.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new is2(this.painter, i2, e2), this.painter.renderToTexture = new os2(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t2) => {
                var i3;
                "style" === t2.dataType ? this.terrain.tileManager.freeRtt() : "source" === t2.dataType && t2.tile && (t2.sourceId !== e2.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i3 = t2.source) || void 0 === i3 ? void 0 : i3.type) ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(t2.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new t.l("terrain", { terrain: e2 })), this;
          }
          getTerrain() {
            var e2, t2;
            return null !== (t2 = null === (e2 = this.terrain) || void 0 === e2 ? void 0 : e2.options) && void 0 !== t2 ? t2 : null;
          }
          areTilesLoaded() {
            const e2 = this.style && this.style.tileManagers;
            for (const t2 of Object.values(e2)) if (!t2.areTilesLoaded()) return false;
            return true;
          }
          removeSource(e2) {
            return this.style.removeSource(e2), this._update(true);
          }
          getSource(e2) {
            return this.style.getSource(e2);
          }
          setSourceTileLodParams(e2, t2, i2) {
            if (i2) {
              const a2 = this.getSource(i2);
              if (!a2) throw new Error(`There is no source with ID "${i2}", cannot set LOD parameters`);
              a2.calculateTileZoom = Te2(Math.max(1, e2), Math.max(1, t2));
            } else for (const i3 in this.style.tileManagers) this.style.tileManagers[i3].getSource().calculateTileZoom = Te2(Math.max(1, e2), Math.max(1, t2));
            return this._update(true), this;
          }
          refreshTiles(e2, i2) {
            const a2 = this.style.tileManagers[e2];
            if (!a2) throw new Error(`There is no tile manager with ID "${e2}", cannot refresh tile`);
            void 0 === i2 ? a2.reload(true) : a2.refreshTiles(i2.map(((e3) => new t.ac(e3.z, e3.x, e3.y))));
          }
          addImage(e2, i2, a2 = {}) {
            const { pixelRatio: r2 = 1, sdf: o2 = false, stretchX: s2, stretchY: l2, content: c2, textFitWidth: h2, textFitHeight: u2 } = a2;
            if (this._lazyInitEmptyStyle(), !(i2 instanceof HTMLImageElement || t.b(i2))) {
              if (void 0 === i2.width || void 0 === i2.height) return this.fire(new t.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: a3, height: n2, data: d2 } = i2, _3 = i2;
                return this.style.addImage(e2, { data: new t.R({ width: a3, height: n2 }, new Uint8Array(d2)), pixelRatio: r2, stretchX: s2, stretchY: l2, content: c2, textFitWidth: h2, textFitHeight: u2, sdf: o2, version: 0, userImage: _3 }), _3.onAdd && _3.onAdd(this, e2), this;
              }
            }
            {
              const { width: a3, height: d2, data: _3 } = n.getImageData(i2);
              this.style.addImage(e2, { data: new t.R({ width: a3, height: d2 }, _3), pixelRatio: r2, stretchX: s2, stretchY: l2, content: c2, textFitWidth: h2, textFitHeight: u2, sdf: o2, version: 0 });
            }
          }
          updateImage(e2, i2) {
            const a2 = this.style.getImage(e2);
            if (!a2) return this.fire(new t.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const r2 = i2 instanceof HTMLImageElement || t.b(i2) ? n.getImageData(i2) : i2, { width: o2, height: s2, data: l2 } = r2;
            if (void 0 === o2 || void 0 === s2) return this.fire(new t.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (o2 !== a2.data.width || s2 !== a2.data.height) return this.fire(new t.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const c2 = !(i2 instanceof HTMLImageElement || t.b(i2));
            return a2.data.replace(l2, c2), this.style.updateImage(e2, a2), this;
          }
          getImage(e2) {
            return this.style.getImage(e2);
          }
          hasImage(e2) {
            return e2 ? !!this.style.getImage(e2) : (this.fire(new t.k(new Error("Missing required image id"))), false);
          }
          removeImage(e2) {
            this.style.removeImage(e2);
          }
          loadImage(e2) {
            return g.getImage(this._requestManager.transformRequest(e2, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(e2, t2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
          }
          moveLayer(e2, t2) {
            return this.style.moveLayer(e2, t2), this._update(true);
          }
          removeLayer(e2) {
            return this.style.removeLayer(e2), this._update(true);
          }
          getLayer(e2) {
            return this.style.getLayer(e2);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(e2, t2, i2) {
            return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
          }
          setFilter(e2, t2, i2 = {}) {
            return this.style.setFilter(e2, t2, i2), this._update(true);
          }
          getFilter(e2) {
            return this.style.getFilter(e2);
          }
          setPaintProperty(e2, t2, i2, a2 = {}) {
            return this.style.setPaintProperty(e2, t2, i2, a2), this._update(true);
          }
          getPaintProperty(e2, t2) {
            return this.style.getPaintProperty(e2, t2);
          }
          setLayoutProperty(e2, t2, i2, a2 = {}) {
            return this.style.setLayoutProperty(e2, t2, i2, a2), this._update(true);
          }
          getLayoutProperty(e2, t2) {
            return this.style.getLayoutProperty(e2, t2);
          }
          setGlyphs(e2, t2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(e2, t2), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(e2, t2, i2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(e2, t2, i2, ((e3) => {
              e3 || this._update(true);
            })), this;
          }
          removeSprite(e2) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(e2), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(e2, t2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(e2, t2, ((e3) => {
              e3 || this._update(true);
            })), this;
          }
          setLight(e2, t2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(e2, t2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(e2, t2), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(e2, t2) {
            return this.style.setFeatureState(e2, t2), this._update();
          }
          removeFeatureState(e2, t2) {
            return this.style.removeFeatureState(e2, t2), this._update();
          }
          getFeatureState(e2) {
            return this.style.getFeatureState(e2);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let e2 = 0, t2 = 0;
            return this._container && (e2 = this._container.clientWidth || 400, t2 = this._container.clientHeight || 300), [e2, t2];
          }
          _setupContainer() {
            const e2 = this._container;
            e2.classList.add("maplibregl-map");
            const t2 = this._canvasContainer = h.create("div", "maplibregl-canvas-container", e2);
            this._interactive && t2.classList.add("maplibregl-interactive"), this._canvas = h.create("canvas", "maplibregl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const i2 = this._containerDimensions(), a2 = this._getClampedPixelRatio(i2[0], i2[1]);
            this._resizeCanvas(i2[0], i2[1], a2);
            const r2 = this._controlContainer = h.create("div", "maplibregl-control-container", e2), o2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((e3) => {
              o2[e3] = h.create("div", `maplibregl-ctrl-${e3} `, r2);
            })), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(e2, t2, i2) {
            this._canvas.width = Math.floor(i2 * e2), this._canvas.height = Math.floor(i2 * t2), this._canvas.style.width = `${e2}px`, this._canvas.style.height = `${t2}px`;
          }
          _setupPainter() {
            const e2 = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
            let t2 = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((i3) => {
              t2 = { requestedAttributes: e2 }, i3 && (t2.statusMessage = i3.statusMessage, t2.type = i3.type);
            }), { once: true });
            let i2 = null;
            if (i2 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e2) : this._canvas.getContext("webgl2", e2) || this._canvas.getContext("webgl", e2), !i2) {
              const e3 = "Failed to initialize WebGL";
              throw t2 ? (t2.message = e3, new Error(JSON.stringify(t2))) : new Error(e3);
            }
            this.painter = new qr2(i2, this.transform), u.testSupport(i2);
          }
          migrateProjection(e2, i2) {
            super.migrateProjection(e2, i2), this.painter.transform = e2, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e2) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e2) {
            return this._update(), this._renderTaskQueue.add(e2);
          }
          _cancelRenderFrame(e2) {
            this._renderTaskQueue.remove(e2);
          }
          _render(e2) {
            var i2, a2, r2, o2, s2;
            const n2 = this._idleTriggered ? this._fadeDuration : 0, l2 = (null === (i2 = this.style.projection) || void 0 === i2 ? void 0 : i2.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed) return;
            let h2 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const e3 = this.transform.zoom, i3 = c();
              this.style.zoomHistory.update(e3, i3);
              const a3 = new t.H(e3, { now: i3, fadeDuration: n2, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r3 = a3.crossFadingFactor();
              1 === r3 && r3 === this._crossFadingFactor || (h2 = true, this._crossFadingFactor = r3), this.style.update(a3);
            }
            const u2 = (null === (a2 = this.style.projection) || void 0 === a2 ? void 0 : a2.transitionState) > 0 !== l2;
            null === (r2 = this.style.projection) || void 0 === r2 || r2.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (o2 = this.style.projection) || void 0 === o2 ? void 0 : o2.transitionState, null === (s2 = this.style.projection) || void 0 === s2 ? void 0 : s2.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u2) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, n2, this._crossSourceCollisions, u2), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n2, showPadding: this.showPadding }), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = true, t.cG.mark(t.cH.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || h2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const d2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return d2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || d2 || (this._fullyLoaded = true, t.cG.mark(t.cH.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var e2;
            this._hash && this._hash.remove();
            for (const e3 of this._controls) e3.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), g.removeThrottleControl(this._imageQueueHandle), null === (e2 = this._resizeObserver) || void 0 === e2 || e2.disconnect();
            const i2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (null == i2 ? void 0 : i2.loseContext) && i2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), h.remove(this._canvasContainer), h.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), t.cG.clearMetrics(), this._removed = true, this.fire(new t.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), n.frame(this._frameRequest, ((e2) => {
              t.cG.frame(e2), this._frameRequest = null;
              try {
                this._render(e2);
              } catch (e3) {
                if (!t.Z(e3) && !(function(e4) {
                  return e4.message === or2;
                })(e3)) throw e3;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e2) {
            this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e2) {
            this._showPadding !== e2 && (this._showPadding = e2, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e2) {
            this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e2) {
            this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e2) {
            this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e2) {
            this._vertices = e2, this._update();
          }
          get version() {
            return ns2;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(e2) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(e2), this._update(true);
          }
        }, e.MapMouseEvent = ao2, e.MapTouchEvent = ro2, e.MapWheelEvent = oo2, e.Marker = ms2, e.NavigationControl = class {
          constructor(e2) {
            this._updateZoomButtons = () => {
              const e3 = this._map.getZoom(), t2 = e3 === this._map.getMaxZoom(), i2 = e3 === this._map.getMinZoom();
              this._zoomInButton.disabled = t2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", t2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e3, t2) => {
              const i2 = this._map._getUIString(`NavigationControl.${t2}`);
              e3.title = i2, e3.setAttribute("aria-label", i2);
            }, this.options = t.e({}, cs2, e2), this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e3) => e3.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e3) => this._map.zoomIn({}, { originalEvent: e3 }))), h.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e3) => this._map.zoomOut({}, { originalEvent: e3 }))), h.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e3) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e3 }) : this._map.resetNorth({}, { originalEvent: e3 });
            })), this._compassIcon = h.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(e2) {
            return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new hs2(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            h.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(e2, t2) {
            const i2 = h.create("button", e2, this._container);
            return i2.type = "button", i2.addEventListener("click", t2), i2;
          }
        }, e.Popup = class extends t.E {
          constructor(e2) {
            super(), this._updateOpacity = () => {
              void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && h.remove(this._content), this._container && (h.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e3) => {
              this._update(e3.point);
            }, this._onMouseMove = (e3) => {
              this._update(e3.point);
            }, this._onDrag = (e3) => {
              this._update(e3.point);
            }, this._update = (e3) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = h.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = h.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e4 of this.options.className.split(" ")) this._container.classList.add(e4);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = ds2(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e3) return;
              const t2 = this._flatPos = this._pos = this._trackPointer && e3 ? e3 : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e3 ? e3 : this._map.transform.locationToScreenPoint(this._lngLat));
              let i2 = this.options.anchor;
              const a2 = Ps2(this.options.offset);
              if (!i2) {
                const e4 = this._container.offsetWidth, r3 = this._container.offsetHeight, o2 = (function(e5) {
                  var t3, i3, a3, r4;
                  return e5 ? { top: null !== (t3 = e5.top) && void 0 !== t3 ? t3 : 0, right: null !== (i3 = e5.right) && void 0 !== i3 ? i3 : 0, bottom: null !== (a3 = e5.bottom) && void 0 !== a3 ? a3 : 0, left: null !== (r4 = e5.left) && void 0 !== r4 ? r4 : 0 } : { top: 0, right: 0, bottom: 0, left: 0 };
                })(this.options.padding);
                let s2;
                s2 = t2.y + a2.bottom.y < r3 + o2.top ? ["top"] : t2.y > this._map.transform.height - r3 - o2.bottom ? ["bottom"] : [], t2.x < e4 / 2 + o2.left ? s2.push("left") : t2.x > this._map.transform.width - e4 / 2 - o2.right && s2.push("right"), i2 = 0 === s2.length ? "bottom" : s2.join("-");
              }
              let r2 = t2.add(a2[i2]);
              this.options.subpixelPositioning || (r2 = r2.round()), h.setTransform(this._container, `${_s2[i2]} translate(${r2.x}px,${r2.y}px)`), ps2(this._container, i2, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = t.e(Object.create(ws2), e2);
          }
          addTo(e2) {
            return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e2) {
            return this._lngLat = t.V.convert(e2), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(e2) {
            return this.setDOMContent(document.createTextNode(e2));
          }
          setHTML(e2) {
            const t2 = document.createDocumentFragment(), i2 = document.createElement("body");
            let a2;
            for (i2.innerHTML = e2; a2 = i2.firstChild, a2; ) t2.appendChild(a2);
            return this.setDOMContent(t2);
          }
          getMaxWidth() {
            var e2;
            return null === (e2 = this._container) || void 0 === e2 ? void 0 : e2.style.maxWidth;
          }
          setMaxWidth(e2) {
            return this.options.maxWidth = e2, this._update(), this;
          }
          setDOMContent(e2) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = h.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(e2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(e2) {
            return this._container && this._container.classList.add(e2), this;
          }
          removeClassName(e2) {
            return this._container && this._container.classList.remove(e2), this;
          }
          setOffset(e2) {
            return this.options.offset = e2, this._update(), this;
          }
          toggleClassName(e2) {
            if (this._container) return this._container.classList.toggle(e2);
          }
          setSubpixelPositioning(e2) {
            this.options.subpixelPositioning = e2;
          }
          setPadding(e2) {
            this.options.padding = e2, this._update();
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = h.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const e2 = this._container.querySelector(Ts2);
            e2 && e2.focus();
          }
        }, e.RasterDEMTileSource = Y2, e.RasterTileSource = K2, e.ScaleControl = class {
          constructor(e2) {
            this._onMove = () => {
              bs2(this._map, this._container, this.options);
            }, this.setUnit = (e3) => {
              this.options.unit = e3, bs2(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, xs2), e2);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e2) {
            return this._map = e2, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            h.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, e.ScrollZoomHandler = Bo2, e.Style = ki, e.TerrainControl = class {
          constructor(e2) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = e2;
          }
          onAdd(e2) {
            return this._map = e2, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = h.create("button", "maplibregl-ctrl-terrain", this._container), h.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            h.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, e.TwoFingersTouchPitchHandler = Ro2, e.TwoFingersTouchRotateHandler = So2, e.TwoFingersTouchZoomHandler = Mo2, e.TwoFingersTouchZoomRotateHandler = Uo2, e.VectorTileSource = X, e.VideoSource = ie2, e.addSourceType = (e2, i2) => t._(void 0, void 0, void 0, (function* () {
          if (oe2(e2)) throw new Error(`A source type called "${e2}" already exists.`);
          ((e3, t2) => {
            re2[e3] = t2;
          })(e2, i2);
        })), e.clearPrewarmedResources = function() {
          const e2 = B2;
          e2 && (e2.isPreloaded() && 1 === e2.numActive() ? (e2.release(L2), B2 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, e.createTileMesh = li2, e.getMaxParallelImageRequests = function() {
          return t.c.MAX_PARALLEL_IMAGE_REQUESTS;
        }, e.getRTLTextPluginStatus = function() {
          return ce2().getRTLTextPluginStatus();
        }, e.getVersion = function() {
          return Cs2;
        }, e.getWorkerCount = function() {
          return k2.workerCount;
        }, e.getWorkerUrl = function() {
          return t.c.WORKER_URL;
        }, e.importScriptInWorkers = function(e2) {
          return Z2().broadcast("IS", e2);
        }, e.isTimeFrozen = function() {
          return l.isFrozen();
        }, e.now = c, e.prewarm = function() {
          j2().acquire(L2);
        }, e.restoreNow = function() {
          l.restoreNow();
        }, e.setMaxParallelImageRequests = function(e2) {
          t.c.MAX_PARALLEL_IMAGE_REQUESTS = e2;
        }, e.setNow = function(e2) {
          l.setNow(e2);
        }, e.setRTLTextPlugin = function(e2, t2) {
          return ce2().setRTLTextPlugin(e2, t2);
        }, e.setWorkerCount = function(e2) {
          k2.workerCount = e2;
        }, e.setWorkerUrl = function(e2) {
          t.c.WORKER_URL = e2;
        };
      }));
      var maplibregl$1 = maplibregl;
      return maplibregl$1;
    }));
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err.context = er2;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs
var import_maplibre_gl = __toESM(require_maplibre_gl(), 1);

// node_modules/js-base64/base64.mjs
var version = "3.7.8";
var VERSION = version;
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it2) => new Uint8Array(Array.prototype.slice.call(it2, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc2 = c.charCodeAt(0);
    return cc2 < 128 ? c : cc2 < 2048 ? _fromCC(192 | cc2 >>> 6) + _fromCC(128 | cc2 & 63) : _fromCC(224 | cc2 >>> 12 & 15) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
  } else {
    var cc2 = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc2 >>> 18 & 7) + _fromCC(128 | cc2 >>> 12 & 63) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp2 = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp2 - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, r1, r2;
  let binArray = [];
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    if (r1 === 64) {
      binArray.push(_fromCC(u24 >> 16 & 255));
    } else if (r2 === 64) {
      binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
    } else {
      binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
    }
  }
  return binArray.join("");
};
var _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI,
  encodeURL: encodeURI,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs
var import_events = __toESM(require_events(), 1);

// node_modules/quick-lru/index.js
var QuickLRU = class extends Map {
  #size = 0;
  #cache = /* @__PURE__ */ new Map();
  #oldCache = /* @__PURE__ */ new Map();
  #maxSize;
  #maxAge;
  #onEviction;
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.#maxSize = options.maxSize;
    this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.#onEviction = options.onEviction;
  }
  // For tests.
  get __oldCache() {
    return this.#oldCache;
  }
  #emitEvictions(cache) {
    if (typeof this.#onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache) {
      this.#onEviction(key, item.value);
    }
  }
  #deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.#onEviction === "function") {
        this.#onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  #getOrDeleteIfExpired(key, item) {
    const deleted = this.#deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  #getItemValue(key, item) {
    return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
  }
  #peek(key, cache) {
    const item = cache.get(key);
    return this.#getItemValue(key, item);
  }
  #set(key, value) {
    this.#cache.set(key, value);
    this.#size++;
    if (this.#size >= this.#maxSize) {
      this.#size = 0;
      this.#emitEvictions(this.#oldCache);
      this.#oldCache = this.#cache;
      this.#cache = /* @__PURE__ */ new Map();
    }
  }
  #moveToRecent(key, item) {
    this.#oldCache.delete(key);
    this.#set(key, item);
  }
  *#entriesAscending() {
    for (const item of this.#oldCache) {
      const [key, value] = item;
      if (!this.#cache.has(key)) {
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.#cache) {
      const [key, value] = item;
      const deleted = this.#deleteIfExpired(key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.#cache.has(key)) {
      const item = this.#cache.get(key);
      return this.#getItemValue(key, item);
    }
    if (this.#oldCache.has(key)) {
      const item = this.#oldCache.get(key);
      if (this.#deleteIfExpired(key, item) === false) {
        this.#moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = this.#maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.#cache.has(key)) {
      this.#cache.set(key, {
        value,
        expiry
      });
    } else {
      this.#set(key, { value, expiry });
    }
    return this;
  }
  has(key) {
    if (this.#cache.has(key)) {
      return !this.#deleteIfExpired(key, this.#cache.get(key));
    }
    if (this.#oldCache.has(key)) {
      return !this.#deleteIfExpired(key, this.#oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.#cache.has(key)) {
      return this.#peek(key, this.#cache);
    }
    if (this.#oldCache.has(key)) {
      return this.#peek(key, this.#oldCache);
    }
  }
  expiresIn(key) {
    const item = this.#cache.get(key) ?? this.#oldCache.get(key);
    if (item) {
      return item.expiry ? item.expiry - Date.now() : Number.POSITIVE_INFINITY;
    }
  }
  delete(key) {
    const deleted = this.#cache.delete(key);
    if (deleted) {
      this.#size--;
    }
    return this.#oldCache.delete(key) || deleted;
  }
  clear() {
    this.#cache.clear();
    this.#oldCache.clear();
    this.#size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this.#entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.#cache = new Map(items);
      this.#oldCache = /* @__PURE__ */ new Map();
      this.#size = items.length;
    } else {
      if (removeCount > 0) {
        this.#emitEvictions(items.slice(0, removeCount));
      }
      this.#oldCache = new Map(items.slice(removeCount));
      this.#cache = /* @__PURE__ */ new Map();
      this.#size = 0;
    }
    this.#maxSize = newSize;
  }
  evict(count = 1) {
    const requested = Number(count);
    if (!requested || requested <= 0) {
      return;
    }
    const items = [...this.#entriesAscending()];
    const evictCount = Math.trunc(Math.min(requested, Math.max(items.length - 1, 0)));
    if (evictCount <= 0) {
      return;
    }
    this.#emitEvictions(items.slice(0, evictCount));
    this.#oldCache = new Map(items.slice(evictCount));
    this.#cache = /* @__PURE__ */ new Map();
    this.#size = 0;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.#cache) {
      const [key, value] = item;
      const deleted = this.#deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of this.#oldCache) {
      const [key, value] = item;
      if (!this.#cache.has(key)) {
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.#cache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      const deleted = this.#deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...this.#oldCache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      if (!this.#cache.has(key)) {
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of this.#entriesAscending()) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!this.#size) {
      return this.#oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.#oldCache.keys()) {
      if (!this.#cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this.#size + oldCacheSize, this.#maxSize);
  }
  get maxSize() {
    return this.#maxSize;
  }
  get maxAge() {
    return this.#maxAge;
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return "QuickLRU";
  }
  toString() {
    return `QuickLRU(${this.size}/${this.maxSize})`;
  }
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
};

// node_modules/@maptiler/client/dist/maptiler-client.mjs
function tryGettingFetch() {
  if (typeof self !== "undefined") {
    return fetch.bind(self);
  }
  if (typeof global !== "undefined" && global.fetch) {
    return global.fetch;
  }
  return null;
}
var ClientConfig = class {
  constructor() {
    this._apiKey = "";
    this._fetch = tryGettingFetch();
    this.tileCacheSize = 200;
  }
  /**
   * Set the MapTiler Cloud API key
   */
  set apiKey(k2) {
    this._apiKey = k2;
  }
  /**
   * Get the MapTiler Cloud API key
   */
  get apiKey() {
    return this._apiKey;
  }
  /**
   * Set a the custom fetch function to replace the default one
   */
  set fetch(f2) {
    this._fetch = f2;
  }
  /**
   * Get the fetch fucntion
   */
  get fetch() {
    return this._fetch;
  }
};
var config = new ClientConfig();
var NonISOLanguage = {
  /**
   * Language mode to display the labels in the end user's device language.
   */
  AUTO: {
    code: null,
    flag: "auto",
    name: "Auto",
    latin: false,
    isMode: true,
    geocoding: true
  },
  /**
   * The OSM language using latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,
   * though it can be an handy fallback. This is not to be confused with the "Classical Latin" language, which is available under the tag `.CLASSICAL_LATIN`.
   */
  LATIN: {
    code: "latin",
    flag: "name:latin",
    name: "Latin",
    latin: true,
    isMode: false,
    geocoding: false
  },
  /**
   * The OSM language using non-latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,
   * though it can be an handy fallback.
   */
  NON_LATIN: {
    code: "nonlatin",
    flag: "name:nonlatin",
    name: "Non Latin",
    latin: false,
    isMode: false,
    geocoding: false
  },
  /**
   * Using the local language generaly (but not always) means that every labels of a given region will use the dominant local language.
   */
  LOCAL: {
    code: null,
    flag: "name",
    name: "Local",
    latin: true,
    isMode: false,
    geocoding: false
  }
};
var ISOLanguage = {
  /**
   * Albanian language
   */
  ALBANIAN: {
    code: "sq",
    flag: "name:sq",
    name: "Albanian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Amharic language
   */
  AMHARIC: {
    code: "am",
    flag: "name:am",
    name: "Amharic",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Arabic language (right-to-left script)
   */
  ARABIC: {
    code: "ar",
    flag: "name:ar",
    name: "Arabic",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Armenian language
   */
  ARMENIAN: {
    code: "hy",
    flag: "name:hy",
    name: "Armenian",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Azerbaijani language
   */
  AZERBAIJANI: {
    code: "az",
    flag: "name:az",
    name: "Azerbaijani",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Basque language
   */
  BASQUE: {
    code: "eu",
    flag: "name:eu",
    name: "Basque",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Belarusian langauge
   */
  BELARUSIAN: {
    code: "be",
    flag: "name:be",
    name: "Belarusian",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Bengali language
   */
  BENGALI: {
    code: "bn",
    flag: "name:bn",
    name: "Bengali",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Bosnian language
   */
  BOSNIAN: {
    code: "bs",
    flag: "name:bs",
    name: "Bosnian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Breton language
   */
  BRETON: {
    code: "br",
    flag: "name:br",
    name: "Breton",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Bulgarian language
   */
  BULGARIAN: {
    code: "bg",
    flag: "bg",
    name: "Bulgarian",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Catalan language
   */
  CATALAN: {
    code: "ca",
    flag: "name:ca",
    name: "Catalan",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Chinese language
   */
  CHINESE: {
    code: "zh",
    flag: "name:zh",
    name: "Chinese",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Traditional Chinese language
   */
  TRADITIONAL_CHINESE: {
    code: "zh-Hant",
    flag: "name:zh-Hant",
    name: "Chinese (traditional)",
    latin: false,
    isMode: false,
    geocoding: false
  },
  /**
   * Simplified Chinese language
   */
  SIMPLIFIED_CHINESE: {
    code: "zh-Hans",
    flag: "name:zh-Hans",
    name: "Chinese (simplified)",
    latin: false,
    isMode: false,
    geocoding: false
  },
  /**
   * Corsican language
   */
  CORSICAN: {
    code: "co",
    flag: "name:co",
    name: "Corsican",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Croatian language
   */
  CROATIAN: {
    code: "hr",
    flag: "name:hr",
    name: "Croatian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Czech language
   */
  CZECH: {
    code: "cs",
    flag: "name:cs",
    name: "Czech",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Danish language
   */
  DANISH: {
    code: "da",
    flag: "name:da",
    name: "Danish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Dutch language
   */
  DUTCH: {
    code: "nl",
    flag: "name:nl",
    name: "Dutch",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * German language
   */
  GERMAN: {
    code: "de",
    flag: "name:de",
    name: "German",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Greek language
   */
  GREEK: {
    code: "el",
    flag: "name:el",
    name: "Greek",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * English language
   */
  ENGLISH: {
    code: "en",
    flag: "name:en",
    name: "English",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Esperanto language
   */
  ESPERANTO: {
    code: "eo",
    flag: "name:eo",
    name: "Esperanto",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Estonian language
   */
  ESTONIAN: {
    code: "et",
    flag: "name:et",
    name: "Estonian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Finnish language
   */
  FINNISH: {
    code: "fi",
    flag: "name:fi",
    name: "Finnish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * French language
   */
  FRENCH: {
    code: "fr",
    flag: "name:fr",
    name: "French",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Frisian language
   */
  FRISIAN: {
    code: "fy",
    flag: "name:fy",
    name: "Frisian (West)",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Georgian language
   */
  GEORGIAN: {
    code: "ka",
    flag: "name:ka",
    name: "Georgian",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Hebrew language (right-to-left non-latin script)
   */
  HEBREW: {
    code: "he",
    flag: "name:he",
    name: "Hebrew",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Hindi language
   */
  HINDI: {
    code: "hi",
    flag: "name:hi",
    name: "Hindi",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Hungarian language
   */
  HUNGARIAN: {
    code: "hu",
    flag: "name:hu",
    name: "Hungarian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Icelandic language
   */
  ICELANDIC: {
    code: "is",
    flag: "name:is",
    name: "Icelandic",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Indonesian language
   */
  INDONESIAN: {
    code: "id",
    flag: "name:id",
    name: "Indonesian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Irish language
   */
  IRISH: {
    code: "ga",
    flag: "name:ga",
    name: "Irish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Italian language
   */
  ITALIAN: {
    code: "it",
    flag: "name:it",
    name: "Italian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Japanese language
   */
  JAPANESE: {
    code: "ja",
    flag: "name:ja",
    name: "Japanese",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Japanese language in Hiragana form
   */
  JAPANESE_HIRAGANA: {
    code: "ja-Hira",
    flag: "name:ja-Hira",
    name: "Japanese Hiragana form",
    latin: false,
    isMode: false,
    geocoding: false
  },
  /**
   * Japanese language (latin script)
   */
  JAPANESE_2018: {
    code: "ja-Latn",
    flag: "name:ja-Latn",
    name: "Japanese (Latin 2018)",
    latin: true,
    isMode: false,
    geocoding: false
  },
  /**
   * Japanese language in Kana form (non-latin script)
   */
  JAPANESE_KANA: {
    code: "ja_kana",
    flag: "name:ja_kana",
    name: "Japanese (Kana)",
    latin: false,
    isMode: false,
    geocoding: false
  },
  /**
   * Japanse language, romanized (latin script)
   */
  JAPANESE_LATIN: {
    code: "ja_rm",
    flag: "name:ja_rm",
    name: "Japanese (Latin script)",
    latin: true,
    isMode: false,
    geocoding: false
  },
  /**
   * Kannada language
   */
  KANNADA: {
    code: "kn",
    flag: "name:kn",
    name: "Kannada",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Kazakh language
   */
  KAZAKH: {
    code: "kk",
    flag: "name:kk",
    name: "Kazakh",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Korean language
   */
  KOREAN: {
    code: "ko",
    flag: "name:ko",
    name: "Korean",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Korean language (latin script)
   */
  KOREAN_LATIN: {
    code: "ko-Latn",
    flag: "name:ko-Latn",
    name: "Korean (Latin script)",
    latin: true,
    isMode: false,
    geocoding: false
  },
  /**
   * Kurdish language
   */
  KURDISH: {
    code: "ku",
    flag: "name:ku",
    name: "Kurdish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Classical Latin language
   */
  CLASSICAL_LATIN: {
    code: "la",
    flag: "name:la",
    name: "Latin",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Latvian language
   */
  LATVIAN: {
    code: "lv",
    flag: "name:lv",
    name: "Latvian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Lithuanian language
   */
  LITHUANIAN: {
    code: "lt",
    flag: "name:lt",
    name: "Lithuanian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Luxembourgish language
   */
  LUXEMBOURGISH: {
    code: "lb",
    flag: "name:lb",
    name: "Luxembourgish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Macedonian language
   */
  MACEDONIAN: {
    code: "mk",
    flag: "name:mk",
    name: "Macedonian",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Malayalm language
   */
  MALAYALAM: {
    code: "ml",
    flag: "name:ml",
    name: "Malayalam",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Maltese language
   */
  MALTESE: {
    code: "mt",
    flag: "name:mt",
    name: "Maltese",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Norwegian language
   */
  NORWEGIAN: {
    code: "no",
    flag: "name:no",
    name: "Norwegian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Occitan language
   */
  OCCITAN: {
    code: "oc",
    flag: "name:oc",
    name: "Occitan",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Persian language
   */
  PERSIAN: {
    code: "fa",
    flag: "name:fa",
    name: "Persian",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Polish language
   */
  POLISH: {
    code: "pl",
    flag: "name:pl",
    name: "Polish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Portuguese language
   */
  PORTUGUESE: {
    code: "pt",
    flag: "name:pt",
    name: "Portuguese",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Punjabi language
   */
  PUNJABI: {
    code: "pa",
    flag: "name:pa",
    name: "Punjabi",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Western Punjabi language
   */
  WESTERN_PUNJABI: {
    code: "pnb",
    flag: "name:pnb",
    name: "Western Punjabi",
    latin: false,
    isMode: false,
    geocoding: false
  },
  /**
   * Romanian language
   */
  ROMANIAN: {
    code: "ro",
    flag: "name:ro",
    name: "Romanian",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Romansh language
   */
  ROMANSH: {
    code: "rm",
    flag: "name:rm",
    name: "Romansh",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Russian language
   */
  RUSSIAN: {
    code: "ru",
    flag: "name:ru",
    name: "Russian",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Serbian language (cyrillic script)
   */
  SERBIAN_CYRILLIC: {
    code: "sr",
    flag: "name:sr",
    name: "Serbian (Cyrillic script)",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Serbian language (latin script)
   */
  SERBIAN_LATIN: {
    code: "sr-Latn",
    flag: "name:sr-Latn",
    name: "Serbian (Latin script)",
    latin: true,
    isMode: false,
    geocoding: false
  },
  /**
   * Scottish Gaelic language
   */
  SCOTTISH_GAELIC: {
    code: "gd",
    flag: "name:gd",
    name: "Scottish Gaelic",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Slovak language
   */
  SLOVAK: {
    code: "sk",
    flag: "name:sk",
    name: "Slovak",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Slovene language
   */
  SLOVENE: {
    code: "sl",
    flag: "name:sl",
    name: "Slovene",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Spanish language
   */
  SPANISH: {
    code: "es",
    flag: "name:es",
    name: "Spanish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Swedish language
   */
  SWEDISH: {
    code: "sv",
    flag: "name:sv",
    name: "Swedish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Tamil language
   */
  TAMIL: {
    code: "ta",
    flag: "name:ta",
    name: "Tamil",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Telugu language
   */
  TELUGU: {
    code: "te",
    flag: "name:te",
    name: "Telugu",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Thai language
   */
  THAI: {
    code: "th",
    flag: "name:th",
    name: "Thai",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Turkish language
   */
  TURKISH: {
    code: "tr",
    flag: "name:tr",
    name: "Turkish",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Ukrainian language
   */
  UKRAINIAN: {
    code: "uk",
    flag: "name:uk",
    name: "Ukrainian",
    latin: false,
    isMode: false,
    geocoding: true
  },
  /**
   * Vietnamese language (latin script)
   */
  VIETNAMESE: {
    code: "vi",
    flag: "name:vi",
    name: "Vietnamese (Latin script)",
    latin: true,
    isMode: false,
    geocoding: true
  },
  /**
   * Welsh language
   */
  WELSH: {
    code: "cy",
    flag: "name:cy",
    name: "Welsh",
    latin: true,
    isMode: false,
    geocoding: true
  }
};
var Language = {
  ...NonISOLanguage,
  ...ISOLanguage
};
function getLanguageInfoFromKey(languageKey, languageDictionary = Language) {
  if (languageKey in languageDictionary) {
    return languageKey[languageKey];
  }
  return null;
}
function getLanguageInfoFromCode(languageCode, languageDictionary = Language) {
  for (const lang of Object.values(languageDictionary)) {
    if (lang.code === languageCode) {
      return lang;
    }
  }
  return null;
}
function getLanguageInfoFromFlag(languageFlag, languageDictionary = Language) {
  for (const lang of Object.values(languageDictionary)) {
    if (lang.flag === languageFlag) {
      return lang;
    }
  }
  return null;
}
function getAutoLanguage() {
  if (typeof navigator === "undefined") {
    const code = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];
    const langInfo = getLanguageInfoFromCode(code);
    return langInfo ?? Language.ENGLISH;
  }
  const canditatelangs = Array.from(
    new Set(navigator.languages.map((l) => l.split("-")[0]))
  ).map((code) => getLanguageInfoFromCode(code)).filter((li2) => li2);
  return canditatelangs[0] ?? Language.ENGLISH;
}
function isLanguageInfo(obj) {
  return obj !== null && typeof obj === "object" && "code" in obj && "flag" in obj && "name" in obj && "latin" in obj && "isMode" in obj && "geocoding" in obj && (typeof obj.code === "string" || obj.code === null) && typeof obj.flag === "string" && typeof obj.name === "string" && typeof obj.latin === "boolean" && typeof obj.isMode === "boolean" && typeof obj.geocoding === "boolean";
}
function toLanguageInfo(lang, languageDictionary = Language) {
  if (isLanguageInfo(lang)) {
    return getLanguageInfoFromFlag(lang.flag, languageDictionary);
  }
  if (typeof lang !== "string") {
    return null;
  }
  return getLanguageInfoFromKey(lang, languageDictionary) || getLanguageInfoFromCode(lang, languageDictionary) || getLanguageInfoFromFlag(lang, languageDictionary) || null;
}
function areSameLanguages(langA, langB, languageDictionary = Language) {
  const langAObj = toLanguageInfo(langA, languageDictionary);
  const langBObj = toLanguageInfo(langB, languageDictionary);
  return langAObj && langBObj && langAObj.flag === langBObj.flag;
}
async function callFetch(resource, options = {}) {
  if (config.fetch === null) {
    throw new Error(
      "The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch"
    );
  }
  if (new URL(resource).searchParams.get("key").trim() === "") {
    throw new Error(
      "The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com"
    );
  }
  return config.fetch(resource, options);
}
var defaults = {
  maptilerApiURL: "https://api.maptiler.com/",
  mapStyle: "streets-v2"
};
Object.freeze(defaults);
var ServiceError = class extends Error {
  constructor(res, customMessage = "") {
    super(
      `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`
    );
    this.res = res;
  }
};
var customMessages$4 = {
  400: "Query too long / Invalid parameters",
  403: "Key is missing, invalid or restricted"
};
function addLanguageGeocodingOptions(searchParams, options) {
  const { language } = options;
  if (language === void 0) {
    return;
  }
  const languageCodes = (Array.isArray(language) ? language : [language]).map((elem) => toValidGeocodingLanguageCode(elem)).filter((elem) => elem);
  const languages = Array.from(new Set(languageCodes)).join(",");
  searchParams.set("language", languages);
}
function toValidGeocodingLanguageCode(lang) {
  const langInfo = lang === Language.AUTO.flag ? getAutoLanguage() : typeof lang === "string" ? getLanguageInfoFromCode(lang) : isLanguageInfo(lang) ? lang.flag === Language.AUTO.flag ? getAutoLanguage() : getLanguageInfoFromFlag(lang.flag) : null;
  return langInfo?.geocoding ? langInfo.code : null;
}
function addCommonForwardAndReverseGeocodingOptions(searchParams, options) {
  const { apiKey, limit, types, excludeTypes } = options;
  searchParams.set("key", apiKey ?? config.apiKey);
  if (limit !== void 0) {
    searchParams.set("limit", String(limit));
  }
  if (types !== void 0) {
    searchParams.set("types", types.join(","));
  }
  if (excludeTypes !== void 0) {
    searchParams.set("excludeTypes", String(excludeTypes));
  }
  addLanguageGeocodingOptions(searchParams, options);
}
function addForwardGeocodingOptions(searchParams, options) {
  addCommonForwardAndReverseGeocodingOptions(searchParams, options);
  const { bbox, proximity, country, fuzzyMatch, autocomplete } = options;
  if (bbox !== void 0) {
    searchParams.set("bbox", bbox.join(","));
  }
  if (proximity !== void 0) {
    searchParams.set(
      "proximity",
      proximity === "ip" ? proximity : proximity.join(",")
    );
  }
  if (country !== void 0) {
    searchParams.set("country", country.join(","));
  }
  if (fuzzyMatch !== void 0) {
    searchParams.set("fuzzyMatch", fuzzyMatch ? "true" : "false");
  }
  if (autocomplete !== void 0) {
    searchParams.set("autocomplete", autocomplete ? "true" : "false");
  }
}
async function forward(query, options = {}) {
  if (typeof query !== "string" || query.trim().length === 0) {
    throw new Error("The query must be a non-empty string");
  }
  const endpoint = new URL(
    `geocoding/${encodeURIComponent(query)}.json`,
    defaults.maptilerApiURL
  );
  addForwardGeocodingOptions(endpoint.searchParams, options);
  const res = await callFetch(endpoint.toString());
  if (!res.ok) {
    throw new ServiceError(res, customMessages$4[res.status] ?? "");
  }
  return await res.json();
}
async function reverse(position, options = {}) {
  if (!Array.isArray(position) || position.length < 2) {
    throw new Error("The position must be an array of form [lng, lat].");
  }
  const endpoint = new URL(
    `geocoding/${position[0]},${position[1]}.json`,
    defaults.maptilerApiURL
  );
  addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);
  const res = await callFetch(endpoint.toString());
  if (!res.ok) {
    throw new ServiceError(res, customMessages$4[res.status] ?? "");
  }
  return await res.json();
}
async function byId(id2, options = {}) {
  const endpoint = new URL(`geocoding/${id2}.json`, defaults.maptilerApiURL);
  endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
  addLanguageGeocodingOptions(endpoint.searchParams, options);
  const res = await callFetch(endpoint.toString());
  if (!res.ok) {
    throw new ServiceError(res, customMessages$4[res.status] ?? "");
  }
  return await res.json();
}
async function batch$1(queries, options = {}) {
  if (!queries.length) {
    return [];
  }
  const joinedQuery = queries.map((query) => encodeURIComponent(query)).join(";");
  const endpoint = new URL(
    `geocoding/${joinedQuery}.json`,
    defaults.maptilerApiURL
  );
  addForwardGeocodingOptions(endpoint.searchParams, options);
  const res = await callFetch(endpoint.toString());
  if (!res.ok) {
    throw new ServiceError(res, customMessages$4[res.status] ?? "");
  }
  const obj = await res.json();
  return queries.length === 1 ? [obj] : obj;
}
var geocoding = {
  forward,
  reverse,
  byId,
  batch: batch$1
};
var customMessages$3 = {
  403: "Key is missing, invalid or restricted"
};
async function info(options = {}) {
  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);
  endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
  if ("elevation" in options) {
    endpoint.searchParams.set(
      "elevation",
      options.elevation ? "true" : "false"
    );
  }
  const urlWithParams = endpoint.toString();
  const res = await callFetch(urlWithParams);
  if (!res.ok) {
    throw new ServiceError(
      res,
      res.status in customMessages$3 ? customMessages$3[res.status] : ""
    );
  }
  const obj = await res.json();
  return obj;
}
var geolocation = {
  info
};
var customMessages$2 = {
  403: "Key is missing, invalid or restricted"
};
async function search(query, options = {}) {
  if (typeof query !== "string" || query.trim().length === 0) {
    throw new Error("The query must be a non-empty string");
  }
  const endpoint = new URL(
    `coordinates/search/${query}.json`,
    defaults.maptilerApiURL
  );
  endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
  if ("limit" in options) {
    endpoint.searchParams.set("limit", options.limit.toString());
  }
  if ("transformations" in options) {
    endpoint.searchParams.set(
      "transformations",
      options.transformations.toString()
    );
  }
  if ("exports" in options) {
    endpoint.searchParams.set("exports", options.exports.toString());
  }
  const urlWithParams = endpoint.toString();
  const res = await callFetch(urlWithParams);
  if (!res.ok) {
    throw new ServiceError(
      res,
      res.status in customMessages$2 ? customMessages$2[res.status] : ""
    );
  }
  const obj = await res.json();
  return obj;
}
async function transform(positions, options = {}) {
  const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions]).map((coord) => `${coord[0]},${coord[1]}`).join(";");
  const endpoint = new URL(
    `coordinates/transform/${coordinatesStr}.json`,
    defaults.maptilerApiURL
  );
  endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
  if ("sourceCrs" in options) {
    endpoint.searchParams.set("s_srs", options.sourceCrs.toString());
  }
  if ("targetCrs" in options) {
    endpoint.searchParams.set("t_srs", options.targetCrs.toString());
  }
  if ("operations" in options) {
    endpoint.searchParams.set(
      "ops",
      (Array.isArray(options.operations) ? options.operations : [options.operations]).join("|")
    );
  }
  const urlWithParams = endpoint.toString();
  const res = await callFetch(urlWithParams);
  if (!res.ok) {
    throw new ServiceError(
      res,
      res.status in customMessages$2 ? customMessages$2[res.status] : ""
    );
  }
  const obj = await res.json();
  return obj;
}
var coordinates = {
  search,
  transform
};
var customMessages$1 = {
  403: "Key is missing, invalid or restricted"
};
async function get(dataId, options = {}) {
  if (typeof dataId !== "string" || dataId.trim().length === 0) {
    throw new Error("The data ID must be a non-empty string");
  }
  const endpoint = new URL(
    `data/${encodeURIComponent(dataId)}/features.json`,
    defaults.maptilerApiURL
  );
  endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
  const urlWithParams = endpoint.toString();
  const res = await callFetch(urlWithParams);
  if (!res.ok) {
    throw new ServiceError(
      res,
      res.status in customMessages$1 ? customMessages$1[res.status] : ""
    );
  }
  const obj = await res.json();
  return obj;
}
var data = {
  get
};
function expandMapStyle(style) {
  const maptilerDomainRegex = /^maptiler:\/\/(.*)/;
  let match;
  const trimmed = style.trim();
  let expandedStyle;
  if (trimmed.startsWith("http://") || trimmed.startsWith("https://")) {
    expandedStyle = trimmed;
  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {
    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;
  } else {
    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;
  }
  return expandedStyle;
}
var MapStyleVariant = class {
  constructor(name, variantType, id2, referenceStyle, description, imageURL, deprecated = false, deprecationMessage) {
    this.name = name;
    this.variantType = variantType;
    this.id = id2;
    this.referenceStyle = referenceStyle;
    this.description = description;
    this.imageURL = imageURL;
    this.deprecated = deprecated;
    this.deprecationMessage = deprecationMessage;
  }
  /**
   * Get the human-friendly name
   * @returns
   */
  getName() {
    return this.name;
  }
  getFullName() {
    return `${this.referenceStyle.getName()} ${this.name}`;
  }
  /**
   * Get the variant type (eg. "DEFAULT", "DARK", "PASTEL", etc.)
   * @returns
   */
  getType() {
    return this.variantType;
  }
  /**
   * Get the MapTiler Cloud id
   * @returns
   */
  getId() {
    return this.id;
  }
  /**
   * Get the human-friendly description
   */
  getDescription() {
    return this.description;
  }
  /**
   * Get the reference style this variant belongs to
   * @returns
   */
  getReferenceStyle() {
    return this.referenceStyle;
  }
  /**
   * Check if a variant of a given type exists for _this_ variants
   * (eg. if this is a "DARK", then we can check if there is a "LIGHT" variant of it)
   * @param variantType
   * @returns
   */
  hasVariant(variantType) {
    return this.referenceStyle.hasVariant(variantType);
  }
  /**
   * Retrieve the variant of a given type. If not found, will return the "DEFAULT" variant.
   * (eg. _this_ "DARK" variant does not have any "PASTEL" variant, then the "DEFAULT" is returned)
   * @param variantType
   * @returns
   */
  getVariant(variantType) {
    const variant = this.referenceStyle.getVariant(variantType);
    this.warnIfDeprecated(variant);
    return variant;
  }
  /**
   * Get all the variants for _this_ variants, except _this_ current one
   * @returns
   */
  getVariants() {
    return this.referenceStyle.getVariants().filter((v) => v !== this).map((v) => {
      this.warnIfDeprecated(v);
      return v;
    });
  }
  /**
   * Get the image URL that represent _this_ variant
   * @returns
   */
  getImageURL() {
    return this.imageURL;
  }
  /**
   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)
   * @returns
   */
  getExpandedStyleURL() {
    return expandMapStyle(this.getId());
  }
  warnIfDeprecated(variant = this) {
    if (!variant.deprecated) return variant;
    if (variant.deprecationMessage) {
      console.warn(variant.deprecationMessage);
    } else {
      const name = variant.getFullName();
      console.warn(
        `Style "${name}" is deprecated and will be removed in a future version.`
      );
    }
    return variant;
  }
};
var ReferenceMapStyle = class {
  constructor(name, id2) {
    this.name = name;
    this.id = id2;
    this.variants = {};
    this.orderedVariants = [];
  }
  /**
   * Get the human-friendly name of this reference style
   * @returns
   */
  getName() {
    return this.name;
  }
  /**
   * Get the id of _this_ reference style
   * @returns
   */
  getId() {
    return this.id;
  }
  /**
   * Add a variant to _this_ reference style
   * @param v
   */
  addVariant(v) {
    this.variants[v.getType()] = v;
    this.orderedVariants.push(v);
  }
  /**
   * Check if a given variant type exists for this reference style
   * @param variantType
   * @returns
   */
  hasVariant(variantType) {
    return variantType in this.variants;
  }
  /**
   * Get a given variant. If the given type of variant does not exist for this reference style,
   * then the most relevant default variant is returned instead
   * @param variantType
   * @returns
   */
  getVariant(variantType) {
    return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];
  }
  /**
   * Get the list of variants for this reference style
   * @returns
   */
  getVariants() {
    return Object.values(this.variants);
  }
  /**
   * Get the defualt variant for this reference style
   * @returns
   */
  getDefaultVariant() {
    return this.orderedVariants[0].warnIfDeprecated();
  }
};
var MAP_STYLE_CONFIG = [
  {
    referenceStyleID: "STREETS_V2",
    name: "Streets",
    description: "",
    variants: [
      {
        id: "streets-v2",
        name: "Default v2",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"streets-v2" is deprecated, use "streets-v4" instead`
      },
      {
        id: "streets-v2-dark",
        name: "Dark v2",
        variantType: "DARK",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"streets-v2-dark" is deprecated, use "streets-v4-dark" instead`
      },
      {
        id: "streets-v2-light",
        name: "Light v2",
        variantType: "LIGHT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"streets-v2-light" is deprecated, use "streets-v4-light" instead`
      },
      {
        id: "streets-v2-night",
        name: "Night v2",
        variantType: "NIGHT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"streets-v2-night" is deprecated, use "streets-v4-night" instead`
      },
      {
        id: "streets-v2-pastel",
        name: "Pastel v2",
        variantType: "PASTEL",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"streets-v2-pastel" is deprecated, use "streets-v4-pastel" instead`
      }
    ]
  },
  {
    referenceStyleID: "STREETS_V4",
    name: "Streets",
    description: "",
    variants: [
      {
        id: "streets-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "streets-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "streets-v4-pastel",
        name: "Pastel",
        variantType: "PASTEL",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "BASE_V4",
    name: "Base",
    description: "",
    variants: [
      {
        id: "base-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "base-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "base-v4-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      },
      {
        id: "base-v4-ai",
        name: "Base AI",
        variantType: "AI",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "OUTDOOR",
    name: "Outdoor",
    description: "",
    variants: [
      {
        id: "outdoor-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"outdoor-v2" is deprecated, use "outdoor-v4" instead`
      },
      {
        id: "outdoor-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"outdoor-v2-dark" is deprecated, use "outdoor-v4-dark" instead`
      }
    ]
  },
  {
    referenceStyleID: "WINTER_V2",
    name: "Winter",
    description: "",
    variants: [
      {
        id: "winter-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
        // this is not deprecated yet...
        // deprecated: true,
        // deprecationMessage: `"winter-v2" is deprecated, use "winter-v4" instead`,
      },
      {
        id: "winter-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
        // this is not deprecated yet...
        // deprecated: true,
        // deprecationMessage: `"winter-v2-dark" is deprecated, use "winter-v4-dark" instead`,
      }
    ]
  },
  {
    referenceStyleID: "WINTER_V4",
    name: "Winter",
    description: "",
    variants: [
      {
        id: "winter-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "winter-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "SATELLITE_V2",
    name: "Satellite",
    description: "",
    variants: [
      {
        id: "satellite",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"satellite" is deprecated, use "satellite-v4" instead`
      }
    ]
  },
  {
    referenceStyleID: "HYBRID_V2",
    name: "Hybrid",
    description: "",
    variants: [
      {
        id: "hybrid",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "HYBRID_V4",
    name: "Hybrid",
    description: "",
    variants: [
      {
        id: "hybrid-v4",
        name: "Default",
        variantType: "DEFAULT",
        imageURL: ""
      },
      {
        id: "hybrid-v4-dark",
        name: "Dark",
        variantType: "DARK",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "BASIC_V2",
    name: "Basic",
    description: "",
    variants: [
      {
        id: "basic-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"basic-v2" is deprecated, use "base-v4" instead`
      },
      {
        id: "basic-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: "",
        deprecationMessage: `"basic-v2" is deprecated, use "base-v4" instead`
      },
      {
        id: "basic-v2-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"basic-v2" is deprecated, use "base-v4" instead`
      }
    ]
  },
  {
    referenceStyleID: "BRIGHT",
    name: "Bright",
    description: "",
    variants: [
      {
        id: "bright-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "bright-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "bright-v2-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      },
      {
        id: "bright-v2-pastel",
        name: "Pastel",
        variantType: "PASTEL",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "OPENSTREETMAP_V2",
    name: "OpenStreetMap",
    description: "",
    variants: [
      {
        id: "openstreetmap",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "openstreetmap-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "TOPO_V2",
    name: "Topo",
    description: "",
    variants: [
      {
        id: "topo-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"topo-v2" is deprecated, use "topo-v4" instead`
      },
      {
        id: "topo-v2-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"topo-v2-dark" is deprecated, use "topo-v4-dark" instead`
      },
      {
        id: "topo-v2-shiny",
        name: "Shiny",
        variantType: "SHINY",
        description: "",
        imageURL: "",
        deprecated: true
      },
      {
        id: "topo-v2-pastel",
        name: "Pastel",
        variantType: "PASTEL",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"topo-v2-pastel" is deprecated, use "topo-v4-pastel" instead`
      },
      {
        id: "topo-v2-topographique",
        name: "Topographique",
        variantType: "TOPOGRAPHIQUE",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"topo-v2-topographique" is deprecated, use "topo-v4-topographique" instead`
      }
    ]
  },
  {
    referenceStyleID: "VOYAGER_V2",
    name: "Voyager",
    description: "",
    variants: [
      {
        id: "voyager-v2",
        name: "Default",
        deprecated: true,
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "voyager-v2-darkmatter",
        name: "Darkmatter",
        deprecated: true,
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "voyager-v2-positron",
        name: "Positron",
        deprecated: true,
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      },
      {
        id: "voyager-v2-vintage",
        name: "Vintage",
        deprecated: true,
        variantType: "VINTAGE",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "TONER_V2",
    name: "Toner",
    description: "",
    deprecated: true,
    deprecationMessage: `"toner-v2" is deprecated, and will be no longer be a default style in the future`,
    variants: [
      {
        id: "toner-v2",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"toner-v2" is deprecated, and may be removed in future versions.`
      },
      {
        id: "toner-v2-background",
        name: "Background",
        variantType: "BACKGROUND",
        deprecated: true,
        description: "",
        imageURL: "",
        deprecationMessage: `"toner-v2-background" is deprecated, and may be removed in future versions.`
      },
      {
        id: "toner-v2-lite",
        name: "Lite",
        variantType: "LITE",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"toner-v2-lite" is deprecated, and may be removed in future versions.`
      },
      {
        id: "toner-v2-lines",
        name: "Lines",
        variantType: "LINES",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"toner-v2-lines" is deprecated, and may be removed in future versions.`
      }
    ]
  },
  {
    referenceStyleID: "DATAVIZ_V2",
    name: "Dataviz",
    description: "",
    variants: [
      {
        id: "dataviz",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"dataviz" is deprecated, use "dataviz-v4" instead`
      },
      {
        id: "dataviz-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"dataviz-dark" is deprecated, use "dataviz-v4-dark" instead`
      },
      {
        id: "dataviz-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"dataviz-light" is deprecated, use "dataviz-v4-light" instead`
      }
    ]
  },
  {
    referenceStyleID: "BACKDROP_V2",
    name: "Backdrop",
    description: "",
    variants: [
      {
        id: "backdrop",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"backdrop" is deprecated, use "backdrop-v4" instead`
      },
      {
        id: "backdrop-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"backdrop-dark" is deprecated, use "backdrop-v4-dark" instead`
      },
      {
        id: "backdrop-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"backdrop-light" is deprecated, use "backdrop-v4-light" instead`
      }
    ]
  },
  {
    referenceStyleID: "OCEAN_V2",
    name: "Ocean",
    description: "",
    variants: [
      {
        id: "ocean",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"ocean" is deprecated, use "ocean-v4" instead`
      }
    ]
  },
  {
    referenceStyleID: "AQUARELLE_V2",
    name: "Aquarelle",
    description: "Watercolor map for creative use",
    variants: [
      {
        id: "aquarelle",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"aquarelle" is deprecated, use "aquarelle-v4" instead`
      },
      {
        id: "aquarelle-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"aquarelle-dark" is deprecated, use "aquarelle-v4-dark" instead`
      },
      {
        id: "aquarelle-vivid",
        name: "Vivid",
        variantType: "VIVID",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"aquarelle-vivid" is deprecated, use "aquarelle-v4-vivid" instead`
      }
    ]
  },
  {
    referenceStyleID: "LANDSCAPE_V2",
    name: "Landscape",
    description: "Terrain map for data overlays and visualisations",
    variants: [
      {
        id: "landscape",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"landscape" is deprecated, use "landscape-v4" instead`
      },
      {
        id: "landscape-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"landscape-dark" is deprecated, use "landscape-v4-dark" instead`
      },
      {
        id: "landscape-vivid",
        name: "Vivid",
        variantType: "VIVID",
        description: "",
        imageURL: "",
        deprecated: true,
        deprecationMessage: `"landscape-vivid" is deprecated, use "landscape-v4-vivid" instead`
      }
    ]
  },
  {
    referenceStyleID: "LANDSCAPE_V4",
    name: "Landscape",
    description: "Terrain map for data overlays and visualisations",
    variants: [
      {
        id: "landscape-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "landscape-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "landscape-v4-vivid",
        name: "Vivid",
        variantType: "VIVID",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "SATELLITE_V4",
    name: "Satellite v4",
    description: "",
    variants: [
      {
        id: "satellite-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "satellite-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "DATAVIZ_V4",
    name: "Dataviz",
    description: "",
    variants: [
      {
        id: "dataviz-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "dataviz-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "dataviz-v4-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "OUTDOOR_V4",
    name: "Outdoor",
    description: "",
    variants: [
      {
        id: "outdoor-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "outdoor-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "BACKDROP_V4",
    name: "Backdrop",
    description: "",
    variants: [
      {
        id: "backdrop-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "backdrop-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "backdrop-v4-light",
        name: "Light",
        variantType: "LIGHT",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "AQUARELLE_V4",
    name: "Aquarelle",
    description: "Watercolor map for creative use",
    variants: [
      {
        id: "aquarelle-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "aquarelle-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "aquarelle-v4-vivid",
        name: "Vivid",
        variantType: "VIVID",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "OCEAN_V4",
    name: "Ocean",
    description: "",
    variants: [
      {
        id: "ocean-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "ocean-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      }
    ]
  },
  {
    referenceStyleID: "TOPO_V4",
    name: "Topo",
    description: "",
    variants: [
      {
        id: "topo-v4",
        name: "Default",
        variantType: "DEFAULT",
        description: "",
        imageURL: ""
      },
      {
        id: "topo-v4-dark",
        name: "Dark",
        variantType: "DARK",
        description: "",
        imageURL: ""
      },
      {
        id: "topo-v4-pastel",
        name: "Pastel",
        variantType: "PASTEL",
        description: "",
        imageURL: ""
      },
      {
        id: "topo-v4-topographique",
        name: "Topographique",
        variantType: "TOPOGRAPHIQUE",
        description: "",
        imageURL: ""
      }
    ]
  }
];
var defaultReferenceStyleMap = {
  STREETS: "STREETS_V2",
  BASIC: "BASIC_V2",
  LANDSCAPE: "LANDSCAPE_V2",
  AQUARELLE: "AQUARELLE_V2",
  SATELLITE: "SATELLITE_V2",
  WINTER: "WINTER_V2",
  HYBRID: "HYBRID_V2",
  OCEAN: "OCEAN_V2",
  TONER: "TONER_V2",
  TOPO: "TOPO_V2",
  OPENSTREETMAP: "OPENSTREETMAP_V2",
  DATAVIZ: "DATAVIZ_V2",
  BACKDROP: "BACKDROP_V2",
  VOYAGER: "VOYAGER_V2"
};
var mapStylePresetList = [
  ...MAP_STYLE_CONFIG
];
function applyVersionToDefaultReferenceStyle(defaultKey, referenceKey) {
  if (mapStylePresetList.find((style) => style.referenceStyleID === defaultKey)) {
    console.warn(
      `Default reference style ${defaultKey} already exists, it will be overwritten...`
    );
  }
  const versionedMapStyle = mapStylePresetList.find(
    (style) => style.referenceStyleID === referenceKey
  );
  if (!versionedMapStyle) {
    throw new Error(
      `Versioned map style not found for reference style: ${referenceKey}`
    );
  }
  const defaultStyle = {
    ...versionedMapStyle,
    referenceStyleID: defaultKey
  };
  mapStylePresetList.push(defaultStyle);
}
Object.entries(defaultReferenceStyleMap).forEach(
  ([defaultKey, referenceKey]) => {
    applyVersionToDefaultReferenceStyle(defaultKey, referenceKey);
  }
);
function makeReferenceStyleProxy(referenceStyle) {
  return new Proxy(referenceStyle, {
    get(target, prop, receiver) {
      if (target.hasVariant(prop)) {
        return target.getVariant(prop);
      }
      if (prop.toString().toUpperCase() === prop) {
        return referenceStyle.getDefaultVariant();
      }
      const style = Reflect.get(target, prop, receiver);
      return style;
    }
  });
}
function buildMapStyles() {
  const mapStyle = {};
  for (let i = 0; i < mapStylePresetList.length; i += 1) {
    const refStyleInfo = mapStylePresetList[i];
    const refStyle = makeReferenceStyleProxy(
      new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID)
    );
    for (let j2 = 0; j2 < refStyleInfo.variants.length; j2 += 1) {
      const variantInfo = refStyleInfo.variants[j2];
      const variant = new MapStyleVariant(
        variantInfo.name,
        // name
        variantInfo.variantType,
        // variantType
        variantInfo.id,
        // id
        refStyle,
        // referenceStyle
        variantInfo.description,
        variantInfo.imageURL,
        // imageURL
        variantInfo.deprecated
        // deprecated
      );
      refStyle.addVariant(variant);
    }
    mapStyle[refStyleInfo.referenceStyleID] = refStyle;
  }
  return mapStyle;
}
function styleToStyle(style) {
  if (!style) {
    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();
  }
  if (typeof style === "string" || style instanceof String) {
    return style.trim().toLowerCase();
  }
  if (style instanceof MapStyleVariant) {
    return style.getId();
  }
  if (style instanceof ReferenceMapStyle) {
    return style.getDefaultVariant().getId();
  }
}
var MapStyle = buildMapStyles();
function extractLineStrings(geoJson) {
  const lineStrings = [];
  function extractFromGeometry(geometry) {
    if (geometry.type === "LineString" || geometry.type === "MultiLineString") {
      lineStrings.push(geometry);
    }
  }
  function extractFromFeature(feature) {
    if (feature.geometry) {
      extractFromGeometry(feature.geometry);
    }
  }
  function extractFromFeatureCollection(collection) {
    for (const feature of collection.features) {
      if (feature.type === "Feature") {
        extractFromFeature(feature);
      } else if (feature.type === "FeatureCollection") {
        extractFromFeatureCollection(feature);
      }
    }
  }
  if (geoJson.type === "Feature") {
    extractFromFeature(geoJson);
  } else if (geoJson.type === "FeatureCollection") {
    extractFromFeatureCollection(geoJson);
  } else {
    extractFromGeometry(geoJson);
  }
  return lineStrings;
}
function getSqSegDist(p, p1, p2) {
  let x = p1[0], y2 = p1[1], dx = p2[0] - x, dy = p2[1] - y2;
  if (dx !== 0 || dy !== 0) {
    const t = ((p[0] - x) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x = p2[0];
      y2 = p2[1];
    } else if (t > 0) {
      x += dx * t;
      y2 += dy * t;
    }
  }
  dx = p[0] - x;
  dy = p[1] - y2;
  return dx * dx + dy * dy;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
  let maxSqDist = sqTolerance, index;
  for (let i = first + 1; i < last; i++) {
    const sqDist = getSqSegDist(points[i], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index - first > 1) {
      simplifyDPStep(points, first, index, sqTolerance, simplified);
    }
    simplified.push(points[index]);
    if (last - index > 1) {
      simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
  }
}
function simplifyDouglasPeucker(points, sqTolerance) {
  const last = points.length - 1;
  const simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);
  return simplified;
}
function simplify(points, tolerance) {
  if (points.length <= 2) {
    return points;
  }
  const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);
  return simplePoints;
}
var misc = {
  extractLineStrings,
  simplify
};
function staticMapMarkerToString(marker, includeColor = true) {
  let str = `${marker[0]},${marker[1]}`;
  if (marker.length === 3 && includeColor) {
    str += `,${marker[2]}`;
  }
  return str;
}
function simplifyAndStringify(path, maxNbChar = 3e3) {
  let str = path.map((point) => point.join(",")).join("|");
  let tolerance = 5e-6;
  const toleranceStep = 1e-5;
  while (str.length > maxNbChar) {
    const simplerPath = misc.simplify(path, tolerance);
    str = simplerPath.map((point) => `${point[0]},${point[1]}`).join("|");
    tolerance += toleranceStep;
  }
  return str;
}
function centered(center, zoom, options = {}) {
  const style = styleToStyle(options.style);
  const scale = options.hiDPI ? "@2x" : "";
  const format = options.format ?? "png";
  let width = ~~(options.width ?? 1024);
  let height = ~~(options.height ?? 1024);
  if (options.hiDPI) {
    width = ~~(width / 2);
    height = ~~(height / 2);
  }
  const endpoint = new URL(
    `maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`,
    defaults.maptilerApiURL
  );
  if ("attribution" in options) {
    endpoint.searchParams.set("attribution", options.attribution.toString());
  }
  if ("markers" in options) {
    let markerStr = "";
    const hasIcon = "markerIcon" in options;
    if (hasIcon) {
      markerStr += `icon:${options.markerIcon}|`;
    }
    if (hasIcon && "markerAnchor" in options) {
      markerStr += `anchor:${options.markerAnchor}|`;
    }
    if (hasIcon && options.hiDPI) {
      markerStr += `scale:2|`;
    }
    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
    endpoint.searchParams.set("markers", markerStr);
  }
  if ("path" in options) {
    let pathStr = "";
    pathStr += `fill:${options.pathFillColor ?? "none"}|`;
    if ("pathStrokeColor" in options) {
      pathStr += `stroke:${options.pathStrokeColor}|`;
    }
    if ("pathWidth" in options) {
      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
      pathStr += `width:${pathWidth.toString()}|`;
    }
    pathStr += simplifyAndStringify(options.path);
    endpoint.searchParams.set("path", pathStr);
  }
  endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
  return endpoint.toString();
}
function bounded(boundingBox, options = {}) {
  const style = styleToStyle(options.style);
  const scale = options.hiDPI ? "@2x" : "";
  const format = options.format ?? "png";
  let width = ~~(options.width ?? 1024);
  let height = ~~(options.height ?? 1024);
  if (options.hiDPI) {
    width = ~~(width / 2);
    height = ~~(height / 2);
  }
  const endpoint = new URL(
    `maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`,
    defaults.maptilerApiURL
  );
  if ("attribution" in options) {
    endpoint.searchParams.set("attribution", options.attribution.toString());
  }
  if ("padding" in options) {
    endpoint.searchParams.set("padding", options.padding.toString());
  }
  if ("markers" in options) {
    let markerStr = "";
    const hasIcon = "markerIcon" in options;
    if (hasIcon) {
      markerStr += `icon:${options.markerIcon}|`;
    }
    if (hasIcon && "markerAnchor" in options) {
      markerStr += `anchor:${options.markerAnchor}|`;
    }
    if (hasIcon && options.hiDPI) {
      markerStr += `scale:2|`;
    }
    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
    endpoint.searchParams.set("markers", markerStr);
  }
  if ("path" in options) {
    let pathStr = "";
    pathStr += `fill:${options.pathFillColor ?? "none"}|`;
    if ("pathStrokeColor" in options) {
      pathStr += `stroke:${options.pathStrokeColor}|`;
    }
    if ("pathWidth" in options) {
      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
      pathStr += `width:${pathWidth.toString()}|`;
    }
    pathStr += simplifyAndStringify(options.path);
    endpoint.searchParams.set("path", pathStr);
  }
  endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
  return endpoint.toString();
}
function automatic(options = {}) {
  if (!("markers" in options) && !("path" in options)) {
    throw new Error(
      "Automatic static maps require markers and/or path to be created."
    );
  }
  const style = styleToStyle(options.style);
  const scale = options.hiDPI ? "@2x" : "";
  const format = options.format ?? "png";
  let width = ~~(options.width ?? 1024);
  let height = ~~(options.height ?? 1024);
  if (options.hiDPI) {
    width = ~~(width / 2);
    height = ~~(height / 2);
  }
  const endpoint = new URL(
    `maps/${encodeURIComponent(
      style
    )}/static/auto/${width}x${height}${scale}.${format}`,
    defaults.maptilerApiURL
  );
  if ("attribution" in options) {
    endpoint.searchParams.set("attribution", options.attribution.toString());
  }
  if ("padding" in options) {
    endpoint.searchParams.set("padding", options.padding.toString());
  }
  if ("markers" in options) {
    let markerStr = "";
    const hasIcon = "markerIcon" in options;
    if (hasIcon) {
      markerStr += `icon:${options.markerIcon}|`;
    }
    if (hasIcon && "markerAnchor" in options) {
      markerStr += `anchor:${options.markerAnchor}|`;
    }
    if (hasIcon && options.hiDPI) {
      markerStr += `scale:2|`;
    }
    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];
    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join("|");
    endpoint.searchParams.set("markers", markerStr);
  }
  if ("path" in options) {
    let pathStr = "";
    pathStr += `fill:${options.pathFillColor ?? "none"}|`;
    if ("pathStrokeColor" in options) {
      pathStr += `stroke:${options.pathStrokeColor}|`;
    }
    if ("pathWidth" in options) {
      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
      pathStr += `width:${pathWidth.toString()}|`;
    }
    pathStr += simplifyAndStringify(options.path);
    endpoint.searchParams.set("path", pathStr);
  }
  endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
  return endpoint.toString();
}
var staticMaps = {
  centered,
  bounded,
  automatic
};
var EARTH_RADIUS = 63710088e-1;
var EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
var MAX_VALID_LATITUDE = 85.0511287;
function longitudeToMercatorX(lng) {
  return (180 + lng) / 360;
}
function latitudeToMercatorY(lat) {
  lat = Math.max(Math.min(lat, MAX_VALID_LATITUDE), -MAX_VALID_LATITUDE);
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function wgs84ToMercator(position) {
  const wrappedPos = wrapWgs84(position);
  return [
    longitudeToMercatorX(wrappedPos[0]),
    latitudeToMercatorY(wrappedPos[1])
  ];
}
function mercatorXToLongitude(x) {
  return x * 360 - 180;
}
function mercatorYToLatitude(y2) {
  const y22 = 180 - y2 * 360;
  return 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
}
function mercatorToWgs84(position) {
  return [mercatorXToLongitude(position[0]), mercatorYToLatitude(position[1])];
}
function haversineDistanceWgs84(from, to2) {
  const rad = Math.PI / 180;
  const lat1 = from[1] * rad;
  const lat2 = to2[1] * rad;
  const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((to2[0] - from[0]) * rad);
  const maxMeters = EARTH_RADIUS * Math.acos(Math.min(a, 1));
  return maxMeters;
}
function haversineCumulatedDistanceWgs84(positions) {
  const cumulatedDistance = Array(positions.length);
  cumulatedDistance[0] = 0;
  const l = cumulatedDistance.length;
  for (let i = 1; i < l; i++) {
    cumulatedDistance[i] = haversineDistanceWgs84(positions[i - 1], positions[i]) + cumulatedDistance[i - 1];
  }
  return cumulatedDistance;
}
function wrapWgs84(position) {
  const lng = position[0];
  const lat = position[1];
  const d = 360;
  const w2 = ((lng + 180) % d + d) % d - 180;
  const wrapLong = w2 === -180 ? 180 : w2;
  return [wrapLong, lat];
}
function circumferenceAtLatitude(latitude) {
  return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);
}
function mercatorToTileIndex(position, zoom, strict = true) {
  const numberOfTilePerAxis = 2 ** zoom;
  const fIndex = [
    position[0] * numberOfTilePerAxis,
    position[1] * numberOfTilePerAxis
  ];
  return strict ? [~~fIndex[0], ~~fIndex[1]] : fIndex;
}
function wgs84ToTileIndex(position, zoom, strict = true) {
  const merc = wgs84ToMercator(position);
  return mercatorToTileIndex(merc, zoom, strict);
}
function toRadians(degrees) {
  return degrees * Math.PI / 180;
}
function toDegrees(radians) {
  return radians * 180 / Math.PI;
}
function haversineIntermediateWgs84(pos1, pos2, ratio) {
  const d = haversineDistanceWgs84(pos1, pos2);
  const 1 = toRadians(pos1[0]);
  const 1 = toRadians(pos1[1]);
  const 2 = toRadians(pos2[0]);
  const 2 = toRadians(pos2[1]);
  const  = d / EARTH_RADIUS;
  const a = Math.sin((1 - ratio) * ) / Math.sin();
  const b = Math.sin(ratio * ) / Math.sin();
  const x = a * Math.cos(1) * Math.cos(1) + b * Math.cos(2) * Math.cos(2);
  const y2 = a * Math.cos(1) * Math.sin(1) + b * Math.cos(2) * Math.sin(2);
  const z2 = a * Math.sin(1) + b * Math.sin(2);
  const 3 = Math.atan2(z2, Math.sqrt(x * x + y2 * y2));
  const 3 = Math.atan2(y2, x);
  return [toDegrees(3), toDegrees(3)];
}
var math = {
  EARTH_RADIUS,
  EARTH_CIRCUMFERENCE,
  longitudeToMercatorX,
  latitudeToMercatorY,
  wgs84ToMercator,
  mercatorXToLongitude,
  mercatorYToLatitude,
  mercatorToWgs84,
  haversineDistanceWgs84,
  wrapWgs84,
  circumferenceAtLatitude,
  mercatorToTileIndex,
  wgs84ToTileIndex,
  toRadians,
  toDegrees,
  haversineIntermediateWgs84,
  haversineCumulatedDistanceWgs84
};
var tileCache = null;
function getTileCache() {
  if (!tileCache) {
    tileCache = new QuickLRU({ maxSize: config.tileCacheSize });
  }
  return tileCache;
}
async function bufferToPixelDataBrowser(buff) {
  const blob = new Blob([buff]);
  const imageBitmap = await createImageBitmap(blob);
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = imageBitmap.width;
  canvas.height = imageBitmap.height;
  ctx.drawImage(imageBitmap, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  return {
    pixels: imageData.data,
    width: canvas.width,
    height: canvas.height,
    components: imageData.data.length / (canvas.width * canvas.height)
  };
}
function getBufferToPixelDataParser() {
  if (config.bufferToPixelData) {
    return config.bufferToPixelData;
  }
  if (typeof window !== "undefined") {
    return bufferToPixelDataBrowser;
  }
  throw new Error(
    "An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`"
  );
}
function canParsePixelData() {
  return !!config.bufferToPixelData || typeof window !== "undefined";
}
var TERRAIN_TILESET = "terrain-rgb-v2";
var API_BATCH_SIZE = 50;
var API_WARN_SIZE = 1e3;
var terrainTileJson = null;
var customMessages = {
  403: "Key is missing, invalid or restricted"
};
async function computeOnServer(positions, apiKey) {
  if (positions.length > API_WARN_SIZE) {
    console.warn(
      "Computing elevation for complex geometries is discouraged - simplify the geometry before proceeding"
    );
  }
  const parts = Math.ceil(positions.length / API_BATCH_SIZE);
  const respPromises = Array.from({ length: parts }, () => null).map(
    (_2, part) => {
      const startPos = part * API_BATCH_SIZE;
      const batch2 = positions.slice(startPos, startPos + API_BATCH_SIZE);
      const batchEncoded = batch2.map((pos) => pos.join(",")).join(";");
      const endpoint = new URL(
        `elevation/${batchEncoded}.json`,
        defaults.maptilerApiURL
      );
      endpoint.searchParams.set("key", apiKey);
      return callFetch(endpoint.toString());
    }
  );
  const resps = await Promise.allSettled(respPromises);
  const jsons = await Promise.all(
    resps.map(async (resp) => {
      if (resp.status === "rejected") {
        throw new Error(
          `Some segments could not be fetched, error: ${resp.reason}`
        );
      }
      if (!resp.value.ok) {
        throw new Error(
          `Some segments could not be fetched, response: ${resp.value.status} ${await resp.value.text()}, url: ${resp.value.url}`
        );
      }
      return resp.value.json();
    })
  );
  return jsons.flat();
}
async function computeOnClient(positions, apiKey, zoom) {
  if (!terrainTileJson) {
    const endpoint = new URL(
      `tiles/${TERRAIN_TILESET}/tiles.json`,
      defaults.maptilerApiURL
    );
    endpoint.searchParams.set("key", apiKey);
    const urlWithParams = endpoint.toString();
    const res = await callFetch(urlWithParams);
    if (res.ok) {
      terrainTileJson = await res.json();
    } else {
      throw new ServiceError(res, customMessages[res.status] ?? "");
    }
  }
  const tileParser = getBufferToPixelDataParser();
  const tileURLSchema = terrainTileJson.tiles[0];
  const cache = getTileCache();
  const maxZoom = terrainTileJson.maxzoom;
  let usedZoom = ~~(zoom ?? maxZoom);
  if (usedZoom > maxZoom || usedZoom < 0) {
    usedZoom = maxZoom;
  }
  const tileIndicesFloats = positions.map(
    (position) => math.wgs84ToTileIndex(position, usedZoom, false)
  );
  const tileIndicesInteger = tileIndicesFloats.map((index) => [
    ~~index[0],
    ~~index[1]
  ]);
  const tileIDs = tileIndicesInteger.map(
    (index) => `terrain_${usedZoom.toString()}_${index[0].toString()}_${index[1].toString()}`
  );
  const uniqueTilesToFetch = Array.from(
    new Set(tileIDs.filter((tileID) => !cache.has(tileID)))
  ).map((tileID) => tileID.split("_").slice(1));
  const tileURLs = uniqueTilesToFetch.map(
    (zxy) => tileURLSchema.replace("{x}", zxy[1].toString()).replace("{y}", zxy[2].toString()).replace("{z}", zxy[0].toString())
  );
  const promisesFetchTiles = tileURLs.map((url) => callFetch(url));
  const resTiles = await Promise.allSettled(promisesFetchTiles);
  const fulfilledRes = resTiles.map(
    (el2) => el2.status === "fulfilled" ? el2.value : null
  ).filter((res) => res);
  const fulfilledRButNotOkRes = fulfilledRes.filter((res) => !res.ok);
  if (fulfilledRes.length !== promisesFetchTiles.length) {
    throw new Error("Some tiles could not be fetched.");
  }
  if (fulfilledRButNotOkRes.length) {
    throw new ServiceError(
      fulfilledRButNotOkRes[0],
      customMessages[fulfilledRButNotOkRes[0].status] ?? ""
    );
  }
  const tileArrayBuffers = await Promise.all(
    fulfilledRes.map((res) => res.arrayBuffer())
  );
  if (!tileArrayBuffers.every((buff) => buff.byteLength > 0)) {
    throw new Error("Some tiles are not available.");
  }
  const tilePixelDatas = await Promise.all(
    tileArrayBuffers.map((buff) => tileParser(buff))
  );
  tilePixelDatas.forEach((tilePixelData, i) => {
    const zxy = uniqueTilesToFetch[i];
    const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;
    cache.set(tileID, tilePixelData);
  });
  const elevatedPositions = positions.map((position, i) => {
    const tileID = tileIDs[i];
    const tileIndexFloat = tileIndicesFloats[i];
    const tilePixelData = cache.get(tileID);
    const pixelX = Math.min(
      Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)),
      tilePixelData.width - 1
    );
    const pixelY = Math.min(
      Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)),
      tilePixelData.height - 1
    );
    const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;
    const R2 = tilePixelData.pixels[pixelDataIndex];
    const G2 = tilePixelData.pixels[pixelDataIndex + 1];
    const B2 = tilePixelData.pixels[pixelDataIndex + 2];
    const elevation2 = -1e4 + (R2 * 256 * 256 + G2 * 256 + B2) * 0.1;
    return [position[0], position[1], ~~(elevation2 * 1e3) / 1e3];
  });
  return elevatedPositions;
}
async function at(position, options = {}) {
  const elevatedPositions = await batch([position], options);
  return elevatedPositions[0];
}
async function batch(positions, options = {}) {
  if (positions.length === 0) return [];
  const apiKey = options.apiKey ?? config.apiKey;
  const elevatedPositions = options.computeOn === "client" ? await computeOnClient(positions, apiKey, options.zoom) : await computeOnServer(positions, apiKey);
  if (options.smoothingKernelSize) {
    const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;
    const elevations = elevatedPositions.map((pos) => pos[2]);
    const kernelSpan = ~~(kernelSize / 2);
    for (let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1) {
      let sum = 0;
      for (let j2 = 0; j2 < kernelSize; j2 += 1) {
        const elev = elevations[i - kernelSpan + j2];
        sum += elev;
      }
      sum /= kernelSize;
      elevatedPositions[i][2] = sum;
    }
  }
  return elevatedPositions;
}
async function fromLineString(ls2, options = {}) {
  if (ls2.type !== "LineString") {
    throw new Error("The provided object is not a GeoJSON LineString");
  }
  options.computeOn ?? (options.computeOn = canParsePixelData() ? "client" : "server");
  const clone = structuredClone(ls2);
  const elevatedPositions = await batch(clone.coordinates, options);
  clone.coordinates = elevatedPositions;
  return clone;
}
async function fromMultiLineString(ls2, options = {}) {
  if (ls2.type !== "MultiLineString") {
    throw new Error("The provided object is not a GeoJSON MultiLineString");
  }
  options.computeOn ?? (options.computeOn = canParsePixelData() ? "client" : "server");
  const clone = structuredClone(ls2);
  const multiLengths = clone.coordinates.map((poss) => poss.length);
  const flattenPositions = clone.coordinates.flat();
  const flattenPositionsElevated = await batch(flattenPositions, options);
  const result = [];
  let index = 0;
  for (const length of multiLengths) {
    result.push(flattenPositionsElevated.slice(index, index + length));
    index += length;
  }
  clone.coordinates = result;
  return clone;
}
var elevation = {
  at,
  batch,
  fromLineString,
  fromMultiLineString
};

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y2) {
  const lsw = (x & 65535) + (y2 & 65535);
  const msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q2), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version2, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if (namespace?.length !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version2;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL2;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y2, z2) {
  switch (s) {
    case 0:
      return x & y2 ^ ~x & z2;
    case 1:
      return x ^ y2 ^ z2;
    case 2:
      return x & y2 ^ x & z2 ^ y2 & z2;
    case 3:
      return x ^ y2 ^ z2;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M2 = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[i * 64 + j2 * 4] << 24 | bytes[i * 64 + j2 * 4 + 1] << 16 | bytes[i * 64 + j2 * 4 + 2] << 8 | bytes[i * 64 + j2 * 4 + 3];
    }
    M2[i] = arr;
  }
  M2[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N - 1][14] = Math.floor(M2[N - 1][14]);
  M2[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W2 = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W2[t] = M2[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W2[t] = ROTL(W2[t - 3] ^ W2[t - 8] ^ W2[t - 14] ^ W2[t - 16], 1);
    }
    let a = H2[0];
    let b = H2[1];
    let c = H2[2];
    let d = H2[3];
    let e = H2[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T2 = ROTL(a, 5) + f(s, b, c, d) + e + K2[s] + W2[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T2;
    }
    H2[0] = H2[0] + a >>> 0;
    H2[1] = H2[1] + b >>> 0;
    H2[2] = H2[2] + c >>> 0;
    H2[3] = H2[3] + d >>> 0;
    H2[4] = H2[4] + e >>> 0;
  }
  return Uint8Array.of(H2[0] >> 24, H2[0] >> 16, H2[0] >> 8, H2[0], H2[1] >> 24, H2[1] >> 16, H2[1] >> 8, H2[1], H2[2] >> 24, H2[2] >> 16, H2[2] >> 8, H2[2], H2[3] >> 24, H2[3] >> 16, H2[3] >> 8, H2[3], H2[4] >> 24, H2[4] >> 16, H2[4] >> 8, H2[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL2;

// node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs
var Ii = Object.defineProperty;
var Nn = (r) => {
  throw TypeError(r);
};
var _i = (r, e, t) => e in r ? Ii(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var y = (r, e, t) => _i(r, typeof e != "symbol" ? e + "" : e, t);
var Sr = (r, e, t) => e.has(r) || Nn("Cannot " + t);
var L = (r, e, t) => (Sr(r, e, "read from private field"), t ? t.call(r) : e.get(r));
var Y = (r, e, t) => e.has(r) ? Nn("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t);
var J = (r, e, t, n) => (Sr(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t);
var Q = (r, e, t) => (Sr(r, e, "access private method"), t);
(function() {
  typeof window > "u" || (window.requestIdleCallback = window.requestIdleCallback || function(r) {
    const e = Date.now();
    return setTimeout(function() {
      r({
        didTimeout: false,
        timeRemaining: function() {
          return Math.max(0, 50 - (Date.now() - e));
        }
      });
    }, 1);
  }, window.cancelIdleCallback = window.cancelIdleCallback || function(r) {
    clearTimeout(r);
  });
})();
var Ni = class extends import_maplibre_gl.default.Marker {
  addTo(e) {
    return super.addTo(e);
  }
};
var Dp = class extends import_maplibre_gl.default.Popup {
  addTo(e) {
    return super.addTo(e);
  }
};
var Up = class extends import_maplibre_gl.default.Style {
  constructor(e, t = {}) {
    super(e, t);
  }
};
var Bp = class extends import_maplibre_gl.default.CanvasSource {
  onAdd(e) {
    super.onAdd(e);
  }
};
var qp = class extends import_maplibre_gl.default.GeoJSONSource {
  onAdd(e) {
    super.onAdd(e);
  }
};
var Vp = class extends import_maplibre_gl.default.ImageSource {
  onAdd(e) {
    super.onAdd(e);
  }
};
var Gp = class extends import_maplibre_gl.default.RasterTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
};
var Hp = class extends import_maplibre_gl.default.RasterDEMTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
};
var Kp = class extends import_maplibre_gl.default.VectorTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
};
var Zp = class extends import_maplibre_gl.default.VideoSource {
  onAdd(e) {
    super.onAdd(e);
  }
};
var Ya = class extends import_maplibre_gl.default.NavigationControl {
  onAdd(e) {
    return super.onAdd(e);
  }
};
var ji = class extends import_maplibre_gl.default.GeolocateControl {
  onAdd(e) {
    return super.onAdd(e);
  }
};
var Xp = class extends import_maplibre_gl.default.AttributionControl {
  onAdd(e) {
    return super.onAdd(e);
  }
};
var Di = class extends import_maplibre_gl.default.LogoControl {
  onAdd(e) {
    return super.onAdd(e);
  }
};
var Ui = class extends import_maplibre_gl.default.ScaleControl {
  onAdd(e) {
    return super.onAdd(e);
  }
};
var Bi = class extends import_maplibre_gl.default.FullscreenControl {
  onAdd(e) {
    return super.onAdd(e);
  }
};
var Yp = class extends import_maplibre_gl.default.TerrainControl {
  onAdd(e) {
    return super.onAdd(e);
  }
};
var Wp = class extends import_maplibre_gl.default.BoxZoomHandler {
  constructor(e, t) {
    super(e, t);
  }
};
var Jp = class extends import_maplibre_gl.default.ScrollZoomHandler {
  constructor(e, t) {
    super(e, t);
  }
};
var Qp = class extends import_maplibre_gl.default.CooperativeGesturesHandler {
  constructor(e, t) {
    super(e, t);
  }
};
var ef = class extends import_maplibre_gl.default.KeyboardHandler {
  constructor(e) {
    super(e);
  }
};
var tf = class extends import_maplibre_gl.default.TwoFingersTouchPitchHandler {
  constructor(e) {
    super(e);
  }
};
var rf = class extends import_maplibre_gl.default.MapWheelEvent {
  constructor(e, t, n) {
    super(e, t, n);
  }
};
var nf = class extends import_maplibre_gl.default.MapTouchEvent {
  constructor(e, t, n) {
    super(e, t, n);
  }
};
var af = class extends import_maplibre_gl.default.MapMouseEvent {
  constructor(e, t, n, a = {}) {
    super(e, t, n, a);
  }
};
var O = {
  /**
   * Language mode to display labels in both the local language and the language of the visitor's device, concatenated.
   * Note that if those two languages are the same, labels won't be duplicated.
   */
  VISITOR: {
    code: null,
    flag: "visitor",
    name: "Visitor",
    latin: true,
    isMode: true,
    geocoding: false
  },
  /**
   * Language mode to display labels in both the local language and English, concatenated.
   * Note that if those two languages are the same, labels won't be duplicated.
   */
  VISITOR_ENGLISH: {
    code: null,
    flag: "visitor_en",
    name: "Visitor English",
    latin: true,
    isMode: true,
    geocoding: false
  },
  /**
   * Language mode to display labels in a language enforced in the style.
   */
  STYLE: {
    code: null,
    flag: "style",
    name: "Style",
    latin: false,
    isMode: true,
    geocoding: false
  },
  /**
   * Language mode to display labels in a language enforced in the style. The language cannot be further modified.
   */
  STYLE_LOCK: {
    code: null,
    flag: "style_lock",
    name: "Style Lock",
    latin: false,
    isMode: true,
    geocoding: false
  },
  ...Language
};
function Bn() {
  if (typeof navigator > "u") {
    const e = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0], t = getLanguageInfoFromCode(e);
    return t || O.ENGLISH;
  }
  return Array.from(new Set(navigator.languages.map((e) => e.split("-")[0]))).map((e) => getLanguageInfoFromCode(e)).filter((e) => e)[0] ?? O.LOCAL;
}
var W = {
  maptilerLogoURL: "https://api.maptiler.com/resources/logo.svg",
  maptilerURL: "https://www.maptiler.com/",
  maptilerApiHost: "api.maptiler.com",
  telemetryURL: "https://api.maptiler.com/metrics",
  rtlPluginURL: "https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js",
  primaryLanguage: O.STYLE,
  secondaryLanguage: O.LOCAL,
  terrainSourceURL: "https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json",
  terrainSourceId: "maptiler-terrain"
};
Object.freeze(W);
var cn = v4_default();
var qi = class extends import_events.default {
  constructor() {
    super(...arguments);
    y(this, "primaryLanguage", W.primaryLanguage);
    y(this, "secondaryLanguage");
    y(this, "session", true);
    y(this, "caching", true);
    y(this, "telemetry", true);
    y(this, "_unit", "metric");
    y(this, "_apiKey", "");
  }
  /**
   * Set the unit system
   */
  set unit(t) {
    this._unit = t, this.emit("unit", t);
  }
  /**
   * Get the unit system
   */
  get unit() {
    return this._unit;
  }
  /**
   * Set the MapTiler Cloud API key
   */
  set apiKey(t) {
    this._apiKey = t, config.apiKey = t, this.emit("apiKey", t);
  }
  /**
   * Get the MapTiler Cloud API key
   */
  get apiKey() {
    return this._apiKey;
  }
  /**
   * Set a the custom fetch function to replace the default one
   */
  set fetch(t) {
    config.fetch = t;
  }
  /**
   * Get the fetch fucntion
   */
  get fetch() {
    return config.fetch;
  }
};
var j = new qi();
var qn = class extends Di {
  constructor(t = {}) {
    super(t);
    y(this, "logoURL", "");
    y(this, "linkURL", "");
    this.logoURL = t.logoURL ?? W.maptilerLogoURL, this.linkURL = t.linkURL ?? W.maptilerURL;
  }
  onAdd(t) {
    this._map = t, this._compact = this.options.compact ?? false, this._container = window.document.createElement("div"), this._container.className = "maplibregl-ctrl";
    const n = window.document.createElement("a");
    return n.style.backgroundRepeat = "no-repeat", n.style.cursor = "pointer", n.style.display = "block", n.style.height = "23px", n.style.margin = "0 0 -4px -4px", n.style.overflow = "hidden", n.style.width = "88px", n.style.backgroundImage = `url(${this.logoURL})`, n.style.backgroundSize = "100px 30px", n.style.width = "100px", n.style.height = "30px", n.target = "_blank", n.rel = "noopener", n.href = this.linkURL, n.setAttribute("aria-label", "MapTiler logo"), n.setAttribute("rel", "noopener"), this._container.appendChild(n), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
};
var Dr = "localcache_source";
var Ur = "localcache";
var Vi = "maptiler_sdk";
var Gi = 1e3;
var Hi = 100;
var Br = typeof caches < "u";
var { addProtocol: Vn } = import_maplibre_gl.default;
function Ki(r, e) {
  if (Br && j.caching && j.session && r.host === W.maptilerApiHost) {
    if (e === "Source" && r.href.includes("tiles.json"))
      return r.href.replace("https://", `${Dr}://`);
    if (e === "Tile" || e === "Glyphs")
      return r.href.replace("https://", `${Ur}://`);
  }
  return r.href;
}
var Lr;
async function Wa() {
  return Lr || (Lr = await caches.open(Vi)), Lr;
}
var Gn = 0;
async function Zi() {
  const r = await Wa(), e = await r.keys(), t = e.slice(0, Math.max(e.length - Gi, 0));
  for (const n of t)
    r.delete(n);
}
function Xi() {
  Vn(
    Dr,
    async (r, e) => {
      if (!r.url) throw new Error("");
      r.url = r.url.replace(`${Dr}://`, "https://");
      const t = r;
      t.signal = e.signal;
      const n = await fetch(r.url, t), a = await n.json();
      return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${n.headers.get("Last-Modified")}`), {
        data: a,
        cacheControl: n.headers.get("Cache-Control"),
        expires: n.headers.get("Expires")
      };
    }
  ), Vn(Ur, async (r, e) => {
    if (!r.url) throw new Error("");
    r.url = r.url.replace(`${Ur}://`, "https://");
    const t = new URL(r.url), n = new URL(t);
    n.searchParams.delete("mtsid"), n.searchParams.delete("key");
    const a = n.toString(), o = new URL(t);
    o.searchParams.delete("last-modified");
    const i = o.toString(), s = async (f2) => ({
      data: await f2.arrayBuffer(),
      cacheControl: f2.headers.get("Cache-Control"),
      expires: f2.headers.get("Expires")
    }), l = await Wa(), u = await l.match(a);
    if (u)
      return s(u);
    const c = r;
    c.signal = e.signal;
    const p = await fetch(i, c);
    return p.status >= 200 && p.status < 300 && (l.put(a, p.clone()).catch(() => {
    }), ++Gn > Hi && (Zi(), Gn = 0)), s(p);
  });
}
async function Yi(r) {
  if (typeof window > "u") return;
  const e = import_maplibre_gl.default.getRTLTextPluginStatus();
  if (e === "unavailable" || e === "requested")
    try {
      await import_maplibre_gl.default.setRTLTextPlugin(r ?? W.rtlPluginURL, true);
    } catch (t) {
      console.error("Error enabling RTL plugin. It is enabled by default and cannot be unset after. Are you attempting to enable it twice?", t);
    }
}
function Wi(r, e) {
  for (const t of r)
    typeof e[t] == "function" && (e[t] = e[t].bind(e));
}
function Hn(r, e) {
  let t = null;
  try {
    t = new URL(r);
  } catch {
    return {
      url: r
    };
  }
  return t.host === W.maptilerApiHost && (t.searchParams.has("key") || t.searchParams.append("key", j.apiKey), j.session && t.searchParams.append("mtsid", cn)), {
    url: Ki(t, e)
  };
}
function Kn(r) {
  return (e, t) => {
    if (r != null) {
      const n = r(e, t), a = Hn((n == null ? void 0 : n.url) ?? "", t);
      return {
        ...n,
        ...a
      };
    }
    return Hn(e, t);
  };
}
function Ja() {
  return Math.random().toString(36).substring(2);
}
function nr(r) {
  return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi.test(r);
}
function Ji(r) {
  try {
    return JSON.parse(r);
  } catch {
  }
  return null;
}
function Qi() {
  return document.createElement("canvas").getContext("webgl2") ? null : typeof WebGL2RenderingContext < "u" ? "Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed." : "Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.";
}
function es(r) {
  const e = Qi();
  if (!e) return;
  let t = null;
  if (typeof r == "string" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t)
    throw new Error("The Map container must be provided.");
  const n = document.createElement("div");
  throw n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n), new Error(e);
}
function of(r) {
  const e = "The WebGL context was lost.", t = r.getContainer(), n = document.createElement("div");
  n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n);
}
function Zn(r, e) {
  return !(!Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" || e && !r[1].startsWith("name:") || !e && r[1] !== "name");
}
function ts(r, e, t) {
  const n = structuredClone(r), a = (o) => {
    if (typeof o != "string")
      for (let i = 0; i < o.length; i += 1)
        Zn(o[i], t) ? o[i] = structuredClone(e) : a(o[i]);
  };
  return Zn(n, t) ? e : (a(n), n);
}
function rs(r, e) {
  const t = e ? /\{name:\S+\}/ : /\{name\}/;
  return {
    contains: t.test(r),
    exactMatch: new RegExp(`^${t.source}$`).test(r)
  };
}
function ns(r, e, t) {
  const n = t ? /\{name:\S+\}/ : /\{name\}/, a = r.split(n);
  return ["concat", ...a.flatMap((s, l) => l === a.length - 1 ? [s] : [s, e])];
}
function as(r) {
  var n;
  const e = /\{name(?::(?<language>\S+))?\}/g, t = [];
  for (; ; ) {
    const a = e.exec(r);
    if (!a) break;
    const o = ((n = a.groups) == null ? void 0 : n.language) ?? null;
    t.push(o);
  }
  return t;
}
function os(r) {
  return !Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" ? null : r[1].trim() === "name" ? {
    isLanguage: true,
    localization: null
  } : r[1].trim().startsWith("name:") ? {
    isLanguage: true,
    localization: r[1].trim().split(":").pop()
  } : null;
}
function is(r) {
  const e = [], t = structuredClone(r), n = (a) => {
    if (typeof a != "string")
      for (let o = 0; o < a.length; o += 1) {
        const i = os(a[o]);
        i ? e.push(i.localization) : n(a[o]);
      }
  };
  return n([t]), e;
}
function ss(r, e) {
  const t = [];
  for (const o of r) {
    if (o.type !== "symbol")
      continue;
    const i = o, { id: s, layout: l } = i;
    if (!l || !("text-field" in l))
      continue;
    const u = e.getLayoutProperty(s, "text-field");
    if (u)
      if (typeof u == "string") {
        const c = as(u);
        t.push(c);
      } else {
        const c = is(u);
        t.push(c);
      }
  }
  const n = t.flat(), a = {
    unlocalized: 0,
    localized: {}
  };
  for (const o of n)
    o === null ? a.unlocalized += 1 : (o in a.localized || (a.localized[o] = 0), a.localized[o] += 1);
  return a;
}
var ls = 8;
var us = {
  version: {
    required: true,
    type: "enum",
    values: [
      8
    ]
  },
  name: {
    type: "string"
  },
  metadata: {
    type: "*"
  },
  center: {
    type: "array",
    value: "number",
    length: 2
  },
  centerAltitude: {
    type: "number"
  },
  zoom: {
    type: "number"
  },
  bearing: {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees"
  },
  pitch: {
    type: "number",
    default: 0,
    units: "degrees"
  },
  roll: {
    type: "number",
    default: 0,
    units: "degrees"
  },
  state: {
    type: "state",
    default: {}
  },
  light: {
    type: "light"
  },
  sky: {
    type: "sky"
  },
  projection: {
    type: "projection"
  },
  terrain: {
    type: "terrain"
  },
  sources: {
    required: true,
    type: "sources"
  },
  sprite: {
    type: "sprite"
  },
  glyphs: {
    type: "string"
  },
  "font-faces": {
    type: "fontFaces"
  },
  transition: {
    type: "transition"
  },
  layers: {
    required: true,
    type: "array",
    value: "layer"
  }
};
var cs = {
  "*": {
    type: "source"
  }
};
var ps = [
  "source_vector",
  "source_raster",
  "source_raster_dem",
  "source_geojson",
  "source_video",
  "source_image"
];
var fs = {
  type: {
    required: true,
    type: "enum",
    values: {
      vector: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    default: "xyz"
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  attribution: {
    type: "string"
  },
  promoteId: {
    type: "promoteId"
  },
  volatile: {
    type: "boolean",
    default: false
  },
  encoding: {
    type: "enum",
    values: {
      mvt: {},
      mlt: {}
    },
    default: "mvt"
  },
  "*": {
    type: "*"
  }
};
var ds = {
  type: {
    required: true,
    type: "enum",
    values: {
      raster: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels"
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    default: "xyz"
  },
  attribution: {
    type: "string"
  },
  volatile: {
    type: "boolean",
    default: false
  },
  "*": {
    type: "*"
  }
};
var hs = {
  type: {
    required: true,
    type: "enum",
    values: {
      "raster-dem": {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels"
  },
  attribution: {
    type: "string"
  },
  encoding: {
    type: "enum",
    values: {
      terrarium: {},
      mapbox: {},
      custom: {}
    },
    default: "mapbox"
  },
  redFactor: {
    type: "number",
    default: 1
  },
  blueFactor: {
    type: "number",
    default: 1
  },
  greenFactor: {
    type: "number",
    default: 1
  },
  baseShift: {
    type: "number",
    default: 0
  },
  volatile: {
    type: "boolean",
    default: false
  },
  "*": {
    type: "*"
  }
};
var ms = {
  type: {
    required: true,
    type: "enum",
    values: {
      geojson: {}
    }
  },
  data: {
    required: true,
    type: "*"
  },
  maxzoom: {
    type: "number",
    default: 18
  },
  attribution: {
    type: "string"
  },
  buffer: {
    type: "number",
    default: 128,
    maximum: 512,
    minimum: 0
  },
  filter: {
    type: "filter"
  },
  tolerance: {
    type: "number",
    default: 0.375
  },
  cluster: {
    type: "boolean",
    default: false
  },
  clusterRadius: {
    type: "number",
    default: 50,
    minimum: 0
  },
  clusterMaxZoom: {
    type: "number"
  },
  clusterMinPoints: {
    type: "number"
  },
  clusterProperties: {
    type: "*"
  },
  lineMetrics: {
    type: "boolean",
    default: false
  },
  generateId: {
    type: "boolean",
    default: false
  },
  promoteId: {
    type: "promoteId"
  }
};
var ys = {
  type: {
    required: true,
    type: "enum",
    values: {
      video: {}
    }
  },
  urls: {
    required: true,
    type: "array",
    value: "string"
  },
  coordinates: {
    required: true,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
};
var gs = {
  type: {
    required: true,
    type: "enum",
    values: {
      image: {}
    }
  },
  url: {
    required: true,
    type: "string"
  },
  coordinates: {
    required: true,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
};
var vs = {
  id: {
    type: "string",
    required: true
  },
  type: {
    type: "enum",
    values: {
      fill: {},
      line: {},
      symbol: {},
      circle: {},
      heatmap: {},
      "fill-extrusion": {},
      raster: {},
      hillshade: {},
      "color-relief": {},
      background: {}
    },
    required: true
  },
  metadata: {
    type: "*"
  },
  source: {
    type: "string"
  },
  "source-layer": {
    type: "string"
  },
  minzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  maxzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  filter: {
    type: "filter"
  },
  layout: {
    type: "layout"
  },
  paint: {
    type: "paint"
  }
};
var bs = [
  "layout_fill",
  "layout_line",
  "layout_circle",
  "layout_heatmap",
  "layout_fill-extrusion",
  "layout_symbol",
  "layout_raster",
  "layout_hillshade",
  "layout_color-relief",
  "layout_background"
];
var ws = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    expression: {
      interpolated: false,
      parameters: [
        "global-state"
      ]
    },
    "property-type": "data-constant"
  }
};
var Ss = {
  "fill-sort-key": {
    type: "number",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    expression: {
      interpolated: false,
      parameters: [
        "global-state"
      ]
    },
    "property-type": "data-constant"
  }
};
var xs = {
  "circle-sort-key": {
    type: "number",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    expression: {
      interpolated: false,
      parameters: [
        "global-state"
      ]
    },
    "property-type": "data-constant"
  }
};
var ks = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    expression: {
      interpolated: false,
      parameters: [
        "global-state"
      ]
    },
    "property-type": "data-constant"
  }
};
var Ls = {
  "line-cap": {
    type: "enum",
    values: {
      butt: {},
      round: {},
      square: {}
    },
    default: "butt",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-join": {
    type: "enum",
    values: {
      bevel: {},
      round: {},
      miter: {}
    },
    default: "miter",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-miter-limit": {
    type: "number",
    default: 2,
    requires: [
      {
        "line-join": "miter"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-round-limit": {
    type: "number",
    default: 1.05,
    requires: [
      {
        "line-join": "round"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-sort-key": {
    type: "number",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    expression: {
      interpolated: false,
      parameters: [
        "global-state"
      ]
    },
    "property-type": "data-constant"
  }
};
var Es = {
  "symbol-placement": {
    type: "enum",
    values: {
      point: {},
      line: {},
      "line-center": {}
    },
    default: "point",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-spacing": {
    type: "number",
    default: 250,
    minimum: 1,
    units: "pixels",
    requires: [
      {
        "symbol-placement": "line"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-avoid-edges": {
    type: "boolean",
    default: false,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-sort-key": {
    type: "number",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "symbol-z-order": {
    type: "enum",
    values: {
      auto: {},
      "viewport-y": {},
      source: {}
    },
    default: "auto",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-allow-overlap": {
    type: "boolean",
    default: false,
    requires: [
      "icon-image",
      {
        "!": "icon-overlap"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-ignore-placement": {
    type: "boolean",
    default: false,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-optional": {
    type: "boolean",
    default: false,
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-size": {
    type: "number",
    default: 1,
    minimum: 0,
    units: "factor of the original icon size",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-text-fit": {
    type: "enum",
    values: {
      none: {},
      width: {},
      height: {},
      both: {}
    },
    default: "none",
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-text-fit-padding": {
    type: "array",
    value: "number",
    length: 4,
    default: [
      0,
      0,
      0,
      0
    ],
    units: "pixels",
    requires: [
      "icon-image",
      "text-field",
      {
        "icon-text-fit": [
          "both",
          "width",
          "height"
        ]
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-image": {
    type: "resolvedImage",
    tokens: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-padding": {
    type: "padding",
    default: [
      2
    ],
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-keep-upright": {
    type: "boolean",
    default: false,
    requires: [
      "icon-image",
      {
        "icon-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-offset": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    default: "center",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      "viewport-glyph": {},
      auto: {}
    },
    default: "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-field": {
    type: "formatted",
    default: "",
    tokens: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-font": {
    type: "array",
    value: "string",
    default: [
      "Open Sans Regular",
      "Arial Unicode MS Regular"
    ],
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-size": {
    type: "number",
    default: 16,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-width": {
    type: "number",
    default: 10,
    minimum: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-line-height": {
    type: "number",
    default: 1.2,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-letter-spacing": {
    type: "number",
    default: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-justify": {
    type: "enum",
    values: {
      auto: {},
      left: {},
      center: {},
      right: {}
    },
    default: "center",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-radial-offset": {
    type: "number",
    units: "ems",
    default: 0,
    requires: [
      "text-field"
    ],
    "property-type": "data-driven",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    }
  },
  "text-variable-anchor": {
    type: "array",
    value: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-variable-anchor-offset": {
    type: "variableAnchorOffsetCollection",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    default: "center",
    requires: [
      "text-field",
      {
        "!": "text-variable-anchor"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-angle": {
    type: "number",
    default: 45,
    units: "degrees",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-writing-mode": {
    type: "array",
    value: "enum",
    values: {
      horizontal: {},
      vertical: {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-padding": {
    type: "number",
    default: 2,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-keep-upright": {
    type: "boolean",
    default: true,
    requires: [
      "text-field",
      {
        "text-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-transform": {
    type: "enum",
    values: {
      none: {},
      uppercase: {},
      lowercase: {}
    },
    default: "none",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-offset": {
    type: "array",
    value: "number",
    units: "ems",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "text-field",
      {
        "!": "text-radial-offset"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-allow-overlap": {
    type: "boolean",
    default: false,
    requires: [
      "text-field",
      {
        "!": "text-overlap"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-ignore-placement": {
    type: "boolean",
    default: false,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-optional": {
    type: "boolean",
    default: false,
    requires: [
      "text-field",
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    expression: {
      interpolated: false,
      parameters: [
        "global-state"
      ]
    },
    "property-type": "data-constant"
  }
};
var Cs = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    expression: {
      interpolated: false,
      parameters: [
        "global-state"
      ]
    },
    "property-type": "data-constant"
  }
};
var As = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    expression: {
      interpolated: false,
      parameters: [
        "global-state"
      ]
    },
    "property-type": "data-constant"
  }
};
var Ts = {
  type: "boolean",
  expression: {
    interpolated: false,
    parameters: [
      "zoom",
      "feature"
    ]
  },
  "property-type": "data-driven"
};
var Is = {
  type: "enum",
  values: {
    "==": {},
    "!=": {},
    ">": {},
    ">=": {},
    "<": {},
    "<=": {},
    in: {},
    "!in": {},
    all: {},
    any: {},
    none: {},
    has: {},
    "!has": {}
  }
};
var _s = {
  type: "enum",
  values: {
    Point: {},
    LineString: {},
    Polygon: {}
  }
};
var Ms = {
  type: "array",
  minimum: 0,
  maximum: 24,
  value: [
    "number",
    "color"
  ],
  length: 2
};
var Ps = {
  type: "array",
  value: "expression_name",
  minimum: 1
};
var Rs = {
  anchor: {
    type: "enum",
    default: "viewport",
    values: {
      map: {},
      viewport: {}
    },
    "property-type": "data-constant",
    transition: false,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    }
  },
  position: {
    type: "array",
    default: [
      1.15,
      210,
      30
    ],
    length: 3,
    value: "number",
    "property-type": "data-constant",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  intensity: {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  }
};
var Os = {
  "sky-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#88C6FC",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "horizon-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "fog-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "fog-ground-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "horizon-fog-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "sky-horizon-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "atmosphere-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  }
};
var zs = {
  source: {
    type: "string",
    required: true
  },
  exaggeration: {
    type: "number",
    minimum: 0,
    default: 1
  }
};
var Fs = {
  type: {
    type: "projectionDefinition",
    default: "mercator",
    "property-type": "data-constant",
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    }
  }
};
var $s = [
  "paint_fill",
  "paint_line",
  "paint_circle",
  "paint_heatmap",
  "paint_fill-extrusion",
  "paint_symbol",
  "paint_raster",
  "paint_hillshade",
  "paint_color-relief",
  "paint_background"
];
var Ns = {
  "fill-antialias": {
    type: "boolean",
    default: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-color": {
    type: "color",
    default: "#000000",
    transition: true,
    requires: [
      {
        "!": "fill-pattern"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-outline-color": {
    type: "color",
    transition: true,
    requires: [
      {
        "!": "fill-pattern"
      },
      {
        "fill-antialias": true
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "fill-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-pattern": {
    type: "resolvedImage",
    transition: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  }
};
var js = {
  "line-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-color": {
    type: "color",
    default: "#000000",
    transition: true,
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "line-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-width": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-gap-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-offset": {
    type: "number",
    default: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-dasharray": {
    type: "array",
    value: "number",
    minimum: 0,
    transition: true,
    units: "line widths",
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-pattern": {
    type: "resolvedImage",
    transition: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-gradient": {
    type: "color",
    transition: false,
    requires: [
      {
        "!": "line-dasharray"
      },
      {
        "!": "line-pattern"
      },
      {
        source: "geojson",
        has: {
          lineMetrics: true
        }
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "line-progress"
      ]
    },
    "property-type": "color-ramp"
  }
};
var Ds = {
  "circle-radius": {
    type: "number",
    default: 5,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-color": {
    type: "color",
    default: "#000000",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-blur": {
    type: "number",
    default: 0,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "circle-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-scale": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "viewport",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-stroke-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-color": {
    type: "color",
    default: "#000000",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  }
};
var Us = {
  "heatmap-radius": {
    type: "number",
    default: 30,
    minimum: 1,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-weight": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-intensity": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "heatmap-color": {
    type: "color",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "heatmap-density"
      ],
      0,
      "rgba(0, 0, 255, 0)",
      0.1,
      "royalblue",
      0.3,
      "cyan",
      0.5,
      "lime",
      0.7,
      "yellow",
      1,
      "red"
    ],
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "heatmap-density"
      ]
    },
    "property-type": "color-ramp"
  },
  "heatmap-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var Bs = {
  "icon-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-color": {
    type: "color",
    default: "#000000",
    transition: true,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: true,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "icon-image",
      "icon-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-color": {
    type: "color",
    default: "#000000",
    transition: true,
    overridable: true,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: true,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "text-field",
      "text-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var qs = {
  "raster-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-hue-rotate": {
    type: "number",
    default: 0,
    period: 360,
    transition: true,
    units: "degrees",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-min": {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-max": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-saturation": {
    type: "number",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-contrast": {
    type: "number",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-resampling": {
    type: "enum",
    values: {
      linear: {},
      nearest: {}
    },
    default: "linear",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-fade-duration": {
    type: "number",
    default: 300,
    minimum: 0,
    transition: false,
    units: "milliseconds",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var Vs = {
  "hillshade-illumination-direction": {
    type: "numberArray",
    default: 335,
    minimum: 0,
    maximum: 359,
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-altitude": {
    type: "numberArray",
    default: 45,
    minimum: 0,
    maximum: 90,
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "viewport",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-exaggeration": {
    type: "number",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-shadow-color": {
    type: "colorArray",
    default: "#000000",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-highlight-color": {
    type: "colorArray",
    default: "#FFFFFF",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-accent-color": {
    type: "color",
    default: "#000000",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-method": {
    type: "enum",
    values: {
      standard: {},
      basic: {},
      combined: {},
      igor: {},
      multidirectional: {}
    },
    default: "standard",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var Gs = {
  "background-color": {
    type: "color",
    default: "#000000",
    transition: true,
    requires: [
      {
        "!": "background-pattern"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "background-pattern": {
    type: "resolvedImage",
    transition: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "cross-faded"
  },
  "background-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var Hs = {
  duration: {
    type: "number",
    default: 300,
    minimum: 0,
    units: "milliseconds"
  },
  delay: {
    type: "number",
    default: 0,
    minimum: 0,
    units: "milliseconds"
  }
};
var Ks = {
  "*": {
    type: "string"
  }
};
var Zs = {
  type: "array",
  value: "interpolation_name",
  minimum: 1
};
var Xs = {
  type: "enum",
  values: {
    linear: {
      syntax: {
        overloads: [
          {
            parameters: [],
            "output-type": "interpolation"
          }
        ],
        parameters: []
      }
    },
    exponential: {
      syntax: {
        overloads: [
          {
            parameters: [
              "base"
            ],
            "output-type": "interpolation"
          }
        ],
        parameters: [
          {
            name: "base",
            type: "number literal"
          }
        ]
      }
    },
    "cubic-bezier": {
      syntax: {
        overloads: [
          {
            parameters: [
              "x1",
              "y1",
              "x2",
              "y2"
            ],
            "output-type": "interpolation"
          }
        ],
        parameters: [
          {
            name: "x1",
            type: "number literal"
          },
          {
            name: "y1",
            type: "number literal"
          },
          {
            name: "x2",
            type: "number literal"
          },
          {
            name: "y2",
            type: "number literal"
          }
        ]
      }
    }
  }
};
var Ys = {
  $version: ls,
  $root: us,
  sources: cs,
  source: ps,
  source_vector: fs,
  source_raster: ds,
  source_raster_dem: hs,
  source_geojson: ms,
  source_video: ys,
  source_image: gs,
  layer: vs,
  layout: bs,
  layout_background: ws,
  layout_fill: Ss,
  layout_circle: xs,
  layout_heatmap: ks,
  "layout_fill-extrusion": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      expression: {
        interpolated: false,
        parameters: [
          "global-state"
        ]
      },
      "property-type": "data-constant"
    }
  },
  layout_line: Ls,
  layout_symbol: Es,
  layout_raster: Cs,
  layout_hillshade: As,
  "layout_color-relief": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      expression: {
        interpolated: false,
        parameters: [
          "global-state"
        ]
      },
      "property-type": "data-constant"
    }
  },
  filter: Ts,
  filter_operator: Is,
  geometry_type: _s,
  function: {
    expression: {
      type: "expression"
    },
    stops: {
      type: "array",
      value: "function_stop"
    },
    base: {
      type: "number",
      default: 1,
      minimum: 0
    },
    property: {
      type: "string",
      default: "$zoom"
    },
    type: {
      type: "enum",
      values: {
        identity: {},
        exponential: {},
        interval: {},
        categorical: {}
      },
      default: "exponential"
    },
    colorSpace: {
      type: "enum",
      values: {
        rgb: {},
        lab: {},
        hcl: {}
      },
      default: "rgb"
    },
    default: {
      type: "*",
      required: false
    }
  },
  function_stop: Ms,
  expression: Ps,
  light: Rs,
  sky: Os,
  terrain: zs,
  projection: Fs,
  paint: $s,
  paint_fill: Ns,
  "paint_fill-extrusion": {
    "fill-extrusion-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: true,
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-color": {
      type: "color",
      default: "#000000",
      transition: true,
      requires: [
        {
          "!": "fill-extrusion-pattern"
        }
      ],
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: true,
      units: "pixels",
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "fill-extrusion-translate"
      ],
      expression: {
        interpolated: false,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-pattern": {
      type: "resolvedImage",
      transition: true,
      expression: {
        interpolated: false,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "cross-faded-data-driven"
    },
    "fill-extrusion-height": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      transition: true,
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-base": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      transition: true,
      requires: [
        "fill-extrusion-height"
      ],
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-vertical-gradient": {
      type: "boolean",
      default: true,
      transition: false,
      expression: {
        interpolated: false,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  },
  paint_line: js,
  paint_circle: Ds,
  paint_heatmap: Us,
  paint_symbol: Bs,
  paint_raster: qs,
  paint_hillshade: Vs,
  "paint_color-relief": {
    "color-relief-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: true,
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "color-relief-color": {
      type: "color",
      transition: false,
      expression: {
        interpolated: true,
        parameters: [
          "elevation"
        ]
      },
      "property-type": "color-ramp"
    }
  },
  paint_background: Gs,
  transition: Hs,
  "property-type": {
    "data-driven": {
      type: "property-type"
    },
    "cross-faded": {
      type: "property-type"
    },
    "cross-faded-data-driven": {
      type: "property-type"
    },
    "color-ramp": {
      type: "property-type"
    },
    "data-constant": {
      type: "property-type"
    },
    constant: {
      type: "property-type"
    }
  },
  promoteId: Ks,
  interpolation: Zs,
  interpolation_name: Xs
};
var w = class {
  constructor(e, t, n, a) {
    this.message = (e ? `${e}: ` : "") + n, a && (this.identifier = a), t != null && t.__line__ && (this.line = t.__line__);
  }
};
function Ht(r, ...e) {
  for (const t of e)
    for (const n in t)
      r[n] = t[n];
  return r;
}
var ve = class extends Error {
  constructor(e, t) {
    super(t), this.message = t, this.key = e;
  }
};
var pn = class _pn {
  constructor(e, t = []) {
    this.parent = e, this.bindings = {};
    for (const [n, a] of t)
      this.bindings[n] = a;
  }
  concat(e) {
    return new _pn(this, e);
  }
  get(e) {
    if (this.bindings[e])
      return this.bindings[e];
    if (this.parent)
      return this.parent.get(e);
    throw new Error(`${e} not found in scope.`);
  }
  has(e) {
    return this.bindings[e] ? true : this.parent ? this.parent.has(e) : false;
  }
};
var ar = { kind: "null" };
var S = { kind: "number" };
var P = { kind: "string" };
var M = { kind: "boolean" };
var be = { kind: "color" };
var or = {
  kind: "projectionDefinition"
};
var qe = { kind: "object" };
var _ = { kind: "value" };
var Ws = { kind: "error" };
var ir = { kind: "collator" };
var sr = { kind: "formatted" };
var lr = { kind: "padding" };
var gt = { kind: "colorArray" };
var ur = { kind: "numberArray" };
var It = { kind: "resolvedImage" };
var cr = {
  kind: "variableAnchorOffsetCollection"
};
function ae(r, e) {
  return {
    kind: "array",
    itemType: r,
    N: e
  };
}
function D(r) {
  if (r.kind === "array") {
    const e = D(r.itemType);
    return typeof r.N == "number" ? `array<${e}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${e}>`;
  } else
    return r.kind;
}
var Js = [
  ar,
  S,
  P,
  M,
  be,
  or,
  sr,
  qe,
  ae(_),
  lr,
  ur,
  gt,
  It,
  cr
];
function vt(r, e) {
  if (e.kind === "error")
    return null;
  if (r.kind === "array") {
    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !vt(r.itemType, e.itemType)) && (typeof r.N != "number" || r.N === e.N))
      return null;
  } else {
    if (r.kind === e.kind)
      return null;
    if (r.kind === "value") {
      for (const t of Js)
        if (!vt(t, e))
          return null;
    }
  }
  return `Expected ${D(r)} but found ${D(e)} instead.`;
}
function fn(r, e) {
  return e.some((t) => t.kind === r.kind);
}
function Ve(r, e) {
  return e.some((t) => t === "null" ? r === null : t === "array" ? Array.isArray(r) : t === "object" ? r && !Array.isArray(r) && typeof r == "object" : t === typeof r);
}
function Ae(r, e) {
  return r.kind === "array" && e.kind === "array" ? r.itemType.kind === e.itemType.kind && typeof r.N == "number" : r.kind === e.kind;
}
var Qa = 0.96422;
var eo = 1;
var to = 0.82521;
var ro = 4 / 29;
var nt = 6 / 29;
var no = 3 * nt * nt;
var Qs = nt * nt * nt;
var el = Math.PI / 180;
var tl = 180 / Math.PI;
function ao(r) {
  return r = r % 360, r < 0 && (r += 360), r;
}
function oo([r, e, t, n]) {
  r = Er(r), e = Er(e), t = Er(t);
  let a, o;
  const i = Cr((0.2225045 * r + 0.7168786 * e + 0.0606169 * t) / eo);
  r === e && e === t ? a = o = i : (a = Cr((0.4360747 * r + 0.3850649 * e + 0.1430804 * t) / Qa), o = Cr((0.0139322 * r + 0.0971045 * e + 0.7141733 * t) / to));
  const s = 116 * i - 16;
  return [s < 0 ? 0 : s, 500 * (a - i), 200 * (i - o), n];
}
function Er(r) {
  return r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
}
function Cr(r) {
  return r > Qs ? Math.pow(r, 1 / 3) : r / no + ro;
}
function io([r, e, t, n]) {
  let a = (r + 16) / 116, o = isNaN(e) ? a : a + e / 500, i = isNaN(t) ? a : a - t / 200;
  return a = eo * Tr(a), o = Qa * Tr(o), i = to * Tr(i), [
    Ar(3.1338561 * o - 1.6168667 * a - 0.4906146 * i),
    // D50 -> sRGB
    Ar(-0.9787684 * o + 1.9161415 * a + 0.033454 * i),
    Ar(0.0719453 * o - 0.2289914 * a + 1.4052427 * i),
    n
  ];
}
function Ar(r) {
  return r = r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055, r < 0 ? 0 : r > 1 ? 1 : r;
}
function Tr(r) {
  return r > nt ? r * r * r : no * (r - ro);
}
function rl(r) {
  const [e, t, n, a] = oo(r), o = Math.sqrt(t * t + n * n);
  return [Math.round(o * 1e4) ? ao(Math.atan2(n, t) * tl) : NaN, o, e, a];
}
function nl([r, e, t, n]) {
  return r = isNaN(r) ? 0 : r * el, io([t, Math.cos(r) * e, Math.sin(r) * e, n]);
}
function al([r, e, t, n]) {
  r = ao(r), e /= 100, t /= 100;
  function a(o) {
    const i = (o + r / 30) % 12, s = e * Math.min(t, 1 - t);
    return t - s * Math.max(-1, Math.min(i - 3, 9 - i, 1));
  }
  return [a(0), a(8), a(4), n];
}
var ol = Object.hasOwn || function(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
};
function ht(r, e) {
  return ol(r, e) ? r[e] : void 0;
}
function il(r) {
  if (r = r.toLowerCase().trim(), r === "transparent")
    return [0, 0, 0, 0];
  const e = ht(sl, r);
  if (e) {
    const [a, o, i] = e;
    return [a / 255, o / 255, i / 255, 1];
  }
  if (r.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r)) {
    const o = r.length < 6 ? 1 : 2;
    let i = 1;
    return [
      Ot(r.slice(i, i += o)),
      Ot(r.slice(i, i += o)),
      Ot(r.slice(i, i += o)),
      Ot(r.slice(i, i + o) || "ff")
    ];
  }
  if (r.startsWith("rgb")) {
    const a = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, o = r.match(a);
    if (o) {
      const [
        i,
        // eslint-disable-line @typescript-eslint/no-unused-vars
        s,
        // <numeric>
        l,
        // %         (optional)
        u,
        // ,         (optional)
        c,
        // <numeric>
        p,
        // %         (optional)
        f2,
        // ,         (optional)
        d,
        // <numeric>
        h,
        // %         (optional)
        m,
        // ,|/       (optional)
        g,
        // <numeric> (optional)
        b
        // %         (optional)
      ] = o, v = [u || " ", f2 || " ", m].join("");
      if (v === "  " || v === "  /" || v === ",," || v === ",,,") {
        const x = [l, p, h].join(""), C = x === "%%%" ? 100 : x === "" ? 255 : 0;
        if (C) {
          const E = [
            et(+s / C, 0, 1),
            et(+c / C, 0, 1),
            et(+d / C, 0, 1),
            g ? Xn(+g, b) : 1
          ];
          if (Yn(E))
            return E;
        }
      }
      return;
    }
  }
  const t = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, n = r.match(t);
  if (n) {
    const [
      a,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      o,
      // <numeric>
      i,
      // ,         (optional)
      s,
      // <numeric>
      l,
      // ,         (optional)
      u,
      // <numeric>
      c,
      // ,|/       (optional)
      p,
      // <numeric> (optional)
      f2
      // %         (optional)
    ] = n, d = [i || " ", l || " ", c].join("");
    if (d === "  " || d === "  /" || d === ",," || d === ",,,") {
      const h = [
        +o,
        et(+s, 0, 100),
        et(+u, 0, 100),
        p ? Xn(+p, f2) : 1
      ];
      if (Yn(h))
        return al(h);
    }
  }
}
function Ot(r) {
  return parseInt(r.padEnd(2, r), 16) / 255;
}
function Xn(r, e) {
  return et(e ? r / 100 : r, 0, 1);
}
function et(r, e, t) {
  return Math.min(Math.max(e, r), t);
}
function Yn(r) {
  return !r.some(Number.isNaN);
}
var sl = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
function Ge(r, e, t) {
  return r + t * (e - r);
}
function bt(r, e, t) {
  return r.map((n, a) => Ge(n, e[a], t));
}
var $ = class _$ {
  /**
   * @param r Red component premultiplied by `alpha` 0..1
   * @param g Green component premultiplied by `alpha` 0..1
   * @param b Blue component premultiplied by `alpha` 0..1
   * @param [alpha=1] Alpha component 0..1
   * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
   * been multiplied by alpha. If `true` nothing happens if `false` then they will
   * be multiplied automatically.
   */
  constructor(e, t, n, a = 1, o = true) {
    this.r = e, this.g = t, this.b = n, this.a = a, o || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter("rgb", [e, t, n, a]));
  }
  /**
   * Parses CSS color strings and converts colors to sRGB color space if needed.
   * Officially supported color formats:
   * - keyword, e.g. 'aquamarine' or 'steelblue'
   * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
   * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
   * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
   *
   * @param input CSS color string to parse.
   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
   */
  static parse(e) {
    if (e instanceof _$)
      return e;
    if (typeof e != "string")
      return;
    const t = il(e);
    if (t)
      return new _$(...t, false);
  }
  /**
   * Used in color interpolation and by 'to-rgba' expression.
   *
   * @returns Gien color, with reversed alpha blending, in sRGB color space.
   */
  get rgb() {
    const { r: e, g: t, b: n, a } = this, o = a || 1 / 0;
    return this.overwriteGetter("rgb", [e / o, t / o, n / o, a]);
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in HCL color space.
   */
  get hcl() {
    return this.overwriteGetter("hcl", rl(this.rgb));
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in LAB color space.
   */
  get lab() {
    return this.overwriteGetter("lab", oo(this.rgb));
  }
  /**
   * Lazy getter pattern. When getter is called for the first time lazy value
   * is calculated and then overwrites getter function in given object instance.
   *
   * @example:
   * const redColor = Color.parse('red');
   * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
   * // the value of red in HCL space and invoke this `overwriteGetter` function
   * // which in turn will set a field with a key 'hcl' in the `redColor` object.
   * // In other words it will override `get hcl()` from its `Color` prototype
   * // with its own property: hcl = [calculated red value in hcl].
   * let y = redColor.hcl; // next call will no longer invoke getter but simply
   * // return the previously calculated value
   * x === y; // true - `x` is exactly the same object as `y`
   *
   * @param getterKey Getter key
   * @param lazyValue Lazily calculated value to be memoized by current instance
   * @private
   */
  overwriteGetter(e, t) {
    return Object.defineProperty(this, e, { value: t }), t;
  }
  /**
   * Used by 'to-string' expression.
   *
   * @returns Serialized color in format `rgba(r,g,b,a)`
   * where r,g,b are numbers within 0..255 and alpha is number within 1..0
   *
   * @example
   * var purple = new Color.parse('purple');
   * purple.toString; // = "rgba(128,0,128,1)"
   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
   * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
   */
  toString() {
    const [e, t, n, a] = this.rgb;
    return `rgba(${[e, t, n].map((o) => Math.round(o * 255)).join(",")},${a})`;
  }
  static interpolate(e, t, n, a = "rgb") {
    switch (a) {
      case "rgb": {
        const [o, i, s, l] = bt(e.rgb, t.rgb, n);
        return new _$(o, i, s, l, false);
      }
      case "hcl": {
        const [o, i, s, l] = e.hcl, [u, c, p, f2] = t.hcl;
        let d, h;
        if (!isNaN(o) && !isNaN(u)) {
          let x = u - o;
          u > o && x > 180 ? x -= 360 : u < o && o - u > 180 && (x += 360), d = o + n * x;
        } else isNaN(o) ? isNaN(u) ? d = NaN : (d = u, (s === 1 || s === 0) && (h = c)) : (d = o, (p === 1 || p === 0) && (h = i));
        const [m, g, b, v] = nl([
          d,
          h ?? Ge(i, c, n),
          Ge(s, p, n),
          Ge(l, f2, n)
        ]);
        return new _$(m, g, b, v, false);
      }
      case "lab": {
        const [o, i, s, l] = io(bt(e.lab, t.lab, n));
        return new _$(o, i, s, l, false);
      }
    }
  }
};
$.black = new $(0, 0, 0, 1);
$.white = new $(1, 1, 1, 1);
$.transparent = new $(0, 0, 0, 0);
$.red = new $(1, 0, 0, 1);
var dn = class {
  constructor(e, t, n) {
    e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
      sensitivity: this.sensitivity,
      usage: "search"
    });
  }
  compare(e, t) {
    return this.collator.compare(e, t);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
};
var ll = ["bottom", "center", "top"];
var qr = class {
  constructor(e, t, n, a, o, i) {
    this.text = e, this.image = t, this.scale = n, this.fontStack = a, this.textColor = o, this.verticalAlign = i;
  }
};
var Le = class _Le {
  constructor(e) {
    this.sections = e;
  }
  static fromString(e) {
    return new _Le([new qr(e, null, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? true : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
  }
  static factory(e) {
    return e instanceof _Le ? e : _Le.fromString(e);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
  }
};
var de = class _de {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * Numeric padding values
   * @param input A padding value
   * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
   */
  static parse(e) {
    if (e instanceof _de)
      return e;
    if (typeof e == "number")
      return new _de([e, e, e, e]);
    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
      for (const t of e)
        if (typeof t != "number")
          return;
      switch (e.length) {
        case 1:
          e = [e[0], e[0], e[0], e[0]];
          break;
        case 2:
          e = [e[0], e[1], e[0], e[1]];
          break;
        case 3:
          e = [e[0], e[1], e[2], e[1]];
          break;
      }
      return new _de(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    return new _de(bt(e.values, t.values, n));
  }
};
var he = class _he {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * Numeric NumberArray values
   * @param input A NumberArray value
   * @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.
   */
  static parse(e) {
    if (e instanceof _he)
      return e;
    if (typeof e == "number")
      return new _he([e]);
    if (Array.isArray(e)) {
      for (const t of e)
        if (typeof t != "number")
          return;
      return new _he(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    return new _he(bt(e.values, t.values, n));
  }
};
var oe = class _oe {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * ColorArray values
   * @param input A ColorArray value
   * @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.
   */
  static parse(e) {
    if (e instanceof _oe)
      return e;
    if (typeof e == "string") {
      const n = $.parse(e);
      return n ? new _oe([n]) : void 0;
    }
    if (!Array.isArray(e))
      return;
    const t = [];
    for (const n of e) {
      if (typeof n != "string")
        return;
      const a = $.parse(n);
      if (!a)
        return;
      t.push(a);
    }
    return new _oe(t);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n, a = "rgb") {
    const o = [];
    if (e.values.length != t.values.length)
      throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);
    for (let i = 0; i < e.values.length; i++)
      o.push($.interpolate(e.values[i], t.values[i], n, a));
    return new _oe(o);
  }
};
var V = class extends Error {
  constructor(e) {
    super(e), this.name = "RuntimeError";
  }
  toJSON() {
    return this.message;
  }
};
var ul = /* @__PURE__ */ new Set([
  "center",
  "left",
  "right",
  "top",
  "bottom",
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
]);
var we = class _we {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof _we)
      return e;
    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
      for (let t = 0; t < e.length; t += 2) {
        const n = e[t], a = e[t + 1];
        if (typeof n != "string" || !ul.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != "number" || typeof a[1] != "number")
          return;
      }
      return new _we(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    const a = e.values, o = t.values;
    if (a.length !== o.length)
      throw new V(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);
    const i = [];
    for (let s = 0; s < a.length; s += 2) {
      if (a[s] !== o[s])
        throw new V(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${a[s]}, to[${s}]: ${o[s]}`);
      i.push(a[s]);
      const [l, u] = a[s + 1], [c, p] = o[s + 1];
      i.push([Ge(l, c, n), Ge(u, p, n)]);
    }
    return new _we(i);
  }
};
var je = class _je {
  constructor(e) {
    this.name = e.name, this.available = e.available;
  }
  toString() {
    return this.name;
  }
  static fromString(e) {
    return e ? new _je({ name: e, available: false }) : null;
  }
};
var pe = class _pe {
  constructor(e, t, n) {
    this.from = e, this.to = t, this.transition = n;
  }
  static interpolate(e, t, n) {
    return new _pe(e, t, n);
  }
  static parse(e) {
    if (e instanceof _pe)
      return e;
    if (Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number")
      return new _pe(e[0], e[1], e[2]);
    if (typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number")
      return new _pe(e.from, e.to, e.transition);
    if (typeof e == "string")
      return new _pe(e, e, 1);
  }
};
function so(r, e, t, n) {
  return typeof r == "number" && r >= 0 && r <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 ? typeof n > "u" || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[r, e, t, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [r, e, t, n] : [r, e, t]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
function wt(r) {
  if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof pe || r instanceof $ || r instanceof dn || r instanceof Le || r instanceof de || r instanceof he || r instanceof oe || r instanceof we || r instanceof je)
    return true;
  if (Array.isArray(r)) {
    for (const e of r)
      if (!wt(e))
        return false;
    return true;
  } else if (typeof r == "object") {
    for (const e in r)
      if (!wt(r[e]))
        return false;
    return true;
  } else
    return false;
}
function H(r) {
  if (r === null)
    return ar;
  if (typeof r == "string")
    return P;
  if (typeof r == "boolean")
    return M;
  if (typeof r == "number")
    return S;
  if (r instanceof $)
    return be;
  if (r instanceof pe)
    return or;
  if (r instanceof dn)
    return ir;
  if (r instanceof Le)
    return sr;
  if (r instanceof de)
    return lr;
  if (r instanceof he)
    return ur;
  if (r instanceof oe)
    return gt;
  if (r instanceof we)
    return cr;
  if (r instanceof je)
    return It;
  if (Array.isArray(r)) {
    const e = r.length;
    let t;
    for (const n of r) {
      const a = H(n);
      if (!t)
        t = a;
      else {
        if (t === a)
          continue;
        t = _;
        break;
      }
    }
    return ae(t || _, e);
  } else
    return qe;
}
function mt(r) {
  const e = typeof r;
  return r === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r) : r instanceof $ || r instanceof pe || r instanceof Le || r instanceof de || r instanceof he || r instanceof oe || r instanceof we || r instanceof je ? r.toString() : JSON.stringify(r);
}
var it = class _it {
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (!wt(e[1]))
      return t.error("invalid value");
    const n = e[1];
    let a = H(n);
    const o = t.expectedType;
    return a.kind === "array" && a.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (a = o), new _it(a, n);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var zt = {
  string: P,
  number: S,
  boolean: M,
  object: qe
};
var fe = class _fe {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    let n = 1, a;
    const o = e[0];
    if (o === "array") {
      let s;
      if (e.length > 2) {
        const u = e[1];
        if (typeof u != "string" || !(u in zt) || u === "object")
          return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
        s = zt[u], n++;
      } else
        s = _;
      let l;
      if (e.length > 3) {
        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
          return t.error('The length argument to "array" must be a positive integer literal', 2);
        l = e[2], n++;
      }
      a = ae(s, l);
    } else {
      if (!zt[o])
        throw new Error(`Types doesn't contain name = ${o}`);
      a = zt[o];
    }
    const i = [];
    for (; n < e.length; n++) {
      const s = t.parse(e[n], n, _);
      if (!s)
        return null;
      i.push(s);
    }
    return new _fe(a, i);
  }
  evaluate(e) {
    for (let t = 0; t < this.args.length; t++) {
      const n = this.args[t].evaluate(e);
      if (vt(this.type, H(n))) {
        if (t === this.args.length - 1)
          throw new V(`Expected value to be of type ${D(this.type)}, but found ${D(H(n))} instead.`);
      } else return n;
    }
    throw new Error();
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
var Wn = {
  "to-boolean": M,
  "to-color": be,
  "to-number": S,
  "to-string": P
};
var Re = class _Re {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    const n = e[0];
    if (!Wn[n])
      throw new Error(`Can't parse ${n} as it is not part of the known types`);
    if ((n === "to-boolean" || n === "to-string") && e.length !== 2)
      return t.error("Expected one argument.");
    const a = Wn[n], o = [];
    for (let i = 1; i < e.length; i++) {
      const s = t.parse(e[i], i, _);
      if (!s)
        return null;
      o.push(s);
    }
    return new _Re(a, o);
  }
  evaluate(e) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(e);
      case "color": {
        let t, n;
        for (const a of this.args) {
          if (t = a.evaluate(e), n = null, t instanceof $)
            return t;
          if (typeof t == "string") {
            const o = e.parseColor(t);
            if (o)
              return o;
          } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = so(t[0], t[1], t[2], t[3]), !n))
            return new $(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
        }
        throw new V(n || `Could not parse color from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "padding": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const a = de.parse(t);
          if (a)
            return a;
        }
        throw new V(`Could not parse padding from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "numberArray": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const a = he.parse(t);
          if (a)
            return a;
        }
        throw new V(`Could not parse numberArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "colorArray": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const a = oe.parse(t);
          if (a)
            return a;
        }
        throw new V(`Could not parse colorArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "variableAnchorOffsetCollection": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const a = we.parse(t);
          if (a)
            return a;
        }
        throw new V(`Could not parse variableAnchorOffsetCollection from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "number": {
        let t = null;
        for (const n of this.args) {
          if (t = n.evaluate(e), t === null)
            return 0;
          const a = Number(t);
          if (!isNaN(a))
            return a;
        }
        throw new V(`Could not convert ${JSON.stringify(t)} to number.`);
      }
      case "formatted":
        return Le.fromString(mt(this.args[0].evaluate(e)));
      case "resolvedImage":
        return je.fromString(mt(this.args[0].evaluate(e)));
      case "projectionDefinition":
        return this.args[0].evaluate(e);
      default:
        return mt(this.args[0].evaluate(e));
    }
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
var cl = ["Unknown", "Point", "LineString", "Polygon"];
var lo = class {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? cl[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(e) {
    let t = this._parseColorCache.get(e);
    return t || (t = $.parse(e), this._parseColorCache.set(e, t)), t;
  }
};
var pr = class _pr {
  constructor(e, t, n = [], a, o = new pn(), i = []) {
    this.registry = e, this.path = n, this.key = n.map((s) => `[${s}]`).join(""), this.scope = o, this.errors = i, this.expectedType = a, this._isConstant = t;
  }
  /**
   * @param expr the JSON expression to parse
   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
   * @param options
   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
   * @private
   */
  parse(e, t, n, a, o = {}) {
    return t ? this.concat(t, n, a)._parse(e, o) : this._parse(e, o);
  }
  _parse(e, t) {
    (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
    function n(a, o, i) {
      return i === "assert" ? new fe(o, [a]) : i === "coerce" ? new Re(o, [a]) : a;
    }
    if (Array.isArray(e)) {
      if (e.length === 0)
        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      const a = e[0];
      if (typeof a != "string")
        return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
      const o = this.registry[a];
      if (o) {
        let i = o.parse(e, this);
        if (!i)
          return null;
        if (this.expectedType) {
          const s = this.expectedType, l = i.type;
          if ((s.kind === "string" || s.kind === "number" || s.kind === "boolean" || s.kind === "object" || s.kind === "array") && l.kind === "value")
            i = n(i, s, t.typeAnnotation || "assert");
          else if (s.kind === "projectionDefinition" && ["string", "array"].includes(l.kind) || ["color", "formatted", "resolvedImage"].includes(s.kind) && ["value", "string"].includes(l.kind) || ["padding", "numberArray"].includes(s.kind) && ["value", "number", "array"].includes(l.kind) || s.kind === "colorArray" && ["value", "string", "array"].includes(l.kind) || s.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(l.kind))
            i = n(i, s, t.typeAnnotation || "coerce");
          else if (this.checkSubtype(s, l))
            return null;
        }
        if (!(i instanceof it) && i.type.kind !== "resolvedImage" && this._isConstant(i)) {
          const s = new lo();
          try {
            i = new it(i.type, i.evaluate(s));
          } catch (l) {
            return this.error(l.message), null;
          }
        }
        return i;
      }
      return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
    } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);
  }
  /**
   * Returns a copy of this context suitable for parsing the subexpression at
   * index `index`, optionally appending to 'let' binding map.
   *
   * Note that `errors` property, intended for collecting errors while
   * parsing, is copied by reference rather than cloned.
   * @private
   */
  concat(e, t, n) {
    const a = typeof e == "number" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;
    return new _pr(this.registry, this._isConstant, a, t || null, o, this.errors);
  }
  /**
   * Push a parsing (or type checking) error into the `this.errors`
   * @param error The message
   * @param keys Optionally specify the source of the error at a child
   * of the current expression at `this.key`.
   * @private
   */
  error(e, ...t) {
    const n = `${this.key}${t.map((a) => `[${a}]`).join("")}`;
    this.errors.push(new ve(n, e));
  }
  /**
   * Returns null if `t` is a subtype of `expected`; otherwise returns an
   * error message and also pushes it to `this.errors`.
   * @param expected The expected type
   * @param t The actual type
   * @returns null if `t` is a subtype of `expected`; otherwise returns an error message
   */
  checkSubtype(e, t) {
    const n = vt(e, t);
    return n && this.error(n), n;
  }
};
var fr = class _fr {
  constructor(e, t) {
    this.type = t.type, this.bindings = [].concat(e), this.result = t;
  }
  evaluate(e) {
    return this.result.evaluate(e);
  }
  eachChild(e) {
    for (const t of this.bindings)
      e(t[1]);
    e(this.result);
  }
  static parse(e, t) {
    if (e.length < 4)
      return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
    const n = [];
    for (let o = 1; o < e.length - 1; o += 2) {
      const i = e[o];
      if (typeof i != "string")
        return t.error(`Expected string, but found ${typeof i} instead.`, o);
      if (/[^a-zA-Z0-9_]/.test(i))
        return t.error("Variable names must contain only alphanumeric characters or '_'.", o);
      const s = t.parse(e[o + 1], o + 1);
      if (!s)
        return null;
      n.push([i, s]);
    }
    const a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
    return a ? new _fr(n, a) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
};
var dr = class _dr {
  constructor(e, t) {
    this.type = t.type, this.name = e, this.boundExpression = t;
  }
  static parse(e, t) {
    if (e.length !== 2 || typeof e[1] != "string")
      return t.error("'var' expression requires exactly one string literal argument.");
    const n = e[1];
    return t.scope.has(n) ? new _dr(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
  }
  evaluate(e) {
    return this.boundExpression.evaluate(e);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
var hn = class _hn {
  constructor(e, t, n) {
    this.type = e, this.index = t, this.input = n;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, S), a = t.parse(e[2], 2, ae(t.expectedType || _));
    if (!n || !a)
      return null;
    const o = a.type;
    return new _hn(o.itemType, n, a);
  }
  evaluate(e) {
    const t = this.index.evaluate(e), n = this.input.evaluate(e);
    if (t < 0)
      throw new V(`Array index out of bounds: ${t} < 0.`);
    if (t >= n.length)
      throw new V(`Array index out of bounds: ${t} > ${n.length - 1}.`);
    if (t !== Math.floor(t))
      throw new V(`Array index must be an integer, but found ${t} instead.`);
    return n[t];
  }
  eachChild(e) {
    e(this.index), e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var mn = class _mn {
  constructor(e, t) {
    this.type = M, this.needle = e, this.haystack = t;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, _), a = t.parse(e[2], 2, _);
    return !n || !a ? null : fn(n.type, [M, P, S, ar, _]) ? new _mn(n, a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);
  }
  evaluate(e) {
    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!n)
      return false;
    if (!Ve(t, ["boolean", "string", "number", "null"]))
      throw new V(`Expected first argument to be of type boolean, string, number or null, but found ${D(H(t))} instead.`);
    if (!Ve(n, ["string", "array"]))
      throw new V(`Expected second argument to be of type array or string, but found ${D(H(n))} instead.`);
    return n.indexOf(t) >= 0;
  }
  eachChild(e) {
    e(this.needle), e(this.haystack);
  }
  outputDefined() {
    return true;
  }
};
var Kt = class _Kt {
  constructor(e, t, n) {
    this.type = S, this.needle = e, this.haystack = t, this.fromIndex = n;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5)
      return t.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, _), a = t.parse(e[2], 2, _);
    if (!n || !a)
      return null;
    if (!fn(n.type, [M, P, S, ar, _]))
      return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);
    if (e.length === 4) {
      const o = t.parse(e[3], 3, S);
      return o ? new _Kt(n, a, o) : null;
    } else
      return new _Kt(n, a);
  }
  evaluate(e) {
    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!Ve(t, ["boolean", "string", "number", "null"]))
      throw new V(`Expected first argument to be of type boolean, string, number or null, but found ${D(H(t))} instead.`);
    let a;
    if (this.fromIndex && (a = this.fromIndex.evaluate(e)), Ve(n, ["string"])) {
      const o = n.indexOf(t, a);
      return o === -1 ? -1 : [...n.slice(0, o)].length;
    } else {
      if (Ve(n, ["array"]))
        return n.indexOf(t, a);
      throw new V(`Expected second argument to be of type array or string, but found ${D(H(n))} instead.`);
    }
  }
  eachChild(e) {
    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
  }
  outputDefined() {
    return false;
  }
};
var yn = class _yn {
  constructor(e, t, n, a, o, i) {
    this.inputType = e, this.type = t, this.input = n, this.cases = a, this.outputs = o, this.otherwise = i;
  }
  static parse(e, t) {
    if (e.length < 5)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 1)
      return t.error("Expected an even number of arguments.");
    let n, a;
    t.expectedType && t.expectedType.kind !== "value" && (a = t.expectedType);
    const o = {}, i = [];
    for (let u = 2; u < e.length - 1; u += 2) {
      let c = e[u];
      const p = e[u + 1];
      Array.isArray(c) || (c = [c]);
      const f2 = t.concat(u);
      if (c.length === 0)
        return f2.error("Expected at least one branch label.");
      for (const h of c) {
        if (typeof h != "number" && typeof h != "string")
          return f2.error("Branch labels must be numbers or strings.");
        if (typeof h == "number" && Math.abs(h) > Number.MAX_SAFE_INTEGER)
          return f2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
        if (typeof h == "number" && Math.floor(h) !== h)
          return f2.error("Numeric branch labels must be integer values.");
        if (!n)
          n = H(h);
        else if (f2.checkSubtype(n, H(h)))
          return null;
        if (typeof o[String(h)] < "u")
          return f2.error("Branch labels must be unique.");
        o[String(h)] = i.length;
      }
      const d = t.parse(p, u, a);
      if (!d)
        return null;
      a = a || d.type, i.push(d);
    }
    const s = t.parse(e[1], 1, _);
    if (!s)
      return null;
    const l = t.parse(e[e.length - 1], e.length - 1, a);
    return !l || s.type.kind !== "value" && t.concat(1).checkSubtype(n, s.type) ? null : new _yn(n, a, s, o, i, l);
  }
  evaluate(e) {
    const t = this.input.evaluate(e);
    return (H(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
  }
  eachChild(e) {
    e(this.input), this.outputs.forEach(e), e(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
  }
};
var gn = class _gn {
  constructor(e, t, n) {
    this.type = e, this.branches = t, this.otherwise = n;
  }
  static parse(e, t) {
    if (e.length < 4)
      return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 0)
      return t.error("Expected an odd number of arguments.");
    let n;
    t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
    const a = [];
    for (let i = 1; i < e.length - 1; i += 2) {
      const s = t.parse(e[i], i, M);
      if (!s)
        return null;
      const l = t.parse(e[i + 1], i + 1, n);
      if (!l)
        return null;
      a.push([s, l]), n = n || l.type;
    }
    const o = t.parse(e[e.length - 1], e.length - 1, n);
    if (!o)
      return null;
    if (!n)
      throw new Error("Can't infer output type");
    return new _gn(n, a, o);
  }
  evaluate(e) {
    for (const [t, n] of this.branches)
      if (t.evaluate(e))
        return n.evaluate(e);
    return this.otherwise.evaluate(e);
  }
  eachChild(e) {
    for (const [t, n] of this.branches)
      e(t), e(n);
    e(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
  }
};
var Zt = class _Zt {
  constructor(e, t, n, a) {
    this.type = e, this.input = t, this.beginIndex = n, this.endIndex = a;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5)
      return t.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, _), a = t.parse(e[2], 2, S);
    if (!n || !a)
      return null;
    if (!fn(n.type, [ae(_), P, _]))
      return t.error(`Expected first argument to be of type array or string, but found ${D(n.type)} instead`);
    if (e.length === 4) {
      const o = t.parse(e[3], 3, S);
      return o ? new _Zt(n.type, n, a, o) : null;
    } else
      return new _Zt(n.type, n, a);
  }
  evaluate(e) {
    const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
    let a;
    if (this.endIndex && (a = this.endIndex.evaluate(e)), Ve(t, ["string"]))
      return [...t].slice(n, a).join("");
    if (Ve(t, ["array"]))
      return t.slice(n, a);
    throw new V(`Expected first argument to be of type array or string, but found ${D(H(t))} instead.`);
  }
  eachChild(e) {
    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
  }
  outputDefined() {
    return false;
  }
};
function uo(r, e) {
  const t = r.length - 1;
  let n = 0, a = t, o = 0, i, s;
  for (; n <= a; )
    if (o = Math.floor((n + a) / 2), i = r[o], s = r[o + 1], i <= e) {
      if (o === t || e < s)
        return o;
      n = o + 1;
    } else if (i > e)
      a = o - 1;
    else
      throw new V("Input is not a number.");
  return 0;
}
var hr = class _hr {
  constructor(e, t, n) {
    this.type = e, this.input = t, this.labels = [], this.outputs = [];
    for (const [a, o] of n)
      this.labels.push(a), this.outputs.push(o);
  }
  static parse(e, t) {
    if (e.length - 1 < 4)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0)
      return t.error("Expected an even number of arguments.");
    const n = t.parse(e[1], 1, S);
    if (!n)
      return null;
    const a = [];
    let o = null;
    t.expectedType && t.expectedType.kind !== "value" && (o = t.expectedType);
    for (let i = 1; i < e.length; i += 2) {
      const s = i === 1 ? -1 / 0 : e[i], l = e[i + 1], u = i, c = i + 1;
      if (typeof s != "number")
        return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u);
      if (a.length && a[a.length - 1][0] >= s)
        return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u);
      const p = t.parse(l, c, o);
      if (!p)
        return null;
      o = o || p.type, a.push([s, p]);
    }
    return new _hr(o, n, a);
  }
  evaluate(e) {
    const t = this.labels, n = this.outputs;
    if (t.length === 1)
      return n[0].evaluate(e);
    const a = this.input.evaluate(e);
    if (a <= t[0])
      return n[0].evaluate(e);
    const o = t.length;
    if (a >= t[o - 1])
      return n[o - 1].evaluate(e);
    const i = uo(t, a);
    return n[i].evaluate(e);
  }
  eachChild(e) {
    e(this.input);
    for (const t of this.outputs)
      e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
function pl(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Ir;
var Jn;
function fl() {
  if (Jn) return Ir;
  Jn = 1, Ir = r;
  function r(e, t, n, a) {
    this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (a - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = a;
  }
  return r.prototype = {
    sampleCurveX: function(e) {
      return ((this.ax * e + this.bx) * e + this.cx) * e;
    },
    sampleCurveY: function(e) {
      return ((this.ay * e + this.by) * e + this.cy) * e;
    },
    sampleCurveDerivativeX: function(e) {
      return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
    },
    solveCurveX: function(e, t) {
      if (t === void 0 && (t = 1e-6), e < 0) return 0;
      if (e > 1) return 1;
      for (var n = e, a = 0; a < 8; a++) {
        var o = this.sampleCurveX(n) - e;
        if (Math.abs(o) < t) return n;
        var i = this.sampleCurveDerivativeX(n);
        if (Math.abs(i) < 1e-6) break;
        n = n - o / i;
      }
      var s = 0, l = 1;
      for (n = e, a = 0; a < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < t)); a++)
        e > o ? s = n : l = n, n = (l - s) * 0.5 + s;
      return n;
    },
    solve: function(e, t) {
      return this.sampleCurveY(this.solveCurveX(e, t));
    }
  }, Ir;
}
var dl = fl();
var hl = pl(dl);
var Se = class _Se {
  constructor(e, t, n, a, o) {
    this.type = e, this.operator = t, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];
    for (const [i, s] of o)
      this.labels.push(i), this.outputs.push(s);
  }
  static interpolationFactor(e, t, n, a) {
    let o = 0;
    if (e.name === "exponential")
      o = _r(t, e.base, n, a);
    else if (e.name === "linear")
      o = _r(t, 1, n, a);
    else if (e.name === "cubic-bezier") {
      const i = e.controlPoints;
      o = new hl(i[0], i[1], i[2], i[3]).solve(_r(t, 1, n, a));
    }
    return o;
  }
  static parse(e, t) {
    let [n, a, o, ...i] = e;
    if (!Array.isArray(a) || a.length === 0)
      return t.error("Expected an interpolation type expression.", 1);
    if (a[0] === "linear")
      a = { name: "linear" };
    else if (a[0] === "exponential") {
      const u = a[1];
      if (typeof u != "number")
        return t.error("Exponential interpolation requires a numeric base.", 1, 1);
      a = {
        name: "exponential",
        base: u
      };
    } else if (a[0] === "cubic-bezier") {
      const u = a.slice(1);
      if (u.length !== 4 || u.some((c) => typeof c != "number" || c < 0 || c > 1))
        return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      a = {
        name: "cubic-bezier",
        controlPoints: u
      };
    } else
      return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);
    if (e.length - 1 < 4)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0)
      return t.error("Expected an even number of arguments.");
    if (o = t.parse(o, 2, S), !o)
      return null;
    const s = [];
    let l = null;
    (n === "interpolate-hcl" || n === "interpolate-lab") && t.expectedType != gt ? l = be : t.expectedType && t.expectedType.kind !== "value" && (l = t.expectedType);
    for (let u = 0; u < i.length; u += 2) {
      const c = i[u], p = i[u + 1], f2 = u + 3, d = u + 4;
      if (typeof c != "number")
        return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f2);
      if (s.length && s[s.length - 1][0] >= c)
        return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f2);
      const h = t.parse(p, d, l);
      if (!h)
        return null;
      l = l || h.type, s.push([c, h]);
    }
    return !Ae(l, S) && !Ae(l, or) && !Ae(l, be) && !Ae(l, lr) && !Ae(l, ur) && !Ae(l, gt) && !Ae(l, cr) && !Ae(l, ae(S)) ? t.error(`Type ${D(l)} is not interpolatable.`) : new _Se(l, n, a, o, s);
  }
  evaluate(e) {
    const t = this.labels, n = this.outputs;
    if (t.length === 1)
      return n[0].evaluate(e);
    const a = this.input.evaluate(e);
    if (a <= t[0])
      return n[0].evaluate(e);
    const o = t.length;
    if (a >= t[o - 1])
      return n[o - 1].evaluate(e);
    const i = uo(t, a), s = t[i], l = t[i + 1], u = _Se.interpolationFactor(this.interpolation, a, s, l), c = n[i].evaluate(e), p = n[i + 1].evaluate(e);
    switch (this.operator) {
      case "interpolate":
        switch (this.type.kind) {
          case "number":
            return Ge(c, p, u);
          case "color":
            return $.interpolate(c, p, u);
          case "padding":
            return de.interpolate(c, p, u);
          case "colorArray":
            return oe.interpolate(c, p, u);
          case "numberArray":
            return he.interpolate(c, p, u);
          case "variableAnchorOffsetCollection":
            return we.interpolate(c, p, u);
          case "array":
            return bt(c, p, u);
          case "projectionDefinition":
            return pe.interpolate(c, p, u);
        }
      case "interpolate-hcl":
        switch (this.type.kind) {
          case "color":
            return $.interpolate(c, p, u, "hcl");
          case "colorArray":
            return oe.interpolate(c, p, u, "hcl");
        }
      case "interpolate-lab":
        switch (this.type.kind) {
          case "color":
            return $.interpolate(c, p, u, "lab");
          case "colorArray":
            return oe.interpolate(c, p, u, "lab");
        }
    }
  }
  eachChild(e) {
    e(this.input);
    for (const t of this.outputs)
      e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
function _r(r, e, t, n) {
  const a = n - t, o = r - t;
  return a === 0 ? 0 : e === 1 ? o / a : (Math.pow(e, o) - 1) / (Math.pow(e, a) - 1);
}
var St = class _St {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    let n = null;
    const a = t.expectedType;
    a && a.kind !== "value" && (n = a);
    const o = [];
    for (const s of e.slice(1)) {
      const l = t.parse(s, 1 + o.length, n, void 0, {
        typeAnnotation: "omit"
      });
      if (!l)
        return null;
      n = n || l.type, o.push(l);
    }
    if (!n)
      throw new Error("No output type");
    return a && o.some((s) => vt(a, s.type)) ? new _St(_, o) : new _St(n, o);
  }
  evaluate(e) {
    let t = null, n = 0, a;
    for (const o of this.args)
      if (n++, t = o.evaluate(e), t && t instanceof je && !t.available && (a || (a = t.name), t = null, n === this.args.length && (t = a)), t !== null)
        break;
    return t;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
function Qn(r, e) {
  return r === "==" || r === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
function ml(r, e, t) {
  return e === t;
}
function yl(r, e, t) {
  return e !== t;
}
function gl(r, e, t) {
  return e < t;
}
function vl(r, e, t) {
  return e > t;
}
function bl(r, e, t) {
  return e <= t;
}
function wl(r, e, t) {
  return e >= t;
}
function co(r, e, t, n) {
  return n.compare(e, t) === 0;
}
function Sl(r, e, t, n) {
  return !co(r, e, t, n);
}
function xl(r, e, t, n) {
  return n.compare(e, t) < 0;
}
function kl(r, e, t, n) {
  return n.compare(e, t) > 0;
}
function Ll(r, e, t, n) {
  return n.compare(e, t) <= 0;
}
function El(r, e, t, n) {
  return n.compare(e, t) >= 0;
}
function ut(r, e, t) {
  const n = r !== "==" && r !== "!=";
  return class po {
    constructor(o, i, s) {
      this.type = M, this.lhs = o, this.rhs = i, this.collator = s, this.hasUntypedArgument = o.type.kind === "value" || i.type.kind === "value";
    }
    static parse(o, i) {
      if (o.length !== 3 && o.length !== 4)
        return i.error("Expected two or three arguments.");
      const s = o[0];
      let l = i.parse(o[1], 1, _);
      if (!l)
        return null;
      if (!Qn(s, l.type))
        return i.concat(1).error(`"${s}" comparisons are not supported for type '${D(l.type)}'.`);
      let u = i.parse(o[2], 2, _);
      if (!u)
        return null;
      if (!Qn(s, u.type))
        return i.concat(2).error(`"${s}" comparisons are not supported for type '${D(u.type)}'.`);
      if (l.type.kind !== u.type.kind && l.type.kind !== "value" && u.type.kind !== "value")
        return i.error(`Cannot compare types '${D(l.type)}' and '${D(u.type)}'.`);
      n && (l.type.kind === "value" && u.type.kind !== "value" ? l = new fe(u.type, [l]) : l.type.kind !== "value" && u.type.kind === "value" && (u = new fe(l.type, [u])));
      let c = null;
      if (o.length === 4) {
        if (l.type.kind !== "string" && u.type.kind !== "string" && l.type.kind !== "value" && u.type.kind !== "value")
          return i.error("Cannot use collator to compare non-string types.");
        if (c = i.parse(o[3], 3, ir), !c)
          return null;
      }
      return new po(l, u, c);
    }
    evaluate(o) {
      const i = this.lhs.evaluate(o), s = this.rhs.evaluate(o);
      if (n && this.hasUntypedArgument) {
        const l = H(i), u = H(s);
        if (l.kind !== u.kind || !(l.kind === "string" || l.kind === "number"))
          throw new V(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`);
      }
      if (this.collator && !n && this.hasUntypedArgument) {
        const l = H(i), u = H(s);
        if (l.kind !== "string" || u.kind !== "string")
          return e(o, i, s);
      }
      return this.collator ? t(o, i, s, this.collator.evaluate(o)) : e(o, i, s);
    }
    eachChild(o) {
      o(this.lhs), o(this.rhs), this.collator && o(this.collator);
    }
    outputDefined() {
      return true;
    }
  };
}
var Cl = ut("==", ml, co);
var Al = ut("!=", yl, Sl);
var Tl = ut("<", gl, xl);
var Il = ut(">", vl, kl);
var _l = ut("<=", bl, Ll);
var Ml = ut(">=", wl, El);
var mr = class _mr {
  constructor(e, t, n) {
    this.type = ir, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected one argument.");
    const n = e[1];
    if (typeof n != "object" || Array.isArray(n))
      return t.error("Collator options argument must be an object.");
    const a = t.parse(n["case-sensitive"] === void 0 ? false : n["case-sensitive"], 1, M);
    if (!a)
      return null;
    const o = t.parse(n["diacritic-sensitive"] === void 0 ? false : n["diacritic-sensitive"], 1, M);
    if (!o)
      return null;
    let i = null;
    return n.locale && (i = t.parse(n.locale, 1, P), !i) ? null : new _mr(a, o, i);
  }
  evaluate(e) {
    return new dn(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
  }
  eachChild(e) {
    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
  }
  outputDefined() {
    return false;
  }
};
var vn = class _vn {
  constructor(e, t, n, a, o) {
    this.type = P, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = o;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error("Expected two arguments.");
    const n = t.parse(e[1], 1, S);
    if (!n)
      return null;
    const a = e[2];
    if (typeof a != "object" || Array.isArray(a))
      return t.error("NumberFormat options argument must be an object.");
    let o = null;
    if (a.locale && (o = t.parse(a.locale, 1, P), !o))
      return null;
    let i = null;
    if (a.currency && (i = t.parse(a.currency, 1, P), !i))
      return null;
    let s = null;
    if (a["min-fraction-digits"] && (s = t.parse(a["min-fraction-digits"], 1, S), !s))
      return null;
    let l = null;
    return a["max-fraction-digits"] && (l = t.parse(a["max-fraction-digits"], 1, S), !l) ? null : new _vn(n, o, i, s, l);
  }
  evaluate(e) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
      style: this.currency ? "currency" : "decimal",
      currency: this.currency ? this.currency.evaluate(e) : void 0,
      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
    }).format(this.number.evaluate(e));
  }
  eachChild(e) {
    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
  }
  outputDefined() {
    return false;
  }
};
var bn = class _bn {
  constructor(e) {
    this.type = sr, this.sections = e;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    const n = e[1];
    if (!Array.isArray(n) && typeof n == "object")
      return t.error("First argument must be an image or text section.");
    const a = [];
    let o = false;
    for (let i = 1; i <= e.length - 1; ++i) {
      const s = e[i];
      if (o && typeof s == "object" && !Array.isArray(s)) {
        o = false;
        let l = null;
        if (s["font-scale"] && (l = t.parse(s["font-scale"], 1, S), !l))
          return null;
        let u = null;
        if (s["text-font"] && (u = t.parse(s["text-font"], 1, ae(P)), !u))
          return null;
        let c = null;
        if (s["text-color"] && (c = t.parse(s["text-color"], 1, be), !c))
          return null;
        let p = null;
        if (s["vertical-align"]) {
          if (typeof s["vertical-align"] == "string" && !ll.includes(s["vertical-align"]))
            return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s["vertical-align"]}' instead.`);
          if (p = t.parse(s["vertical-align"], 1, P), !p)
            return null;
        }
        const f2 = a[a.length - 1];
        f2.scale = l, f2.font = u, f2.textColor = c, f2.verticalAlign = p;
      } else {
        const l = t.parse(e[i], 1, _);
        if (!l)
          return null;
        const u = l.type.kind;
        if (u !== "string" && u !== "value" && u !== "null" && u !== "resolvedImage")
          return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        o = true, a.push({
          content: l,
          scale: null,
          font: null,
          textColor: null,
          verticalAlign: null
        });
      }
    }
    return new _bn(a);
  }
  evaluate(e) {
    const t = (n) => {
      const a = n.content.evaluate(e);
      return H(a) === It ? new qr("", a, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new qr(mt(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);
    };
    return new Le(this.sections.map(t));
  }
  eachChild(e) {
    for (const t of this.sections)
      e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);
  }
  outputDefined() {
    return false;
  }
};
var wn = class _wn {
  constructor(e) {
    this.type = It, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected two arguments.");
    const n = t.parse(e[1], 1, P);
    return n ? new _wn(n) : t.error("No image name provided.");
  }
  evaluate(e) {
    const t = this.input.evaluate(e), n = je.fromString(t);
    return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var Sn = class _Sn {
  constructor(e) {
    this.type = S, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1);
    return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? t.error(`Expected argument of type string or array, but found ${D(n.type)} instead.`) : new _Sn(n) : null;
  }
  evaluate(e) {
    const t = this.input.evaluate(e);
    if (typeof t == "string")
      return [...t].length;
    if (Array.isArray(t))
      return t.length;
    throw new V(`Expected value to be of type string or array, but found ${D(H(t))} instead.`);
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var xe = 8192;
function Pl(r, e) {
  const t = Rl(r[0]), n = zl(r[1]), a = Math.pow(2, e.z);
  return [Math.round(t * a * xe), Math.round(n * a * xe)];
}
function xn(r, e) {
  const t = Math.pow(2, e.z), n = (r[0] / xe + e.x) / t, a = (r[1] / xe + e.y) / t;
  return [Ol(n), Fl(a)];
}
function Rl(r) {
  return (180 + r) / 360;
}
function Ol(r) {
  return r * 360 - 180;
}
function zl(r) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function Fl(r) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - r * 360) * Math.PI / 180)) - 90;
}
function _t(r, e) {
  r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);
}
function xt(r, e) {
  return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);
}
function $l(r, e, t) {
  return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];
}
function Nl(r, e, t) {
  const n = r[0] - e[0], a = r[1] - e[1], o = r[0] - t[0], i = r[1] - t[1];
  return n * i - o * a === 0 && n * o <= 0 && a * i <= 0;
}
function yr(r, e, t, n) {
  const a = [e[0] - r[0], e[1] - r[1]], o = [n[0] - t[0], n[1] - t[1]];
  return Bl(o, a) === 0 ? false : !!(ea(r, e, t, n) && ea(t, n, r, e));
}
function jl(r, e, t) {
  for (const n of t)
    for (let a = 0; a < n.length - 1; ++a)
      if (yr(r, e, n[a], n[a + 1]))
        return true;
  return false;
}
function ct(r, e, t = false) {
  let n = false;
  for (const a of e)
    for (let o = 0; o < a.length - 1; o++) {
      if (Nl(r, a[o], a[o + 1]))
        return t;
      $l(r, a[o], a[o + 1]) && (n = !n);
    }
  return n;
}
function Dl(r, e) {
  for (const t of e)
    if (ct(r, t))
      return true;
  return false;
}
function fo(r, e) {
  for (const t of r)
    if (!ct(t, e))
      return false;
  for (let t = 0; t < r.length - 1; ++t)
    if (jl(r[t], r[t + 1], e))
      return false;
  return true;
}
function Ul(r, e) {
  for (const t of e)
    if (fo(r, t))
      return true;
  return false;
}
function Bl(r, e) {
  return r[0] * e[1] - r[1] * e[0];
}
function ea(r, e, t, n) {
  const a = r[0] - t[0], o = r[1] - t[1], i = e[0] - t[0], s = e[1] - t[1], l = n[0] - t[0], u = n[1] - t[1], c = a * u - l * o, p = i * u - l * s;
  return c > 0 && p < 0 || c < 0 && p > 0;
}
function kn(r, e, t) {
  const n = [];
  for (let a = 0; a < r.length; a++) {
    const o = [];
    for (let i = 0; i < r[a].length; i++) {
      const s = Pl(r[a][i], t);
      _t(e, s), o.push(s);
    }
    n.push(o);
  }
  return n;
}
function ho(r, e, t) {
  const n = [];
  for (let a = 0; a < r.length; a++) {
    const o = kn(r[a], e, t);
    n.push(o);
  }
  return n;
}
function mo(r, e, t, n) {
  if (r[0] < t[0] || r[0] > t[2]) {
    const a = n * 0.5;
    let o = r[0] - t[0] > a ? -n : t[0] - r[0] > a ? n : 0;
    o === 0 && (o = r[0] - t[2] > a ? -n : t[2] - r[0] > a ? n : 0), r[0] += o;
  }
  _t(e, r);
}
function ql(r) {
  r[0] = r[1] = 1 / 0, r[2] = r[3] = -1 / 0;
}
function ta(r, e, t, n) {
  const a = Math.pow(2, n.z) * xe, o = [n.x * xe, n.y * xe], i = [];
  for (const s of r)
    for (const l of s) {
      const u = [l.x + o[0], l.y + o[1]];
      mo(u, e, t, a), i.push(u);
    }
  return i;
}
function ra(r, e, t, n) {
  const a = Math.pow(2, n.z) * xe, o = [n.x * xe, n.y * xe], i = [];
  for (const s of r) {
    const l = [];
    for (const u of s) {
      const c = [u.x + o[0], u.y + o[1]];
      _t(e, c), l.push(c);
    }
    i.push(l);
  }
  if (e[2] - e[0] <= a / 2) {
    ql(e);
    for (const s of i)
      for (const l of s)
        mo(l, e, t, a);
  }
  return i;
}
function Vl(r, e) {
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();
  if (e.type === "Polygon") {
    const o = kn(e.coordinates, n, a), i = ta(r.geometry(), t, n, a);
    if (!xt(t, n))
      return false;
    for (const s of i)
      if (!ct(s, o))
        return false;
  }
  if (e.type === "MultiPolygon") {
    const o = ho(e.coordinates, n, a), i = ta(r.geometry(), t, n, a);
    if (!xt(t, n))
      return false;
    for (const s of i)
      if (!Dl(s, o))
        return false;
  }
  return true;
}
function Gl(r, e) {
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();
  if (e.type === "Polygon") {
    const o = kn(e.coordinates, n, a), i = ra(r.geometry(), t, n, a);
    if (!xt(t, n))
      return false;
    for (const s of i)
      if (!fo(s, o))
        return false;
  }
  if (e.type === "MultiPolygon") {
    const o = ho(e.coordinates, n, a), i = ra(r.geometry(), t, n, a);
    if (!xt(t, n))
      return false;
    for (const s of i)
      if (!Ul(s, o))
        return false;
  }
  return true;
}
var He = class _He {
  constructor(e, t) {
    this.type = M, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (wt(e[1])) {
      const n = e[1];
      if (n.type === "FeatureCollection") {
        const a = [];
        for (const o of n.features) {
          const { type: i, coordinates: s } = o.geometry;
          i === "Polygon" && a.push(s), i === "MultiPolygon" && a.push(...s);
        }
        if (a.length) {
          const o = {
            type: "MultiPolygon",
            coordinates: a
          };
          return new _He(n, o);
        }
      } else if (n.type === "Feature") {
        const a = n.geometry.type;
        if (a === "Polygon" || a === "MultiPolygon")
          return new _He(n, n.geometry);
      } else if (n.type === "Polygon" || n.type === "MultiPolygon")
        return new _He(n, n);
    }
    return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point")
        return Vl(e, this.geometries);
      if (e.geometryType() === "LineString")
        return Gl(e, this.geometries);
    }
    return false;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var yo = class {
  constructor(e = [], t = (n, a) => n < a ? -1 : n > a ? 1 : 0) {
    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0)
      for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
  }
  push(e) {
    this.data.push(e), this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return;
    const e = this.data[0], t = this.data.pop();
    return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    const { data: t, compare: n } = this, a = t[e];
    for (; e > 0; ) {
      const o = e - 1 >> 1, i = t[o];
      if (n(a, i) >= 0) break;
      t[e] = i, e = o;
    }
    t[e] = a;
  }
  _down(e) {
    const { data: t, compare: n } = this, a = this.length >> 1, o = t[e];
    for (; e < a; ) {
      let i = (e << 1) + 1;
      const s = i + 1;
      if (s < this.length && n(t[s], t[i]) < 0 && (i = s), n(t[i], o) >= 0) break;
      t[e] = t[i], e = i;
    }
    t[e] = o;
  }
};
function Hl(r, e) {
  if (r.length <= 1)
    return [r];
  const n = [];
  let a, o;
  for (const i of r) {
    const s = Kl(i);
    s !== 0 && (i.area = Math.abs(s), o === void 0 && (o = s < 0), o === s < 0 ? (a && n.push(a), a = [i]) : a.push(i));
  }
  return a && n.push(a), n;
}
function Kl(r) {
  let e = 0;
  for (let t = 0, n = r.length, a = n - 1, o, i; t < n; a = t++)
    o = r[t], i = r[a], e += (i.x - o.x) * (o.y + i.y);
  return e;
}
var Zl = 6378.137;
var na = 1 / 298.257223563;
var aa = na * (2 - na);
var oa = Math.PI / 180;
var Ln = class {
  constructor(e) {
    const t = oa * Zl * 1e3, n = Math.cos(e * oa), a = 1 / (1 - aa * (1 - n * n)), o = Math.sqrt(a);
    this.kx = t * o * n, this.ky = t * o * a * (1 - aa);
  }
  /**
   * Given two points of the form [longitude, latitude], returns the distance.
   *
   * @param a - point [longitude, latitude]
   * @param b - point [longitude, latitude]
   * @returns distance
   * @example
   * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
   * //=distance
   */
  distance(e, t) {
    const n = this.wrap(e[0] - t[0]) * this.kx, a = (e[1] - t[1]) * this.ky;
    return Math.sqrt(n * n + a * a);
  }
  /**
   * Returns an object of the form {point, index, t}, where point is closest point on the line
   * from the given point, index is the start index of the segment with the closest point,
   * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
   *
   * @param line - an array of points that form the line
   * @param p - point [longitude, latitude]
   * @returns the nearest point, its index in the array and the proportion along the line
   * @example
   * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
   * //=point
   */
  pointOnLine(e, t) {
    let n = 1 / 0, a, o, i, s;
    for (let l = 0; l < e.length - 1; l++) {
      let u = e[l][0], c = e[l][1], p = this.wrap(e[l + 1][0] - u) * this.kx, f2 = (e[l + 1][1] - c) * this.ky, d = 0;
      (p !== 0 || f2 !== 0) && (d = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c) * this.ky * f2) / (p * p + f2 * f2), d > 1 ? (u = e[l + 1][0], c = e[l + 1][1]) : d > 0 && (u += p / this.kx * d, c += f2 / this.ky * d)), p = this.wrap(t[0] - u) * this.kx, f2 = (t[1] - c) * this.ky;
      const h = p * p + f2 * f2;
      h < n && (n = h, a = u, o = c, i = l, s = d);
    }
    return {
      point: [a, o],
      index: i,
      t: Math.max(0, Math.min(1, s))
    };
  }
  wrap(e) {
    for (; e < -180; )
      e += 360;
    for (; e > 180; )
      e -= 360;
    return e;
  }
};
var Vr = 100;
var Gr = 50;
function go(r, e) {
  return e[0] - r[0];
}
function Xt(r) {
  return r[1] - r[0] + 1;
}
function Ce(r, e) {
  return r[1] >= r[0] && r[1] < e;
}
function Hr(r, e) {
  if (r[0] > r[1])
    return [null, null];
  const t = Xt(r);
  if (e) {
    if (t === 2)
      return [r, null];
    const a = Math.floor(t / 2);
    return [
      [r[0], r[0] + a],
      [r[0] + a, r[1]]
    ];
  }
  if (t === 1)
    return [r, null];
  const n = Math.floor(t / 2) - 1;
  return [
    [r[0], r[0] + n],
    [r[0] + n + 1, r[1]]
  ];
}
function Kr(r, e) {
  if (!Ce(e, r.length))
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let n = e[0]; n <= e[1]; ++n)
    _t(t, r[n]);
  return t;
}
function Zr(r) {
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (const t of r)
    for (const n of t)
      _t(e, n);
  return e;
}
function ia(r) {
  return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0;
}
function En(r, e, t) {
  if (!ia(r) || !ia(e))
    return NaN;
  let n = 0, a = 0;
  return r[2] < e[0] && (n = e[0] - r[2]), r[0] > e[2] && (n = r[0] - e[2]), r[1] > e[3] && (a = r[1] - e[3]), r[3] < e[1] && (a = e[1] - r[3]), t.distance([0, 0], [n, a]);
}
function Be(r, e, t) {
  const n = t.pointOnLine(e, r);
  return t.distance(r, n.point);
}
function Cn(r, e, t, n, a) {
  const o = Math.min(Be(r, [t, n], a), Be(e, [t, n], a)), i = Math.min(Be(t, [r, e], a), Be(n, [r, e], a));
  return Math.min(o, i);
}
function Xl(r, e, t, n, a) {
  if (!(Ce(e, r.length) && Ce(n, t.length)))
    return 1 / 0;
  let i = 1 / 0;
  for (let s = e[0]; s < e[1]; ++s) {
    const l = r[s], u = r[s + 1];
    for (let c = n[0]; c < n[1]; ++c) {
      const p = t[c], f2 = t[c + 1];
      if (yr(l, u, p, f2))
        return 0;
      i = Math.min(i, Cn(l, u, p, f2, a));
    }
  }
  return i;
}
function Yl(r, e, t, n, a) {
  if (!(Ce(e, r.length) && Ce(n, t.length)))
    return NaN;
  let i = 1 / 0;
  for (let s = e[0]; s <= e[1]; ++s)
    for (let l = n[0]; l <= n[1]; ++l)
      if (i = Math.min(i, a.distance(r[s], t[l])), i === 0)
        return i;
  return i;
}
function Wl(r, e, t) {
  if (ct(r, e, true))
    return 0;
  let n = 1 / 0;
  for (const a of e) {
    const o = a[0], i = a[a.length - 1];
    if (o !== i && (n = Math.min(n, Be(r, [i, o], t)), n === 0))
      return n;
    const s = t.pointOnLine(a, r);
    if (n = Math.min(n, t.distance(r, s.point)), n === 0)
      return n;
  }
  return n;
}
function Jl(r, e, t, n) {
  if (!Ce(e, r.length))
    return NaN;
  for (let o = e[0]; o <= e[1]; ++o)
    if (ct(r[o], t, true))
      return 0;
  let a = 1 / 0;
  for (let o = e[0]; o < e[1]; ++o) {
    const i = r[o], s = r[o + 1];
    for (const l of t)
      for (let u = 0, c = l.length, p = c - 1; u < c; p = u++) {
        const f2 = l[p], d = l[u];
        if (yr(i, s, f2, d))
          return 0;
        a = Math.min(a, Cn(i, s, f2, d, n));
      }
  }
  return a;
}
function sa(r, e) {
  for (const t of r)
    for (const n of t)
      if (ct(n, e, true))
        return true;
  return false;
}
function Ql(r, e, t, n = 1 / 0) {
  const a = Zr(r), o = Zr(e);
  if (n !== 1 / 0 && En(a, o, t) >= n)
    return n;
  if (xt(a, o)) {
    if (sa(r, e))
      return 0;
  } else if (sa(e, r))
    return 0;
  let i = 1 / 0;
  for (const s of r)
    for (let l = 0, u = s.length, c = u - 1; l < u; c = l++) {
      const p = s[c], f2 = s[l];
      for (const d of e)
        for (let h = 0, m = d.length, g = m - 1; h < m; g = h++) {
          const b = d[g], v = d[h];
          if (yr(p, f2, b, v))
            return 0;
          i = Math.min(i, Cn(p, f2, b, v, t));
        }
    }
  return i;
}
function la(r, e, t, n, a, o) {
  if (!o)
    return;
  const i = En(Kr(n, o), a, t);
  i < e && r.push([i, o, [0, 0]]);
}
function Ft(r, e, t, n, a, o, i) {
  if (!o || !i)
    return;
  const s = En(Kr(n, o), Kr(a, i), t);
  s < e && r.push([s, o, i]);
}
function Yt(r, e, t, n, a = 1 / 0) {
  let o = Math.min(n.distance(r[0], t[0][0]), a);
  if (o === 0)
    return o;
  const i = new yo([[0, [0, r.length - 1], [0, 0]]], go), s = Zr(t);
  for (; i.length > 0; ) {
    const l = i.pop();
    if (l[0] >= o)
      continue;
    const u = l[1], c = e ? Gr : Vr;
    if (Xt(u) <= c) {
      if (!Ce(u, r.length))
        return NaN;
      if (e) {
        const p = Jl(r, u, t, n);
        if (isNaN(p) || p === 0)
          return p;
        o = Math.min(o, p);
      } else
        for (let p = u[0]; p <= u[1]; ++p) {
          const f2 = Wl(r[p], t, n);
          if (o = Math.min(o, f2), o === 0)
            return 0;
        }
    } else {
      const p = Hr(u, e);
      la(i, o, n, r, s, p[0]), la(i, o, n, r, s, p[1]);
    }
  }
  return o;
}
function Wt(r, e, t, n, a, o = 1 / 0) {
  let i = Math.min(o, a.distance(r[0], t[0]));
  if (i === 0)
    return i;
  const s = new yo([[0, [0, r.length - 1], [0, t.length - 1]]], go);
  for (; s.length > 0; ) {
    const l = s.pop();
    if (l[0] >= i)
      continue;
    const u = l[1], c = l[2], p = e ? Gr : Vr, f2 = n ? Gr : Vr;
    if (Xt(u) <= p && Xt(c) <= f2) {
      if (!Ce(u, r.length) && Ce(c, t.length))
        return NaN;
      let d;
      if (e && n)
        d = Xl(r, u, t, c, a), i = Math.min(i, d);
      else if (e && !n) {
        const h = r.slice(u[0], u[1] + 1);
        for (let m = c[0]; m <= c[1]; ++m)
          if (d = Be(t[m], h, a), i = Math.min(i, d), i === 0)
            return i;
      } else if (!e && n) {
        const h = t.slice(c[0], c[1] + 1);
        for (let m = u[0]; m <= u[1]; ++m)
          if (d = Be(r[m], h, a), i = Math.min(i, d), i === 0)
            return i;
      } else
        d = Yl(r, u, t, c, a), i = Math.min(i, d);
    } else {
      const d = Hr(u, e), h = Hr(c, n);
      Ft(s, i, a, r, t, d[0], h[0]), Ft(s, i, a, r, t, d[0], h[1]), Ft(s, i, a, r, t, d[1], h[0]), Ft(s, i, a, r, t, d[1], h[1]);
    }
  }
  return i;
}
function eu(r, e) {
  const t = r.geometry(), n = t.flat().map((i) => xn([i.x, i.y], r.canonical));
  if (t.length === 0)
    return NaN;
  const a = new Ln(n[0][1]);
  let o = 1 / 0;
  for (const i of e) {
    switch (i.type) {
      case "Point":
        o = Math.min(o, Wt(n, false, [i.coordinates], false, a, o));
        break;
      case "LineString":
        o = Math.min(o, Wt(n, false, i.coordinates, true, a, o));
        break;
      case "Polygon":
        o = Math.min(o, Yt(n, false, i.coordinates, a, o));
        break;
    }
    if (o === 0)
      return o;
  }
  return o;
}
function tu(r, e) {
  const t = r.geometry(), n = t.flat().map((i) => xn([i.x, i.y], r.canonical));
  if (t.length === 0)
    return NaN;
  const a = new Ln(n[0][1]);
  let o = 1 / 0;
  for (const i of e) {
    switch (i.type) {
      case "Point":
        o = Math.min(o, Wt(n, true, [i.coordinates], false, a, o));
        break;
      case "LineString":
        o = Math.min(o, Wt(n, true, i.coordinates, true, a, o));
        break;
      case "Polygon":
        o = Math.min(o, Yt(n, true, i.coordinates, a, o));
        break;
    }
    if (o === 0)
      return o;
  }
  return o;
}
function ru(r, e) {
  const t = r.geometry();
  if (t.length === 0 || t[0].length === 0)
    return NaN;
  const n = Hl(t).map((i) => i.map((s) => s.map((l) => xn([l.x, l.y], r.canonical)))), a = new Ln(n[0][0][0][1]);
  let o = 1 / 0;
  for (const i of e)
    for (const s of n) {
      switch (i.type) {
        case "Point":
          o = Math.min(o, Yt([i.coordinates], false, s, a, o));
          break;
        case "LineString":
          o = Math.min(o, Yt(i.coordinates, true, s, a, o));
          break;
        case "Polygon":
          o = Math.min(o, Ql(s, i.coordinates, a, o));
          break;
      }
      if (o === 0)
        return o;
    }
  return o;
}
function Mr(r) {
  return r.type === "MultiPolygon" ? r.coordinates.map((e) => ({
    type: "Polygon",
    coordinates: e
  })) : r.type === "MultiLineString" ? r.coordinates.map((e) => ({
    type: "LineString",
    coordinates: e
  })) : r.type === "MultiPoint" ? r.coordinates.map((e) => ({
    type: "Point",
    coordinates: e
  })) : [r];
}
var Ke = class _Ke {
  constructor(e, t) {
    this.type = S, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (wt(e[1])) {
      const n = e[1];
      if (n.type === "FeatureCollection")
        return new _Ke(n, n.features.map((a) => Mr(a.geometry)).flat());
      if (n.type === "Feature")
        return new _Ke(n, Mr(n.geometry));
      if ("type" in n && "coordinates" in n)
        return new _Ke(n, Mr(n));
    }
    return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point")
        return eu(e, this.geometries);
      if (e.geometryType() === "LineString")
        return tu(e, this.geometries);
      if (e.geometryType() === "Polygon")
        return ru(e, this.geometries);
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var Mt = class _Mt {
  constructor(e) {
    this.type = _, this.key = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    const n = e[1];
    return n == null ? t.error("Global state property must be defined.") : typeof n != "string" ? t.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new _Mt(n);
  }
  evaluate(e) {
    var t;
    const n = (t = e.globals) === null || t === void 0 ? void 0 : t.globalState;
    return !n || Object.keys(n).length === 0 ? null : ht(n, this.key);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
var An = {
  // special forms
  "==": Cl,
  "!=": Al,
  ">": Il,
  "<": Tl,
  ">=": Ml,
  "<=": _l,
  array: fe,
  at: hn,
  boolean: fe,
  case: gn,
  coalesce: St,
  collator: mr,
  format: bn,
  image: wn,
  in: mn,
  "index-of": Kt,
  interpolate: Se,
  "interpolate-hcl": Se,
  "interpolate-lab": Se,
  length: Sn,
  let: fr,
  literal: it,
  match: yn,
  number: fe,
  "number-format": vn,
  object: fe,
  slice: Zt,
  step: hr,
  string: fe,
  "to-boolean": Re,
  "to-color": Re,
  "to-number": Re,
  "to-string": Re,
  var: dr,
  within: He,
  distance: Ke,
  "global-state": Mt
};
var me = class _me {
  constructor(e, t, n, a) {
    this.name = e, this.type = t, this._evaluate = n, this.args = a;
  }
  evaluate(e) {
    return this._evaluate(e, this.args);
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return false;
  }
  static parse(e, t) {
    const n = e[0], a = _me.definitions[n];
    if (!a)
      return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
    const o = Array.isArray(a) ? a[0] : a.type, i = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, s = i.filter(
      ([u]) => !Array.isArray(u) || // varags
      u.length === e.length - 1
      // correct param count
    );
    let l = null;
    for (const [u, c] of s) {
      l = new pr(t.registry, Jt, t.path, null, t.scope);
      const p = [];
      let f2 = false;
      for (let d = 1; d < e.length; d++) {
        const h = e[d], m = Array.isArray(u) ? u[d - 1] : u.type, g = l.parse(h, 1 + p.length, m);
        if (!g) {
          f2 = true;
          break;
        }
        p.push(g);
      }
      if (!f2) {
        if (Array.isArray(u) && u.length !== p.length) {
          l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);
          continue;
        }
        for (let d = 0; d < p.length; d++) {
          const h = Array.isArray(u) ? u[d] : u.type, m = p[d];
          l.concat(d + 1).checkSubtype(h, m.type);
        }
        if (l.errors.length === 0)
          return new _me(n, o, c, p);
      }
    }
    if (s.length === 1)
      t.errors.push(...l.errors);
    else {
      const c = (s.length ? s : i).map(([f2]) => au(f2)).join(" | "), p = [];
      for (let f2 = 1; f2 < e.length; f2++) {
        const d = t.parse(e[f2], 1 + p.length);
        if (!d)
          return null;
        p.push(D(d.type));
      }
      t.error(`Expected arguments of type ${c}, but found (${p.join(", ")}) instead.`);
    }
    return null;
  }
  static register(e, t) {
    _me.definitions = t;
    for (const n in t)
      e[n] = _me;
  }
};
function ua(r, [e, t, n, a]) {
  e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);
  const o = a ? a.evaluate(r) : 1, i = so(e, t, n, o);
  if (i)
    throw new V(i);
  return new $(e / 255, t / 255, n / 255, o, false);
}
function ca(r, e) {
  return r in e;
}
function Pr(r, e) {
  const t = e[r];
  return typeof t > "u" ? null : t;
}
function nu(r, e, t, n) {
  for (; t <= n; ) {
    const a = t + n >> 1;
    if (e[a] === r)
      return true;
    e[a] > r ? n = a - 1 : t = a + 1;
  }
  return false;
}
function De(r) {
  return { type: r };
}
me.register(An, {
  error: [
    Ws,
    [P],
    (r, [e]) => {
      throw new V(e.evaluate(r));
    }
  ],
  typeof: [P, [_], (r, [e]) => D(H(e.evaluate(r)))],
  "to-rgba": [
    ae(S, 4),
    [be],
    (r, [e]) => {
      const [t, n, a, o] = e.evaluate(r).rgb;
      return [t * 255, n * 255, a * 255, o];
    }
  ],
  rgb: [be, [S, S, S], ua],
  rgba: [be, [S, S, S, S], ua],
  has: {
    type: M,
    overloads: [
      [[P], (r, [e]) => ca(e.evaluate(r), r.properties())],
      [
        [P, qe],
        (r, [e, t]) => ca(e.evaluate(r), t.evaluate(r))
      ]
    ]
  },
  get: {
    type: _,
    overloads: [
      [[P], (r, [e]) => Pr(e.evaluate(r), r.properties())],
      [
        [P, qe],
        (r, [e, t]) => Pr(e.evaluate(r), t.evaluate(r))
      ]
    ]
  },
  "feature-state": [
    _,
    [P],
    (r, [e]) => Pr(e.evaluate(r), r.featureState || {})
  ],
  properties: [qe, [], (r) => r.properties()],
  "geometry-type": [P, [], (r) => r.geometryType()],
  id: [_, [], (r) => r.id()],
  zoom: [S, [], (r) => r.globals.zoom],
  "heatmap-density": [S, [], (r) => r.globals.heatmapDensity || 0],
  elevation: [S, [], (r) => r.globals.elevation || 0],
  "line-progress": [S, [], (r) => r.globals.lineProgress || 0],
  accumulated: [
    _,
    [],
    (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated
  ],
  "+": [
    S,
    De(S),
    (r, e) => {
      let t = 0;
      for (const n of e)
        t += n.evaluate(r);
      return t;
    }
  ],
  "*": [
    S,
    De(S),
    (r, e) => {
      let t = 1;
      for (const n of e)
        t *= n.evaluate(r);
      return t;
    }
  ],
  "-": {
    type: S,
    overloads: [
      [[S, S], (r, [e, t]) => e.evaluate(r) - t.evaluate(r)],
      [[S], (r, [e]) => -e.evaluate(r)]
    ]
  },
  "/": [S, [S, S], (r, [e, t]) => e.evaluate(r) / t.evaluate(r)],
  "%": [S, [S, S], (r, [e, t]) => e.evaluate(r) % t.evaluate(r)],
  ln2: [S, [], () => Math.LN2],
  pi: [S, [], () => Math.PI],
  e: [S, [], () => Math.E],
  "^": [
    S,
    [S, S],
    (r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))
  ],
  sqrt: [S, [S], (r, [e]) => Math.sqrt(e.evaluate(r))],
  log10: [S, [S], (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10],
  ln: [S, [S], (r, [e]) => Math.log(e.evaluate(r))],
  log2: [S, [S], (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2],
  sin: [S, [S], (r, [e]) => Math.sin(e.evaluate(r))],
  cos: [S, [S], (r, [e]) => Math.cos(e.evaluate(r))],
  tan: [S, [S], (r, [e]) => Math.tan(e.evaluate(r))],
  asin: [S, [S], (r, [e]) => Math.asin(e.evaluate(r))],
  acos: [S, [S], (r, [e]) => Math.acos(e.evaluate(r))],
  atan: [S, [S], (r, [e]) => Math.atan(e.evaluate(r))],
  min: [
    S,
    De(S),
    (r, e) => Math.min(...e.map((t) => t.evaluate(r)))
  ],
  max: [
    S,
    De(S),
    (r, e) => Math.max(...e.map((t) => t.evaluate(r)))
  ],
  abs: [S, [S], (r, [e]) => Math.abs(e.evaluate(r))],
  round: [
    S,
    [S],
    (r, [e]) => {
      const t = e.evaluate(r);
      return t < 0 ? -Math.round(-t) : Math.round(t);
    }
  ],
  floor: [S, [S], (r, [e]) => Math.floor(e.evaluate(r))],
  ceil: [S, [S], (r, [e]) => Math.ceil(e.evaluate(r))],
  "filter-==": [
    M,
    [P, _],
    (r, [e, t]) => r.properties()[e.value] === t.value
  ],
  "filter-id-==": [M, [_], (r, [e]) => r.id() === e.value],
  "filter-type-==": [
    M,
    [P],
    (r, [e]) => r.geometryType() === e.value
  ],
  "filter-<": [
    M,
    [P, _],
    (r, [e, t]) => {
      const n = r.properties()[e.value], a = t.value;
      return typeof n == typeof a && n < a;
    }
  ],
  "filter-id-<": [
    M,
    [_],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t < n;
    }
  ],
  "filter->": [
    M,
    [P, _],
    (r, [e, t]) => {
      const n = r.properties()[e.value], a = t.value;
      return typeof n == typeof a && n > a;
    }
  ],
  "filter-id->": [
    M,
    [_],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t > n;
    }
  ],
  "filter-<=": [
    M,
    [P, _],
    (r, [e, t]) => {
      const n = r.properties()[e.value], a = t.value;
      return typeof n == typeof a && n <= a;
    }
  ],
  "filter-id-<=": [
    M,
    [_],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t <= n;
    }
  ],
  "filter->=": [
    M,
    [P, _],
    (r, [e, t]) => {
      const n = r.properties()[e.value], a = t.value;
      return typeof n == typeof a && n >= a;
    }
  ],
  "filter-id->=": [
    M,
    [_],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t >= n;
    }
  ],
  "filter-has": [M, [_], (r, [e]) => e.value in r.properties()],
  "filter-has-id": [M, [], (r) => r.id() !== null && r.id() !== void 0],
  "filter-type-in": [
    M,
    [ae(P)],
    (r, [e]) => e.value.indexOf(r.geometryType()) >= 0
  ],
  "filter-id-in": [
    M,
    [ae(_)],
    (r, [e]) => e.value.indexOf(r.id()) >= 0
  ],
  "filter-in-small": [
    M,
    [P, ae(_)],
    // assumes v is an array literal
    (r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0
  ],
  "filter-in-large": [
    M,
    [P, ae(_)],
    // assumes v is a array literal with values sorted in ascending order and of a single type
    (r, [e, t]) => nu(r.properties()[e.value], t.value, 0, t.value.length - 1)
  ],
  all: {
    type: M,
    overloads: [
      [[M, M], (r, [e, t]) => e.evaluate(r) && t.evaluate(r)],
      [
        De(M),
        (r, e) => {
          for (const t of e)
            if (!t.evaluate(r))
              return false;
          return true;
        }
      ]
    ]
  },
  any: {
    type: M,
    overloads: [
      [[M, M], (r, [e, t]) => e.evaluate(r) || t.evaluate(r)],
      [
        De(M),
        (r, e) => {
          for (const t of e)
            if (t.evaluate(r))
              return true;
          return false;
        }
      ]
    ]
  },
  "!": [M, [M], (r, [e]) => !e.evaluate(r)],
  "is-supported-script": [
    M,
    [P],
    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    (r, [e]) => {
      const t = r.globals && r.globals.isSupportedScript;
      return t ? t(e.evaluate(r)) : true;
    }
  ],
  upcase: [P, [P], (r, [e]) => e.evaluate(r).toUpperCase()],
  downcase: [P, [P], (r, [e]) => e.evaluate(r).toLowerCase()],
  concat: [
    P,
    De(_),
    (r, e) => e.map((t) => mt(t.evaluate(r))).join("")
  ],
  "resolved-locale": [
    P,
    [ir],
    (r, [e]) => e.evaluate(r).resolvedLocale()
  ]
});
function au(r) {
  return Array.isArray(r) ? `(${r.map(D).join(", ")})` : `(${D(r.type)}...)`;
}
function Jt(r) {
  if (r instanceof dr)
    return Jt(r.boundExpression);
  if (r instanceof me && r.name === "error")
    return false;
  if (r instanceof mr)
    return false;
  if (r instanceof He)
    return false;
  if (r instanceof Ke)
    return false;
  if (r instanceof Mt)
    return false;
  const e = r instanceof Re || r instanceof fe;
  let t = true;
  return r.eachChild((n) => {
    e ? t = t && Jt(n) : t = t && n instanceof it;
  }), t ? gr(r) && vr(r, [
    "zoom",
    "heatmap-density",
    "elevation",
    "line-progress",
    "accumulated",
    "is-supported-script"
  ]) : false;
}
function gr(r) {
  if (r instanceof me) {
    if (r.name === "get" && r.args.length === 1)
      return false;
    if (r.name === "feature-state")
      return false;
    if (r.name === "has" && r.args.length === 1)
      return false;
    if (r.name === "properties" || r.name === "geometry-type" || r.name === "id")
      return false;
    if (/^filter-/.test(r.name))
      return false;
  }
  if (r instanceof He || r instanceof Ke)
    return false;
  let e = true;
  return r.eachChild((t) => {
    e && !gr(t) && (e = false);
  }), e;
}
function kt(r) {
  if (r instanceof me && r.name === "feature-state")
    return false;
  let e = true;
  return r.eachChild((t) => {
    e && !kt(t) && (e = false);
  }), e;
}
function vr(r, e) {
  if (r instanceof me && e.indexOf(r.name) >= 0)
    return false;
  let t = true;
  return r.eachChild((n) => {
    t && !vr(n, e) && (t = false);
  }), t;
}
function Xr(r) {
  return { result: "success", value: r };
}
function tt(r) {
  return { result: "error", value: r };
}
function Qt(r) {
  return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
}
function vo(r) {
  return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
}
function bo(r) {
  return !!r.expression && r.expression.interpolated;
}
function R(r) {
  return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
}
function Tn(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r) && H(r) === qe;
}
var ou = class {
  constructor(e, t, n) {
    this.expression = e, this._warningHistory = {}, this._evaluator = new lo(), this._defaultValue = t ? lu(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null, this._globalState = n;
  }
  evaluateWithoutErrorHandling(e, t, n, a, o, i) {
    return this._globalState && (e = st(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i, this.expression.evaluate(this._evaluator);
  }
  evaluate(e, t, n, a, o, i) {
    this._globalState && (e = st(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i || null;
    try {
      const s = this.expression.evaluate(this._evaluator);
      if (s == null || typeof s == "number" && s !== s)
        return this._defaultValue;
      if (this._enumValues && !(s in this._enumValues))
        throw new V(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s)} instead.`);
      return s;
    } catch (s) {
      return this._warningHistory[s.message] || (this._warningHistory[s.message] = true, typeof console < "u" && console.warn(s.message)), this._defaultValue;
    }
  }
};
function wo(r) {
  return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in An;
}
function So(r, e, t) {
  const n = new pr(An, Jt, [], e ? su(e) : void 0), a = n.parse(r, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return a ? Xr(new ou(a, e, t)) : tt(n.errors);
}
var pa = class {
  constructor(e, t, n) {
    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !kt(t.expression), this.globalStateRefs = In(t.expression), this._globalState = n;
  }
  evaluateWithoutErrorHandling(e, t, n, a, o, i) {
    return this._globalState && (e = st(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
  }
  evaluate(e, t, n, a, o, i) {
    return this._globalState && (e = st(e, this._globalState)), this._styleExpression.evaluate(e, t, n, a, o, i);
  }
};
var fa = class {
  constructor(e, t, n, a, o) {
    this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== "camera" && !kt(t.expression), this.globalStateRefs = In(t.expression), this.interpolationType = a, this._globalState = o;
  }
  evaluateWithoutErrorHandling(e, t, n, a, o, i) {
    return this._globalState && (e = st(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
  }
  evaluate(e, t, n, a, o, i) {
    return this._globalState && (e = st(e, this._globalState)), this._styleExpression.evaluate(e, t, n, a, o, i);
  }
  interpolationFactor(e, t, n) {
    return this.interpolationType ? Se.interpolationFactor(this.interpolationType, e, t, n) : 0;
  }
};
function iu(r, e, t) {
  const n = So(r, e, t);
  if (n.result === "error")
    return n;
  const a = n.value.expression, o = gr(a);
  if (!o && !Qt(e))
    return tt([new ve("", "data expressions not supported")]);
  const i = vr(a, ["zoom"]);
  if (!i && !vo(e))
    return tt([new ve("", "zoom expressions not supported")]);
  const s = Bt(a);
  if (!s && !i)
    return tt([
      new ve("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')
    ]);
  if (s instanceof ve)
    return tt([s]);
  if (s instanceof Se && !bo(e))
    return tt([
      new ve("", '"interpolate" expressions cannot be used with this property')
    ]);
  if (!s)
    return Xr(o ? new pa("constant", n.value, t) : new pa("source", n.value, t));
  const l = s instanceof Se ? s.interpolation : void 0;
  return Xr(o ? new fa("camera", n.value, s.labels, l, t) : new fa("composite", n.value, s.labels, l, t));
}
function Bt(r) {
  let e = null;
  if (r instanceof fr)
    e = Bt(r.result);
  else if (r instanceof St) {
    for (const t of r.args)
      if (e = Bt(t), e)
        break;
  } else (r instanceof hr || r instanceof Se) && r.input instanceof me && r.input.name === "zoom" && (e = r);
  return e instanceof ve || r.eachChild((t) => {
    const n = Bt(t);
    n instanceof ve ? e = n : !e && n ? e = new ve("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && n && e !== n && (e = new ve("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), e;
}
function In(r, e = /* @__PURE__ */ new Set()) {
  return r instanceof Mt && e.add(r.key), r.eachChild((t) => {
    In(t, e);
  }), e;
}
function su(r) {
  const e = {
    color: be,
    string: P,
    number: S,
    enum: P,
    boolean: M,
    formatted: sr,
    padding: lr,
    numberArray: ur,
    colorArray: gt,
    projectionDefinition: or,
    resolvedImage: It,
    variableAnchorOffsetCollection: cr
  };
  return r.type === "array" ? ae(e[r.value] || _, r.length) : e[r.type];
}
function lu(r) {
  if (r.type === "color" && Tn(r.default))
    return new $(0, 0, 0, 0);
  switch (r.type) {
    case "color":
      return $.parse(r.default) || null;
    case "padding":
      return de.parse(r.default) || null;
    case "numberArray":
      return he.parse(r.default) || null;
    case "colorArray":
      return oe.parse(r.default) || null;
    case "variableAnchorOffsetCollection":
      return we.parse(r.default) || null;
    case "projectionDefinition":
      return pe.parse(r.default) || null;
    default:
      return r.default === void 0 ? null : r.default;
  }
}
function st(r, e) {
  const { zoom: t, heatmapDensity: n, elevation: a, lineProgress: o, isSupportedScript: i, accumulated: s } = r ?? {};
  return {
    zoom: t,
    heatmapDensity: n,
    elevation: a,
    lineProgress: o,
    isSupportedScript: i,
    accumulated: s,
    globalState: e
  };
}
function xo(r) {
  if (r === true || r === false)
    return true;
  if (!Array.isArray(r) || r.length === 0)
    return false;
  switch (r[0]) {
    case "has":
      return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
    case "in":
      return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
    case "!in":
    case "!has":
    case "none":
      return false;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
    case "any":
    case "all":
      for (const e of r.slice(1))
        if (!xo(e) && typeof e != "boolean")
          return false;
      return true;
    default:
      return true;
  }
}
function ko(r) {
  const e = r.key, t = r.value;
  return t ? [new w(e, t, "constants have been deprecated as of v8")] : [];
}
function G(r) {
  return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
}
function Xe(r) {
  if (Array.isArray(r))
    return r.map(Xe);
  if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
    const e = {};
    for (const t in r)
      e[t] = Xe(r[t]);
    return e;
  }
  return G(r);
}
function ie(r) {
  const e = r.key, t = r.value, n = r.valueSpec || {}, a = r.objectElementValidators || {}, o = r.style, i = r.styleSpec, s = r.validateSpec;
  let l = [];
  const u = R(t);
  if (u !== "object")
    return [new w(e, t, `object expected, ${u} found`)];
  for (const c in t) {
    const p = c.split(".")[0], f2 = ht(n, p) || n["*"];
    let d;
    if (ht(a, p))
      d = a[p];
    else if (ht(n, p)) {
      if (t[c] === void 0)
        continue;
      d = s;
    } else if (a["*"])
      d = a["*"];
    else if (n["*"])
      d = s;
    else {
      l.push(new w(e, t[c], `unknown property "${c}"`));
      continue;
    }
    l = l.concat(d({
      key: (e && `${e}.`) + c,
      value: t[c],
      valueSpec: f2,
      style: o,
      styleSpec: i,
      object: t,
      objectKey: c,
      validateSpec: s
    }, t));
  }
  for (const c in n)
    a[c] || n[c].required && n[c].default === void 0 && t[c] === void 0 && l.push(new w(e, t, `missing required property "${c}"`));
  return l;
}
function _n(r) {
  const e = r.value, t = r.valueSpec, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.key, s = r.arrayElementValidator || n;
  if (R(e) !== "array")
    return [new w(i, e, `array expected, ${R(e)} found`)];
  if (t.length && e.length !== t.length)
    return [
      new w(i, e, `array length ${t.length} expected, length ${e.length} found`)
    ];
  let l = {
    type: t.value,
    values: t.values
  };
  o.$version < 7 && (l.function = t.function), R(t.value) === "object" && (l = t.value);
  let u = [];
  for (let c = 0; c < e.length; c++)
    u = u.concat(s({
      array: e,
      arrayIndex: c,
      value: e[c],
      valueSpec: l,
      validateSpec: r.validateSpec,
      style: a,
      styleSpec: o,
      key: `${i}[${c}]`
    }));
  return u;
}
function br(r) {
  const e = r.key, t = r.value, n = r.valueSpec;
  let a = R(t);
  return a === "number" && t !== t && (a = "NaN"), a !== "number" ? [new w(e, t, `number expected, ${a} found`)] : "minimum" in n && t < n.minimum ? [
    new w(e, t, `${t} is less than the minimum value ${n.minimum}`)
  ] : "maximum" in n && t > n.maximum ? [
    new w(e, t, `${t} is greater than the maximum value ${n.maximum}`)
  ] : [];
}
function Lo(r) {
  const e = r.valueSpec, t = G(r.value.type);
  let n, a = {}, o, i;
  const s = t !== "categorical" && r.value.property === void 0, l = !s, u = R(r.value.stops) === "array" && R(r.value.stops[0]) === "array" && R(r.value.stops[0][0]) === "object", c = ie({
    key: r.key,
    value: r.value,
    valueSpec: r.styleSpec.function,
    validateSpec: r.validateSpec,
    style: r.style,
    styleSpec: r.styleSpec,
    objectElementValidators: {
      stops: p,
      default: h
    }
  });
  return t === "identity" && s && c.push(new w(r.key, r.value, 'missing required property "property"')), t !== "identity" && !r.value.stops && c.push(new w(r.key, r.value, 'missing required property "stops"')), t === "exponential" && r.valueSpec.expression && !bo(r.valueSpec) && c.push(new w(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (l && !Qt(r.valueSpec) ? c.push(new w(r.key, r.value, "property functions not supported")) : s && !vo(r.valueSpec) && c.push(new w(r.key, r.value, "zoom functions not supported"))), (t === "categorical" || u) && r.value.property === void 0 && c.push(new w(r.key, r.value, '"property" property is required')), c;
  function p(m) {
    if (t === "identity")
      return [
        new w(m.key, m.value, 'identity function may not have a "stops" property')
      ];
    let g = [];
    const b = m.value;
    return g = g.concat(_n({
      key: m.key,
      value: b,
      valueSpec: m.valueSpec,
      validateSpec: m.validateSpec,
      style: m.style,
      styleSpec: m.styleSpec,
      arrayElementValidator: f2
    })), R(b) === "array" && b.length === 0 && g.push(new w(m.key, b, "array must have at least one stop")), g;
  }
  function f2(m) {
    let g = [];
    const b = m.value, v = m.key;
    if (R(b) !== "array")
      return [new w(v, b, `array expected, ${R(b)} found`)];
    if (b.length !== 2)
      return [
        new w(v, b, `array length 2 expected, length ${b.length} found`)
      ];
    if (u) {
      if (R(b[0]) !== "object")
        return [
          new w(v, b, `object expected, ${R(b[0])} found`)
        ];
      if (b[0].zoom === void 0)
        return [new w(v, b, "object stop key must have zoom")];
      if (b[0].value === void 0)
        return [new w(v, b, "object stop key must have value")];
      if (i && i > G(b[0].zoom))
        return [
          new w(v, b[0].zoom, "stop zoom values must appear in ascending order")
        ];
      G(b[0].zoom) !== i && (i = G(b[0].zoom), o = void 0, a = {}), g = g.concat(ie({
        key: `${v}[0]`,
        value: b[0],
        valueSpec: { zoom: {} },
        validateSpec: m.validateSpec,
        style: m.style,
        styleSpec: m.styleSpec,
        objectElementValidators: {
          zoom: br,
          value: d
        }
      }));
    } else
      g = g.concat(d({
        key: `${v}[0]`,
        value: b[0],
        validateSpec: m.validateSpec,
        style: m.style,
        styleSpec: m.styleSpec
      }, b));
    return wo(Xe(b[1])) ? g.concat([
      new w(`${v}[1]`, b[1], "expressions are not allowed in function stops.")
    ]) : g.concat(m.validateSpec({
      key: `${v}[1]`,
      value: b[1],
      valueSpec: e,
      validateSpec: m.validateSpec,
      style: m.style,
      styleSpec: m.styleSpec
    }));
  }
  function d(m, g) {
    const b = R(m.value), v = G(m.value), x = m.value !== null ? m.value : g;
    if (!n)
      n = b;
    else if (b !== n)
      return [
        new w(m.key, x, `${b} stop domain type must match previous stop domain type ${n}`)
      ];
    if (b !== "number" && b !== "string" && b !== "boolean")
      return [
        new w(m.key, x, "stop domain value must be a number, string, or boolean")
      ];
    if (b !== "number" && t !== "categorical") {
      let C = `number expected, ${b} found`;
      return Qt(e) && t === void 0 && (C += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new w(m.key, x, C)];
    }
    return t === "categorical" && b === "number" && (!isFinite(v) || Math.floor(v) !== v) ? [
      new w(m.key, x, `integer expected, found ${v}`)
    ] : t !== "categorical" && b === "number" && o !== void 0 && v < o ? [
      new w(m.key, x, "stop domain values must appear in ascending order")
    ] : (o = v, t === "categorical" && v in a ? [
      new w(m.key, x, "stop domain values must be unique")
    ] : (a[v] = true, []));
  }
  function h(m) {
    return m.validateSpec({
      key: m.key,
      value: m.value,
      valueSpec: e,
      validateSpec: m.validateSpec,
      style: m.style,
      styleSpec: m.styleSpec
    });
  }
}
function lt(r) {
  const e = (r.expressionContext === "property" ? iu : So)(Xe(r.value), r.valueSpec);
  if (e.result === "error")
    return e.value.map((n) => new w(`${r.key}${n.key}`, r.value, n.message));
  const t = e.value.expression || e.value._styleExpression.expression;
  if (r.expressionContext === "property" && r.propertyKey === "text-font" && !t.outputDefined())
    return [
      new w(r.key, r.value, `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)
    ];
  if (r.expressionContext === "property" && r.propertyType === "layout" && !kt(t))
    return [
      new w(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')
    ];
  if (r.expressionContext === "filter" && !kt(t))
    return [
      new w(r.key, r.value, '"feature-state" data expressions are not supported with filters.')
    ];
  if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
    if (!vr(t, ["zoom", "feature-state"]))
      return [
        new w(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
      ];
    if (r.expressionContext === "cluster-initial" && !gr(t))
      return [
        new w(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
      ];
  }
  return [];
}
function uu(r) {
  const e = r.value, t = r.key, n = R(e);
  return n !== "boolean" ? [new w(t, e, `boolean expected, ${n} found`)] : [];
}
function Yr(r) {
  const e = r.key, t = r.value, n = R(t);
  return n !== "string" ? [new w(e, t, `color expected, ${n} found`)] : $.parse(String(t)) ? [] : [new w(e, t, `color expected, "${t}" found`)];
}
function Lt(r) {
  const e = r.key, t = r.value, n = r.valueSpec, a = [];
  return Array.isArray(n.values) ? n.values.indexOf(G(t)) === -1 && a.push(new w(e, t, `expected one of [${n.values.join(", ")}], ${JSON.stringify(t)} found`)) : Object.keys(n.values).indexOf(G(t)) === -1 && a.push(new w(e, t, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(t)} found`)), a;
}
function Mn(r) {
  return xo(Xe(r.value)) ? lt(Ht({}, r, {
    expressionContext: "filter",
    valueSpec: { value: "boolean" }
  })) : Eo(r);
}
function Eo(r) {
  const e = r.value, t = r.key;
  if (R(e) !== "array")
    return [new w(t, e, `array expected, ${R(e)} found`)];
  const n = r.styleSpec;
  let a, o = [];
  if (e.length < 1)
    return [new w(t, e, "filter array must have at least 1 element")];
  switch (o = o.concat(Lt({
    key: `${t}[0]`,
    value: e[0],
    valueSpec: n.filter_operator,
    style: r.style,
    styleSpec: r.styleSpec
  })), G(e[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      e.length >= 2 && G(e[1]) === "$type" && o.push(new w(t, e, `"$type" cannot be use with operator "${e[0]}"`));
    /* falls through */
    case "==":
    case "!=":
      e.length !== 3 && o.push(new w(t, e, `filter array for operator "${e[0]}" must have 3 elements`));
    /* falls through */
    case "in":
    case "!in":
      e.length >= 2 && (a = R(e[1]), a !== "string" && o.push(new w(`${t}[1]`, e[1], `string expected, ${a} found`)));
      for (let i = 2; i < e.length; i++)
        a = R(e[i]), G(e[1]) === "$type" ? o = o.concat(Lt({
          key: `${t}[${i}]`,
          value: e[i],
          valueSpec: n.geometry_type,
          style: r.style,
          styleSpec: r.styleSpec
        })) : a !== "string" && a !== "number" && a !== "boolean" && o.push(new w(`${t}[${i}]`, e[i], `string, number, or boolean expected, ${a} found`));
      break;
    case "any":
    case "all":
    case "none":
      for (let i = 1; i < e.length; i++)
        o = o.concat(Eo({
          key: `${t}[${i}]`,
          value: e[i],
          style: r.style,
          styleSpec: r.styleSpec
        }));
      break;
    case "has":
    case "!has":
      a = R(e[1]), e.length !== 2 ? o.push(new w(t, e, `filter array for "${e[0]}" operator must have 2 elements`)) : a !== "string" && o.push(new w(`${t}[1]`, e[1], `string expected, ${a} found`));
      break;
  }
  return o;
}
function Co(r, e) {
  const t = r.key, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.value, s = r.objectKey, l = o[`${e}_${r.layerType}`];
  if (!l)
    return [];
  const u = s.match(/^(.*)-transition$/);
  if (e === "paint" && u && l[u[1]] && l[u[1]].transition)
    return n({
      key: t,
      value: i,
      valueSpec: o.transition,
      style: a,
      styleSpec: o
    });
  const c = r.valueSpec || l[s];
  if (!c)
    return [new w(t, i, `unknown property "${s}"`)];
  let p;
  if (R(i) === "string" && Qt(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(i)))
    return [
      new w(t, i, `"${s}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(p[1])} }\`.`)
    ];
  const f2 = [];
  return r.layerType === "symbol" && s === "text-font" && Tn(Xe(i)) && G(i.type) === "identity" && f2.push(new w(t, i, '"text-font" does not support identity functions')), f2.concat(n({
    key: r.key,
    value: i,
    valueSpec: c,
    style: a,
    styleSpec: o,
    expressionContext: "property",
    propertyType: e,
    propertyKey: s
  }));
}
function Ao(r) {
  return Co(r, "paint");
}
function To(r) {
  return Co(r, "layout");
}
function Io(r) {
  let e = [];
  const t = r.value, n = r.key, a = r.style, o = r.styleSpec;
  if (R(t) !== "object")
    return [new w(n, t, `object expected, ${R(t)} found`)];
  !t.type && !t.ref && e.push(new w(n, t, 'either "type" or "ref" is required'));
  let i = G(t.type);
  const s = G(t.ref);
  if (t.id) {
    const l = G(t.id);
    for (let u = 0; u < r.arrayIndex; u++) {
      const c = a.layers[u];
      G(c.id) === l && e.push(new w(n, t.id, `duplicate layer id "${t.id}", previously used at line ${c.id.__line__}`));
    }
  }
  if ("ref" in t) {
    ["type", "source", "source-layer", "filter", "layout"].forEach((u) => {
      u in t && e.push(new w(n, t[u], `"${u}" is prohibited for ref layers`));
    });
    let l;
    a.layers.forEach((u) => {
      G(u.id) === s && (l = u);
    }), l ? l.ref ? e.push(new w(n, t.ref, "ref cannot reference another ref layer")) : i = G(l.type) : e.push(new w(n, t.ref, `ref layer "${s}" not found`));
  } else if (i !== "background")
    if (!t.source)
      e.push(new w(n, t, 'missing required property "source"'));
    else {
      const l = a.sources && a.sources[t.source], u = l && G(l.type);
      l ? u === "vector" && i === "raster" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster source`)) : u !== "raster-dem" && i === "hillshade" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u !== "raster-dem" && i === "color-relief" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u === "raster" && i !== "raster" ? e.push(new w(n, t.source, `layer "${t.id}" requires a vector source`)) : u === "vector" && !t["source-layer"] ? e.push(new w(n, t, `layer "${t.id}" must specify a "source-layer"`)) : u === "raster-dem" && i !== "hillshade" && i !== "color-relief" ? e.push(new w(n, t.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : i === "line" && t.paint && t.paint["line-gradient"] && (u !== "geojson" || !l.lineMetrics) && e.push(new w(n, t, `layer "${t.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new w(n, t.source, `source "${t.source}" not found`));
    }
  return e = e.concat(ie({
    key: n,
    value: t,
    valueSpec: o.layer,
    style: r.style,
    styleSpec: r.styleSpec,
    validateSpec: r.validateSpec,
    objectElementValidators: {
      "*"() {
        return [];
      },
      // We don't want to enforce the spec's `"requires": true` for backward compatibility with refs;
      // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.
      type() {
        return r.validateSpec({
          key: `${n}.type`,
          value: t.type,
          valueSpec: o.layer.type,
          style: r.style,
          styleSpec: r.styleSpec,
          validateSpec: r.validateSpec,
          object: t,
          objectKey: "type"
        });
      },
      filter: Mn,
      layout(l) {
        return ie({
          layer: t,
          key: l.key,
          value: l.value,
          style: l.style,
          styleSpec: l.styleSpec,
          validateSpec: l.validateSpec,
          objectElementValidators: {
            "*"(u) {
              return To(Ht({ layerType: i }, u));
            }
          }
        });
      },
      paint(l) {
        return ie({
          layer: t,
          key: l.key,
          value: l.value,
          style: l.style,
          styleSpec: l.styleSpec,
          validateSpec: l.validateSpec,
          objectElementValidators: {
            "*"(u) {
              return Ao(Ht({ layerType: i }, u));
            }
          }
        });
      }
    }
  })), e;
}
function $e(r) {
  const e = r.value, t = r.key, n = R(e);
  return n !== "string" ? [new w(t, e, `string expected, ${n} found`)] : [];
}
function cu(r) {
  var e;
  const t = (e = r.sourceName) !== null && e !== void 0 ? e : "", n = r.value, a = r.styleSpec, o = a.source_raster_dem, i = r.style;
  let s = [];
  const l = R(n);
  if (n === void 0)
    return s;
  if (l !== "object")
    return s.push(new w("source_raster_dem", n, `object expected, ${l} found`)), s;
  const c = G(n.encoding) === "custom", p = ["redFactor", "greenFactor", "blueFactor", "baseShift"], f2 = r.value.encoding ? `"${r.value.encoding}"` : "Default";
  for (const d in n)
    !c && p.includes(d) ? s.push(new w(d, n[d], `In "${t}": "${d}" is only valid when "encoding" is set to "custom". ${f2} encoding found`)) : o[d] ? s = s.concat(r.validateSpec({
      key: d,
      value: n[d],
      valueSpec: o[d],
      validateSpec: r.validateSpec,
      style: i,
      styleSpec: a
    })) : s.push(new w(d, n[d], `unknown property "${d}"`));
  return s;
}
var da = {
  promoteId: pu
};
function _o(r) {
  const e = r.value, t = r.key, n = r.styleSpec, a = r.style, o = r.validateSpec;
  if (!e.type)
    return [new w(t, e, '"type" is required')];
  const i = G(e.type);
  let s;
  switch (i) {
    case "vector":
    case "raster":
      return s = ie({
        key: t,
        value: e,
        valueSpec: n[`source_${i.replace("-", "_")}`],
        style: r.style,
        styleSpec: n,
        objectElementValidators: da,
        validateSpec: o
      }), s;
    case "raster-dem":
      return s = cu({
        sourceName: t,
        value: e,
        style: r.style,
        styleSpec: n,
        validateSpec: o
      }), s;
    case "geojson":
      if (s = ie({
        key: t,
        value: e,
        valueSpec: n.source_geojson,
        style: a,
        styleSpec: n,
        validateSpec: o,
        objectElementValidators: da
      }), e.cluster)
        for (const l in e.clusterProperties) {
          const [u, c] = e.clusterProperties[l], p = typeof u == "string" ? [u, ["accumulated"], ["get", l]] : u;
          s.push(...lt({
            key: `${t}.${l}.map`,
            value: c,
            expressionContext: "cluster-map"
          })), s.push(...lt({
            key: `${t}.${l}.reduce`,
            value: p,
            expressionContext: "cluster-reduce"
          }));
        }
      return s;
    case "video":
      return ie({
        key: t,
        value: e,
        valueSpec: n.source_video,
        style: a,
        validateSpec: o,
        styleSpec: n
      });
    case "image":
      return ie({
        key: t,
        value: e,
        valueSpec: n.source_image,
        style: a,
        validateSpec: o,
        styleSpec: n
      });
    case "canvas":
      return [
        new w(t, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
      ];
    default:
      return Lt({
        key: `${t}.type`,
        value: e.type,
        valueSpec: {
          values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
        }
      });
  }
}
function pu({ key: r, value: e }) {
  if (R(e) === "string")
    return $e({ key: r, value: e });
  {
    const t = [];
    for (const n in e)
      t.push(...$e({ key: `${r}.${n}`, value: e[n] }));
    return t;
  }
}
function Mo(r) {
  const e = r.value, t = r.styleSpec, n = t.light, a = r.style;
  let o = [];
  const i = R(e);
  if (e === void 0)
    return o;
  if (i !== "object")
    return o = o.concat([
      new w("light", e, `object expected, ${i} found`)
    ]), o;
  for (const s in e) {
    const l = s.match(/^(.*)-transition$/);
    l && n[l[1]] && n[l[1]].transition ? o = o.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: t.transition,
      validateSpec: r.validateSpec,
      style: a,
      styleSpec: t
    })) : n[s] ? o = o.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: n[s],
      validateSpec: r.validateSpec,
      style: a,
      styleSpec: t
    })) : o = o.concat([
      new w(s, e[s], `unknown property "${s}"`)
    ]);
  }
  return o;
}
function Po(r) {
  const e = r.value, t = r.styleSpec, n = t.sky, a = r.style, o = R(e);
  if (e === void 0)
    return [];
  if (o !== "object")
    return [new w("sky", e, `object expected, ${o} found`)];
  let i = [];
  for (const s in e)
    n[s] ? i = i.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: n[s],
      style: a,
      styleSpec: t
    })) : i = i.concat([
      new w(s, e[s], `unknown property "${s}"`)
    ]);
  return i;
}
function Ro(r) {
  const e = r.value, t = r.styleSpec, n = t.terrain, a = r.style;
  let o = [];
  const i = R(e);
  if (e === void 0)
    return o;
  if (i !== "object")
    return o = o.concat([
      new w("terrain", e, `object expected, ${i} found`)
    ]), o;
  for (const s in e)
    n[s] ? o = o.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: n[s],
      validateSpec: r.validateSpec,
      style: a,
      styleSpec: t
    })) : o = o.concat([
      new w(s, e[s], `unknown property "${s}"`)
    ]);
  return o;
}
function fu(r) {
  return $e(r).length === 0 ? [] : lt(r);
}
function du(r) {
  return $e(r).length === 0 ? [] : lt(r);
}
function hu(r) {
  const e = r.key, t = r.value;
  if (R(t) === "array") {
    if (t.length < 1 || t.length > 4)
      return [
        new w(e, t, `padding requires 1 to 4 values; ${t.length} values found`)
      ];
    const a = {
      type: "number"
    };
    let o = [];
    for (let i = 0; i < t.length; i++)
      o = o.concat(r.validateSpec({
        key: `${e}[${i}]`,
        value: t[i],
        validateSpec: r.validateSpec,
        valueSpec: a
      }));
    return o;
  } else
    return br({
      key: e,
      value: t,
      valueSpec: {}
    });
}
function mu(r) {
  const e = r.key, t = r.value;
  if (R(t) === "array") {
    const a = {
      type: "number"
    };
    if (t.length < 1)
      return [
        new w(e, t, "array length at least 1 expected, length 0 found")
      ];
    let o = [];
    for (let i = 0; i < t.length; i++)
      o = o.concat(r.validateSpec({
        key: `${e}[${i}]`,
        value: t[i],
        validateSpec: r.validateSpec,
        valueSpec: a
      }));
    return o;
  } else
    return br({
      key: e,
      value: t,
      valueSpec: {}
    });
}
function yu(r) {
  const e = r.key, t = r.value;
  if (R(t) === "array") {
    if (t.length < 1)
      return [
        new w(e, t, "array length at least 1 expected, length 0 found")
      ];
    let a = [];
    for (let o = 0; o < t.length; o++)
      a = a.concat(Yr({
        key: `${e}[${o}]`,
        value: t[o]
      }));
    return a;
  } else
    return Yr({
      key: e,
      value: t
    });
}
function gu(r) {
  const e = r.key, t = r.value, n = R(t), a = r.styleSpec;
  if (n !== "array" || t.length < 1 || t.length % 2 !== 0)
    return [
      new w(e, t, "variableAnchorOffsetCollection requires a non-empty array of even length")
    ];
  let o = [];
  for (let i = 0; i < t.length; i += 2)
    o = o.concat(Lt({
      key: `${e}[${i}]`,
      value: t[i],
      valueSpec: a.layout_symbol["text-anchor"]
    })), o = o.concat(_n({
      key: `${e}[${i + 1}]`,
      value: t[i + 1],
      valueSpec: {
        length: 2,
        value: "number"
      },
      validateSpec: r.validateSpec,
      style: r.style,
      styleSpec: a
    }));
  return o;
}
function Oo(r) {
  let e = [];
  const t = r.value, n = r.key;
  if (Array.isArray(t)) {
    const a = [], o = [];
    for (const i in t) {
      t[i].id && a.includes(t[i].id) && e.push(new w(n, t, `all the sprites' ids must be unique, but ${t[i].id} is duplicated`)), a.push(t[i].id), t[i].url && o.includes(t[i].url) && e.push(new w(n, t, `all the sprites' URLs must be unique, but ${t[i].url} is duplicated`)), o.push(t[i].url);
      const s = {
        id: {
          type: "string",
          required: true
        },
        url: {
          type: "string",
          required: true
        }
      };
      e = e.concat(ie({
        key: `${n}[${i}]`,
        value: t[i],
        valueSpec: s,
        validateSpec: r.validateSpec
      }));
    }
    return e;
  } else
    return $e({
      key: n,
      value: t
    });
}
function vu(r) {
  const e = r.value, t = r.styleSpec, n = t.projection, a = r.style, o = R(e);
  if (e === void 0)
    return [];
  if (o !== "object")
    return [
      new w("projection", e, `object expected, ${o} found`)
    ];
  let i = [];
  for (const s in e)
    n[s] ? i = i.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: n[s],
      style: a,
      styleSpec: t
    })) : i = i.concat([
      new w(s, e[s], `unknown property "${s}"`)
    ]);
  return i;
}
function bu(r) {
  const e = r.key;
  let t = r.value;
  t = t instanceof String ? t.valueOf() : t;
  const n = R(t);
  return n === "array" && !Su(t) && !wu(t) ? [
    new w(e, t, `projection expected, invalid array ${JSON.stringify(t)} found`)
  ] : ["array", "string"].includes(n) ? [] : [
    new w(e, t, `projection expected, invalid type "${n}" found`)
  ];
}
function wu(r) {
  return !!["interpolate", "step", "literal"].includes(r[0]);
}
function Su(r) {
  return Array.isArray(r) && r.length === 3 && typeof r[0] == "string" && typeof r[1] == "string" && typeof r[2] == "number";
}
function zo(r) {
  return !!r && r.constructor === Object;
}
function Fo(r) {
  return zo(r.value) ? [] : [
    new w(r.key, r.value, `object expected, ${R(r.value)} found`)
  ];
}
function xu(r) {
  const e = r.key, t = r.value, n = r.validateSpec, a = r.styleSpec, o = r.style;
  if (!zo(t))
    return [new w(e, t, `object expected, ${R(t)} found`)];
  const i = [];
  for (const s in t) {
    const l = t[s], u = R(l);
    if (u === "string")
      i.push(...$e({
        key: `${e}.${s}`,
        value: l
      }));
    else if (u === "array") {
      const c = {
        url: {
          type: "string",
          required: true
        },
        "unicode-range": {
          type: "array",
          value: "string"
        }
      };
      for (const [p, f2] of l.entries())
        i.push(...ie({
          key: `${e}.${s}[${p}]`,
          value: f2,
          valueSpec: c,
          styleSpec: a,
          style: o,
          validateSpec: n
        }));
    } else
      i.push(new w(`${e}.${s}`, l, `string or array expected, ${u} found`));
  }
  return i;
}
var ha = {
  "*"() {
    return [];
  },
  array: _n,
  boolean: uu,
  number: br,
  color: Yr,
  constants: ko,
  enum: Lt,
  filter: Mn,
  function: Lo,
  layer: Io,
  object: ie,
  source: _o,
  light: Mo,
  sky: Po,
  terrain: Ro,
  projection: vu,
  projectionDefinition: bu,
  string: $e,
  formatted: fu,
  resolvedImage: du,
  padding: hu,
  numberArray: mu,
  colorArray: yu,
  variableAnchorOffsetCollection: gu,
  sprite: Oo,
  state: Fo,
  fontFaces: xu
};
function er(r) {
  const e = r.value, t = r.valueSpec, n = r.styleSpec;
  return r.validateSpec = er, t.expression && Tn(G(e)) ? Lo(r) : t.expression && wo(Xe(e)) ? lt(r) : t.type && ha[t.type] ? ha[t.type](r) : ie(Ht({}, r, {
    valueSpec: t.type ? n[t.type] : t
  }));
}
function $o(r) {
  const e = r.value, t = r.key, n = $e(r);
  return n.length || (e.indexOf("{fontstack}") === -1 && n.push(new w(t, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && n.push(new w(t, e, '"glyphs" url must include a "{range}" token'))), n;
}
function se(r, e = Ys) {
  let t = [];
  return t = t.concat(er({
    key: "",
    value: r,
    valueSpec: e.$root,
    styleSpec: e,
    style: r,
    validateSpec: er,
    objectElementValidators: {
      glyphs: $o,
      "*"() {
        return [];
      }
    }
  })), r.constants && (t = t.concat(ko({
    key: "constants",
    value: r.constants
  }))), No(t);
}
se.source = ge(ye(_o));
se.sprite = ge(ye(Oo));
se.glyphs = ge(ye($o));
se.light = ge(ye(Mo));
se.sky = ge(ye(Po));
se.terrain = ge(ye(Ro));
se.state = ge(ye(Fo));
se.layer = ge(ye(Io));
se.filter = ge(ye(Mn));
se.paintProperty = ge(ye(Ao));
se.layoutProperty = ge(ye(To));
function ye(r) {
  return function(e) {
    return r(Object.assign({}, e, { validateSpec: er }));
  };
}
function No(r) {
  return [].concat(r).sort((e, t) => e.line - t.line);
}
function ge(r) {
  return function(...e) {
    return No(r.apply(this, e));
  };
}
function ma(r) {
  if (!r)
    return {
      style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
      requiresUrlMonitoring: false,
      // default styles don't require URL monitoring
      isFallback: true
    };
  if (typeof r == "string") {
    const t = Lu(r);
    return t.isValidStyle ? {
      style: t.styleObject,
      requiresUrlMonitoring: false,
      isFallback: false
    } : t.isValidJSON ? {
      style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
      requiresUrlMonitoring: false,
      // default styles don't require URL monitoring
      isFallback: true
    } : r.startsWith("http") ? { style: r, requiresUrlMonitoring: true, isFallback: false } : r.toLowerCase().includes(".json") ? {
      style: ku(r),
      requiresUrlMonitoring: true,
      isFallback: false
    } : {
      style: expandMapStyle(r),
      requiresUrlMonitoring: true,
      isFallback: false
    };
  }
  return r instanceof MapStyleVariant ? {
    style: r.getExpandedStyleURL(),
    requiresUrlMonitoring: false,
    isFallback: false
  } : r instanceof ReferenceMapStyle ? {
    style: r.getDefaultVariant().getExpandedStyleURL(),
    requiresUrlMonitoring: false,
    isFallback: false
  } : se(r).length === 0 ? {
    style: r,
    requiresUrlMonitoring: false,
    isFallback: false,
    isJSON: true
  } : {
    style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
    requiresUrlMonitoring: false,
    // default styles don't require URL monitoring
    isFallback: true
  };
}
function ku(r) {
  try {
    return new URL(r).href;
  } catch {
  }
  return new URL(r, location.origin).href;
}
function Lu(r) {
  try {
    const e = JSON.parse(r), t = se(e);
    return {
      isValidJSON: true,
      isValidStyle: t.length === 0,
      styleObject: t.length === 0 ? e : null
    };
  } catch {
    return {
      isValidJSON: false,
      isValidStyle: false,
      styleObject: null
    };
  }
}
function Ee(r, e, t) {
  const n = window.document.createElement(r);
  return e !== void 0 && (n.className = e), t && t.appendChild(n), n;
}
function Et(r) {
  r.parentNode && r.parentNode.removeChild(r);
}
var Eu = class {
  constructor() {
    y(this, "_map");
    y(this, "_container");
    y(this, "_terrainButton");
    Wi(["_toggleTerrain", "_updateTerrainIcon"], this);
  }
  onAdd(e) {
    return this._map = e, this._container = Ee("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Ee("button", "maplibregl-ctrl-terrain", this._container), Ee("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
  }
  onRemove() {
    Et(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
  }
  _toggleTerrain() {
    jo(this._map), this._updateTerrainIcon();
  }
  _updateTerrainIcon() {
    this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.hasTerrain() ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
  }
};
function jo(r) {
  r.hasTerrain() ? r.disableTerrain() : r.enableTerrain();
}
var Cu = class extends Ya {
  constructor(t = {}) {
    super({
      showCompass: t.showCompass ?? true,
      showZoom: t.showZoom ?? true,
      visualizePitch: t.visualizePitch ?? true
    });
    y(this, "_rotateCompassArrow", () => {
      const t2 = this._map.getBearing(), n = this._map.getPitch(), a = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(n * (Math.PI / 180)) ** 0.5)}) rotateX(${Math.min(70, n)}deg) rotateZ(${-t2}deg)` : `rotate(${-t2}deg)`;
      this._compassIcon.style.transform = a;
    });
    this._compass && (this._compass.removeEventListener("click", this._compass.clickFunction), this._compass.addEventListener("click", (n) => {
      this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: n }) : this._map.resetNorth({}, { originalEvent: n });
    }));
  }
  /**
   * Overloading: the button now stores its click callback so that we can later on delete it and replace it
   */
  _createButton(t, n) {
    const a = super._createButton(t, n);
    return a.clickFunction = n, a;
  }
};
var ya = import_maplibre_gl.default.Marker;
var ga = import_maplibre_gl.default.LngLat;
var Au = import_maplibre_gl.default.LngLatBounds;
var Tu = class extends ji {
  constructor() {
    super(...arguments);
    y(this, "lastUpdatedCenter", new ga(0, 0));
    y(this, "_updateCamera", (t) => {
      var c;
      const n = new ga(t.coords.longitude, t.coords.latitude), a = t.coords.accuracy, i = {
        bearing: this._map.getBearing(),
        ...this.options.fitBoundsOptions,
        linear: true
      }, s = this._map.getZoom();
      s > (((c = this.options.fitBoundsOptions) == null ? void 0 : c.maxZoom) ?? 30) && (i.zoom = s), this._map.fitBounds(Au.fromLngLat(n, a), i, {
        geolocateSource: true
        // tag this camera change so it won't cause the control to change to background state
      });
      let l = false;
      const u = () => {
        l = true;
      };
      this._map.once("click", u), this._map.once("dblclick", u), this._map.once("dragstart", u), this._map.once("mousedown", u), this._map.once("touchstart", u), this._map.once("wheel", u), this._map.once("moveend", () => {
        this._map.off("click", u), this._map.off("dblclick", u), this._map.off("dragstart", u), this._map.off("mousedown", u), this._map.off("touchstart", u), this._map.off("wheel", u), !l && (this.lastUpdatedCenter = this._map.getCenter());
      });
    });
    y(this, "_finishSetupUI", (t) => {
      if (this._map) {
        if (t === false) {
          const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.disabled = true, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
        } else {
          const n = this._map._getUIString("GeolocateControl.FindMyLocation");
          this._geolocateButton.disabled = false, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
        }
        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Ee("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ya({ element: this._dotElement }), this._circleElement = Ee("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ya({
          element: this._circleElement,
          pitchAlignment: "map"
        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("move", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("moveend", (n) => {
          const a = n.originalEvent && n.originalEvent.type === "resize", o = this.lastUpdatedCenter.distanceTo(this._map.getCenter());
          !n.geolocateSource && this._watchState === "ACTIVE_LOCK" && !a && o > 1 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new Event("trackuserlocationend")));
        });
      }
    });
    y(this, "_onZoom", () => {
      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
    });
  }
  _updateCircleRadius() {
    if (this._watchState !== "BACKGROUND" && this._watchState !== "ACTIVE_LOCK")
      return;
    const t = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude], n = this._map.project(t), a = this._map.unproject([n.x, n.y]), o = this._map.unproject([n.x + 20, n.y]), i = a.distanceTo(o) / 20, s = Math.ceil(2 * this._accuracy / i);
    this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;
  }
  // We are overwriting the method _setErrorState from Maplibre's GeolocateControl because the
  // case BACKGROUND_ERROR is not dealt with in the original function and yields an error.
  // Related issue: https://github.com/maplibre/maplibre-gl-js/issues/2294
  _setErrorState() {
    switch (this._watchState) {
      case "WAITING_ACTIVE":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
        break;
      case "ACTIVE_LOCK":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "BACKGROUND":
        this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "ACTIVE_ERROR":
        break;
      case "BACKGROUND_ERROR":
        break;
      default:
        throw new Error(`Unexpected watchState ${this._watchState}`);
    }
  }
};
var Te;
var ee;
var Ie;
var _e;
var at2;
var Iu = class {
  /**
   * @param selectorOrElement Element to be used as control, specified as either reference to element itself or a CSS selector to find the element in DOM
   * @param onClick Function called when the element is clicked
   * @param onRender Function called every time the underlying map renders a new state
   */
  constructor(e, t, n) {
    Y(this, Te);
    Y(this, ee);
    Y(this, Ie);
    Y(this, _e);
    Y(this, at2);
    if (typeof e == "string") {
      const a = document.querySelector(e);
      if (!a) throw new Error(`No element has been found with selector "${e}" when creating an external control.`);
      J(this, ee, a);
    } else
      J(this, ee, e);
    t && J(this, Ie, (a) => {
      t(L(this, Te), L(this, ee), a);
    }), n && J(this, _e, (a) => {
      n(L(this, Te), L(this, ee), a);
    }), J(this, at2, L(this, ee).parentElement);
  }
  onAdd(e) {
    return J(this, Te, e), L(this, Ie) && L(this, ee).addEventListener("click", L(this, Ie)), L(this, _e) && L(this, Te).on("render", L(this, _e)), Et(L(this, ee)), L(this, ee);
  }
  onRemove() {
    L(this, Ie) && L(this, ee).removeEventListener("click", L(this, Ie)), L(this, _e) && L(this, Te).off("render", L(this, _e)), L(this, at2) ? L(this, at2).appendChild(L(this, ee)) : Et(L(this, ee));
  }
};
Te = /* @__PURE__ */ new WeakMap(), ee = /* @__PURE__ */ new WeakMap(), Ie = /* @__PURE__ */ new WeakMap(), _e = /* @__PURE__ */ new WeakMap(), at2 = /* @__PURE__ */ new WeakMap();
var _u = class {
  constructor() {
    y(this, "map");
    y(this, "container");
    y(this, "projectionButton");
  }
  onAdd(e) {
    return this.map = e, this.container = Ee("div", "maplibregl-ctrl maplibregl-ctrl-group"), this.projectionButton = Ee("button", "maplibregl-ctrl-projection", this.container), Ee("span", "maplibregl-ctrl-icon", this.projectionButton).setAttribute("aria-hidden", "true"), this.projectionButton.type = "button", this.projectionButton.addEventListener("click", this.toggleProjection.bind(this)), e.on("projectiontransition", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;
  }
  onRemove() {
    Et(this.container), this.map.off("projectiontransition", this.updateProjectionIcon), this.map = void 0;
  }
  toggleProjection() {
    Do(this.map), this.updateProjectionIcon();
  }
  updateProjectionIcon() {
    this.projectionButton.classList.remove("maplibregl-ctrl-projection-globe"), this.projectionButton.classList.remove("maplibregl-ctrl-projection-mercator"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add("maplibregl-ctrl-projection-mercator"), this.projectionButton.title = "Enable Mercator projection") : (this.projectionButton.classList.add("maplibregl-ctrl-projection-globe"), this.projectionButton.title = "Enable Globe projection");
  }
};
function Do(r) {
  r.getProjection() === void 0 && r.setProjection({ type: "mercator" }), r.isGlobeProjection() ? r.setProjection("mercator", { persist: true }) : r.setProjection("globe", { persist: true });
}
var pt = {
  "zoom-in": (r) => r.zoomIn(),
  "zoom-out": (r) => r.zoomOut(),
  "toggle-projection": Do,
  "toggle-terrain": jo,
  "reset-view": (r) => {
    r.getPitch() === 0 ? r.easeTo({ pitch: Math.min(r.getMaxPitch(), 80) }) : r.resetNorthPitch();
  },
  "reset-bearing": (r) => {
    r.rotateTo(0);
  },
  "reset-pitch": (r) => {
    r.setPitch(0);
  },
  "reset-roll": (r) => {
    r.setRoll(0);
  }
};
var At;
var ot;
var Wr = class extends Iu {
  /**
   * Constructs an instance of External Control to have a predefined functionality
   * @param controlElement Element to be used as control, specified as reference to element itself
   * @param controlType One of the predefined types of functionality
   */
  constructor(t, n) {
    if (n && !(n in pt)) throw new Error(`data-maptiler-control value "${n}" is invalid.`);
    super(t, n && pt[n]);
    Y(this, At);
    Y(this, ot, /* @__PURE__ */ new Map());
  }
  onAdd(t) {
    return J(this, At, t), super.onAdd(t);
  }
  onRemove() {
    for (const [t, n] of L(this, ot)) {
      const a = t.deref();
      a && a.removeEventListener("click", n);
    }
    L(this, ot).clear(), super.onRemove();
  }
  /**
   * Configure a child element to be part of this control and to have a predefined functionality added
   * @param controlElement Element that is a descendant of the control element and that optionally should have some functionality
   * @param controlType One of the predefined types of functionality
   */
  configureGroupItem(t, n) {
    if (!n) return;
    if (!(n in pt)) throw new Error(`data-maptiler-control value "${n}" is invalid.`);
    const a = (o) => {
      pt[n](L(this, At), t, o);
    };
    t.addEventListener("click", a), L(this, ot).set(new WeakRef(t), a);
  }
};
At = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap(), y(Wr, "controlCallbacks", pt);
var te;
var ce;
var Me;
var Pe;
var re;
var Tt;
var K;
var Uo;
var ue;
var Bo;
var Rr = class {
  constructor(e, t) {
    Y(this, K);
    Y(this, te);
    y(this, "map");
    Y(this, ce);
    Y(this, Me);
    Y(this, Pe);
    Y(this, re, false);
    Y(this, Tt);
    e.style !== void 0 && J(this, re, true), J(this, te, {
      // set defaults
      zoomAdjust: -4,
      position: "top-right",
      // inherit map options
      ...t,
      // override any lingering control options
      forceNoAttributionControl: true,
      attributionControl: false,
      navigationControl: false,
      geolocateControl: false,
      maptilerLogo: false,
      minimap: false,
      hash: false,
      pitchAdjust: false,
      // override map options with new user defined minimap options
      ...e,
      containerStyle: {
        border: "1px solid #000",
        width: "400px",
        height: "300px",
        ...e.containerStyle ?? {}
      }
    }), e.lockZoom !== void 0 && (L(this, te).minZoom = e.lockZoom, L(this, te).maxZoom = e.lockZoom);
  }
  setStyle(e, t) {
    L(this, re) || this.map.setStyle(e, t), Q(this, K, ue).call(this);
  }
  addLayer(e, t) {
    return L(this, re) || this.map.addLayer(e, t), Q(this, K, ue).call(this), this.map;
  }
  moveLayer(e, t) {
    return L(this, re) || this.map.moveLayer(e, t), Q(this, K, ue).call(this), this.map;
  }
  removeLayer(e) {
    return L(this, re) || this.map.removeLayer(e), Q(this, K, ue).call(this), this;
  }
  setLayerZoomRange(e, t, n) {
    return L(this, re) || this.map.setLayerZoomRange(e, t, n), Q(this, K, ue).call(this), this;
  }
  setFilter(e, t, n) {
    return L(this, re) || this.map.setFilter(e, t, n), Q(this, K, ue).call(this), this;
  }
  setPaintProperty(e, t, n, a) {
    return L(this, re) || this.map.setPaintProperty(e, t, n, a), Q(this, K, ue).call(this), this;
  }
  setLayoutProperty(e, t, n, a) {
    return L(this, re) || this.map.setLayoutProperty(e, t, n, a), Q(this, K, ue).call(this), this;
  }
  setGlyphs(e, t) {
    return L(this, re) || this.map.setGlyphs(e, t), Q(this, K, ue).call(this), this;
  }
  onAdd(e) {
    J(this, ce, e), J(this, Me, Ee("div", "maplibregl-ctrl maplibregl-ctrl-group"));
    for (const [t, n] of Object.entries(L(this, te).containerStyle))
      L(this, Me).style.setProperty(t, n);
    return L(this, te).container = L(this, Me), L(this, te).zoom = e.getZoom() + L(this, te).zoomAdjust, this.map = new Go(L(this, te)), this.map.once("style.load", () => {
      this.map.resize();
    }), this.map.once("load", () => {
      Q(this, K, Uo).call(this, L(this, te).parentRect), J(this, Tt, Q(this, K, Bo).call(this));
    }), L(this, Me);
  }
  onRemove() {
    var e;
    (e = L(this, Tt)) == null || e.call(this), Et(L(this, Me));
  }
};
te = /* @__PURE__ */ new WeakMap(), ce = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakMap(), Pe = /* @__PURE__ */ new WeakMap(), re = /* @__PURE__ */ new WeakMap(), Tt = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakSet(), Uo = function(e) {
  e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || (J(this, Pe, {
    type: "Feature",
    properties: {
      name: "parentRect"
    },
    geometry: {
      type: "Polygon",
      coordinates: [[[], [], [], [], []]]
    }
  }), this.map.addSource("parentRect", {
    type: "geojson",
    data: L(this, Pe)
  }), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({
    id: "parentRectOutline",
    type: "line",
    source: "parentRect",
    layout: {
      ...e.lineLayout
    },
    paint: {
      "line-color": "#FFF",
      "line-width": 1,
      "line-opacity": 0.85,
      ...e.linePaint
    }
  }), e.fillPaint !== void 0 && this.map.addLayer({
    id: "parentRectFill",
    type: "fill",
    source: "parentRect",
    layout: {},
    paint: {
      "fill-color": "#08F",
      "fill-opacity": 0.135,
      ...e.fillPaint
    }
  }), Q(this, K, ue).call(this));
}, ue = function() {
  if (L(this, Pe) === void 0) return;
  const { devicePixelRatio: e } = window, t = L(this, ce).getCanvas(), n = t.width / e, a = t.height / e, o = L(this, ce).unproject.bind(L(this, ce)), i = o([0, 0]), s = o([n, 0]), l = o([0, a]), u = o([n, a]);
  L(this, Pe).geometry.coordinates = [[l.toArray(), u.toArray(), s.toArray(), i.toArray(), l.toArray()]];
  const c = this.map.getSource("parentRect");
  c !== void 0 && c.setData(L(this, Pe));
}, Bo = function() {
  const { pitchAdjust: e } = L(this, te), t = () => {
    i("parent");
  }, n = () => {
    i("minimap");
  }, a = () => {
    L(this, ce).on("move", t), this.map.on("move", n);
  }, o = () => {
    L(this, ce).off("move", t), this.map.off("move", n);
  }, i = (s) => {
    o();
    const l = s === "parent" ? L(this, ce) : this.map, u = s === "parent" ? this.map : L(this, ce), c = l.getCenter(), p = l.getZoom() + L(this, te).zoomAdjust * (s === "parent" ? 1 : -1), f2 = l.getBearing(), d = l.getPitch();
    u.jumpTo({
      center: c,
      zoom: p,
      bearing: f2,
      pitch: e ? d : 0
    }), Q(this, K, ue).call(this), a();
  };
  return a(), () => {
    o();
  };
};
var Mu = class {
  /**
   *
   * @param map : a Map instance
   * @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)
   */
  constructor(e, t = 2e3) {
    y(this, "map");
    y(this, "registeredModules", /* @__PURE__ */ new Set());
    y(this, "viewerType");
    this.map = e, this.viewerType = "Map", setTimeout(
      async () => {
        if (!j.telemetry)
          return;
        const n = this.preparePayload();
        try {
          (await fetch(n, { method: "POST" })).ok || console.warn("The metrics could not be sent to MapTiler Cloud");
        } catch (a) {
          console.warn("The metrics could not be sent to MapTiler Cloud", a);
        }
      },
      Math.max(1e3, t)
    );
  }
  /**
   * Register a module to the telemetry system of the SDK.
   * The arguments `name` and `version` likely come from the package.json
   * of each module.
   */
  registerModule(e, t) {
    this.registeredModules.add(`${e}:${t}`);
  }
  registerViewerType(e = "Map") {
    this.viewerType = e;
  }
  preparePayload() {
    const e = new URL(W.telemetryURL);
    return e.searchParams.append("sdk", wi()), e.searchParams.append("key", j.apiKey), e.searchParams.append("mtsid", cn), e.searchParams.append("session", j.session ? "1" : "0"), e.searchParams.append("caching", j.caching ? "1" : "0"), e.searchParams.append("lang-updated", this.map.isLanguageUpdated() ? "1" : "0"), e.searchParams.append("terrain", this.map.getTerrain() ? "1" : "0"), e.searchParams.append("globe", this.map.isGlobeProjection() ? "1" : "0"), e.searchParams.append("viewerType", this.viewerType), this.registeredModules.size > 0 && e.searchParams.append("modules", Array.from(this.registeredModules).join("|")), e.href;
  }
};
var Ct = typeof Float32Array < "u" ? Float32Array : Array;
function yt() {
  var r = new Ct(16);
  return Ct != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
}
function Pu(r, e, t, n, a, o, i, s, l, u, c, p, f2, d, h, m, g) {
  return r[0] = e, r[1] = t, r[2] = n, r[3] = a, r[4] = o, r[5] = i, r[6] = s, r[7] = l, r[8] = u, r[9] = c, r[10] = p, r[11] = f2, r[12] = d, r[13] = h, r[14] = m, r[15] = g, r;
}
function Ru(r, e, t) {
  var n = e[0], a = e[1], o = e[2], i = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], f2 = e[9], d = e[10], h = e[11], m = e[12], g = e[13], b = e[14], v = e[15], x = t[0], C = t[1], E = t[2], A = t[3];
  return r[0] = x * n + C * s + E * p + A * m, r[1] = x * a + C * l + E * f2 + A * g, r[2] = x * o + C * u + E * d + A * b, r[3] = x * i + C * c + E * h + A * v, x = t[4], C = t[5], E = t[6], A = t[7], r[4] = x * n + C * s + E * p + A * m, r[5] = x * a + C * l + E * f2 + A * g, r[6] = x * o + C * u + E * d + A * b, r[7] = x * i + C * c + E * h + A * v, x = t[8], C = t[9], E = t[10], A = t[11], r[8] = x * n + C * s + E * p + A * m, r[9] = x * a + C * l + E * f2 + A * g, r[10] = x * o + C * u + E * d + A * b, r[11] = x * i + C * c + E * h + A * v, x = t[12], C = t[13], E = t[14], A = t[15], r[12] = x * n + C * s + E * p + A * m, r[13] = x * a + C * l + E * f2 + A * g, r[14] = x * o + C * u + E * d + A * b, r[15] = x * i + C * c + E * h + A * v, r;
}
function Ou(r, e, t) {
  var n = t[0], a = t[1], o = t[2];
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * a, r[5] = e[5] * a, r[6] = e[6] * a, r[7] = e[7] * a, r[8] = e[8] * o, r[9] = e[9] * o, r[10] = e[10] * o, r[11] = e[11] * o, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function va(r, e, t) {
  var n = Math.sin(t), a = Math.cos(t), o = e[4], i = e[5], s = e[6], l = e[7], u = e[8], c = e[9], p = e[10], f2 = e[11];
  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = o * a + u * n, r[5] = i * a + c * n, r[6] = s * a + p * n, r[7] = l * a + f2 * n, r[8] = u * a - o * n, r[9] = c * a - i * n, r[10] = p * a - s * n, r[11] = f2 * a - l * n, r;
}
function zu(r, e, t) {
  var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[8], c = e[9], p = e[10], f2 = e[11];
  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a - u * n, r[1] = i * a - c * n, r[2] = s * a - p * n, r[3] = l * a - f2 * n, r[8] = o * n + u * a, r[9] = i * n + c * a, r[10] = s * n + p * a, r[11] = l * n + f2 * a, r;
}
function ba(r, e, t) {
  var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[4], c = e[5], p = e[6], f2 = e[7];
  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a + u * n, r[1] = i * a + c * n, r[2] = s * a + p * n, r[3] = l * a + f2 * n, r[4] = u * a - o * n, r[5] = c * a - i * n, r[6] = p * a - s * n, r[7] = f2 * a - l * n, r;
}
function Fu(r, e, t, n, a) {
  var o = 1 / Math.tan(e / 2);
  if (r[0] = o / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, a != null && a !== 1 / 0) {
    var i = 1 / (n - a);
    r[10] = (a + n) * i, r[14] = 2 * a * n * i;
  } else
    r[10] = -1, r[14] = -2 * n;
  return r;
}
var $u = Fu;
function qt() {
  var r = new Ct(3);
  return Ct != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function Nu(r, e, t) {
  var n = new Ct(3);
  return n[0] = r, n[1] = e, n[2] = t, n;
}
function Or(r, e) {
  var t = e[0], n = e[1], a = e[2], o = t * t + n * n + a * a;
  return o > 0 && (o = 1 / Math.sqrt(o)), r[0] = e[0] * o, r[1] = e[1] * o, r[2] = e[2] * o, r;
}
function wa(r, e, t) {
  var n = e[0], a = e[1], o = e[2], i = t[0], s = t[1], l = t[2];
  return r[0] = a * l - o * s, r[1] = o * i - n * l, r[2] = n * s - a * i, r;
}
(function() {
  var r = qt();
  return function(e, t, n, a, o, i) {
    var s, l;
    for (t || (t = 3), n || (n = 0), a ? l = Math.min(a * t + n, e.length) : l = e.length, s = n; s < l; s += t)
      r[0] = e[s], r[1] = e[s + 1], r[2] = e[s + 2], o(r, r, i), e[s] = r[0], e[s + 1] = r[1], e[s + 2] = r[2];
    return e;
  };
})();
function ju(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var zr;
var Sa;
function Du() {
  return Sa || (Sa = 1, zr = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), zr;
}
var Fr;
var xa;
function qo() {
  if (xa) return Fr;
  xa = 1;
  const r = Du(), e = {};
  for (const a of Object.keys(r))
    e[r[a]] = a;
  const t = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  Fr = t;
  for (const a of Object.keys(t)) {
    if (!("channels" in t[a]))
      throw new Error("missing channels property: " + a);
    if (!("labels" in t[a]))
      throw new Error("missing channel labels property: " + a);
    if (t[a].labels.length !== t[a].channels)
      throw new Error("channel and label counts mismatch: " + a);
    const { channels: o, labels: i } = t[a];
    delete t[a].channels, delete t[a].labels, Object.defineProperty(t[a], "channels", { value: o }), Object.defineProperty(t[a], "labels", { value: i });
  }
  t.rgb.hsl = function(a) {
    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(o, i, s), u = Math.max(o, i, s), c = u - l;
    let p, f2;
    u === l ? p = 0 : o === u ? p = (i - s) / c : i === u ? p = 2 + (s - o) / c : s === u && (p = 4 + (o - i) / c), p = Math.min(p * 60, 360), p < 0 && (p += 360);
    const d = (l + u) / 2;
    return u === l ? f2 = 0 : d <= 0.5 ? f2 = c / (u + l) : f2 = c / (2 - u - l), [p, f2 * 100, d * 100];
  }, t.rgb.hsv = function(a) {
    let o, i, s, l, u;
    const c = a[0] / 255, p = a[1] / 255, f2 = a[2] / 255, d = Math.max(c, p, f2), h = d - Math.min(c, p, f2), m = function(g) {
      return (d - g) / 6 / h + 1 / 2;
    };
    return h === 0 ? (l = 0, u = 0) : (u = h / d, o = m(c), i = m(p), s = m(f2), c === d ? l = s - i : p === d ? l = 1 / 3 + o - s : f2 === d && (l = 2 / 3 + i - o), l < 0 ? l += 1 : l > 1 && (l -= 1)), [
      l * 360,
      u * 100,
      d * 100
    ];
  }, t.rgb.hwb = function(a) {
    const o = a[0], i = a[1];
    let s = a[2];
    const l = t.rgb.hsl(a)[0], u = 1 / 255 * Math.min(o, Math.min(i, s));
    return s = 1 - 1 / 255 * Math.max(o, Math.max(i, s)), [l, u * 100, s * 100];
  }, t.rgb.cmyk = function(a) {
    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(1 - o, 1 - i, 1 - s), u = (1 - o - l) / (1 - l) || 0, c = (1 - i - l) / (1 - l) || 0, p = (1 - s - l) / (1 - l) || 0;
    return [u * 100, c * 100, p * 100, l * 100];
  };
  function n(a, o) {
    return (a[0] - o[0]) ** 2 + (a[1] - o[1]) ** 2 + (a[2] - o[2]) ** 2;
  }
  return t.rgb.keyword = function(a) {
    const o = e[a];
    if (o)
      return o;
    let i = 1 / 0, s;
    for (const l of Object.keys(r)) {
      const u = r[l], c = n(a, u);
      c < i && (i = c, s = l);
    }
    return s;
  }, t.keyword.rgb = function(a) {
    return r[a];
  }, t.rgb.xyz = function(a) {
    let o = a[0] / 255, i = a[1] / 255, s = a[2] / 255;
    o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92, i = i > 0.04045 ? ((i + 0.055) / 1.055) ** 2.4 : i / 12.92, s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92;
    const l = o * 0.4124 + i * 0.3576 + s * 0.1805, u = o * 0.2126 + i * 0.7152 + s * 0.0722, c = o * 0.0193 + i * 0.1192 + s * 0.9505;
    return [l * 100, u * 100, c * 100];
  }, t.rgb.lab = function(a) {
    const o = t.rgb.xyz(a);
    let i = o[0], s = o[1], l = o[2];
    i /= 95.047, s /= 100, l /= 108.883, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, l = l > 8856e-6 ? l ** (1 / 3) : 7.787 * l + 16 / 116;
    const u = 116 * s - 16, c = 500 * (i - s), p = 200 * (s - l);
    return [u, c, p];
  }, t.hsl.rgb = function(a) {
    const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;
    let l, u, c;
    if (i === 0)
      return c = s * 255, [c, c, c];
    s < 0.5 ? l = s * (1 + i) : l = s + i - s * i;
    const p = 2 * s - l, f2 = [0, 0, 0];
    for (let d = 0; d < 3; d++)
      u = o + 1 / 3 * -(d - 1), u < 0 && u++, u > 1 && u--, 6 * u < 1 ? c = p + (l - p) * 6 * u : 2 * u < 1 ? c = l : 3 * u < 2 ? c = p + (l - p) * (2 / 3 - u) * 6 : c = p, f2[d] = c * 255;
    return f2;
  }, t.hsl.hsv = function(a) {
    const o = a[0];
    let i = a[1] / 100, s = a[2] / 100, l = i;
    const u = Math.max(s, 0.01);
    s *= 2, i *= s <= 1 ? s : 2 - s, l *= u <= 1 ? u : 2 - u;
    const c = (s + i) / 2, p = s === 0 ? 2 * l / (u + l) : 2 * i / (s + i);
    return [o, p * 100, c * 100];
  }, t.hsv.rgb = function(a) {
    const o = a[0] / 60, i = a[1] / 100;
    let s = a[2] / 100;
    const l = Math.floor(o) % 6, u = o - Math.floor(o), c = 255 * s * (1 - i), p = 255 * s * (1 - i * u), f2 = 255 * s * (1 - i * (1 - u));
    switch (s *= 255, l) {
      case 0:
        return [s, f2, c];
      case 1:
        return [p, s, c];
      case 2:
        return [c, s, f2];
      case 3:
        return [c, p, s];
      case 4:
        return [f2, c, s];
      case 5:
        return [s, c, p];
    }
  }, t.hsv.hsl = function(a) {
    const o = a[0], i = a[1] / 100, s = a[2] / 100, l = Math.max(s, 0.01);
    let u, c;
    c = (2 - i) * s;
    const p = (2 - i) * l;
    return u = i * l, u /= p <= 1 ? p : 2 - p, u = u || 0, c /= 2, [o, u * 100, c * 100];
  }, t.hwb.rgb = function(a) {
    const o = a[0] / 360;
    let i = a[1] / 100, s = a[2] / 100;
    const l = i + s;
    let u;
    l > 1 && (i /= l, s /= l);
    const c = Math.floor(6 * o), p = 1 - s;
    u = 6 * o - c, (c & 1) !== 0 && (u = 1 - u);
    const f2 = i + u * (p - i);
    let d, h, m;
    switch (c) {
      default:
      case 6:
      case 0:
        d = p, h = f2, m = i;
        break;
      case 1:
        d = f2, h = p, m = i;
        break;
      case 2:
        d = i, h = p, m = f2;
        break;
      case 3:
        d = i, h = f2, m = p;
        break;
      case 4:
        d = f2, h = i, m = p;
        break;
      case 5:
        d = p, h = i, m = f2;
        break;
    }
    return [d * 255, h * 255, m * 255];
  }, t.cmyk.rgb = function(a) {
    const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100, l = a[3] / 100, u = 1 - Math.min(1, o * (1 - l) + l), c = 1 - Math.min(1, i * (1 - l) + l), p = 1 - Math.min(1, s * (1 - l) + l);
    return [u * 255, c * 255, p * 255];
  }, t.xyz.rgb = function(a) {
    const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100;
    let l, u, c;
    return l = o * 3.2406 + i * -1.5372 + s * -0.4986, u = o * -0.9689 + i * 1.8758 + s * 0.0415, c = o * 0.0557 + i * -0.204 + s * 1.057, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, u = u > 31308e-7 ? 1.055 * u ** (1 / 2.4) - 0.055 : u * 12.92, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, l = Math.min(Math.max(0, l), 1), u = Math.min(Math.max(0, u), 1), c = Math.min(Math.max(0, c), 1), [l * 255, u * 255, c * 255];
  }, t.xyz.lab = function(a) {
    let o = a[0], i = a[1], s = a[2];
    o /= 95.047, i /= 100, s /= 108.883, o = o > 8856e-6 ? o ** (1 / 3) : 7.787 * o + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116;
    const l = 116 * i - 16, u = 500 * (o - i), c = 200 * (i - s);
    return [l, u, c];
  }, t.lab.xyz = function(a) {
    const o = a[0], i = a[1], s = a[2];
    let l, u, c;
    u = (o + 16) / 116, l = i / 500 + u, c = u - s / 200;
    const p = u ** 3, f2 = l ** 3, d = c ** 3;
    return u = p > 8856e-6 ? p : (u - 16 / 116) / 7.787, l = f2 > 8856e-6 ? f2 : (l - 16 / 116) / 7.787, c = d > 8856e-6 ? d : (c - 16 / 116) / 7.787, l *= 95.047, u *= 100, c *= 108.883, [l, u, c];
  }, t.lab.lch = function(a) {
    const o = a[0], i = a[1], s = a[2];
    let l;
    l = Math.atan2(s, i) * 360 / 2 / Math.PI, l < 0 && (l += 360);
    const c = Math.sqrt(i * i + s * s);
    return [o, c, l];
  }, t.lch.lab = function(a) {
    const o = a[0], i = a[1], l = a[2] / 360 * 2 * Math.PI, u = i * Math.cos(l), c = i * Math.sin(l);
    return [o, u, c];
  }, t.rgb.ansi16 = function(a, o = null) {
    const [i, s, l] = a;
    let u = o === null ? t.rgb.hsv(a)[2] : o;
    if (u = Math.round(u / 50), u === 0)
      return 30;
    let c = 30 + (Math.round(l / 255) << 2 | Math.round(s / 255) << 1 | Math.round(i / 255));
    return u === 2 && (c += 60), c;
  }, t.hsv.ansi16 = function(a) {
    return t.rgb.ansi16(t.hsv.rgb(a), a[2]);
  }, t.rgb.ansi256 = function(a) {
    const o = a[0], i = a[1], s = a[2];
    return o === i && i === s ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(i / 255 * 5) + Math.round(s / 255 * 5);
  }, t.ansi16.rgb = function(a) {
    let o = a % 10;
    if (o === 0 || o === 7)
      return a > 50 && (o += 3.5), o = o / 10.5 * 255, [o, o, o];
    const i = (~~(a > 50) + 1) * 0.5, s = (o & 1) * i * 255, l = (o >> 1 & 1) * i * 255, u = (o >> 2 & 1) * i * 255;
    return [s, l, u];
  }, t.ansi256.rgb = function(a) {
    if (a >= 232) {
      const u = (a - 232) * 10 + 8;
      return [u, u, u];
    }
    a -= 16;
    let o;
    const i = Math.floor(a / 36) / 5 * 255, s = Math.floor((o = a % 36) / 6) / 5 * 255, l = o % 6 / 5 * 255;
    return [i, s, l];
  }, t.rgb.hex = function(a) {
    const i = (((Math.round(a[0]) & 255) << 16) + ((Math.round(a[1]) & 255) << 8) + (Math.round(a[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(i.length) + i;
  }, t.hex.rgb = function(a) {
    const o = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!o)
      return [0, 0, 0];
    let i = o[0];
    o[0].length === 3 && (i = i.split("").map((p) => p + p).join(""));
    const s = parseInt(i, 16), l = s >> 16 & 255, u = s >> 8 & 255, c = s & 255;
    return [l, u, c];
  }, t.rgb.hcg = function(a) {
    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.max(Math.max(o, i), s), u = Math.min(Math.min(o, i), s), c = l - u;
    let p, f2;
    return c < 1 ? p = u / (1 - c) : p = 0, c <= 0 ? f2 = 0 : l === o ? f2 = (i - s) / c % 6 : l === i ? f2 = 2 + (s - o) / c : f2 = 4 + (o - i) / c, f2 /= 6, f2 %= 1, [f2 * 360, c * 100, p * 100];
  }, t.hsl.hcg = function(a) {
    const o = a[1] / 100, i = a[2] / 100, s = i < 0.5 ? 2 * o * i : 2 * o * (1 - i);
    let l = 0;
    return s < 1 && (l = (i - 0.5 * s) / (1 - s)), [a[0], s * 100, l * 100];
  }, t.hsv.hcg = function(a) {
    const o = a[1] / 100, i = a[2] / 100, s = o * i;
    let l = 0;
    return s < 1 && (l = (i - s) / (1 - s)), [a[0], s * 100, l * 100];
  }, t.hcg.rgb = function(a) {
    const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;
    if (i === 0)
      return [s * 255, s * 255, s * 255];
    const l = [0, 0, 0], u = o % 1 * 6, c = u % 1, p = 1 - c;
    let f2 = 0;
    switch (Math.floor(u)) {
      case 0:
        l[0] = 1, l[1] = c, l[2] = 0;
        break;
      case 1:
        l[0] = p, l[1] = 1, l[2] = 0;
        break;
      case 2:
        l[0] = 0, l[1] = 1, l[2] = c;
        break;
      case 3:
        l[0] = 0, l[1] = p, l[2] = 1;
        break;
      case 4:
        l[0] = c, l[1] = 0, l[2] = 1;
        break;
      default:
        l[0] = 1, l[1] = 0, l[2] = p;
    }
    return f2 = (1 - i) * s, [
      (i * l[0] + f2) * 255,
      (i * l[1] + f2) * 255,
      (i * l[2] + f2) * 255
    ];
  }, t.hcg.hsv = function(a) {
    const o = a[1] / 100, i = a[2] / 100, s = o + i * (1 - o);
    let l = 0;
    return s > 0 && (l = o / s), [a[0], l * 100, s * 100];
  }, t.hcg.hsl = function(a) {
    const o = a[1] / 100, s = a[2] / 100 * (1 - o) + 0.5 * o;
    let l = 0;
    return s > 0 && s < 0.5 ? l = o / (2 * s) : s >= 0.5 && s < 1 && (l = o / (2 * (1 - s))), [a[0], l * 100, s * 100];
  }, t.hcg.hwb = function(a) {
    const o = a[1] / 100, i = a[2] / 100, s = o + i * (1 - o);
    return [a[0], (s - o) * 100, (1 - s) * 100];
  }, t.hwb.hcg = function(a) {
    const o = a[1] / 100, s = 1 - a[2] / 100, l = s - o;
    let u = 0;
    return l < 1 && (u = (s - l) / (1 - l)), [a[0], l * 100, u * 100];
  }, t.apple.rgb = function(a) {
    return [a[0] / 65535 * 255, a[1] / 65535 * 255, a[2] / 65535 * 255];
  }, t.rgb.apple = function(a) {
    return [a[0] / 255 * 65535, a[1] / 255 * 65535, a[2] / 255 * 65535];
  }, t.gray.rgb = function(a) {
    return [a[0] / 100 * 255, a[0] / 100 * 255, a[0] / 100 * 255];
  }, t.gray.hsl = function(a) {
    return [0, 0, a[0]];
  }, t.gray.hsv = t.gray.hsl, t.gray.hwb = function(a) {
    return [0, 100, a[0]];
  }, t.gray.cmyk = function(a) {
    return [0, 0, 0, a[0]];
  }, t.gray.lab = function(a) {
    return [a[0], 0, 0];
  }, t.gray.hex = function(a) {
    const o = Math.round(a[0] / 100 * 255) & 255, s = ((o << 16) + (o << 8) + o).toString(16).toUpperCase();
    return "000000".substring(s.length) + s;
  }, t.rgb.gray = function(a) {
    return [(a[0] + a[1] + a[2]) / 3 / 255 * 100];
  }, Fr;
}
var $r;
var ka;
function Uu() {
  if (ka) return $r;
  ka = 1;
  const r = qo();
  function e() {
    const o = {}, i = Object.keys(r);
    for (let s = i.length, l = 0; l < s; l++)
      o[i[l]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return o;
  }
  function t(o) {
    const i = e(), s = [o];
    for (i[o].distance = 0; s.length; ) {
      const l = s.pop(), u = Object.keys(r[l]);
      for (let c = u.length, p = 0; p < c; p++) {
        const f2 = u[p], d = i[f2];
        d.distance === -1 && (d.distance = i[l].distance + 1, d.parent = l, s.unshift(f2));
      }
    }
    return i;
  }
  function n(o, i) {
    return function(s) {
      return i(o(s));
    };
  }
  function a(o, i) {
    const s = [i[o].parent, o];
    let l = r[i[o].parent][o], u = i[o].parent;
    for (; i[u].parent; )
      s.unshift(i[u].parent), l = n(r[i[u].parent][u], l), u = i[u].parent;
    return l.conversion = s, l;
  }
  return $r = function(o) {
    const i = t(o), s = {}, l = Object.keys(i);
    for (let u = l.length, c = 0; c < u; c++) {
      const p = l[c];
      i[p].parent !== null && (s[p] = a(p, i));
    }
    return s;
  }, $r;
}
var Nr;
var La;
function Bu() {
  if (La) return Nr;
  La = 1;
  const r = qo(), e = Uu(), t = {}, n = Object.keys(r);
  function a(i) {
    const s = function(...l) {
      const u = l[0];
      return u == null ? u : (u.length > 1 && (l = u), i(l));
    };
    return "conversion" in i && (s.conversion = i.conversion), s;
  }
  function o(i) {
    const s = function(...l) {
      const u = l[0];
      if (u == null)
        return u;
      u.length > 1 && (l = u);
      const c = i(l);
      if (typeof c == "object")
        for (let p = c.length, f2 = 0; f2 < p; f2++)
          c[f2] = Math.round(c[f2]);
      return c;
    };
    return "conversion" in i && (s.conversion = i.conversion), s;
  }
  return n.forEach((i) => {
    t[i] = {}, Object.defineProperty(t[i], "channels", { value: r[i].channels }), Object.defineProperty(t[i], "labels", { value: r[i].labels });
    const s = e(i);
    Object.keys(s).forEach((u) => {
      const c = s[u];
      t[i][u] = o(c), t[i][u].raw = a(c);
    });
  }), Nr = t, Nr;
}
var qu = Bu();
var Vu = ju(qu);
function Ea({ gl: r, type: e, source: t }) {
  const n = r.createShader(e);
  if (n === null)
    throw new Error("Cannot create shader");
  if (r.shaderSource(n, t), r.compileShader(n), !r.getShaderParameter(n, r.COMPILE_STATUS))
    throw console.error("Shader compilation error:", r.getShaderInfoLog(n)), r.deleteShader(n), new Error("Cannot compile shader");
  return n;
}
function Gu({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }) {
  const n = Ea({
    gl: r,
    type: r.VERTEX_SHADER,
    source: e
  }), a = Ea({ gl: r, type: r.FRAGMENT_SHADER, source: t }), o = r.createProgram();
  if (r.attachShader(o, n), r.attachShader(o, a), r.linkProgram(o), !r.getProgramParameter(o, r.LINK_STATUS))
    throw console.error("Error: ", r.getProgramInfoLog(o)), new Error("Cannot link shader program");
  return o;
}
function Hu(r, e, t) {
  const n = r.getUniformLocation(e, t);
  if (n === null)
    throw new Error(`Cannot get uniform location for ${t}`);
  return n;
}
function Vo({
  gl: r,
  vertexShaderSource: e,
  fragmentShaderSource: t,
  attributesKeys: n,
  uniformsKeys: a,
  vertices: o,
  indices: i
}) {
  const s = Gu({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }), l = n.reduce((d, h) => (d[h] = r.getAttribLocation(s, `a_${h}`), d), {}), u = a.reduce((d, h) => (d[h] = Hu(r, s, `u_${h}`), d), {}), c = r.createBuffer();
  r.bindBuffer(r.ARRAY_BUFFER, c), r.bufferData(r.ARRAY_BUFFER, new Float32Array(o), r.STATIC_DRAW);
  let p, f2;
  return i !== void 0 && (p = r.createBuffer(), f2 = i.length, r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, p), r.bufferData(r.ELEMENT_ARRAY_BUFFER, new Uint16Array(i), r.STATIC_DRAW)), {
    shaderProgram: s,
    programInfo: {
      attributesLocations: l,
      uniformsLocations: u
    },
    positionBuffer: c,
    indexBuffer: p,
    indexBufferLength: f2
  };
}
function Vt(r) {
  if (!r)
    return [1, 1, 1, 0];
  if (r === "transparent")
    return [1, 1, 1, 0];
  try {
    const e = Ku(r), t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(e);
    if (t != null && t.length) {
      const a = !!t[4];
      return [...Vu.hex.rgb(e).map((o) => o / 255), a ? parseInt(t[4], 16) / 255 : 1];
    }
    const n = e.match(/(\d\.\d(\d+)?|\d{3}|\d{2}|\d{1})/gi) ?? ["0", "0", "0"];
    if (e.includes("rgb")) {
      const a = e.includes("rgba"), o = [
        ...n.map((i) => parseFloat(i)).map((i, s) => s < 3 ? i / 255 : i)
        // because alpha is in the range 0 - 1, not 0 - 255
      ];
      return a || o.push(1), o;
    }
  } catch {
  }
  return console.warn([`[parseColorStringToVec4]: Color ${r} is either not a valid color or its type is not supported, defaulting to black`]), [0, 0, 0, 1];
}
var ft;
function Ku(r) {
  return ft = ft ?? document.createElement("canvas").getContext("2d"), ft ? (ft.fillStyle = r, ft.fillStyle) : "#000000";
}
var Pn = 1;
var U = Pn / 2;
var B = Pn / 2;
var q = Pn / 2;
var Zu = [-U, -B, q, U, -B, q, U, B, q, -U, B, q];
var Xu = [-U, -B, -q, -U, B, -q, U, B, -q, U, -B, -q];
var Yu = [-U, B, -q, -U, B, q, U, B, q, U, B, -q];
var Wu = [-U, -B, -q, U, -B, -q, U, -B, q, -U, -B, q];
var Ju = [U, -B, -q, U, B, -q, U, B, q, U, -B, q];
var Qu = [-U, -B, -q, -U, -B, q, -U, B, q, -U, B, -q];
var ec = [...Zu, ...Xu, ...Yu, ...Wu, ...Ju, ...Qu];
var tc = [
  // Front
  0,
  1,
  2,
  0,
  2,
  3,
  // Back
  4,
  5,
  6,
  4,
  6,
  7,
  // Left
  8,
  9,
  10,
  8,
  10,
  11,
  // Right
  12,
  13,
  14,
  12,
  14,
  15,
  // Up
  16,
  17,
  18,
  16,
  18,
  19,
  // Down
  20,
  21,
  22,
  20,
  22,
  23
];
var rc = `attribute vec3 a_vertexPosition;
varying vec3 vTextureCoord;

uniform mat4 u_projectionMatrix;
uniform mat4 u_modelViewMatrix;
  
void main(void) {
  vTextureCoord = vec3(-a_vertexPosition.x, a_vertexPosition.y, a_vertexPosition.z);
  gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);
}
`;
var Ca = `precision mediump float;

varying vec3 vTextureCoord;

%USE_TEXTURE_MACRO_MARKER%

# ifdef USE_TEXTURE
uniform samplerCube u_cubeSampler;
uniform float u_fadeOpacity;
# endif

uniform vec4 u_bgColor;

void main(void) {
  #ifdef USE_TEXTURE
  vec4 texColor = textureCube(u_cubeSampler, vTextureCoord);

    gl_FragColor = mix(
      u_bgColor,
      texColor,
      min(texColor.a, u_fadeOpacity)
    );

    gl_FragColor.a = max(gl_FragColor.a, u_fadeOpacity);

  #else
  gl_FragColor = u_bgColor;
  #endif
}
`;
var nc = ((r) => (r.UNIVERSE_DARK = "universe-dark", r))(nc || {});
var ze = {
  stars: {
    color: "hsl(233,100%,92%)",
    preset: "stars"
  },
  space: {
    color: "hsl(210, 100%, 4%)",
    preset: "space"
  },
  milkyway: {
    color: "hsl(233,100%,92%)",
    preset: "milkyway"
  },
  "milkyway-subtle": {
    color: "hsl(233,100%,92%)",
    preset: "milkyway-subtle"
  },
  "milkyway-bright": {
    color: "hsl(233,100%,92%)",
    preset: "milkyway-bright"
  },
  "milkyway-colored": {
    color: "black",
    preset: "milkyway-colored"
  }
};
var Ue = ((r) => (r.POSITIVE_X = "pX", r.NEGATIVE_X = "nX", r.POSITIVE_Y = "pY", r.NEGATIVE_Y = "nY", r.POSITIVE_Z = "pZ", r.NEGATIVE_Z = "nZ", r))(Ue || {});
var rt = /* @__PURE__ */ new Map();
function ac(r) {
  const e = rt.get(r);
  e && (rt.delete(r), r.deleteTexture(e));
}
var Aa = /* @__PURE__ */ new Map();
var Ta;
function oc({ gl: r, faces: e, onReady: t, forceRefresh: n }) {
  if (rt.get(r) && !n && Ta === JSON.stringify(e)) {
    t(rt.get(r), Aa.get(r));
    return;
  }
  Ta = JSON.stringify(e);
  const a = rt.get(r) ?? r.createTexture();
  if (r.bindTexture(r.TEXTURE_CUBE_MAP, a), !e) {
    console.warn("[CubemapLayer][loadCubemapTexture]: Faces are null");
    return;
  }
  const o = Object.keys(e).length;
  if (o !== 6) {
    console.warn(`[CubemapLayer][loadCubemapTexture]: Faces should contain exactly 6 images, but found ${o}`);
    return;
  }
  const i = Object.entries(e).map(([s, l]) => new Promise((u, c) => {
    const p = s;
    if (l === void 0) {
      c(new Error(`[CubemapLayer][loadCubemapTexture]: Face ${s} is undefined`));
      return;
    }
    const f2 = new Image();
    f2.crossOrigin = "anonymous";
    const d = () => {
      u({ image: f2, key: p });
    };
    f2.src = l, f2.complete && f2.naturalWidth > 0 ? d() : f2.onload = d, f2.onerror = () => {
      c(new Error(`[CubemapLayer][loadCubemapTexture]: Error loading image ${l}`));
    };
  }));
  Promise.all(i).then((s) => {
    for (let u = 0; u < s.length; u++) {
      const p = r.RGBA, f2 = r.RGBA, d = r.UNSIGNED_BYTE, { image: h, key: m } = s[u] ?? {};
      if (!h || !m) {
        console.warn("[CubemapLayer][loadCubemapTexture]: Image or key is null");
        continue;
      }
      const g = ic(r, m);
      r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(g, 0, p, f2, d, h);
    }
    r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.generateMipmap(r.TEXTURE_CUBE_MAP), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR);
    const l = s.map((u) => u.image);
    t(a, l), Aa.set(r, l), rt.set(r, a);
  }).catch((s) => {
    console.error("[CubemapLayer][loadCubemapTexture]: Error loading cubemap texture", s);
  });
}
function ic(r, e) {
  if (e === Ue.POSITIVE_X)
    return r.TEXTURE_CUBE_MAP_POSITIVE_X;
  if (e === Ue.NEGATIVE_X)
    return r.TEXTURE_CUBE_MAP_NEGATIVE_X;
  if (e === Ue.POSITIVE_Y)
    return r.TEXTURE_CUBE_MAP_POSITIVE_Y;
  if (e === Ue.NEGATIVE_Y)
    return r.TEXTURE_CUBE_MAP_NEGATIVE_Y;
  if (e === Ue.POSITIVE_Z)
    return r.TEXTURE_CUBE_MAP_POSITIVE_Z;
  if (e === Ue.NEGATIVE_Z)
    return r.TEXTURE_CUBE_MAP_NEGATIVE_Z;
  throw new Error(`[CubemapLayer][loadCubemapTexture]: Invalid key ${e}`);
}
function sc(r, e, t) {
  return [
    Oe(r[0], e[0], t),
    Oe(r[1], e[1], t),
    Oe(r[2], e[2], t),
    Oe(r[3], e[3], t)
  ];
}
function Oe(r, e, t) {
  return r + (e - r) * t;
}
function tr(r) {
  if (!r)
    return {};
  const e = Object.keys(r).sort().map((t) => [t, r[t]]);
  return Object.fromEntries(e);
}
var Qe = "https://api.maptiler.com/resources/space";
var lc = ["vertexPosition"];
var uc = ["projectionMatrix", "modelViewMatrix", "cubeSampler", "bgColor", "fadeOpacity"];
var Ia = "%USE_TEXTURE_MACRO_MARKER%";
var cc = "#define USE_TEXTURE";
var _a = ze.stars;
function pc(r, e) {
  if (!Jr(r))
    return {
      color: "transparent"
    };
  if (r === true)
    return e;
  const t = {
    ...r
  };
  if (r.faces || r.path)
    return delete t.preset, t;
  const n = r.preset;
  if (!(n === void 0) && !(n in ze))
    throw new Error(`[CubemapLayer]: Invalid preset "${n}". Available presets: ${Object.keys(ze).join(", ")}`);
  return {
    ...t,
    // this _could_ be nullish_
    color: t.color ?? ze[n].color ?? "hsl(233,100%,92%)"
  };
}
var $t = class {
  /**
   * Creates a new instance of CubemapLayer
   *
   * @param {CubemapLayerConstructorOptions | true} cubemapConfig - Configuration options for the cubemap layer or `true` to use default options.
   * Can specify faces, preset, path, and color properties to configure the cubemap.
   *
   * @remarks You shouldn't have to use this class directly.
   * Instead, use the `Map.setHalo` method to create and add a halo layer to the map.
   * The constructor initializes the cubemap with the provided configuration.
   * It processes the faces definition, sets up background colors, and determines
   * whether to use a cubemap texture based on the provided options.
   */
  constructor(e) {
    y(this, "id", "Cubemap Layer");
    y(this, "type", "custom");
    y(this, "renderingMode", "3d");
    y(this, "map");
    y(this, "faces");
    y(this, "useCubemapTexture", true);
    y(this, "currentFadeOpacity", 0);
    y(this, "cubeMapNeedsUpdate", false);
    y(this, "bgColor");
    y(this, "previousBgColor", [0, 0, 0, 0]);
    y(this, "targetBgColor", [0, 0, 0, 0]);
    y(this, "transitionDelta", 0);
    y(this, "gl");
    y(this, "cubemap");
    y(this, "texture");
    y(this, "currentFacesDefinitionKey", "");
    y(this, "options");
    y(this, "animationActive", true);
    y(this, "imageIsAnimating", false);
    y(this, "imageFadeInDelta", 0);
    const t = Jr(e);
    if (t.length > 0)
      throw new Error(`[CubemapLayer]: Invalid cubemap specification:
- ${t.join(`
 - `)}`);
    const n = pc(e, _a);
    this.options = n, this.currentFacesDefinitionKey = JSON.stringify(n.faces ?? n.preset ?? n.path), this.bgColor = [0, 0, 0, 0], this.targetBgColor = Vt(n.color), this.faces = Ma(n), this.useCubemapTexture = this.faces !== null;
  }
  /**
   * Updates the cubemap object with the current faces and shader configuration.
   * This method is called when the cubemap faces change or when the layer is initialized.
   * @returns {void}
   * @remarks
   * It creates a new Object3D instance with the specified vertex and fragment shaders,
   * attributes, and uniforms. The cubemap will be rendered using this configuration.
   */
  updateCubemap({ facesNeedUpdate: e } = { facesNeedUpdate: true }) {
    this.useCubemapTexture = this.faces !== null;
    const t = uc.filter((n) => n === "cubeSampler" || n === "fadeOpacity" ? this.useCubemapTexture : true);
    this.cubemap = Vo({
      gl: this.gl,
      vertexShaderSource: rc,
      // Because we only want to use the read the texture in gl if we're supposed to
      fragmentShaderSource: this.useCubemapTexture ? Ca.replace(Ia, cc) : Ca.replace(Ia, ""),
      attributesKeys: lc,
      uniformsKeys: t,
      vertices: ec,
      indices: tc
    }), this.cubeMapNeedsUpdate = e, this.useCubemapTexture && this.updateTexture(this.gl, this.faces), this.animateColorChange();
  }
  /**
   * Called when the layer is added to the map.
   * Initializes the cubemap and sets up the WebGL context.
   *
   * @param {MapSDK} map - The map instance to which this layer is added.
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   */
  onAdd(e, t) {
    this.map = e, this.gl = t, this.updateCubemap();
  }
  /**
   * Called when the layer is removed from the map.
   * Cleans up the cubemap resources and WebGL buffers.
   *
   * @param {MapSDK} _map - The map instance from which this layer is removed.
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   */
  onRemove(e, t) {
    this.cubemap && (this.texture && (ac(t), this.texture = void 0), t.deleteProgram(this.cubemap.shaderProgram), t.deleteBuffer(this.cubemap.positionBuffer));
  }
  /**
   * Updates the cubemap texture with the provided faces.
   * This method is called when the cubemap faces change or when the layer is initialized.
   *
   * @param {WebGLContext} gl - The WebGL context used for rendering.
   * @param {CubemapFaces} faces - The cubemap faces to be loaded into the texture.
   */
  updateTexture(e, t) {
    if (this.cubeMapNeedsUpdate === true && !this.imageIsAnimating) {
      if (this.cubeMapNeedsUpdate = false, !this.useCubemapTexture)
        return;
      oc({
        gl: e,
        faces: t,
        onReady: (n) => {
          this.texture = n, this.animateIn();
        }
      });
    }
  }
  /**
   * Called before the layer is rendered.
   * Updates the cubemap texture with the current faces.
   *
   * @param {WebGLContext} gl - The WebGL context used for rendering.
   * @param {CustomRenderMethodInput} _options - Additional options for the render method.
   */
  prerender(e, t) {
    this.faces && this.updateTexture(this.gl, this.faces);
  }
  /**
   * Lerps the background color transition of the cubemap layer.
   * This method smoothly transitions the background color from the previous color to the target color.
   *
   * @private
   */
  animateColorChange() {
    const e = () => {
      this.transitionDelta < 1 && (requestAnimationFrame(e), this.bgColor = sc(this.previousBgColor, this.targetBgColor, this.transitionDelta), this.transitionDelta += 0.075, this.map.triggerRepaint());
    };
    requestAnimationFrame(e);
  }
  /**
   * Animates the cubemap image fading in.
   * This method gradually increases the opacity of the cubemap image to create a fade-in effect.
   * @private
   */
  async animateIn() {
    if (!this.imageIsAnimating) {
      if (!this.animationActive) {
        this.currentFadeOpacity = 1, this.imageFadeInDelta = 1, this.map.triggerRepaint();
        return;
      }
      return new Promise((e) => {
        this.imageIsAnimating = true;
        const t = () => {
          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = Oe(0, 1, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta < 1) {
            requestAnimationFrame(t);
            return;
          }
          this.imageIsAnimating = false, this.imageFadeInDelta = 0, e();
        };
        requestAnimationFrame(t);
      });
    }
  }
  /**
   * Animates the cubemap image fading out.
   * This method gradually decreases the opacity of the cubemap image to create a fade-out effect.
   * @returns {Promise<void>} A promise that resolves when the animation is complete.
   * @private
   */
  async animateOut() {
    if (!(this.imageIsAnimating || !this.animationActive))
      return new Promise((e) => {
        const t = () => {
          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = Oe(1, 0, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta >= 1) {
            this.imageIsAnimating = false, this.imageFadeInDelta = 0, e();
            return;
          }
          requestAnimationFrame(t);
        };
        requestAnimationFrame(t);
      });
  }
  setAnimationActive(e) {
    this.animationActive = e;
  }
  /**
   * Renders the cubemap layer to the WebGL context.
   * This method is called internally during the rendering phase of the map.
   *
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   * @param {CustomRenderMethodInput} _options - Additional options for the render method.
   * @throws Error if the map, cubemap, or texture is undefined.
   */
  render(e, t) {
    if (!this.map.isGlobeProjection())
      return;
    if (this.map === void 0)
      throw new Error("[CubemapLayer]: Map is undefined");
    if (this.cubemap === void 0)
      throw new Error("[CubemapLayer]: Cubemap is undefined");
    this.texture, e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.DST_ALPHA), e.useProgram(this.cubemap.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.cubemap.positionBuffer), e.vertexAttribPointer(this.cubemap.programInfo.attributesLocations.vertexPosition, 3, e.FLOAT, false, 0, 0), e.enableVertexAttribArray(this.cubemap.programInfo.attributesLocations.vertexPosition);
    const n = 0.1, a = 1e4, o = e.canvas, i = o.clientWidth / o.clientHeight, s = this.map.transform, l = s.fov * (Math.PI / 180), u = yt();
    $u(u, l, i, n, a), ba(u, u, s.rollInRadians), va(u, u, -s.pitchInRadians), ba(u, u, s.bearingInRadians);
    const c = s.center.lat * Math.PI / 180, p = s.center.lng * Math.PI / 180;
    va(u, u, c), zu(u, u, -p), e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.projectionMatrix, false, u);
    const f2 = yt();
    if (e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.modelViewMatrix, false, f2), e.uniform4fv(this.cubemap.programInfo.uniformsLocations.bgColor, new Float32Array(this.bgColor)), e.uniform1f(this.cubemap.programInfo.uniformsLocations.fadeOpacity, this.currentFadeOpacity), this.useCubemapTexture && this.texture && (e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_CUBE_MAP, this.texture), e.uniform1i(this.cubemap.programInfo.uniformsLocations.cubeSampler, 0)), this.cubemap.indexBuffer === void 0)
      throw new Error("Index buffer is undefined");
    if (this.cubemap.indexBufferLength === void 0)
      throw new Error("Index buffer length is undefined");
    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.cubemap.indexBuffer), e.drawElements(e.TRIANGLES, this.cubemap.indexBufferLength, e.UNSIGNED_SHORT, 0);
  }
  setBgColor(e) {
    this.targetBgColor = e, this.previousBgColor = this.bgColor, this.transitionDelta = 0;
  }
  /**
   * Returns the current configuration options for the cubemap layer.
   * @returns {CubemapLayerConstructorOptions} The current configuration options.
   */
  getConfig() {
    return this.options;
  }
  /**
   * Checks if the cubemap needs to be updated based on the provided specification.
   *
   * @param {CubemapDefinition} spec - The cubemap specification to compare with the current cubemap.
   * @returns {boolean} True if the cubemap needs to be updated, false otherwise.
   */
  shouldUpdate(e) {
    const t = this.getConfig();
    if (e === void 0 && t)
      return true;
    const n = typeof e == "boolean" ? e : tr(e), a = tr(t);
    return JSON.stringify(n) !== JSON.stringify(a);
  }
  async setCubemapFaces(e) {
    if (await this.animateOut(), !e.faces && !e.preset && !e.path) {
      this.faces = null, this.useCubemapTexture = false, this.currentFacesDefinitionKey = "empty", await this.animateIn();
      return;
    }
    this.faces = Ma(e), this.currentFacesDefinitionKey = JSON.stringify(e.faces ?? e.preset ?? e.path);
  }
  /**
   * Sets the cubemap for the layer based on the provided definition.
   * This method updates the cubemap faces, background color, and triggers a repaint of the map.
   *
   * @param {CubemapDefinition} cubemap - The cubemap definition containing faces, preset, path, or color.
   * @returns {Promise<void>} A promise that resolves when the cubemap is set and the map is updated.
   * @remarks
   * This method checks if the provided cubemap definition has a color, and if so, it updates the background color.
   * It also checks if the faces definition has changed compared to the current one,
   * and if so, it updates the cubemap faces.
   * Finally, it calls `updateCubemap` to apply the changes and trigger a repaint of the map.
   */
  async setCubemap(e) {
    const t = Jr(e);
    if (t.length > 0)
      throw new Error(`[CubemapLayer]: Invalid cubemap specification:
- ${t.join(`
 - `)}`);
    const n = typeof e == "boolean" ? _a : e;
    this.options = n;
    const a = JSON.stringify(n.faces ?? n.preset ?? n.path), o = this.currentFacesDefinitionKey !== a;
    o && (await this.setCubemapFaces(n), this.cubeMapNeedsUpdate = true);
    const i = Vt(n.color);
    if (n.color && this.targetBgColor.toString() !== i.toString())
      this.setBgColor(i);
    else if (!n.color && n.preset && n.preset in ze) {
      const s = ze[n.preset];
      this.setBgColor(Vt(s.color));
    }
    this.updateCubemap({ facesNeedUpdate: o });
  }
  /**
   * Shows the cubemap layer by setting its visibility to "visible".
   * This method is used to make the cubemap layer visible on the map.
   */
  show() {
    this.map.setLayoutProperty(this.id, "visibility", "visible");
  }
  /**
   * Hides the cubemap layer by setting its visibility to "none".
   * This method is used to remove the cubemap layer from the map without deleting it.
   */
  hide() {
    this.map.setLayoutProperty(this.id, "visibility", "none");
  }
};
function Jr(r) {
  const e = [];
  if (typeof r > "u")
    return e.push("Space specification is undefined."), e;
  if (typeof r == "boolean")
    return [];
  if (Object.keys(r).length === 0)
    return e.push("Space specification is an empty object."), e;
  const t = ["color", "preset", "path", "faces"], n = Object.keys(r).filter((o) => !t.includes(o));
  if (n.length > 0)
    return e.push(
      `Space specification contains unsupported properties: ${n.map((o) => `\`${o}\``).join(", ")}. Supported properties: \`color\`, \`preset\`, \`path\`, \`faces\`.`
    ), e;
  if (!r.path && !r.preset && !r.faces && !r.color)
    return e.push("Space specification contains neither a path, preset, faces, nor color."), e;
  r.preset && !(r.preset in ze) && e.push(`Space preset "${r.preset}" is not a valid preset. Available presets: ${Object.keys(ze).join(", ")}`);
  const a = Object.keys(r).filter((o) => o !== "color").filter((o) => o === "preset" || o === "path" || o === "faces");
  return a.length > 1 && e.push(
    `Space specification contains multiple properties for cubemap definition: ${a.join(", ")}. Only one of \`path\`, \`preset\`, or \`faces\` should be defined.`
  ), r.faces && (!r.faces.pX || !r.faces.nX || !r.faces.pY || !r.faces.nY || !r.faces.pZ || !r.faces.nZ) && e.push("Space specification contains faces but one or more of the faces are undefined."), r.faces && Object.values(r.faces).every((o) => typeof o != "string") && e.push("Space specification contains faces but one or more of the faces are not strings."), e;
}
function Ma(r) {
  if (r.faces)
    return r.faces;
  if (r.preset)
    return {
      pX: `${Qe}/${r.preset}/px.webp`,
      nX: `${Qe}/${r.preset}/nx.webp`,
      pY: `${Qe}/${r.preset}/py.webp`,
      nY: `${Qe}/${r.preset}/ny.webp`,
      pZ: `${Qe}/${r.preset}/pz.webp`,
      nZ: `${Qe}/${r.preset}/nz.webp`
    };
  if (r.path) {
    const e = r.path.baseUrl, t = r.path.format ?? "png";
    return {
      pX: `${e}/px.${t}`,
      nX: `${e}/nx.${t}`,
      pY: `${e}/py.${t}`,
      nY: `${e}/ny.${t}`,
      pZ: `${e}/pz.${t}`,
      nZ: `${e}/nz.${t}`
    };
  }
  return null;
}
var fc = `attribute vec3 a_position;

uniform mat4 u_matrix;
uniform mat4 u_rotationMatrix;

uniform float u_scale;

varying vec2 v_pos;
varying float v_scale;

void main() {
  v_scale = u_scale;
  v_pos = a_position.xy * u_scale;
  gl_Position = u_matrix * u_rotationMatrix * vec4(a_position, 1.0);
}
`;
var dc = `precision mediump float;
varying vec2 v_pos;
      
uniform int u_stopsNumber;
uniform float u_stops[100];
uniform vec4 u_colors[100];
uniform float u_maxDistance;

varying float v_scale;

const float EPSILON = 0.000001;

vec2 center = vec2(0.0, 0.0);
void main() {
  float rawDistance = distance(center, v_pos);
  float distanceFromGlobeEdge = rawDistance - 1.0;

    vec4 color = u_colors[0];

  // if we're further than the max distance, we should not render anything.
  // This is to always render a circle, otherwise we end up rendering
  // to the corners of the plane.
  if (distance(center, v_pos) > u_maxDistance * v_scale) {
    discard;
  }

  for (int i = 1; i < 100; i++) {
    // if we're past the last stop
    // we should fill to the end with the last stop color
    if (i >= u_stopsNumber) {
      color = u_colors[i - 1];
      break;
    }

    float scaledStopPosition = u_stops[i] * pow(v_scale, 1.6);
    float lastStopValue = u_stops[i - 1];
    float thisStopValue = u_stops[i];

    // this is to avoid blending errors when the stops are the same
    // eg when you would want a sharp edge between two stops.
    // \`numbersAreEqual\` will be 1.0 if the numbers are equal, 0.0 if they are not.
    // We then subtract EPSILON from the last stop making the stop value _almost_ equal
    // to the next stop but not enough to cause blending issues.
    // It's more efficient to do this than an if / else statement.
    float numbersAreEqual = 1.0 - step(EPSILON, abs(lastStopValue - thisStopValue));
    lastStopValue = lastStopValue - numbersAreEqual * EPSILON;

    float lastScaledStopPosition = lastStopValue * pow(v_scale, 1.6);

    if (distanceFromGlobeEdge <= scaledStopPosition) {
      float stopBlendFactor = (distanceFromGlobeEdge - lastScaledStopPosition) / (scaledStopPosition - lastScaledStopPosition);
      color = mix(u_colors[i - 1], u_colors[i], stopBlendFactor);
      break;
    }
  }
  
  // gl_FragColor = color;
  gl_FragColor = vec4(color.rgb * color.a, color.a);
}
`;
var ke = 2;
var hc = ["position"];
var mc = ["matrix", "rotationMatrix", "stopsNumber", "stops", "colors", "maxDistance", "scale"];
var yc = [
  -ke,
  -ke,
  0,
  ke,
  -ke,
  0,
  -ke,
  ke,
  0,
  ke,
  ke,
  0
];
var Nt = [
  [0, "rgba(176, 208, 240, 1)"],
  [0.1, "rgba(98, 168, 229, 0.3)"],
  [0.2, "rgba(98, 168, 229, 0.0)"]
];
var jt = 0.9;
var Pa = 0.06;
var Dt = class {
  /**
   * Creates a new RadialGradientLayer instance.
   *
   * @param {RadialGradientLayerConstructorOptions | boolean} gradient - Configuration options for the radial gradient or a boolean value.
   * If a boolean is provided, default configuration options will be used.
   * If an `RadialGradientLayerConstructorOptions` is provided, it will be merged with default options.
   */
  constructor(e) {
    y(this, "id", "Halo Layer");
    y(this, "type", "custom");
    y(this, "renderingMode", "3d");
    y(this, "gradient");
    y(this, "scale", 0);
    y(this, "animationDelta", 0);
    y(this, "map");
    y(this, "plane");
    y(this, "animationActive", true);
    if (typeof e == "boolean") {
      this.gradient = {
        scale: jt,
        stops: Nt
      };
      return;
    }
    const t = Ra(e);
    if (t.length > 0)
      throw new Error(`[RadialGradientLayer]: Invalid Halo specification:
 - ${t.join(`
 - `)}
    `);
    this.gradient = {
      scale: e.scale ?? jt,
      stops: e.stops ?? Nt
    };
  }
  /**
   * Adds the radial gradient layer to the specified map.
   * This method is called by the map when the layer is added to it.
   *
   * @param {MapSDK} map - The MapSDK instance to which this layer is being added
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL rendering context used for rendering the layer
   * @returns void
   */
  onAdd(e, t) {
    this.map = e, this.plane = Vo({
      gl: t,
      vertexShaderSource: fc,
      fragmentShaderSource: dc,
      attributesKeys: hc,
      uniformsKeys: mc,
      vertices: yc
    }), this.animateIn();
  }
  /**
   * Returns the current gradient configuration of the radial gradient layer.
   *
   * @returns {GradientDefinition} The current gradient configuration.
   */
  getConfig() {
    return this.gradient;
  }
  /**
   * Checks if the gradient needs to be updated based on the provided specification.
   *
   * @param {GradientDefinition} spec - The gradient specification to compare with the current gradient.
   * @returns {boolean} True if the gradient needs to be updated, false otherwise.
   */
  shouldUpdate(e) {
    const t = this.getConfig();
    if (e === void 0 && t)
      return true;
    const n = typeof e == "boolean" ? e : tr(e), a = tr(t);
    return JSON.stringify(n) !== JSON.stringify(a);
  }
  /**
   * Animates the radial gradient into view by gradually scaling from 0 to the target scale.
   *
   * This method uses requestAnimationFrame to create a smooth scaling animation effect.
   * During each frame, it:
   *   1. Interpolates the scale value between 0 and the target scale
   *   2. Increments the animation progress (animationDelta)
   *   3. Triggers a map repaint
   *
   * @private
   * @returns {Promise<void>} A promise that resolves when the animation completes
   */
  async animateIn() {
    if (!this.animationActive) {
      this.scale = this.gradient.scale, this.animationDelta = 1, this.map.triggerRepaint();
      return;
    }
    return new Promise((e) => {
      this.animationDelta = 0;
      const t = () => {
        if (this.animationDelta <= 1) {
          this.scale = Oe(0, this.gradient.scale, this.animationDelta), this.animationDelta += Pa, this.map.triggerRepaint(), requestAnimationFrame(t);
          return;
        }
        e();
      };
      requestAnimationFrame(t);
    });
  }
  /**
   * Animates the radial gradient layer out by gradually reducing its scale to zero.
   *
   * This method creates a smooth transition effect by linearly interpolating the scale
   * from its current value to zero over multiple animation frames. During each frame,
   * the animation progresses by incrementing the internal animation delta value.
   *
   * The map is repainted after each animation step to reflect the updated scale.
   *
   * @private
   * @returns A Promise that resolves when the animation is complete.
   */
  async animateOut() {
    if (this.animationActive)
      return this.animationDelta = 0, new Promise((e) => {
        const t = () => {
          if (this.animationDelta < 1) {
            this.scale = Oe(this.gradient.scale, 0, this.animationDelta), this.animationDelta += Pa, this.map.triggerRepaint(), requestAnimationFrame(t);
            return;
          }
          e();
        };
        t();
      });
  }
  onRemove(e, t) {
    this.plane !== void 0 && (t.deleteProgram(this.plane.shaderProgram), t.deleteBuffer(this.plane.positionBuffer));
  }
  prerender(e, t) {
  }
  render(e, t) {
    if (this.map === void 0)
      throw new Error("[RadialGradientLayer]: Map is undefined");
    if (!this.map.isGlobeProjection())
      return;
    if (this.plane === void 0)
      throw new Error("[RadialGradientLayer]: Plane is undefined");
    e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.useProgram(this.plane.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.plane.positionBuffer);
    const n = this.plane.programInfo.attributesLocations.position;
    e.enableVertexAttribArray(n), e.vertexAttribPointer(n, 3, e.FLOAT, false, 0, 0);
    const a = yt(), o = this.scale;
    Ou(a, a, [o, o, o]);
    const i = yt();
    Ru(i, t.defaultProjectionData.mainMatrix, a);
    const s = this.plane.programInfo.uniformsLocations.matrix;
    e.uniformMatrix4fv(s, false, i);
    const l = yt(), u = this.map.transform.cameraPosition, c = Or(qt(), u), p = Nu(0, 1, 0), f2 = qt();
    wa(f2, p, c), Or(f2, f2);
    const d = qt();
    wa(d, c, f2), Or(d, d), Pu(l, f2[0], f2[1], f2[2], 0, d[0], d[1], d[2], 0, c[0], c[1], c[2], 0, 0, 0, 0, 1);
    const h = this.plane.programInfo.uniformsLocations.rotationMatrix;
    e.uniformMatrix4fv(h, false, l);
    const m = this.gradient.stops.length, g = [], b = [];
    for (let v = 0; v <= m; v++)
      if (v < m) {
        g[v] = this.gradient.stops[v][0];
        const x = Vt(this.gradient.stops[v][1]);
        b.push(...x);
      }
    e.uniform1i(this.plane.programInfo.uniformsLocations.stopsNumber, m), e.uniform1fv(this.plane.programInfo.uniformsLocations.stops, new Float32Array(g)), e.uniform4fv(this.plane.programInfo.uniformsLocations.colors, new Float32Array(b)), e.uniform1f(this.plane.programInfo.uniformsLocations.maxDistance, ke), e.uniform1f(this.plane.programInfo.uniformsLocations.scale, o), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
  }
  /**
   * Sets a new gradient for the radial gradient layer and animates the transition.
   *
   * This method first animates the current gradient out, then updates the gradient
   * property with the new gradient definition, and finally animates the new gradient in.
   *
   * @param {GradientDefinition} gradient - The new gradient definition to set for this layer.
   * @returns {Promise<void>} A promise that resolves when the new gradient is set and animated in.
   */
  async setGradient(e) {
    if (e === false) {
      await this.animateOut();
      return;
    }
    await this.animateOut();
    const t = Ra(e);
    if (t.length > 0)
      throw new Error(`[RadialGradientLayer]: Invalid Halo specification:
 - ${t.join(`
 - `)}
    `);
    e === true ? (this.gradient.scale = jt, this.gradient.stops = Nt) : (this.gradient.scale = e.scale ?? jt, this.gradient.stops = e.stops ?? Nt), await this.animateIn();
  }
  setAnimationActive(e) {
    this.animationActive = e;
  }
  show() {
    this.map.setLayoutProperty(this.id, "visibility", "visible");
  }
  hide() {
    this.map.setLayoutProperty(this.id, "visibility", "none");
  }
};
var gc = ["scale", "stops"];
function Ra(r) {
  var t;
  const e = [];
  if (typeof r == "boolean")
    return [];
  try {
    const n = Object.keys(r).filter((a) => !gc.includes(a));
    n.length > 0 && e.push(`Properties ${n.map((a) => `\`${a}\``).join(", ")} are not supported.`);
  } catch {
    e.push("Halo specification is not an object.");
  }
  return typeof r.scale != "number" && e.push("Halo `scale` property is not a number."), !r.stops || r.stops.length === 0 || !Array.isArray(r.stops) ? (e.push("Halo `stops` property is not an array."), e) : ((t = r.stops) != null && t.some((n) => typeof n[0] != "number" || typeof n[1] != "string") && e.push("Halo `stops` property is not an array of [number, string]"), e);
}
function vc() {
  const r = "color: #3A1888; background: white; padding: 5px 0; font-weight: bold;", e = "color: #FBC935; background: white; padding: 5px; font-weight: bold;", t = "color: #F1175D; background: white; padding: 5px 0; font-weight: bold;";
  console.info(
    `%c%c%c %cMapTiler SDK JS v${wi()} %c%c%c`,
    e + "padding-right: 0;",
    r,
    t,
    "color: #333; background: white; padding: 5px 0; font-weight: bold;",
    t,
    r,
    e + "padding-left: 0;"
  );
}
var bc = {
  POINT: "POINT",
  COUNTRY: "COUNTRY"
};
var Go = class Ho extends import_maplibre_gl.default.Map {
  constructor(t) {
    t.logSDKVersion !== false && vc(), es(t.container), t.apiKey && (j.apiKey = t.apiKey);
    const { style: n, requiresUrlMonitoring: a, isFallback: o } = ma(t.style);
    o && console.warn(
      "Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."
    ), j.apiKey || console.warn("MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!");
    const i = location.hash;
    let s = {
      compact: false
    };
    t.customAttribution ? s.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == "object" && (s = {
      ...s,
      ...t.attributionControl
    });
    const l = {
      ...t,
      style: n,
      maplibreLogo: false,
      transformRequest: Kn(t.transformRequest),
      attributionControl: t.forceNoAttributionControl === true ? false : s
    };
    delete l.style;
    super(l);
    y(this, "telemetry");
    y(this, "space");
    y(this, "halo");
    y(this, "options");
    y(this, "isTerrainEnabled", false);
    y(this, "terrainExaggeration", 1);
    y(this, "primaryLanguage");
    y(this, "terrainGrowing", false);
    y(this, "terrainFlattening", false);
    y(this, "minimap");
    y(this, "forceLanguageUpdate");
    y(this, "languageAlwaysBeenStyle");
    y(this, "isReady", false);
    y(this, "terrainAnimationDuration", 1e3);
    y(this, "monitoredStyleUrls");
    y(this, "styleInProcess", false);
    y(this, "curentProjection");
    y(this, "originalLabelStyle", new window.Map());
    y(this, "isStyleLocalized", false);
    y(this, "languageIsUpdated", false);
    y(this, "spaceboxLoadingState", {
      styleLoadCallbackSet: false,
      styleLoadedCallbackFired: false
    });
    this.options = t, this.setStyle(n), a && this.monitorStyleUrl(n);
    const u = () => {
      let h = "The distant style could not be loaded.";
      this.getStyle() ? h += " Leaving the style as is." : (this.setStyle(MapStyle.STREETS), h += `Loading default MapTiler Cloud style "${MapStyle.STREETS.getDefaultVariant().getId()}" as a fallback.`), console.warn(h);
    };
    if (this.on("style.load", () => {
      this.styleInProcess = false, (typeof t.rtlTextPlugin == "string" || typeof t.rtlTextPlugin > "u") && Yi(t.rtlTextPlugin);
    }), this.on("error", (h) => {
      if (h.error instanceof import_maplibre_gl.default.AJAXError) {
        const g = h.error.url, b = new URL(g);
        b.search = "";
        const v = b.href;
        this.monitoredStyleUrls && this.monitoredStyleUrls.has(v) && (this.monitoredStyleUrls.delete(v), u());
        return;
      }
      if (this.styleInProcess) {
        u();
        return;
      }
    }), j.caching && !Br && console.warn("The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache"), j.caching && Br && Xi(), typeof t.language > "u")
      this.primaryLanguage = j.primaryLanguage;
    else {
      const h = toLanguageInfo(t.language, O);
      this.primaryLanguage = h ?? j.primaryLanguage;
    }
    this.forceLanguageUpdate = !(this.primaryLanguage === O.STYLE || this.primaryLanguage === O.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === O.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = t.projection, this.on("style.load", (h) => {
      this.curentProjection === "mercator" ? this.setProjection({ type: "mercator" }) : this.curentProjection === "globe" && this.setProjection({ type: "globe" });
    }), this.once("styledata", async () => {
      if (!t.geolocate || t.center || t.hash && i)
        return;
      try {
        if (t.geolocate === bc.COUNTRY) {
          await this.fitToIpBounds();
          return;
        }
      } catch (g) {
        console.warn(g.message);
      }
      let h;
      try {
        await this.centerOnIpPoint(t.zoom), h = this.getCameraHash();
      } catch (g) {
        console.warn(g.message);
      }
      (await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted" && navigator.geolocation.getCurrentPosition(
        // success callback
        (g) => {
          h === this.getCameraHash() && (this.terrain ? this.easeTo({
            center: [g.coords.longitude, g.coords.latitude],
            zoom: t.zoom || 12,
            duration: 2e3
          }) : this.once("terrain", () => {
            this.easeTo({
              center: [g.coords.longitude, g.coords.latitude],
              zoom: t.zoom || 12,
              duration: 2e3
            });
          }));
        },
        // error callback
        null,
        // options
        {
          maximumAge: 24 * 3600 * 1e3,
          // a day in millisec
          timeout: 5e3,
          // milliseconds
          enableHighAccuracy: false
        }
      );
    }), this.on("styledata", () => {
      this.setPrimaryLanguage(this.primaryLanguage);
    }), this.on("styledata", () => {
      this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);
    }), this.once("load", async () => {
      let h = { logo: null };
      try {
        const m = Object.keys(this.style.tileManagers).map((v) => this.getSource(v)).filter((v) => v && "url" in v && typeof v.url == "string" && v.url.includes("tiles.json")), g = new URL(m[0].url);
        g.searchParams.has("key") || g.searchParams.append("key", j.apiKey), h = await (await fetch(g.href)).json();
      } catch {
      }
      if (t.customControls) {
        const m = "[data-maptiler-control-group]", g = "[data-maptiler-control]", b = (A) => {
          let N = A.dataset.maptilerControl;
          return (N === "true" || N === "") && (N = void 0), N;
        }, v = (A) => A.dataset.maptilerPosition;
        let x = [...this._container.ownerDocument.querySelectorAll(m)], C = [...this._container.ownerDocument.querySelectorAll(g)].filter(
          (A) => A.closest(m) === null
        );
        if (typeof t.customControls == "string") {
          const A = t.customControls;
          x = x.filter((N) => N.matches(A) || N.closest(A) !== null), C = C.filter((N) => N.matches(A) || N.closest(A) !== null);
        }
        for (const A of x) {
          const N = new Wr(A);
          this.addControl(N, v(A));
          for (const le of A.querySelectorAll(g))
            N.configureGroupItem(le, b(le));
        }
        for (const A of C)
          this.addControl(new Wr(A, b(A)), v(A));
        const E = () => {
          const { lng: A, lat: N } = this.getCenter();
          this._container.style.setProperty("--maptiler-center-lng", String(A)), this._container.style.setProperty("--maptiler-center-lat", String(N)), this._container.style.setProperty("--maptiler-zoom", String(this.getZoom())), this._container.style.setProperty("--maptiler-bearing", String(this.getBearing())), this._container.style.setProperty("--maptiler-pitch", String(this.getPitch())), this._container.style.setProperty("--maptiler-roll", String(this.getRoll())), this._container.style.setProperty("--maptiler-is-globe-projection", String(this.isGlobeProjection())), this._container.style.setProperty("--maptiler-has-terrain", String(this.hasTerrain()));
        };
        E(), this.on("render", E);
      }
      if (t.forceNoAttributionControl !== true)
        if ("logo" in h && h.logo) {
          const m = h.logo;
          this.addControl(new qn({ logoURL: m }), t.logoPosition);
        } else t.maptilerLogo && this.addControl(new qn(), t.logoPosition);
      if (t.scaleControl) {
        const m = t.scaleControl === true || t.scaleControl === void 0 ? "bottom-right" : t.scaleControl, g = new Ui({ unit: j.unit });
        this.addControl(g, m), j.on("unit", (b) => {
          g.setUnit(b);
        });
      }
      if (t.navigationControl !== false) {
        const m = t.navigationControl === true || t.navigationControl === void 0 ? "top-right" : t.navigationControl;
        this.addControl(new Cu(), m);
      }
      if (t.geolocateControl !== false) {
        const m = t.geolocateControl === true || t.geolocateControl === void 0 ? "top-right" : t.geolocateControl;
        this.addControl(
          // new maplibregl.GeolocateControl({
          new Tu({
            positionOptions: {
              enableHighAccuracy: true,
              maximumAge: 0,
              timeout: 6e3
            },
            fitBoundsOptions: {
              maxZoom: 15
            },
            trackUserLocation: true,
            showAccuracyCircle: true,
            showUserLocation: true
          }),
          m
        );
      }
      if (t.terrainControl) {
        const m = t.terrainControl === true || t.terrainControl === void 0 ? "top-right" : t.terrainControl;
        this.addControl(new Eu(), m);
      }
      if (t.projectionControl) {
        const m = t.projectionControl === true || t.projectionControl === void 0 ? "top-right" : t.projectionControl;
        this.addControl(new _u(), m);
      }
      if (t.fullscreenControl) {
        const m = t.fullscreenControl === true || t.fullscreenControl === void 0 ? "top-right" : t.fullscreenControl;
        this.addControl(new Bi({}), m);
      }
      this.isReady = true, this.fire("ready", { target: this });
    });
    let c = false, p = false, f2;
    this.once("ready", () => {
      c = true, p && this.fire("loadWithTerrain", f2);
    }), this.once("style.load", () => {
      const { minimap: h } = t;
      if (typeof h == "object") {
        const {
          zoom: m,
          center: g,
          style: b,
          language: v,
          apiKey: x,
          maptilerLogo: C,
          canvasContextAttributes: E,
          refreshExpiredTiles: A,
          maxBounds: N,
          scrollZoom: le,
          minZoom: Ye,
          maxZoom: We,
          boxZoom: X,
          locale: Je,
          fadeDuration: xi,
          crossSourceCollisions: ki,
          clickTolerance: Li,
          bounds: Ei,
          fitBoundsOptions: Ci,
          pixelRatio: Ai,
          validateStyle: Ti
        } = t;
        this.minimap = new Rr(h, {
          zoom: m,
          center: g,
          style: b,
          language: v,
          apiKey: x,
          container: "null",
          maptilerLogo: C,
          canvasContextAttributes: E,
          refreshExpiredTiles: A,
          maxBounds: N,
          scrollZoom: le,
          minZoom: Ye,
          maxZoom: We,
          boxZoom: X,
          locale: Je,
          fadeDuration: xi,
          crossSourceCollisions: ki,
          clickTolerance: Li,
          bounds: Ei,
          fitBoundsOptions: Ci,
          pixelRatio: Ai,
          validateStyle: Ti
        }), this.addControl(this.minimap, h.position ?? "bottom-left");
      } else h === true ? (this.minimap = new Rr({}, t), this.addControl(this.minimap, "bottom-left")) : h !== void 0 && h !== false && (this.minimap = new Rr({}, t), this.addControl(this.minimap, h));
    });
    const d = (h) => {
      h.terrain && (p = true, f2 = {
        type: "loadWithTerrain",
        target: this,
        terrain: h.terrain
      }, this.off("terrain", d), c && this.fire("loadWithTerrain", f2));
    };
    this.on("terrain", d), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration), this.once("load", () => {
      this.getCanvas().addEventListener("webglcontextlost", (m) => {
        if (this._removed === true) {
          console.warn("[webglcontextlost]", "WebGL context lost after map removal. This is harmless.");
          return;
        }
        console.warn("[webglcontextlost]", "Unexpected loss of WebGL context!"), this.fire("webglContextLost", m);
      });
      const h = this.getLayersOrder()[0];
      t.space && this.initSpace({ options: t, before: h }), t.halo && this.initHalo({ options: t, before: h });
    }), this.telemetry = new Mu(this);
  }
  getSpace() {
    return this.space;
  }
  /**
   * Sets the space for the map.
   * @param {CubemapDefinition} space the `CubemapDefinition` options to set.
   * @remarks This method, at present, ** overwrites ** the current config.
   * If an option is not set it will internally revert to the default option
   * unless explicitly set when calling.
   */
  setSpace(t, n = true) {
    if (n && (this.options.space = t), t === false) {
      this.space = void 0;
      return;
    }
    if (this.space) {
      this.space.setCubemap(t), this.getLayer(this.space.id) || this.addLayer(this.space, this.getLayersOrder()[0]);
      return;
    }
    this.space = new $t(t), this.once("load", () => {
      const a = this.getLayersOrder()[0];
      this.space && this.addLayer(this.space, a);
    });
  }
  /**
   * Enables the animations for the space layer.
   */
  enableSpaceAnimations() {
    this.setSpaceAnimationActive(true);
  }
  /**
   * Disables the animations for the space layer.
   */
  disableSpaceAnimations() {
    this.setSpaceAnimationActive(false);
  }
  /**
   * Enables the animations for the halo layer.
   */
  enableHaloAnimations() {
    this.setHaloAnimationActive(true);
  }
  /**
   * Disables the animations for the halo layer.
   */
  disableHaloAnimations() {
    this.setHaloAnimationActive(false);
  }
  /**
   * Sets whether the halo layer should be animated in and out.
   * @param active - Whether the animation should be active.
   */
  setHaloAnimationActive(t) {
    this.halo ? this.halo.setAnimationActive(t) : this.once("load", () => {
      var n;
      (n = this.halo) == null || n.setAnimationActive(t);
    });
  }
  /**
   * Sets whether the space layer should be animated in and out.
   * @param active - Whether the animation should be active.
   */
  setSpaceAnimationActive(t) {
    this.space ? this.space.setAnimationActive(t) : this.once("load", () => {
      var n;
      (n = this.space) == null || n.setAnimationActive(t);
    });
  }
  setSpaceFromStyle({ style: t }) {
    var a, o, i;
    if (this.options.space !== true && typeof this.options.space < "u") {
      this.setSpace(this.options.space);
      return;
    }
    const n = (o = (a = t.metadata) == null ? void 0 : a.maptiler) == null ? void 0 : o.space;
    if (!this.options.space && !n) {
      this.setSpace(false, false);
      return;
    }
    if (JSON.stringify((i = this.space) == null ? void 0 : i.getConfig()) === JSON.stringify(n)) {
      if (this.space && !this.getLayer(this.space.id)) {
        const s = this.getLayersOrder()[0];
        this.addLayer(this.space, s);
      }
      return;
    }
    if (this.options.space === true) {
      this.setSpace(n ?? true);
      return;
    }
    if (this.space && this.isGlobeProjection()) {
      if (!this.getLayer(this.space.id)) {
        const s = this.getLayersOrder()[0];
        this.addLayer(this.space, s);
      }
      this.space.setCubemap(n);
    }
  }
  setHaloFromStyle({ style: t }) {
    var o, i, s;
    if (this.options.halo === false)
      return;
    const n = (o = t.metadata) == null ? void 0 : o.maptiler;
    if (JSON.stringify((i = this.halo) == null ? void 0 : i.getConfig()) === JSON.stringify(n == null ? void 0 : n.halo)) {
      if (this.halo && !this.getLayer(this.halo.id)) {
        const l = this.getLayersOrder().indexOf(((s = this.space) == null ? void 0 : s.id) ?? "") + 1, u = this.getLayersOrder()[l];
        this.addLayer(this.halo, u);
      }
      return;
    }
    if (!(n != null && n.halo) && !this.options.halo) {
      this.setHalo({
        stops: [
          [0, "transparent"],
          [0.01, "transparent"]
        ],
        scale: 1
      });
      return;
    }
    (() => {
      var l;
      if (this.halo) {
        if (!this.getLayer(this.halo.id)) {
          const c = this.getLayersOrder().indexOf(((l = this.space) == null ? void 0 : l.id) ?? "") + 1, p = this.getLayersOrder()[c];
          this.addLayer(this.halo, p);
        }
        const u = (n == null ? void 0 : n.halo) ?? this.options.halo;
        u && this.halo.setGradient(u);
      }
    })();
  }
  initSpace({ options: t = this.options, before: n, spec: a }) {
    if (this.space) {
      this.getLayer(this.space.id) || this.addLayer(this.space, n);
      return;
    }
    if (t.space === false) return;
    if (t.space && t.space !== true) {
      this.space = new $t(t.space), this.addLayer(this.space, n);
      return;
    }
    const o = a;
    o && (this.space = new $t(o), this.addLayer(this.space, n)), this.options.space === true && (this.space = new $t(true), this.addLayer(this.space, n));
  }
  initHalo({ options: t = this.options, before: n, spec: a }) {
    if (this.halo && this.getLayer(this.halo.id) || t.halo === false) return;
    const o = a;
    if (t.halo && t.halo !== true) {
      this.halo = new Dt(t.halo), this.addLayer(this.halo, n);
      return;
    }
    if (o && (this.halo = new Dt(o), this.addLayer(this.halo, n)), this.options.halo === true) {
      this.halo = new Dt(true), this.addLayer(this.halo, n);
      return;
    }
  }
  getHalo() {
    return this.halo;
  }
  setHalo(t) {
    if (this.options.halo = t, !!this.isGlobeProjection()) {
      if (this.halo) {
        this.halo.setGradient(t);
        return;
      }
      this.halo = new Dt(t), this.once("load", () => {
        var s;
        const n = this.getLayersOrder(), a = n[0], o = n.indexOf(((s = this.space) == null ? void 0 : s.id) ?? "") + 2, i = n[o];
        this.halo && this.addLayer(this.halo, this.space ? i : a);
      });
    }
  }
  /**
   * Recreates the map instance with the same options.
   * Useful for WebGL context loss.
   */
  recreate() {
    const t = {
      center: this.getCenter(),
      zoom: this.getZoom(),
      bearing: this.getBearing(),
      pitch: this.getPitch()
    };
    this.remove(), Object.assign(this, new Ho({ ...this.options })), this.once("load", () => {
      this.jumpTo(t);
    });
  }
  /**
   * Set the duration (millisec) of the terrain animation for growing or flattening.
   * Must be positive. (Built-in default: `1000` milliseconds)
   */
  setTerrainAnimationDuration(t) {
    this.terrainAnimationDuration = Math.max(t, 0);
  }
  /**
   * Awaits for _this_ Map instance to be "loaded" and returns a Promise to the Map.
   * If _this_ Map instance is already loaded, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "load" event.
   * @returns
   */
  async onLoadAsync() {
    return new Promise((t) => {
      if (this.loaded()) {
        t(this);
        return;
      }
      this.once("load", () => {
        t(this);
      });
    });
  }
  /**
   * Awaits for _this_ Map instance to be "ready" and returns a Promise to the Map.
   * If _this_ Map instance is already ready, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "ready" event.
   * A map instance is "ready" when all the controls that can be managed by the contructor are
   * dealt with. This happens after the "load" event, due to the asynchronous nature
   * of some built-in controls.
   */
  async onReadyAsync() {
    return new Promise((t) => {
      if (this.isReady) {
        t(this);
        return;
      }
      this.once("ready", () => {
        t(this);
      });
    });
  }
  /**
   * Awaits for _this_ Map instance to be "loaded" as well as with terrain being non-null for the first time
   * and returns a Promise to the Map.
   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "loadWithTerrain" event.
   * @returns
   */
  async onLoadWithTerrainAsync() {
    return new Promise((t) => {
      if (this.isReady && this.terrain) {
        t(this);
        return;
      }
      this.once("loadWithTerrain", () => {
        t(this);
      });
    });
  }
  monitorStyleUrl(t) {
    typeof this.monitoredStyleUrls > "u" && (this.monitoredStyleUrls = /* @__PURE__ */ new Set());
    const n = new URL(t);
    n.search = "", this.monitoredStyleUrls.add(n.href);
  }
  /**
   * Update the style of the map.
   * Can be:
   * - a full style URL (possibly with API key)
   * - a shorthand with only the MapTIler style name (eg. `"streets-v2"`)
   * - a longer form with the prefix `"maptiler://"` (eg. `"maptiler://streets-v2"`)
   */
  setStyle(t, n) {
    var c, p, f2, d, h;
    this.originalLabelStyle.clear(), (c = this.minimap) == null || c.setStyle(t), this.forceLanguageUpdate = true, this.once("idle", () => {
      this.forceLanguageUpdate = false;
    });
    const a = ma(t);
    if (a.requiresUrlMonitoring && this.monitorStyleUrl(a.style), a.isFallback) {
      if (this.getStyle())
        return console.warn(
          "[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead."
        ), this;
      console.warn(
        "[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."
      );
    }
    this.spaceboxLoadingState.styleLoadedCallbackFired = false, this.spaceboxLoadingState.styleLoadCallbackSet = false;
    const o = this.getStyle(), i = a.style;
    try {
      super.setStyle(a.style, { ...n, diff: typeof a.style != "string" }), this.styleInProcess = true;
    } catch (m) {
      this.styleInProcess = false, console.error("[Map.setStyle]: Error while setting style:", m);
    }
    const s = () => {
      const m = a.style;
      if (!m.projection || m.projection.type === "mercator") {
        console.warn("[Map.setStyle]: Neither space nor halo is supported for mercator projection. Ignoring...");
        return;
      }
      this.setSpaceFromStyle({ style: a.style }), this.setHaloFromStyle({ style: a.style });
    }, l = (m) => {
      var b, v, x, C;
      const g = (m == null ? void 0 : m.target.getStyle()) ?? a.style;
      if (!this.spaceboxLoadingState.styleLoadedCallbackFired && (this.spaceboxLoadingState.styleLoadedCallbackFired = true, this.spaceboxLoadingState.styleLoadCallbackSet = false, typeof g != "string"))
        try {
          const E = this.getLayersOrder()[0];
          this.space ? this.setSpaceFromStyle({ style: g }) : this.initSpace({ before: E, spec: (v = (b = g.metadata) == null ? void 0 : b.maptiler) == null ? void 0 : v.space }), this.halo ? this.setHaloFromStyle({ style: g }) : this.initHalo({ before: E, spec: (C = (x = g.metadata) == null ? void 0 : x.maptiler) == null ? void 0 : C.halo });
        } catch (E) {
          console.error(E);
        }
    };
    return typeof a.style == "string" || a.requiresUrlMonitoring ? (this.once("style.load", l), this) : (requestIdleCallback(() => {
      try {
        l();
      } catch (m) {
        console.error(m);
      }
    }), this.spaceboxLoadingState.styleLoadCallbackSet ? ((p = o == null ? void 0 : o.terrain) == null ? void 0 : p.source) !== ((f2 = i == null ? void 0 : i.terrain) == null ? void 0 : f2.source) || ((d = o == null ? void 0 : o.terrain) == null ? void 0 : d.exaggeration) !== ((h = i == null ? void 0 : i.terrain) == null ? void 0 : h.exaggeration) ? (this.once("terrain", s), this) : this : (this.once("style.load", l), this.once("projection.change", l), this.spaceboxLoadingState.styleLoadCallbackSet = true, this));
  }
  /**
   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
   * to the map's style.
   *
   * A layer defines how data from a specified source will be styled. Read more about layer types
   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
   *
   * @param layer - The layer to add,
   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
   * less commonly, the {@link CustomLayerInterface} specification.
   * The MapLibre Style Specification's layer definition is appropriate for most layers.
   *
   * @param beforeId - The ID of an existing layer to insert the new layer before,
   * resulting in the new layer appearing visually beneath the existing layer.
   * If this argument is not specified, the layer will be appended to the end of the layers array
   * and appear visually above all other layers.
   *
   * @returns `this`
   */
  addLayer(t, n) {
    var a;
    return (a = this.minimap) == null || a.addLayer(t, n), super.addLayer(t, n);
  }
  /**
   * Moves a layer to a different z-position.
   *
   * @param id - The ID of the layer to move.
   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.
   * @returns `this`
   *
   * @example
   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.
   * ```ts
   * map.moveLayer('polygon', 'country-label');
   * ```
   */
  moveLayer(t, n) {
    var a;
    return (a = this.minimap) == null || a.moveLayer(t, n), super.moveLayer(t, n);
  }
  /**
   * Removes the layer with the given ID from the map's style.
   *
   * An {@link ErrorEvent} will be fired if the image parameter is invald.
   *
   * @param id - The ID of the layer to remove
   * @returns `this`
   *
   * @example
   * If a layer with ID 'state-data' exists, remove it.
   * ```ts
   * if (map.getLayer('state-data')) map.removeLayer('state-data');
   * ```
   */
  removeLayer(t) {
    var n;
    return (n = this.minimap) == null || n.removeLayer(t), super.removeLayer(t);
  }
  /**
   * Sets the zoom extent for the specified style layer. The zoom extent includes the
   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
   * at which the layer will be rendered.
   *
   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
   * layer will not be rendered at all zoom levels in the zoom range.
   */
  setLayerZoomRange(t, n, a) {
    var o;
    return (o = this.minimap) == null || o.setLayerZoomRange(t, n, a), super.setLayerZoomRange(t, n, a);
  }
  /**
   * Sets the filter for the specified style layer.
   *
   * Filters control which features a style layer renders from its source.
   * Any feature for which the filter expression evaluates to `true` will be
   * rendered on the map. Those that are false will be hidden.
   *
   * Use `setFilter` to show a subset of your source data.
   *
   * To clear the filter, pass `null` or `undefined` as the second parameter.
   */
  setFilter(t, n, a) {
    var o;
    return (o = this.minimap) == null || o.setFilter(t, n, a), super.setFilter(t, n, a);
  }
  /**
   * Sets the value of a paint property in the specified style layer.
   *
   * @param layerId - The ID of the layer to set the paint property in.
   * @param name - The name of the paint property to set.
   * @param value - The value of the paint property to set.
   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
   * @param options - Options object.
   * @returns `this`
   * @example
   * ```ts
   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
   * ```
   */
  setPaintProperty(t, n, a, o) {
    var i;
    return (i = this.minimap) == null || i.setPaintProperty(t, n, a, o), super.setPaintProperty(t, n, a, o);
  }
  /**
   * Sets the value of a layout property in the specified style layer.
   * Layout properties define how the layer is styled.
   * Layout properties for layers of the same type are documented together.
   * Layers of different types have different layout properties.
   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.
   * @param layerId - The ID of the layer to set the layout property in.
   * @param name - The name of the layout property to set.
   * @param value - The value of the layout property to set.
   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
   * @param options - Options object.
   * @returns `this`
   */
  setLayoutProperty(t, n, a, o) {
    var i;
    return (i = this.minimap) == null || i.setLayoutProperty(t, n, a, o), super.setLayoutProperty(t, n, a, o);
  }
  /**
   * Sets the value of the style's glyphs property.
   *
   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).
   * @param options - Options object.
   * @returns `this`
   * @example
   * ```ts
   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');
   * ```
   */
  setGlyphs(t, n) {
    var a;
    return (a = this.minimap) == null || a.setGlyphs(t, n), super.setGlyphs(t, n);
  }
  getStyleLanguage() {
    return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != "object" ? null : "maptiler:language" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata["maptiler:language"] == "string" ? getLanguageInfoFromFlag(this.style.stylesheet.metadata["maptiler:language"]) : null;
  }
  /**
   * Define the primary language of the map. Note that not all the languages shorthands provided are available.
   */
  setLanguage(t) {
    var n;
    (n = this.minimap) == null || n.map.setLanguage(t), this.onStyleReady(() => {
      this.setPrimaryLanguage(t);
    });
  }
  /**
   * Define the primary language of the map. Note that not all the languages shorthands provided are available.
   */
  setPrimaryLanguage(t) {
    const n = this.getStyleLanguage(), a = toLanguageInfo(t, O);
    if (!a) {
      console.warn(`The language "${a}" is not supported.`);
      return;
    }
    if (!(a.flag === O.STYLE.flag && n && (n.flag === O.AUTO.flag || n.flag === O.VISITOR.flag)) && (a.flag !== O.STYLE.flag && (this.languageAlwaysBeenStyle = false), this.languageAlwaysBeenStyle || this.primaryLanguage === a && !this.forceLanguageUpdate))
      return;
    if (this.primaryLanguage.flag === O.STYLE_LOCK.flag) {
      console.warn("The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.");
      return;
    }
    this.primaryLanguage = a;
    let o = a;
    if (a.flag === O.STYLE.flag) {
      if (!n) {
        console.warn("The style has no default languages or has an invalid one.");
        return;
      }
      o = n;
    }
    let i = O.LOCAL.flag, s = ["get", i];
    o.flag === O.VISITOR.flag ? (i = Bn().flag, s = [
      "case",
      ["all", ["has", i], ["has", O.LOCAL.flag]],
      [
        "case",
        ["==", ["get", i], ["get", O.LOCAL.flag]],
        ["get", O.LOCAL.flag],
        ["format", ["get", i], { "font-scale": 0.8 }, `
`, ["get", O.LOCAL.flag], { "font-scale": 1.1 }]
      ],
      ["get", O.LOCAL.flag]
    ]) : o.flag === O.VISITOR_ENGLISH.flag ? (i = O.ENGLISH.flag, s = [
      "case",
      ["all", ["has", i], ["has", O.LOCAL.flag]],
      [
        "case",
        ["==", ["get", i], ["get", O.LOCAL.flag]],
        ["get", O.LOCAL.flag],
        ["format", ["get", i], { "font-scale": 0.8 }, `
`, ["get", O.LOCAL.flag], { "font-scale": 1.1 }]
      ],
      ["get", O.LOCAL.flag]
    ]) : o.flag === O.AUTO.flag ? (i = Bn().flag, s = ["coalesce", ["get", i], ["get", O.LOCAL.flag]]) : o === O.LOCAL ? (i = O.LOCAL.flag, s = ["get", i]) : (i = o.flag, s = ["coalesce", ["get", i], ["get", O.LOCAL.flag]]);
    const { layers: l } = this.getStyle(), u = this.originalLabelStyle.size === 0;
    if (u) {
      const c = ss(l, this);
      this.isStyleLocalized = Object.keys(c.localized).length > 0;
    }
    for (const c of l) {
      if (c.type !== "symbol")
        continue;
      const p = c, f2 = this.getSource(p.source);
      if (!f2 || !("url" in f2 && typeof f2.url == "string") || new URL(f2.url).host !== W.maptilerApiHost)
        continue;
      const { id: h, layout: m } = p;
      if (!m || !("text-field" in m))
        continue;
      let g;
      if (u ? (g = this.getLayoutProperty(h, "text-field"), this.originalLabelStyle.set(h, g)) : g = this.originalLabelStyle.get(h), typeof g == "string") {
        const { contains: b, exactMatch: v } = rs(g, this.isStyleLocalized);
        if (!b) continue;
        if (v)
          this.setLayoutProperty(h, "text-field", s);
        else {
          const x = ns(g, s, this.isStyleLocalized);
          this.setLayoutProperty(h, "text-field", x);
        }
      } else {
        const b = ts(g, s, this.isStyleLocalized);
        this.setLayoutProperty(h, "text-field", b);
      }
    }
    this.languageIsUpdated = true;
  }
  /**
   * Get the primary language
   * @returns
   */
  getPrimaryLanguage() {
    return this.primaryLanguage;
  }
  /**
   * Get the exaggeration factor applied to the terrain
   * @returns
   */
  getTerrainExaggeration() {
    return this.terrainExaggeration;
  }
  /**
   * Know if terrian is enabled or not
   * @returns
   */
  hasTerrain() {
    return this.isTerrainEnabled;
  }
  growTerrain(t) {
    if (!this.terrain)
      return;
    const n = performance.now(), a = this.terrain.exaggeration, o = t - a, i = () => {
      if (!this.terrain || this.terrainFlattening)
        return;
      const s = (performance.now() - n) / this.terrainAnimationDuration;
      if (s < 0.99) {
        const l = 1 - (1 - s) ** 4, u = a + l * o;
        this.terrain.exaggeration = u, requestAnimationFrame(i);
      } else
        this.terrainGrowing = false, this.terrainFlattening = false, this.terrain.exaggeration = t, this.fire("terrainAnimationStop", { terrain: this.terrain });
      this._elevationFreeze = false, this.triggerRepaint();
    };
    !this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = true, this.terrainFlattening = false, requestAnimationFrame(i);
  }
  /**
   * Enables the 3D terrain visualization
   */
  enableTerrain(t = this.terrainExaggeration) {
    if (t < 0) {
      console.warn("Terrain exaggeration cannot be negative.");
      return;
    }
    const n = (o) => {
      !this.terrain || o.type !== "data" || o.dataType !== "source" || !("source" in o) || o.sourceId !== "maptiler-terrain" || o.source.type !== "raster-dem" || o.isSourceLoaded && (this.off("data", n), this.growTerrain(t));
    }, a = () => {
      this.isTerrainEnabled = true, this.terrainExaggeration = t, this.on("data", n), this.addSource(W.terrainSourceId, {
        type: "raster-dem",
        url: W.terrainSourceURL
      }), this.setTerrain({
        source: W.terrainSourceId,
        exaggeration: 0
      });
    };
    if (this.getTerrain()) {
      this.isTerrainEnabled = true, this.growTerrain(t);
      return;
    }
    if (this.loaded() || this.isTerrainEnabled)
      a();
    else {
      const o = () => {
        this.getTerrain() && this.getSource(W.terrainSourceId) || a();
      };
      this.once("load", () => {
        o();
      }), this.once("moveend", () => {
        o();
      });
    }
  }
  /**
   * Disable the 3D terrain visualization
   */
  disableTerrain() {
    if (!this.terrain)
      return;
    this.isTerrainEnabled = false;
    const t = performance.now(), n = this.terrain.exaggeration, a = () => {
      if (!this.terrain || this.terrainGrowing)
        return;
      const o = (performance.now() - t) / this.terrainAnimationDuration;
      if (this._elevationFreeze = false, o < 0.99) {
        const i = (1 - o) ** 4, s = n * i;
        this.terrain.exaggeration = s, requestAnimationFrame(a);
      } else
        this.terrain.exaggeration = 0, this.terrainGrowing = false, this.terrainFlattening = false, this.setTerrain(), this.getSource(W.terrainSourceId) && this.removeSource(W.terrainSourceId), this.fire("terrainAnimationStop", { terrain: null });
      this.triggerRepaint();
    };
    !this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = false, this.terrainFlattening = true, requestAnimationFrame(a);
  }
  /**
   * Sets the 3D terrain exageration factor.
   * If the terrain was not enabled prior to the call of this method,
   * the method `.enableTerrain()` will be called.
   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.
   * If `animate` is `false`, no animated transition to the newly defined exaggeration.
   */
  setTerrainExaggeration(t, n = true) {
    !n && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);
  }
  /**
   * Perform an action when the style is ready. It could be at the moment of calling this method
   * or later.
   */
  onStyleReady(t) {
    this.isStyleLoaded() ? t() : this.once("styledata", () => {
      t();
    });
  }
  async fitToIpBounds() {
    const t = await geolocation.info();
    this.fitBounds(t.country_bounds, {
      duration: 0,
      padding: 100
    });
  }
  async centerOnIpPoint(t) {
    const n = await geolocation.info();
    this.jumpTo({
      center: [n.longitude ?? 0, n.latitude ?? 0],
      zoom: t || 11
    });
  }
  getCameraHash() {
    const t = new Float32Array(5), n = this.getCenter();
    return t[0] = n.lng, t[1] = n.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), gBase64.fromUint8Array(new Uint8Array(t.buffer));
  }
  /**
   * Get the SDK config object.
   * This is convenient to dispatch the SDK configuration to externally built layers
   * that do not directly have access to the SDK configuration but do have access to a Map instance.
   */
  getSdkConfig() {
    return j;
  }
  /**
   * Get the MapTiler session ID. Convenient to dispatch to externaly built component
   * that do not directly have access to the SDK configuration but do have access to a Map instance.
   * @returns
   */
  getMaptilerSessionId() {
    return cn;
  }
  /**
   *  Updates the requestManager's transform request with a new function.
   *
   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
   *
   * @returns {Map} `this`
   *
   *  @example
   *  map.setTransformRequest((url: string, resourceType: string) => {});
   */
  setTransformRequest(t) {
    return super.setTransformRequest(Kn(t)), this;
  }
  /**
   * Gets the {@link ProjectionSpecification}.
   * @returns the projection specification.
   * @example
   * ```ts
   * let projection = map.getProjection();
   * ```
   */
  getProjection() {
    const t = this.style.getProjection();
    return t === void 0 && this.style.projection ? { type: this.style.projection.name } : t;
  }
  /**
   * Returns whether a globe projection is currently being used
   */
  isGlobeProjection() {
    const t = this.getProjection();
    return t ? t.type === "globe" : false;
  }
  /**
   * Activate the globe projection and persist this change during future style changes.
   * @deprecated Will be removed in v4.0.0. Use `map.setProjection("globe", { persist: true })` instead.
   */
  enableGlobeProjection() {
    this.curentProjection = "globe", this.isGlobeProjection() !== true && this.setProjection({ type: "globe" });
  }
  /**
   * Activate the mercator projection and persist this change during future style changes.
   * @deprecated Will be removed in v4.0.0. Use `map.setProjection("mercator", { persist: true })` instead.
   */
  enableMercatorProjection() {
    this.curentProjection = "mercator", this.isGlobeProjection() !== false && this.setProjection({ type: "mercator" });
  }
  setProjection(t, n) {
    return typeof t == "string" && (t = { type: t }), (t.type === "mercator" || t.type === "globe") && (n != null && n.persist) && (this.curentProjection = t.type), this.fire("projection.change", { target: this, projection: t }), super.setProjection(t);
  }
  /**
   * Forget the persisted projection - from both constructor option and result of any `map.setProjection(..., { persist: true })` calls.
   */
  forgetPersistedProjection() {
    return this.curentProjection = void 0, this;
  }
  /**
   * Returns `true` is the language was ever updated, meaning changed
   * from what is delivered in the style.
   * Returns `false` if language in use is the language from the style
   * and has never been changed.
   */
  isLanguageUpdated() {
    return this.languageIsUpdated;
  }
};
var ne = class {
  constructor(e, t, n, a = {}) {
    y(this, "type");
    y(this, "target");
    y(this, "originalEvent");
    y(this, "imageX");
    y(this, "imageY");
    y(this, "isOutOfBounds");
    this.type = e, this.target = t, this.originalEvent = n ?? null, Object.assign(this, a);
  }
};
var Ko = [
  // pass nothing other than target (map / viewer) and type
  "idle",
  "render",
  "load",
  "remove",
  "idle"
  // these are fired on layers, not the map,
  // keeping them for reference
  // "content",
  // "visibility",
];
var Zo = [
  "error"
  // ErrorEvent
];
var Xo = ["resize"];
var Yo = ["webglcontextlost", "webglcontextrestored"];
var Wo = [
  "moveend",
  "movestart",
  "move",
  "zoomend",
  "zoomstart",
  "zoom",
  "rotatestart",
  "rotateend",
  "rotate",
  "dragstart",
  "dragend",
  "drag",
  "boxzoomcancel",
  "boxzoomend",
  "boxzoomstart"
];
var Jo = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseout", "mouseover", "contextmenu", "touchstart", "touchend", "touchmove", "touchcancel"];
var Qo = ["cooperativegestureprevented"];
var ei = [
  "data",
  "dataloading",
  "sourcedata",
  "sourcedataloading",
  "dataabort",
  "sourcedataabort"
  // this is fired on layers, not the map
  // keeping it for reference
  // "metadata",
];
var wc = [
  ...Ko,
  ...Zo,
  ...Xo,
  ...Yo,
  ...Wo,
  ...Jo,
  ...ei,
  ...Qo
];
var Sc = ["lngLat", "_defaultPrevented"];
function xc({ map: r, viewer: e, lngLatToPx: t }) {
  wc.forEach((n) => {
    try {
      r.on(n, (a) => {
        const o = n;
        if (Jo.includes(o)) {
          const d = a, h = d.lngLat && t(d.lngLat), m = e.getImageMetadata(), b = {
            isOutOfBounds: m ? h[0] < 0 || h[0] > m.width || h[1] < 0 || h[1] > m.height : true,
            imageX: h[0],
            imageY: h[1],
            ...Object.fromEntries(Object.entries(a).filter(([v]) => !Sc.includes(v)))
          };
          e.fire(new ne(n, e, d.originalEvent, b));
          return;
        }
        const i = n;
        if (Wo.includes(i)) {
          const d = a;
          e.fire(new ne(n, e, d.originalEvent, d));
          return;
        }
        const s = n;
        if (Zo.includes(s)) {
          const d = a;
          e.fire(new ne(n, e, null, d));
          return;
        }
        const l = n;
        if (Xo.includes(l)) {
          const d = a;
          e.fire(new ne(n, e, null, d));
          return;
        }
        const u = n;
        if (Yo.includes(u)) {
          const d = a;
          e.fire(new ne(n, e, d.originalEvent, d));
          return;
        }
        const c = n;
        if (ei.includes(c)) {
          const d = a;
          e.fire(new ne(n, e, null, d));
          return;
        }
        const p = n;
        if (Qo.includes(p)) {
          const d = a;
          e.fire(new ne(n, e, null, d));
          return;
        }
        const f2 = n;
        if (Ko.includes(f2)) {
          e.fire(new ne(n, e));
          return;
        }
      });
    } catch (a) {
      console.error(`Error forwarding event to ImageViewer, event of type "${n}" is not supported`, a);
    }
  });
}
var kc = class extends Error {
  constructor(t, n, a) {
    const o = `[${a}]: Failed to fetch ${n} at ${t.url}: ${t.status.toString()}: ${t.statusText}`;
    super(o);
    y(this, "status");
    y(this, "statusText");
    this.name = "FetchError", this.message = o, this.status = t.status, this.statusText = t.statusText;
  }
};
var Oa = 85.051129;
function Lc(r, e) {
  return new un(e.x / r, e.y / r).toLngLat();
}
function Ec(r) {
  return Math.pow(2, r);
}
function Cc(r) {
  return Math.log(r) / Math.LN2;
}
function ti(r, e, t) {
  return Math.min(t, Math.max(e, r));
}
function Qr(r) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function en(r) {
  return (180 + r) / 360;
}
function za(r, e, t) {
  const n = t - e, a = ((r - e) % n + n) % n + e;
  return a === e ? t : a;
}
function Ac(r, e) {
  const t = ti(e.lat, -Oa, Oa);
  return new Si(en(e.lng) * r, Qr(t) * r);
}
var Tc = function(r, e) {
  e = ti(e, this.minZoom, this.maxZoom);
  const t = {
    center: new Ne(r.lng, r.lat),
    zoom: e
  };
  let n = this.lngRange;
  const a = this.latRange;
  if (n === null) {
    const X = 179.9999999999;
    n = [-X, X];
  }
  const o = this.tileSize * Ec(t.zoom);
  let i = 0, s = o, l = 0, u = o, c = 0, p = 0;
  const { x: f2, y: d } = this.size, h = 0.5;
  a && (i = Qr(a[1]) * o, s = Qr(a[0]) * o, s - i < h * d && (c = h * d / (s - i))), n && (l = za(en(n[0]) * o, 0, o), u = za(en(n[1]) * o, 0, o), u < l && (u += o), u - l < h * f2 && (p = h * f2 / (u - l)));
  const { x: m, y: g } = Ac(o, r);
  let b, v;
  const x = Math.min(p || 0, c || 0);
  if (x)
    return t.zoom += Cc(x), t;
  let C = 0, E = 0;
  const A = 1, N = 1 - (s - i) / d, le = 1 - (u - l) / f2;
  C = Math.max(le, A), E = Math.max(N, A);
  const Ye = 1 - C, We = 1 - E;
  if (a) {
    const X = We * d / 2;
    g - X < i && (v = i + X), g + X > s && (v = s - X);
  }
  if (n) {
    const X = m, Je = Ye * f2 / 2;
    X - Je < l && (b = l + Je), X + Je > u && (b = u - Je);
  }
  if (b !== void 0 || v !== void 0) {
    const X = new Si(b ?? m, v ?? g);
    t.center = Lc(o, X).wrap();
  }
  return t;
};
var Ic = {
  center: "translate(-50%,-50%)",
  top: "translate(-50%,0)",
  "top-left": "translate(0,0)",
  "top-right": "translate(-100%,0)",
  bottom: "translate(-50%,-100%)",
  "bottom-left": "translate(0,-100%)",
  "bottom-right": "translate(-100%,-100%)",
  left: "translate(0,-50%)",
  right: "translate(-100%,-50%)"
};
function _c(r) {
  function e(t) {
    if (!this._map) return;
    const n = this._map.loaded() && !this._map.isMoving();
    ((t == null ? void 0 : t.type) === "terrain" || (t == null ? void 0 : t.type) === "render" && !n) && this._map.once("render", this._update), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
    let a = "";
    this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? a = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (a = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
    let o = "";
    this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? o = "rotateX(0deg)" : this._pitchAlignment === "map" && (o = `rotateX(${this._map.getPitch()}deg)`), !this._subpixelPositioning && (!t || t.type === "moveend") && (this._pos = this._pos.round());
    const i = `${Ic[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o} ${a}`;
    this._element.style.transform = i;
  }
  r._update = e.bind(r);
}
var Mc = class {
  constructor({ imageViewer: e }) {
    y(this, "viewer");
    y(this, "container");
    y(this, "handleClick", () => {
      this.viewer.fitImageToViewport({ ease: true });
    });
    if (!e)
      throw new Error("ImageViewerFitImageToBoundsControl: an instance of 'ImageViewer' is required");
    this.viewer = e;
  }
  onAdd(e) {
    const t = document.createElement("button");
    this.container = document.createElement("div"), this.container.classList.add("maplibregl-ctrl", "maplibregl-ctrl-group"), t.classList.add("maplibregl-ctrl-fit-image-to-bounds");
    const n = document.createElement("span");
    return n.classList.add("maplibregl-ctrl-icon"), t.title = "Zoom image to viewport bounds", t.appendChild(n), t.addEventListener("click", this.handleClick), this.container.appendChild(t), this.container;
  }
  onRemove() {
    this.container.remove();
  }
};
var ri = /* @__PURE__ */ Symbol("MapTiler:ImageViewer:Internal:lngLatToPxInternal");
var ni = /* @__PURE__ */ Symbol("MapTiler:ImageViewer:Internal:pxToLngLatInternal");
var { Evented: Pc } = import_maplibre_gl.default;
var Rc = {
  style: {
    version: 8,
    sources: {},
    layers: []
  },
  minPitch: 0,
  maxPitch: 0,
  pitch: 0,
  bearing: 0,
  projection: "mercator",
  geolocateControl: false,
  navigationControl: false,
  projectionControl: false,
  hash: false,
  renderWorldCopies: false,
  terrain: false,
  space: false,
  halo: false,
  transformConstrain: Tc
};
var Oc = {
  debug: false,
  fitToBoundsControl: true,
  navigationControl: true
};
var Ha;
var Ka;
var Za;
var zc = class extends (Za = Pc, Ka = ri, Ha = ni, Za) {
  //#region constructor
  /**
   * The constructor for the ImageViewer.
   *
   * @param {Partial<ImageViewerConstructorOptions>} imageViewerConstructorOptions - The options for the ImageViewer.
   * @example
   * ```ts
   * import "@maptiler/sdk/dist/maptiler-sdk.css"; // import css
   * import { ImageViewer } from "@maptiler/sdk"; // import the sdk
   *
   * const imageViewer = new ImageViewer({
   *   container: document.getElementById("map"),
   *   imageUUID: "01986025-ceb9-7487-9ea6-7a8637dcc1a1",
   *   debug: true, // show tile boundaries, padding, collision boxes etc
   *   fitToBoundsControl: true, // show a control to fit the image to the viewport
   *   navigationControl: true, // show a navigation control
   *   center: [0, 0], // center in pixels
   *   zoom: 1, // zoom level
   *   bearing: 0, // bearing
   * });
   * ```
   */
  constructor(t) {
    super();
    y(this, "imageUUID");
    y(this, "debug");
    y(this, "imageMetadata");
    y(this, "sdk");
    y(this, "options");
    y(this, "imageSize");
    y(this, "paddedSizeMax");
    y(this, "fitToBoundsControlInstance");
    y(this, "shouldFitImageToViewport", true);
    y(this, Ka, this.lngLatToPx.bind(this));
    y(this, Ha, this.pxToLngLat.bind(this));
    if (!t.imageUUID)
      throw new Error("[ImageViewer]: `imageUUID` is required");
    if (typeof t.container != "string" && !(t.container instanceof HTMLElement))
      throw new Error("[ImageViewer]: `container` is required and must be a string or HTMLElement");
    this.options = {
      ...Oc,
      ...t
    };
    const n = {
      ...this.options,
      ...Rc
    };
    delete n.center, this.sdk = new Go(n), this.sdk.telemetry.registerViewerType("ImageViewer");
    const { imageUUID: a, debug: o } = t;
    this.imageUUID = a, this.debug = o ?? false, this.debug && (this.sdk.showTileBoundaries = this.debug, this.sdk.showPadding = this.debug, this.sdk.showCollisionBoxes = this.debug, this.sdk.repaint = this.debug), this.init();
  }
  /**
   * The version of the ImageViewer / SDK.
   */
  get version() {
    return this.sdk.version;
  }
  //#region onReadyAsync
  /**
   * Waits for the ImageViewer to be ready.
   *
   * @returns {Promise<void>}
   */
  async onReadyAsync() {
    try {
      await Promise.race([
        new Promise((t, n) => {
          this.once("imageviewerready", (a) => {
            t(a);
          }), this.once("imagevieweriniterror", (a) => {
            n(a.error);
          });
        }),
        new Promise((t, n) => {
          setTimeout(() => {
            n(new Error("Timeout waiting for image viewer to be ready"));
          }, 5e3);
        })
      ]);
    } catch (t) {
      throw t;
    }
  }
  //#region init
  /**
   * Initializes the ImageViewer
   *  - fetches the image metadata
   *  - adds the image source to the sdk instance
   *  - sets the center to the middle of the image (if center is not provided)
   *  - monkeypatches the maplibre-gl sdk transform method to allow for overpanning and underzooming.
   *  - sets up global event forwarding / intercepting from the map instance
   *  - sets the center to the middle of the image (if center is not provided)
   *
   * @internal
   * @returns {Promise<void>}
   */
  async init() {
    var t, n, a;
    try {
      await this.sdk.onReadyAsync(), await this.fetchImageMetadata(), this.addImageSource(), this.options.navigationControl && this.sdk.addControl(
        new Ya({
          visualizePitch: false,
          visualizeRoll: false
        })
      ), this.fitToBoundsControlInstance = new Mc({ imageViewer: this }), this.options.fitToBoundsControl && this.sdk.addControl(this.fitToBoundsControlInstance), xc({
        map: this.sdk,
        viewer: this,
        lngLatToPx: (u) => this.lngLatToPx(u)
      });
      const { center: o, zoom: i, bearing: s } = this.options, l = o ?? [(((t = this.imageMetadata) == null ? void 0 : t.width) ?? 0) / 2, (((n = this.imageMetadata) == null ? void 0 : n.height) ?? 0) / 2];
      this.setCenter(l), this.setBearing(s ?? 0), this.options.zoom ? this.setZoom(i ?? ((a = this.imageMetadata) == null ? void 0 : a.maxzoom) ?? 5) : this.fitImageToViewport(), this.sdk.on("wheel", () => {
        this.shouldFitImageToViewport = false;
      }), this.sdk.on("touchstart", () => {
        this.shouldFitImageToViewport = false;
      }), this.sdk.on("drag", () => {
        this.shouldFitImageToViewport = false;
      }), this.sdk.on("resize", () => {
        var f2, d;
        const u = this.getCenter(), c = ((f2 = this.imageMetadata) == null ? void 0 : f2.width) ?? 0, p = ((d = this.imageMetadata) == null ? void 0 : d.height) ?? 0;
        this.shouldFitImageToViewport && this.fitImageToViewport(), (u[0] !== c / 2 || u[1] !== p / 2) && this.setCenter(u);
      }), this.fire("imageviewerready", new ne("imageviewerready", this));
    } catch (o) {
      this.fire("imagevieweriniterror", { error: o });
    }
  }
  //#region fitImageToViewport
  /**
   * Fits the image to the viewport.
   *
   * @param {Object} options - The options for the fit image to viewport.
   * @param {boolean} options.ease - Whether to ease to the viewport bounds.
   */
  fitImageToViewport({ ease: t = false } = {}) {
    if (!this.imageMetadata)
      throw new Error("[ImageViewer]: Image metadata not found");
    const n = this.pxToLngLat([0, 0]), a = this.pxToLngLat([this.imageMetadata.width ?? 0, this.imageMetadata.height ?? 0]), o = this.sdk.cameraForBounds([n, a], { padding: 50 });
    o && (t ? this.sdk.easeTo({ ...o, pitch: 0 }, null) : this.sdk.jumpTo({ ...o, pitch: 0 }, null)), this.shouldFitImageToViewport = true;
  }
  //#region fetchImageMetadata
  /**
   * Fetches the image metadata from the API.
   *
   * @internal
   * @returns {Promise<void>}
   */
  async fetchImageMetadata() {
    const t = Fc(this.imageUUID), n = await fetch(t);
    if (!n.ok)
      throw new kc(n, "image metadata", "ImageViewer");
    const a = await n.json();
    this.imageMetadata = a, Object.freeze(this.imageMetadata);
  }
  //#region addImageSource
  /**
   * Adds the image source to the sdk instance.
   *
   * @internal
   * @returns {void}
   */
  addImageSource() {
    if (!this.imageMetadata)
      throw this.fire("error", new ne("error", this, null, { error: new Error("[ImageViewer]: Image metadata not found") })), new Error("[ImageViewer]: Image metadata not found");
    const t = $c(this.imageUUID), n = (s) => Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
    this.imageSize = [this.imageMetadata.width, this.imageMetadata.height], this.paddedSizeMax = Math.max(n(this.imageSize[0]), n(this.imageSize[1]));
    const a = this.pxToLngLat([0, 0]), o = this.pxToLngLat(this.imageSize), i = [a.lng, o.lat, o.lng, a.lat];
    this.sdk.addSource("image", {
      ...this.imageMetadata,
      type: "raster",
      bounds: i,
      tiles: [t]
    }), this.sdk.addLayer({
      id: "image",
      type: "raster",
      source: "image"
    });
  }
  //#region SDK mappings
  /**
   * Triggers a repaint of the ImageViewer. Same as map.triggerRepaint().
   *
   * @internal
   * @returns {void}
   */
  triggerRepaint() {
    this.sdk.triggerRepaint();
  }
  /**
   * The scroll zoom handler.
   *
   * @internal
   * @returns {ScrollZoomHandler}
   */
  get scrollZoom() {
    return this.sdk.scrollZoom;
  }
  /**
   * The scroll zoom handler.
   *
   * @internal
   * @param {ScrollZoomHandler} value - The scroll zoom handler.
   */
  set scrollZoom(t) {
    this.sdk.scrollZoom = t;
  }
  /**
   * The box zoom handler.
   *
   * @internal
   * @returns {BoxZoomHandler}
   */
  get boxZoom() {
    return this.sdk.boxZoom;
  }
  /**
   * The box zoom handler.
   *
   * @internal
   * @param {BoxZoomHandler} value - The box zoom handler.
   */
  set boxZoom(t) {
    this.sdk.boxZoom = t;
  }
  /**
   * The drag pan handler.
   *
   * @internal
   * @returns {DragPanHandler}
   */
  get dragPan() {
    return this.sdk.dragPan;
  }
  /**
   * The drag pan handler.
   *
   * @internal
   * @param {DragPanHandler} value - The drag pan handler.
   */
  set dragPan(t) {
    this.sdk.dragPan = t;
  }
  /**
   * The keyboard handler.
   *
   * @internal
   * @returns {KeyboardHandler}
   */
  get keyboard() {
    return this.sdk.keyboard;
  }
  /**
   * The keyboard handler.
   *
   * @internal
   * @param {KeyboardHandler} value - The keyboard handler.
   */
  set keyboard(t) {
    this.sdk.keyboard = t;
  }
  /**
   * The double click zoom handler.
   *
   * @internal
   * @returns {DoubleClickZoomHandler}
   */
  get doubleClickZoom() {
    return this.sdk.doubleClickZoom;
  }
  /**
   * The double click zoom handler.
   *
   * @internal
   * @param {DoubleClickZoomHandler} value - The double click zoom handler.
   */
  set doubleClickZoom(t) {
    this.sdk.doubleClickZoom = t;
  }
  /**
   * The touch zoom rotate handler.
   *
   * @internal
   * @returns {TwoFingersTouchZoomRotateHandler}
   */
  get touchZoomRotate() {
    return this.sdk.touchZoomRotate;
  }
  /**
   * The touch zoom rotate handler.
   *
   * @internal
   * @param {TwoFingersTouchZoomRotateHandler} value - The touch zoom rotate handler.
   */
  set touchZoomRotate(t) {
    this.sdk.touchZoomRotate = t;
  }
  /**
   * The cooperative gestures handler.
   *
   * @internal
   * @returns {CooperativeGesturesHandler}
   */
  get cooperativeGestures() {
    return this.sdk.cooperativeGestures;
  }
  /**
   * The cooperative gestures handler.
   *
   * @internal
   * @param {CooperativeGesturesHandler} value - The cooperative gestures handler.
   */
  set cooperativeGestures(t) {
    this.sdk.cooperativeGestures = t;
  }
  //#endregion SDK Mappings
  //#region lngLatToPx
  /**
   * Converts a LngLat to a px coordinate, based on the image metadata.
   *
   * @internal
   * @param {LngLat} lngLat - The LngLat to convert.
   * @returns {[number, number]} The px coordinate.
   */
  lngLatToPx(t) {
    if (!this.paddedSizeMax) {
      const a = "[ImageViewer]: Unable to convert LngLat to px, padded size max not set";
      throw this.fire("error", new ne("error", this, null, { error: new Error(a) })), new Error(a);
    }
    const n = un.fromLngLat(t);
    return [n.x * this.paddedSizeMax, n.y * this.paddedSizeMax];
  }
  //#region pxToLngLat
  /**
   * Converts a px coordinate to a LngLat, based on the image metadata.
   *
   * @internal
   * @param {LngLat} lngLat - The LngLat to convert.
   * @returns {[number, number]} The px coordinate.
   */
  pxToLngLat(t) {
    if (!this.paddedSizeMax) {
      const a = "[ImageViewer]: Unable to convert px to LngLat, padded size max not set";
      throw this.fire("error", new ne("error", this, null, { error: new Error(a) })), new Error(a);
    }
    return new un(t[0] / this.paddedSizeMax, t[1] / this.paddedSizeMax).toLngLat();
  }
  //#region getSDKInternal
  /**
   * Get the internal SDK instance.
   *
   * @returns {Map} The internal SDK instance.
   * @internal
   */
  getSDKInternal() {
    return this.sdk;
  }
  /**
   * Get the canvas of the internal SDK instance.
   *
   * @returns {HTMLCanvasElement} The canvas of the internal SDK instance.
   */
  getCanvas() {
    return this.sdk.getCanvas();
  }
  //#region flyTo
  /**
   * Fly to a given center.
   *
   * @param {ImageViewerFlyToOptions} options - The options for the fly to.
   * @param {MapDataEvent} eventData - The event data.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  flyTo(t, n) {
    const a = this.pxToLngLat(t.center);
    return this.sdk.flyTo({ ...t, pitch: 0, center: a }, n), this;
  }
  //#region jumpTo
  /**
   * Jump to a given center.
   *
   * @param {ImageViewerJumpToOptions} options - The options for the jump to.
   * @param {MapDataEvent} eventData - The event data.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  jumpTo(t, n) {
    const a = this.pxToLngLat(t.center);
    return this.sdk.jumpTo({ ...t, pitch: 0, center: a }, n), this;
  }
  //#region setZoom
  /**
   * Set the zoom level.
   *
   * @param {number} zoom - The zoom level.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  setZoom(t) {
    return this.sdk.setZoom(t), this;
  }
  //#region getZoom
  /**
   * Get the zoom level.
   *
   * @returns {number} The zoom level.
   */
  getZoom() {
    return this.sdk.getZoom();
  }
  //#region getCenter
  /**
   * Get the center of the ImageViewer in pixels.
   *
   * @internal
   * @returns {[number, number]} The center of the ImageViewer.
   */
  getCenter() {
    const t = this.sdk.getCenter();
    return this.lngLatToPx(t);
  }
  //#region setCenter
  /**
   * Set the center of the ImageViewer in pixels.
   *
   * @param {number} center - The center of the ImageViewer.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  setCenter(t) {
    return this.sdk.setCenter(this.pxToLngLat(t)), this;
  }
  //#region setBearing
  /**
   * Set the bearing of the ImageViewer in degrees.
   *
   * @param {number} bearing - The bearing of the ImageViewer.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  setBearing(t) {
    return this.sdk.setBearing(t), this;
  }
  //#region getBearing
  /**
   * Get the bearing of the ImageViewer in degrees.
   *
   * @returns {number} The bearing of the ImageViewer.
   */
  getBearing() {
    return this.sdk.getBearing();
  }
  //#region panBy
  /**
   * Pan by a given delta in pixels.
   *
   * @param {PointLike} delta - The delta to pan by.
   * @param {ImageViewerEaseToOptions} options - The options for the pan.
   * @param {any} eventData - The event data.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  panBy(t, n, a) {
    return this.sdk.panBy(t, { ...n, pitch: 0 }, a), this;
  }
  //#region panTo
  /**
   * Pan to a given center in pixels.
   *
   * @param {number} center - The center to pan to.
   * @param {ImageViewerEaseToOptions} options - The options for the pan.
   * @param {any} eventData - The event data.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  panTo(t, n, a) {
    return this.sdk.panTo(this.pxToLngLat(t), { ...n, pitch: 0 }, a), this;
  }
  //#region getImageMetadata
  /**
   * Get the image metadata.
   *
   * @returns {ImageMetadata} The image metadata.
   */
  getImageMetadata() {
    return this.imageMetadata;
  }
  //#region getImageBounds
  /**
   * Get the visible bounds of the image in the viewport in imagePixels.
   * [topLeft, bottomRight]
   *
   * @returns {[[number, number], [number, number]]} The visible bounds of the image.
   */
  getImageBounds() {
    const n = this.sdk.getBounds().toArray().map((i) => this.lngLatToPx(Ne.convert(i))), a = [n[0][0], n[1][1]], o = [n[1][0], n[0][1]];
    return [a, o];
  }
  //#region fitImageBounds
  /**
   * Set the bounds of the image.
   *
   * @param {[[number, number], [number, number]]} bounds - The bounds of the image.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  fitImageBounds([t, n]) {
    const a = this.pxToLngLat(t), o = this.pxToLngLat(n), i = Pp.convert([a, o]);
    return this.sdk.fitBounds(i), this;
  }
  //#region remove
  /**
   * Destroys the ImageViewer, removes the map instance and all event listeners. Useful for cleanup.
   *
   * @returns {ImageViewer} The ImageViewer instance.
   */
  remove() {
    this.fire("beforeremove", new ne("beforeremove", this)), this.sdk.remove(), this._listeners && Object.entries(this._listeners).forEach(([t, n]) => {
      n.forEach((a) => {
        this.off(t, a);
      });
    }), this._oneTimeListeners && Object.entries(this._oneTimeListeners).forEach(([t, n]) => {
      n.forEach((a) => {
        this.off(t, a);
      });
    });
  }
  pointIsWithinImageBounds(t) {
    const n = this.getImageMetadata();
    if (!n)
      return false;
    const a = [
      [0, 0],
      [n.width, n.height]
    ];
    return t[0] >= a[0][0] && t[0] <= a[1][0] && t[1] >= a[0][1] && t[1] <= a[1][1];
  }
};
function Fc(r) {
  return `${ai()}/${r}/image.json?key=${j.apiKey}`;
}
function $c(r) {
  return `${ai()}/${r}/{z}/{x}/{y}?key=${j.apiKey}`;
}
function ai() {
  return "https://api.maptiler.com/images";
}
var { Evented: Nc } = import_maplibre_gl.default;
var sf = class extends Nc {
  constructor({ ...t }) {
    super();
    y(this, "viewer");
    y(this, "marker");
    y(this, "position", [0, 0]);
    this.marker = new Ni(t);
  }
  /**
   * Adds the ImageViewerMarker to an instance of ImageViewer.
   *
   * @param {ImageViewer} viewer - The instance of ImageViewer to add the ImageViewerMarker to.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  addTo(t) {
    if (!(t instanceof zc))
      throw new Error("[ImageViewerMarker]: an ImageViewerMarker must be added to an instance of ImageViewer");
    this.viewer = t, Bc(this.marker, this, this.viewer[ri]);
    const n = this.viewer.getSDKInternal();
    return this.setPosition(this.position), _c(this.marker), this.marker.addTo(n), this;
  }
  /**
   * Adds a class name to the ImageViewerMarker.
   *
   * @param {string} className - The class name to add to the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  addClassName(t) {
    return this.marker.addClassName(t), this;
  }
  /**
   * Gets the element of the ImageViewerMarker.
   *
   * @returns {HTMLElement} The element of the ImageViewerMarker.
   */
  getElement() {
    return this.marker.getElement();
  }
  /**
   * Gets the position of the ImageViewerMarker.
   *
   * @returns {PointLike} The position of the ImageViewerMarker.
   * @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)
   *
   */
  getPosition() {
    return this.position;
  }
  /**
   * Gets the offset of the ImageViewerMarker.
   *
   * @returns {PointLike} The offset of the ImageViewerMarker.
   * @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)
   */
  getOffset() {
    return this.marker.getOffset();
  }
  /**
   * Gets the pitch alignment of the ImageViewerMarker.
   *
   * @returns {Alignment} The pitch alignment of the ImageViewerMarker.
   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
   */
  getPitchAlignment() {
    return this.marker.getPitchAlignment();
  }
  /**
   * Gets the popup of the ImageViewerMarker.
   *
   * @returns {Popup} The popup of the ImageViewerMarker.
   * @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)
   */
  getPopup() {
    return this.marker.getPopup();
  }
  /**
   * Gets the rotation of the ImageViewerMarker.
   *
   * @returns {number} The rotation of the ImageViewerMarker.
   */
  getRotation() {
    return this.marker.getRotation();
  }
  /**
   * Gets the rotation alignment of the ImageViewerMarker.
   *
   * @returns {Alignment} The rotation alignment of the ImageViewerMarker.
   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
   */
  getRotationAlignment() {
    return this.marker.getRotationAlignment();
  }
  /**
   * Checks if the ImageViewerMarker is draggable.
   *
   * @returns {boolean} True if the ImageViewerMarker is draggable, false otherwise.
   */
  isDraggable() {
    return this.marker.isDraggable();
  }
  /**
   * Fires an event on the ImageViewerMarker.
   *
   * @param {MarkerEventTypes | Event} event - The event to fire.
   * @param {Record<string, any>} data - The data to fire the event with.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  fire(t, n) {
    return super.fire(t, n), this;
  }
  /**
   * Removes an event listener from the ImageViewerMarker.
   *
   * @param {MarkerEventTypes} event - The event to remove the listener from.
   * @param {ImageViewerMarkerEvent} listener - The listener to remove.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  off(t, n) {
    return super.off(t, n), this;
  }
  /**
   * Adds an event listener to the ImageViewerMarker.
   *
   * @param {MarkerEventTypes} event - The event to add the listener to.
   * @param {ImageViewerMarkerEvent} listener - The listener to add.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  on(t, n) {
    return super.on(t, n);
  }
  /**
   * Checks if the ImageViewerMarker is within the image bounds.
   *
   * @returns {boolean} True if the ImageViewerMarker is within the image bounds, false otherwise.
   */
  isWithinImageBounds() {
    return this.viewer.pointIsWithinImageBounds(this.position);
  }
  /**
   * Removes the ImageViewerMarker from the ImageViewer and cleans up the event listeners.
   *
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  remove() {
    return this.marker.remove(), this.marker._listeners && Object.entries(this.marker._listeners).forEach(([t, n]) => {
      n.forEach((a) => {
        this.off(t, a);
      });
    }), this.marker._oneTimeListeners && Object.entries(this.marker._oneTimeListeners).forEach(([t, n]) => {
      n.forEach((a) => {
        this.off(t, a);
      });
    }), this;
  }
  /**
   * Removes a class name from the ImageViewerMarker dom element.
   *
   * @param {string} className - The class name to remove from the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  removeClassName(t) {
    return this.marker.removeClassName(t), this;
  }
  /**
   * Sets the draggable state of the ImageViewerMarker.
   *
   * @param {boolean} draggable - The draggable state of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setDraggable(t) {
    return this.marker.setDraggable(t), this;
  }
  /**
   * Sets the position of the ImageViewerMarker.
   *
   * @param {[number, number]} px - The position of the ImageViewerMarker in image pixels.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setPosition(t) {
    if (this.position[0] = t[0], this.position[1] = t[1], !this.viewer)
      return this;
    const n = this.viewer[ni](t);
    return this.marker.setLngLat(n), this;
  }
  /**
   * Sets the offset of the ImageViewerMarker.
   *
   * @param {PointLike} offset - The offset of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setOffset(t) {
    return this.marker.setOffset(t), this;
  }
  /**
   * Sets the opacity of the ImageViewerMarker.
   *
   * @param {string} opacity - The opacity of the ImageViewerMarker.
   * @param {string} opacityWhenCovered - The opacity of the ImageViewerMarker when covered.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setOpacity(t, n) {
    return this.marker.setOpacity(t, n), this;
  }
  /**
   * Sets the pitch alignment of the ImageViewerMarker.
   *
   * @param {Alignment} pitchAlignment - The pitch alignment of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
   */
  setPitchAlignment(t) {
    return this.marker.setPitchAlignment(t), this;
  }
  /**
   * Sets the popup of the ImageViewerMarker.
   *
   * @param {Popup} popup - The popup of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   * @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)
   */
  setPopup(t) {
    return this.marker.setPopup(t), this;
  }
  /**
   * Sets the rotation of the ImageViewerMarker.
   *
   * @param {number} rotation - The rotation of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setRotation(t) {
    return this.marker.setRotation(t), this;
  }
  /**
   * Sets the rotation alignment of the ImageViewerMarker.
   *
   * @param {Alignment} rotationAlignment - The rotation alignment of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
   */
  setRotationAlignment(t) {
    return this.marker.setRotationAlignment(t), this;
  }
  /**
   * Sets if subpixel positioning is enabled for the ImageViewerMarker.
   *
   * @param {boolean} subpixelPositioning - The subpixel positioning of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setSubpixelPositioning(t) {
    return this.marker.setSubpixelPositioning(t), this;
  }
  /**
   * Toggles a class name on the ImageViewerMarker dom element.
   *
   * @param {string} className - The class name to toggle on the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  toggleClassName(t) {
    return this.marker.toggleClassName(t), this;
  }
  /**
   * Toggles the popup of the ImageViewerMarker.
   *
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  togglePopup() {
    return this.marker.togglePopup(), this;
  }
};
var jc = ["dragstart", "drag", "dragend"];
var Dc = ["lngLat", "_defaultPrevented", "target"];
var Uc = class {
  constructor(e, t, n) {
    y(this, "type");
    y(this, "target");
    this.type = e, this.target = t, Object.assign(this, n);
  }
};
function Bc(r, e, t) {
  jc.forEach((n) => {
    r.on(n, (a) => {
      var i, s;
      if ((i = a.target) == null ? void 0 : i.getLngLat()) {
        const l = t((s = a.target) == null ? void 0 : s.getLngLat());
        e.setPosition(l);
      }
      e.fire(
        n,
        new Uc(n, e, {
          ...Object.fromEntries(Object.entries(a).filter(([l]) => !Dc.includes(l)))
        })
      );
    });
  });
}
function Rn(r) {
  if (typeof DOMParser < "u") {
    const e = new DOMParser().parseFromString(r, "application/xml");
    if (e.querySelector("parsererror"))
      throw new Error("The provided string is not valid XML");
    return e;
  }
  throw new Error("No XML parser found");
}
function oi(r, e) {
  if (!r.hasChildNodes())
    return false;
  for (const t of Array.from(r.childNodes)) {
    const n = t.nodeName;
    if (typeof n == "string" && n.trim().toLowerCase() === e.toLowerCase())
      return true;
  }
  return false;
}
function Fa(r) {
  if (typeof XMLSerializer < "u")
    return new XMLSerializer().serializeToString(r);
  throw new Error("No XML serializer found");
}
function ii(r) {
  const e = typeof r == "string" ? Rn(r) : r;
  if (!oi(e, "gpx"))
    throw new Error("The XML document is not valid GPX");
  const t = Z(e, "trk"), n = Z(e, "rte"), a = Z(e, "wpt"), o = {
    type: "FeatureCollection",
    features: []
  };
  for (const i of Array.from(t)) {
    const s = Hc(i);
    s && o.features.push(s);
  }
  for (const i of Array.from(n)) {
    const s = Kc(i);
    s && o.features.push(s);
  }
  for (const i of Array.from(a))
    o.features.push(Zc(i));
  return o;
}
function si(r, e) {
  let t = r;
  if (typeof t == "string" && (t = Rn(t)), !oi(t, "kml"))
    throw new Error("The XML document is not valid KML");
  const n = {
    type: "FeatureCollection",
    features: []
  }, a = {}, o = {}, i = {}, s = Z(t, "Placemark"), l = Z(t, "Style"), u = Z(t, "StyleMap");
  for (const c of Array.from(l)) {
    const p = Na(e !== void 0 ? e(c) : Fa(c)).toString(16);
    a[`#${Ze(c, "id")}`] = p, o[p] = c;
  }
  for (const c of Array.from(u)) {
    a[`#${Ze(c, "id")}`] = Na(e !== void 0 ? e(c) : Fa(c)).toString(16);
    const p = Z(c, "Pair"), f2 = {};
    for (const d of Array.from(p))
      f2[F(I(d, "key")) ?? ""] = F(I(d, "styleUrl"));
    i[`#${Ze(c, "id")}`] = f2;
  }
  for (const c of Array.from(s))
    n.features = n.features.concat(Gc(c, a, o, i));
  return n;
}
function $a(r) {
  if (r === null) return ["#000000", 1];
  let e = "", t = 1, n = r;
  return n.startsWith("#") && (n = n.substring(1)), (n.length === 6 || n.length === 3) && (e = n), n.length === 8 && (t = Number.parseInt(n.substring(0, 2), 16) / 255, e = `#${n.substring(6, 8)}${n.substring(4, 6)}${n.substring(2, 4)}`), [e ?? "#000000", t ?? 1];
}
function qc(r) {
  return ci(r.split(" "));
}
function Vc(r) {
  let e = Z(r, "coord");
  const t = [], n = [];
  e.length === 0 && (e = Z(r, "gx:coord"));
  for (const o of Array.from(e))
    t.push(qc(F(o) ?? ""));
  const a = Z(r, "when");
  for (const o of Array.from(a)) n.push(F(o));
  return {
    coords: t,
    times: n
  };
}
function Gt(r) {
  const e = ["Polygon", "LineString", "Point", "Track", "gx:Track"];
  let t, n, a, o, i;
  const s = [], l = [];
  if (I(r, "MultiGeometry") !== null)
    return Gt(I(r, "MultiGeometry"));
  if (I(r, "MultiTrack") !== null)
    return Gt(I(r, "MultiTrack"));
  if (I(r, "gx:MultiTrack") !== null)
    return Gt(I(r, "gx:MultiTrack"));
  for (a = 0; a < e.length; a++)
    if (n = Z(r, e[a]), n) {
      for (o = 0; o < n.length; o++)
        if (t = n[o], e[a] === "Point")
          s.push({
            type: "Point",
            coordinates: pi(F(I(t, "coordinates")) ?? "")
          });
        else if (e[a] === "LineString")
          s.push({
            type: "LineString",
            coordinates: Da(F(I(t, "coordinates")) ?? "")
          });
        else if (e[a] === "Polygon") {
          const u = Z(t, "LinearRing"), c = [];
          for (i = 0; i < u.length; i++)
            c.push(Da(F(I(u[i], "coordinates")) ?? ""));
          s.push({
            type: "Polygon",
            coordinates: c
          });
        } else if (e[a] === "Track" || e[a] === "gx:Track") {
          const u = Vc(t);
          s.push({
            type: "LineString",
            coordinates: u.coords
          }), u.times.length && l.push(u.times);
        }
    }
  return { geoms: s, coordTimes: l };
}
function Gc(r, e, t, n) {
  const a = Gt(r), o = {}, i = F(I(r, "name")), s = F(I(r, "address")), l = F(I(r, "description")), u = I(r, "TimeSpan"), c = I(r, "TimeStamp"), p = I(r, "ExtendedData"), f2 = I(r, "visibility");
  let d, h = F(I(r, "styleUrl")), m = I(r, "LineStyle"), g = I(r, "PolyStyle");
  if (!a.geoms.length) return [];
  if (i && (o.name = i), s && (o.address = s), h) {
    h.startsWith("#") || (h = `#${h}`), o.styleUrl = h, e[h] && (o.styleHash = e[h]), n[h] && (o.styleMapHash = n[h], o.styleHash = e[n[h].normal ?? ""]);
    const v = t[o.styleHash ?? ""];
    if (v) {
      m || (m = I(v, "LineStyle")), g || (g = I(v, "PolyStyle"));
      const x = I(v, "IconStyle");
      if (x) {
        const C = I(x, "Icon");
        if (C) {
          const E = F(I(C, "href"));
          E && (o.icon = E);
        }
      }
    }
  }
  if (l && (o.description = l), u) {
    const v = F(I(u, "begin")), x = F(I(u, "end"));
    v && x && (o.timespan = { begin: v, end: x });
  }
  if (c !== null && (o.timestamp = F(I(c, "when")) ?? (/* @__PURE__ */ new Date()).toISOString()), m !== null) {
    const v = $a(F(I(m, "color"))), x = v[0], C = v[1], E = Number.parseFloat(F(I(m, "width")) ?? "");
    x && (o.stroke = x), Number.isNaN(C) || (o["stroke-opacity"] = C), Number.isNaN(E) || (o["stroke-width"] = E);
  }
  if (g) {
    const v = $a(F(I(g, "color"))), x = v[0], C = v[1], E = F(I(g, "fill")), A = F(I(g, "outline"));
    x && (o.fill = x), Number.isNaN(C) || (o["fill-opacity"] = C), E && (o["fill-opacity"] = E === "1" ? o["fill-opacity"] || 1 : 0), A && (o["stroke-opacity"] = A === "1" ? o["stroke-opacity"] || 1 : 0);
  }
  if (p) {
    const v = Z(p, "Data"), x = Z(p, "SimpleData");
    for (d = 0; d < v.length; d++)
      o[v[d].getAttribute("name") ?? ""] = F(I(v[d], "value")) ?? "";
    for (d = 0; d < x.length; d++)
      o[x[d].getAttribute("name") ?? ""] = F(x[d]) ?? "";
  }
  f2 !== null && (o.visibility = F(f2) ?? ""), a.coordTimes.length !== 0 && (o.coordTimes = a.coordTimes.length === 1 ? a.coordTimes[0] : a.coordTimes);
  const b = {
    type: "Feature",
    geometry: a.geoms.length === 1 ? a.geoms[0] : {
      type: "GeometryCollection",
      geometries: a.geoms
    },
    properties: o
  };
  return Ze(r, "id") && (b.id = Ze(r, "id") ?? void 0), [b];
}
function li(r, e) {
  const t = Z(r, e), n = [], a = [];
  let o = [];
  const i = t.length;
  if (!(i < 2)) {
    for (let s = 0; s < i; s++) {
      const l = fi(t[s]);
      n.push(l.coordinates), l.time && a.push(l.time), (l.heartRate || o.length) && (o.length === 0 && (o = new Array(s).fill(null)), o.push(l.heartRate));
    }
    return {
      line: n,
      times: a,
      heartRates: o
    };
  }
}
function Hc(r) {
  const e = Z(r, "trkseg"), t = [], n = [], a = [];
  let o;
  for (let s = 0; s < e.length; s++)
    if (o = li(e[s], "trkpt"), o !== void 0 && (o.line && t.push(o.line), o.times && o.times.length && n.push(o.times), a.length || o.heartRates && o.heartRates.length)) {
      if (!a.length)
        for (let l = 0; l < s; l++)
          a.push(new Array(t[l].length).fill(null));
      o.heartRates && o.heartRates.length ? a.push(o.heartRates) : a.push(new Array(o.line.length).fill(null));
    }
  if (t.length === 0) return;
  const i = {
    ...On(r),
    ...ui(I(r, "extensions"))
  };
  return n.length !== 0 && (i.coordTimes = t.length === 1 ? n[0] : n), a.length !== 0 && (i.heartRates = t.length === 1 ? a[0] : a), t.length === 1 ? {
    type: "Feature",
    properties: i,
    geometry: {
      type: "LineString",
      coordinates: t[0]
    }
  } : {
    type: "Feature",
    properties: i,
    geometry: {
      type: "MultiLineString",
      coordinates: t
    }
  };
}
function Kc(r) {
  const e = li(r, "rtept");
  return e === void 0 ? void 0 : {
    type: "Feature",
    properties: {
      ...On(r),
      ...ui(I(r, "extensions"))
    },
    geometry: {
      type: "LineString",
      coordinates: e.line
    }
  };
}
function Zc(r) {
  return {
    type: "Feature",
    properties: { ...On(r), ...tn(r, ["sym"]) },
    geometry: {
      type: "Point",
      coordinates: fi(r).coordinates
    }
  };
}
function ui(r) {
  const e = {};
  if (r) {
    const t = I(r, "line");
    if (t) {
      const n = F(I(t, "color")), a = Number.parseFloat(F(I(t, "opacity")) ?? "0"), o = Number.parseFloat(F(I(t, "width")) ?? "0");
      n && (e.stroke = n), Number.isNaN(a) || (e["stroke-opacity"] = a), Number.isNaN(o) || (e["stroke-width"] = o * 96 / 25.4);
    }
  }
  return e;
}
function On(r) {
  const e = tn(r, ["name", "cmt", "desc", "type", "time", "keywords"]), t = Z(r, "link");
  if (t.length !== 0) {
    e.links = [];
    for (const n of Array.from(t)) {
      const a = {
        href: Ze(n, "href"),
        ...tn(n, ["text", "type"])
      };
      e.links.push(a);
    }
  }
  return e;
}
function Na(r) {
  let e = 0;
  if (!r || !r.length) return e;
  for (let t = 0; t < r.length; t++)
    e = (e << 5) - e + r.charCodeAt(t) | 0;
  return e;
}
function Z(r, e) {
  return r.getElementsByTagName(e);
}
function Ze(r, e) {
  return r.getAttribute(e);
}
function ja(r, e) {
  return Number.parseFloat(Ze(r, e) ?? "0");
}
function I(r, e) {
  const t = Z(r, e);
  return t.length ? t[0] : null;
}
function Xc(r) {
  return r.normalize && r.normalize(), r;
}
function ci(r) {
  return r.map(Number.parseFloat).map((e) => Number.isNaN(e) ? null : e);
}
function F(r) {
  return r && Xc(r), r && r.textContent;
}
function tn(r, e) {
  const t = {};
  let n, a;
  for (a = 0; a < e.length; a++)
    n = I(r, e[a]), n && (t[e[a]] = F(n) ?? "");
  return t;
}
function pi(r) {
  return ci(r.replace(/\s*/g, "").split(","));
}
function Da(r) {
  const e = r.replace(/^\s*|\s*$/g, "").split(/\s+/), t = [];
  for (const n of e) t.push(pi(n));
  return t;
}
function fi(r) {
  const e = [ja(r, "lon"), ja(r, "lat")], t = I(r, "ele"), n = I(r, "gpxtpx:hr") || I(r, "hr"), a = I(r, "time");
  let o;
  return t && (o = Number.parseFloat(F(t) ?? "0"), Number.isNaN(o) || e.push(o)), {
    coordinates: e,
    time: a ? F(a) : null,
    heartRate: n !== null ? Number.parseFloat(F(n) ?? "0") : null
  };
}
function Yc(r) {
  let e = r;
  try {
    typeof e == "string" && (e = Rn(e));
  } catch {
    return null;
  }
  try {
    return ii(e);
  } catch {
  }
  try {
    return si(e);
  } catch {
  }
  return null;
}
async function Wc(r, e = {}) {
  const t = e.download ?? false, n = await Jc(r);
  if (t) {
    const a = e.filename ?? "maptiler_screenshot.png", o = document.createElement("a");
    o.style.display = "none", document.body.appendChild(o), o.href = URL.createObjectURL(n), o.download = a, o.click(), setTimeout(() => {
      document.body.removeChild(o), URL.revokeObjectURL(o.href);
    }, 0);
  }
  return n;
}
function Jc(r) {
  return new Promise((e, t) => {
    r.redraw(), r.once("idle", () => {
      r.getCanvas().toBlob((n) => {
        if (!n) {
          t(Error("Screenshot could not be created."));
          return;
        }
        e(n);
      }, "image/png");
    });
  });
}
var rn = [
  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60
  ["#1D5B79", "#468B97", "#EF6262", "#F3AA60"],
  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0
  ["#614BC3", "#33BBC5", "#85E6C5", "#C8FFE0"],
  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc
  ["#461959", "#7A316F", "#CD6688", "#AED8CC"],
  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060
  ["#0079FF", "#00DFA2", "#F6FA70", "#FF0060"],
  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a
  ["#39B5E0", "#A31ACB", "#FF78F0", "#F5EA5A"],
  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a
  ["#37E2D5", "#590696", "#C70A80", "#FBCB0A"],
  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff
  ["#FFD36E", "#FFF56D", "#99FFCD", "#9FB4FF"],
  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99
  ["#00EAD3", "#FFF5B7", "#FF449F", "#005F99"],
  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00
  ["#10A19D", "#540375", "#FF7000", "#FFBF00"]
];
function wr() {
  return rn[~~(Math.random() * rn.length)][~~(Math.random() * 4)];
}
function Pt() {
  return `maptiler_source_${Ja()}`;
}
function Rt() {
  return `maptiler_layer_${Ja()}`;
}
function nn(r, e) {
  if (e <= r[0].zoom)
    return r[0].value;
  if (e >= r[r.length - 1].zoom)
    return r[r.length - 1].value;
  for (let t = 0; t < r.length - 1; t += 1)
    if (e >= r[t].zoom && e < r[t + 1].zoom) {
      const n = r[t + 1].zoom - r[t].zoom, a = (e - r[t].zoom) / n;
      return a * r[t + 1].value + (1 - a) * r[t].value;
    }
  return 0;
}
function Fe(r) {
  return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((e) => [e.zoom, e.value])];
}
function z(r) {
  return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((e) => [e.zoom, e.value])];
}
function di(r, e) {
  if (typeof e == "number" && typeof r == "number")
    return 2 * e + r;
  if (typeof e == "number" && Array.isArray(r))
    return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((t) => [t.zoom, 2 * e + t.value])];
  if (typeof r == "number" && Array.isArray(e))
    return ["interpolate", ["linear"], ["zoom"], ...e.flatMap((t) => [t.zoom, 2 * t.value + r])];
  if (Array.isArray(r) && Array.isArray(e)) {
    const t = Array.from(/* @__PURE__ */ new Set([...r.map((n) => n.zoom), ...e.map((n) => n.zoom)])).sort((n, a) => n < a ? -1 : 1);
    return ["interpolate", ["linear"], ["zoom"], ...t.flatMap((n) => [n, 2 * nn(e, n) + nn(r, n)])];
  }
  return 0;
}
function hi(r, e) {
  return ["interpolate", ["linear"], ["get", e], ...r.flatMap((t) => [t.propertyValue, t.value])];
}
function zn(r) {
  const e = r.trimStart(), t = `${e}${" ".repeat(r.length - e.length)}`, n = Array.from(t);
  if (!n.every((s) => s === " " || s === "_"))
    throw new Error("A dash pattern must be composed only of whitespace and underscore characters.");
  if (!(n.some((s) => s === "_") && n.some((s) => s === " ")))
    throw new Error("A dash pattern must contain at least one underscore and one whitespace character");
  const i = [1];
  for (let s = 1; s < n.length; s += 1) {
    const l = n[s - 1], u = n[s];
    l === u ? i[i.length - 1] += 1 : i.push(1);
  }
  return i;
}
function an(r, e) {
  return ["interpolate", ["linear"], ["get", e], ...r.flatMap((t) => [t.value, t.color])];
}
function on(r, e, t = true) {
  return t ? [
    "interpolate",
    ["linear"],
    ["zoom"],
    0,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.025])],
    2,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.05])],
    4,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.1])],
    8,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.25])],
    16,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius])]
  ] : ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius])];
}
function mi(r, e, t = true) {
  return t ? [
    "interpolate",
    ["linear"],
    ["zoom"],
    0,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.025])],
    2,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.05])],
    4,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.1])],
    8,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.25])],
    16,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value])]
  ] : ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value])];
}
function sn(r, e) {
  return r.every((t) => t.color[3] === r[0].color[3]) ? r[0].color[3] ? r[0].color[3] / 255 : 1 : [
    "interpolate",
    ["linear"],
    ["get", e],
    ...r.getRawColorStops().flatMap((t) => {
      const n = t.value, a = t.color;
      return [n, a.length === 4 ? a[3] / 255 : 1];
    })
  ];
}
function yi(r, e = 10) {
  return [
    "interpolate",
    ["linear"],
    ["heatmap-density"],
    ...Array.from({ length: e + 1 }, (t, n) => {
      const a = n / e;
      return [a, r.getColorHex(a)];
    }).flat()
  ];
}
function Ut(r) {
  const e = r.toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function Qc(r) {
  return `#${Ut(r[0])}${Ut(r[1])}${Ut(r[2])}${r.length === 4 ? Ut(r[3]) : ""}`;
}
var T = class _T extends Array {
  constructor(t = {}) {
    super();
    y(this, "min", 0);
    y(this, "max", 1);
    "min" in t && (this.min = t.min), "max" in t && (this.max = t.max), "stops" in t && this.setStops(t.stops, { clone: false });
  }
  /**
   * Converts a array-definition color ramp definition into a usable ColorRamp instance.
   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
   * @param cr
   * @returns
   */
  static fromArrayDefinition(t) {
    return new _T({
      stops: t.map((n) => ({
        value: n[0],
        color: n[1]
      }))
    });
  }
  setStops(t, n = { clone: true }) {
    const a = n.clone ? this.clone() : this;
    a.length = 0;
    let o = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
    for (let s = 0; s < t.length; s += 1)
      o = Math.min(o, t[s].value), i = Math.max(i, t[s].value), a.push({
        value: t[s].value,
        color: t[s].color.slice()
        // we want to make sure we do a deep copy and not a reference
      });
    return a.sort((s, l) => s.value < l.value ? -1 : 1), this.min = o, this.max = i, a;
  }
  scale(t, n, a = { clone: true }) {
    const o = a.clone, i = this[0].value, l = this.at(-1).value - i, u = n - t, c = [];
    for (let p = 0; p < this.length; p += 1) {
      const h = (this[p].value - i) / l * u + t;
      o ? c.push({
        value: h,
        color: this[p].color.slice()
      }) : this[p].value = h;
    }
    return o ? new _T({ stops: c }) : this;
  }
  // for some reason, I had to reimplement this
  at(t) {
    return t < 0 ? this[this.length + t] : this[t];
  }
  clone() {
    return new _T({ stops: this.getRawColorStops() });
  }
  getRawColorStops() {
    const t = [];
    for (let n = 0; n < this.length; n += 1)
      t.push({ value: this[n].value, color: this[n].color });
    return t;
  }
  reverse(t = { clone: true }) {
    const n = t.clone ? this.clone() : this;
    for (let a = 0; a < ~~(n.length / 2); a += 1) {
      const o = n[a].color;
      n[a].color = n.at(-(a + 1)).color, n.at(-(a + 1)).color = o;
    }
    return n;
  }
  getBounds() {
    return { min: this.min, max: this.max };
  }
  getColor(t, n = { smooth: true }) {
    if (t <= this[0].value)
      return this[0].color;
    if (t >= this.at(-1).value)
      return this.at(-1).color;
    for (let a = 0; a < this.length - 1; a += 1) {
      if (t > this[a + 1].value)
        continue;
      const o = this[a].color;
      if (!n.smooth)
        return o.slice();
      const i = this[a].value, s = this[a + 1].value, l = this[a + 1].color, u = (s - t) / (s - i);
      return o.map((c, p) => Math.round(c * u + l[p] * (1 - u)));
    }
    return [0, 0, 0];
  }
  /**
   * Get the color as an hexadecimal string
   */
  getColorHex(t, n = {
    smooth: true,
    withAlpha: false
  }) {
    return Qc(this.getColor(t, n));
  }
  /**
   * Get the color of the color ramp at a relative position in [0, 1]
   */
  getColorRelative(t, n = { smooth: true }) {
    const a = this.getBounds();
    return this.getColor(a.min + t * (a.max - a.min), n);
  }
  getCanvasStrip(t = {
    horizontal: true,
    size: 512,
    smooth: true
  }) {
    const n = document.createElement("canvas");
    n.width = t.horizontal ? t.size : 1, n.height = t.horizontal ? 1 : t.size;
    const a = n.getContext("2d");
    if (!a) throw new Error("Canvs context is missing");
    const o = a.getImageData(0, 0, n.width, n.height), i = o.data, s = t.size, l = this[0].value, p = (this.at(-1).value - l) / s;
    for (let f2 = 0; f2 < s; f2 += 1) {
      const d = this.getColor(l + f2 * p, {
        smooth: t.smooth
      });
      i[f2 * 4] = d[0], i[f2 * 4 + 1] = d[1], i[f2 * 4 + 2] = d[2], i[f2 * 4 + 3] = d.length > 3 ? d[3] : 255;
    }
    return a.putImageData(o, 0, 0), n;
  }
  /**
   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.
   */
  resample(t, n = 15) {
    const a = this.getBounds(), o = this.scale(0, 1), i = 1 / (n - 1);
    let s;
    if (t === "ease-in-square")
      s = Array.from({ length: n }, (c, p) => {
        const f2 = p * i, d = f2 ** 2, h = o.getColor(d);
        return { value: f2, color: h };
      });
    else if (t === "ease-out-square")
      s = Array.from({ length: n }, (c, p) => {
        const f2 = p * i, d = 1 - (1 - f2) ** 2, h = o.getColor(d);
        return { value: f2, color: h };
      });
    else if (t === "ease-out-sqrt")
      s = Array.from({ length: n }, (c, p) => {
        const f2 = p * i, d = f2 ** 0.5, h = o.getColor(d);
        return { value: f2, color: h };
      });
    else if (t === "ease-in-sqrt")
      s = Array.from({ length: n }, (c, p) => {
        const f2 = p * i, d = 1 - (1 - f2) ** 0.5, h = o.getColor(d);
        return { value: f2, color: h };
      });
    else if (t === "ease-out-exp")
      s = Array.from({ length: n }, (c, p) => {
        const f2 = p * i, d = 1 - 2 ** (-10 * f2), h = o.getColor(d);
        return { value: f2, color: h };
      });
    else if (t === "ease-in-exp")
      s = Array.from({ length: n }, (c, p) => {
        const f2 = p * i, d = 2 ** (10 * f2 - 10), h = o.getColor(d);
        return { value: f2, color: h };
      });
    else
      throw new Error("Invalid ressampling method.");
    return new _T({ stops: s }).scale(a.min, a.max);
  }
  /**
   * Makes a clone of this color ramp that is fully transparant at the begining of their range
   */
  transparentStart() {
    const t = this.getRawColorStops();
    t.unshift({
      value: t[0].value,
      color: t[0].color.slice()
    }), t[1].value += 1e-3;
    for (const n of t)
      n.color.length === 3 && n.color.push(255);
    return t[0].color[3] = 0, new _T({ stops: t });
  }
  /**
   * Check if this color ramp has a transparent start
   */
  hasTransparentStart() {
    return this[0].color.length === 4 && this[0].color[3] === 0;
  }
};
var gi = {
  /**
   * A fully transparent [0, 0, 0, 0] colorramp to hide data.
   * Defined in interval [0, 1], without unit.
   */
  NULL: new T({
    stops: [
      { value: 0, color: [0, 0, 0, 0] },
      { value: 1, color: [0, 0, 0, 0] }
    ]
  }),
  GRAY: new T({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic jet color ramp.
   * Defined in interval [0, 1], without unit.
   */
  JET: new T({
    stops: [
      { value: 0, color: [0, 0, 131] },
      { value: 0.125, color: [0, 60, 170] },
      { value: 0.375, color: [5, 255, 255] },
      { value: 0.625, color: [255, 255, 0] },
      { value: 0.875, color: [250, 0, 0] },
      { value: 1, color: [128, 0, 0] }
    ]
  }),
  /**
   * Classic HSV color ramp (hue, saturation, value).
   * Defined in interval [0, 1], without unit.
   */
  HSV: new T({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 0.169, color: [253, 255, 2] },
      { value: 0.173, color: [247, 255, 2] },
      { value: 0.337, color: [0, 252, 4] },
      { value: 0.341, color: [0, 252, 10] },
      { value: 0.506, color: [1, 249, 255] },
      { value: 0.671, color: [2, 0, 253] },
      { value: 0.675, color: [8, 0, 253] },
      { value: 0.839, color: [255, 0, 251] },
      { value: 0.843, color: [255, 0, 245] },
      { value: 1, color: [255, 0, 6] }
    ]
  }),
  /**
   * Classic hot color ramp.
   * Defined in interval [0, 1], without unit.
   */
  HOT: new T({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.3, color: [230, 0, 0] },
      { value: 0.6, color: [255, 210, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic spring color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SPRING: new T({
    stops: [
      { value: 0, color: [255, 0, 255] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic summer color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SUMMER: new T({
    stops: [
      { value: 0, color: [0, 128, 102] },
      { value: 1, color: [255, 255, 102] }
    ]
  }),
  /**
   * Classic autommn color ramp.
   * Defined in interval [0, 1], without unit.
   */
  AUTOMN: new T({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic winter color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WINTER: new T({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [0, 255, 128] }
    ]
  }),
  /**
   * Classic bone color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BONE: new T({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.376, color: [84, 84, 116] },
      { value: 0.753, color: [169, 200, 200] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic copper color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COPPER: new T({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.804, color: [255, 160, 102] },
      { value: 1, color: [255, 199, 127] }
    ]
  }),
  /**
   * Classic greys color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREYS: new T({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic yignbu color ramp (blue to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIGNBU: new T({
    stops: [
      { value: 0, color: [8, 29, 88] },
      { value: 0.125, color: [37, 52, 148] },
      { value: 0.25, color: [34, 94, 168] },
      { value: 0.375, color: [29, 145, 192] },
      { value: 0.5, color: [65, 182, 196] },
      { value: 0.625, color: [127, 205, 187] },
      { value: 0.75, color: [199, 233, 180] },
      { value: 0.875, color: [237, 248, 217] },
      { value: 1, color: [255, 255, 217] }
    ]
  }),
  /**
   * Classic greens color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREENS: new T({
    stops: [
      { value: 0, color: [0, 68, 27] },
      { value: 0.125, color: [0, 109, 44] },
      { value: 0.25, color: [35, 139, 69] },
      { value: 0.375, color: [65, 171, 93] },
      { value: 0.5, color: [116, 196, 118] },
      { value: 0.625, color: [161, 217, 155] },
      { value: 0.75, color: [199, 233, 192] },
      { value: 0.875, color: [229, 245, 224] },
      { value: 1, color: [247, 252, 245] }
    ]
  }),
  /**
   * Classic yiorrd color ramp (red to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIORRD: new T({
    stops: [
      { value: 0, color: [128, 0, 38] },
      { value: 0.125, color: [189, 0, 38] },
      { value: 0.25, color: [227, 26, 28] },
      { value: 0.375, color: [252, 78, 42] },
      { value: 0.5, color: [253, 141, 60] },
      { value: 0.625, color: [254, 178, 76] },
      { value: 0.75, color: [254, 217, 118] },
      { value: 0.875, color: [255, 237, 160] },
      { value: 1, color: [255, 255, 204] }
    ]
  }),
  /**
   * Classic blue-red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLUERED: new T({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rdbu color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RDBU: new T({
    stops: [
      { value: 0, color: [5, 10, 172] },
      { value: 0.35, color: [106, 137, 247] },
      { value: 0.5, color: [190, 190, 190] },
      { value: 0.6, color: [220, 170, 132] },
      { value: 0.7, color: [230, 145, 90] },
      { value: 1, color: [178, 10, 28] }
    ]
  }),
  /**
   * Classic picnic color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PICNIC: new T({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 0.1, color: [51, 153, 255] },
      { value: 0.2, color: [102, 204, 255] },
      { value: 0.3, color: [153, 204, 255] },
      { value: 0.4, color: [204, 204, 255] },
      { value: 0.5, color: [255, 255, 255] },
      { value: 0.6, color: [255, 204, 255] },
      { value: 0.7, color: [255, 153, 255] },
      { value: 0.8, color: [255, 102, 204] },
      { value: 0.9, color: [255, 102, 102] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rainbow color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW: new T({
    stops: [
      { value: 0, color: [150, 0, 90] },
      { value: 0.125, color: [0, 0, 200] },
      { value: 0.25, color: [0, 25, 255] },
      { value: 0.375, color: [0, 152, 255] },
      { value: 0.5, color: [44, 255, 150] },
      { value: 0.625, color: [151, 255, 0] },
      { value: 0.75, color: [255, 234, 0] },
      { value: 0.875, color: [255, 111, 0] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic Portland color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PORTLAND: new T({
    stops: [
      { value: 0, color: [12, 51, 131] },
      { value: 0.25, color: [10, 136, 186] },
      { value: 0.5, color: [242, 211, 56] },
      { value: 0.75, color: [242, 143, 56] },
      { value: 1, color: [217, 30, 30] }
    ]
  }),
  /**
   * Classic blackbody color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLACKBODY: new T({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.2, color: [230, 0, 0] },
      { value: 0.4, color: [230, 210, 0] },
      { value: 0.7, color: [255, 255, 255] },
      { value: 1, color: [160, 200, 255] }
    ]
  }),
  /**
   * Classic earth color ramp.
   * Defined in interval [0, 1], without unit.
   */
  EARTH: new T({
    stops: [
      { value: 0, color: [0, 0, 130] },
      { value: 0.1, color: [0, 180, 180] },
      { value: 0.2, color: [40, 210, 40] },
      { value: 0.4, color: [230, 230, 50] },
      { value: 0.6, color: [120, 70, 20] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic electric color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ELECTRIC: new T({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.15, color: [30, 0, 100] },
      { value: 0.4, color: [120, 0, 100] },
      { value: 0.6, color: [160, 90, 0] },
      { value: 0.8, color: [230, 200, 0] },
      { value: 1, color: [255, 250, 220] }
    ]
  }),
  /**
   * Classic viridis color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VIRIDIS: new T({
    stops: [
      { value: 0, color: [68, 1, 84] },
      { value: 0.13, color: [71, 44, 122] },
      { value: 0.25, color: [59, 81, 139] },
      { value: 0.38, color: [44, 113, 142] },
      { value: 0.5, color: [33, 144, 141] },
      { value: 0.63, color: [39, 173, 129] },
      { value: 0.75, color: [92, 200, 99] },
      { value: 0.88, color: [170, 220, 50] },
      { value: 1, color: [253, 231, 37] }
    ]
  }),
  /**
   * Classic inferno color ramp.
   * Defined in interval [0, 1], without unit.
   */
  INFERNO: new T({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [31, 12, 72] },
      { value: 0.25, color: [85, 15, 109] },
      { value: 0.38, color: [136, 34, 106] },
      { value: 0.5, color: [186, 54, 85] },
      { value: 0.63, color: [227, 89, 51] },
      { value: 0.75, color: [249, 140, 10] },
      { value: 0.88, color: [249, 201, 50] },
      { value: 1, color: [252, 255, 164] }
    ]
  }),
  /**
   * Classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  MAGMA: new T({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [28, 16, 68] },
      { value: 0.25, color: [79, 18, 123] },
      { value: 0.38, color: [129, 37, 129] },
      { value: 0.5, color: [181, 54, 122] },
      { value: 0.63, color: [229, 80, 100] },
      { value: 0.75, color: [251, 135, 97] },
      { value: 0.88, color: [254, 194, 135] },
      { value: 1, color: [252, 253, 191] }
    ]
  }),
  /**
   * Classic plasma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PLASMA: new T({
    stops: [
      { value: 0, color: [13, 8, 135] },
      { value: 0.13, color: [75, 3, 161] },
      { value: 0.25, color: [125, 3, 168] },
      { value: 0.38, color: [168, 34, 150] },
      { value: 0.5, color: [203, 70, 121] },
      { value: 0.63, color: [229, 107, 93] },
      { value: 0.75, color: [248, 148, 65] },
      { value: 0.88, color: [253, 195, 40] },
      { value: 1, color: [240, 249, 33] }
    ]
  }),
  /**
   * Classic warm color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WARM: new T({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [172, 0, 187] },
      { value: 0.25, color: [219, 0, 170] },
      { value: 0.38, color: [255, 0, 130] },
      { value: 0.5, color: [255, 63, 74] },
      { value: 0.63, color: [255, 123, 0] },
      { value: 0.75, color: [234, 176, 0] },
      { value: 0.88, color: [190, 228, 0] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic cool color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COOL: new T({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [116, 0, 218] },
      { value: 0.25, color: [98, 74, 237] },
      { value: 0.38, color: [68, 146, 231] },
      { value: 0.5, color: [0, 204, 197] },
      { value: 0.63, color: [0, 247, 146] },
      { value: 0.75, color: [0, 255, 88] },
      { value: 0.88, color: [40, 255, 8] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic rainboz soft color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW_SOFT: new T({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.1, color: [199, 0, 180] },
      { value: 0.2, color: [255, 0, 121] },
      { value: 0.3, color: [255, 108, 0] },
      { value: 0.4, color: [222, 194, 0] },
      { value: 0.5, color: [150, 255, 0] },
      { value: 0.6, color: [0, 255, 55] },
      { value: 0.7, color: [0, 246, 150] },
      { value: 0.8, color: [50, 167, 222] },
      { value: 0.9, color: [103, 51, 235] },
      { value: 1, color: [124, 0, 186] }
    ]
  }),
  /**
   * Classic bathymetry color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BATHYMETRY: new T({
    stops: [
      { value: 0, color: [40, 26, 44] },
      { value: 0.13, color: [59, 49, 90] },
      { value: 0.25, color: [64, 76, 139] },
      { value: 0.38, color: [63, 110, 151] },
      { value: 0.5, color: [72, 142, 158] },
      { value: 0.63, color: [85, 174, 163] },
      { value: 0.75, color: [120, 206, 163] },
      { value: 0.88, color: [187, 230, 172] },
      { value: 1, color: [253, 254, 204] }
    ]
  }),
  /**
   * Classic cdom color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CDOM: new T({
    stops: [
      { value: 0, color: [47, 15, 62] },
      { value: 0.13, color: [87, 23, 86] },
      { value: 0.25, color: [130, 28, 99] },
      { value: 0.38, color: [171, 41, 96] },
      { value: 0.5, color: [206, 67, 86] },
      { value: 0.63, color: [230, 106, 84] },
      { value: 0.75, color: [242, 149, 103] },
      { value: 0.88, color: [249, 193, 135] },
      { value: 1, color: [254, 237, 176] }
    ]
  }),
  /**
   * Classic chlorophyll color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CHLOROPHYLL: new T({
    stops: [
      { value: 0, color: [18, 36, 20] },
      { value: 0.13, color: [25, 63, 41] },
      { value: 0.25, color: [24, 91, 59] },
      { value: 0.38, color: [13, 119, 72] },
      { value: 0.5, color: [18, 148, 80] },
      { value: 0.63, color: [80, 173, 89] },
      { value: 0.75, color: [132, 196, 122] },
      { value: 0.88, color: [175, 221, 162] },
      { value: 1, color: [215, 249, 208] }
    ]
  }),
  /**
   * Classic density color ramp.
   * Defined in interval [0, 1], without unit.
   */
  DENSITY: new T({
    stops: [
      { value: 0, color: [54, 14, 36] },
      { value: 0.13, color: [89, 23, 80] },
      { value: 0.25, color: [110, 45, 132] },
      { value: 0.38, color: [120, 77, 178] },
      { value: 0.5, color: [120, 113, 213] },
      { value: 0.63, color: [115, 151, 228] },
      { value: 0.75, color: [134, 185, 227] },
      { value: 0.88, color: [177, 214, 227] },
      { value: 1, color: [230, 241, 241] }
    ]
  }),
  /**
   * Classic freesurface blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_BLUE: new T({
    stops: [
      { value: 0, color: [30, 4, 110] },
      { value: 0.13, color: [47, 14, 176] },
      { value: 0.25, color: [41, 45, 236] },
      { value: 0.38, color: [25, 99, 212] },
      { value: 0.5, color: [68, 131, 200] },
      { value: 0.63, color: [114, 156, 197] },
      { value: 0.75, color: [157, 181, 203] },
      { value: 0.88, color: [200, 208, 216] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic freesurface red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_RED: new T({
    stops: [
      { value: 0, color: [60, 9, 18] },
      { value: 0.13, color: [100, 17, 27] },
      { value: 0.25, color: [142, 20, 29] },
      { value: 0.38, color: [177, 43, 27] },
      { value: 0.5, color: [192, 87, 63] },
      { value: 0.63, color: [205, 125, 105] },
      { value: 0.75, color: [216, 162, 148] },
      { value: 0.88, color: [227, 199, 193] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic oxygen color ramp.
   * Defined in interval [0, 1], without unit.
   */
  OXYGEN: new T({
    stops: [
      { value: 0, color: [64, 5, 5] },
      { value: 0.13, color: [106, 6, 15] },
      { value: 0.25, color: [144, 26, 7] },
      { value: 0.38, color: [168, 64, 3] },
      { value: 0.5, color: [188, 100, 4] },
      { value: 0.63, color: [206, 136, 11] },
      { value: 0.75, color: [220, 174, 25] },
      { value: 0.88, color: [231, 215, 44] },
      { value: 1, color: [248, 254, 105] }
    ]
  }),
  /**
   * Classic par color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PAR: new T({
    stops: [
      { value: 0, color: [51, 20, 24] },
      { value: 0.13, color: [90, 32, 35] },
      { value: 0.25, color: [129, 44, 34] },
      { value: 0.38, color: [159, 68, 25] },
      { value: 0.5, color: [182, 99, 19] },
      { value: 0.63, color: [199, 134, 22] },
      { value: 0.75, color: [212, 171, 35] },
      { value: 0.88, color: [221, 210, 54] },
      { value: 1, color: [225, 253, 75] }
    ]
  }),
  /**
   * Classic phase color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PHASE: new T({
    stops: [
      { value: 0, color: [145, 105, 18] },
      { value: 0.13, color: [184, 71, 38] },
      { value: 0.25, color: [186, 58, 115] },
      { value: 0.38, color: [160, 71, 185] },
      { value: 0.5, color: [110, 97, 218] },
      { value: 0.63, color: [50, 123, 164] },
      { value: 0.75, color: [31, 131, 110] },
      { value: 0.88, color: [77, 129, 34] },
      { value: 1, color: [145, 105, 18] }
    ]
  }),
  /**
   * Classic salinity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SALINITY: new T({
    stops: [
      { value: 0, color: [42, 24, 108] },
      { value: 0.13, color: [33, 50, 162] },
      { value: 0.25, color: [15, 90, 145] },
      { value: 0.38, color: [40, 118, 137] },
      { value: 0.5, color: [59, 146, 135] },
      { value: 0.63, color: [79, 175, 126] },
      { value: 0.75, color: [120, 203, 104] },
      { value: 0.88, color: [193, 221, 100] },
      { value: 1, color: [253, 239, 154] }
    ]
  }),
  /**
   * Classic temperature color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TEMPERATURE: new T({
    stops: [
      { value: 0, color: [4, 35, 51] },
      { value: 0.13, color: [23, 51, 122] },
      { value: 0.25, color: [85, 59, 157] },
      { value: 0.38, color: [129, 79, 143] },
      { value: 0.5, color: [175, 95, 130] },
      { value: 0.63, color: [222, 112, 101] },
      { value: 0.75, color: [249, 146, 66] },
      { value: 0.88, color: [249, 196, 65] },
      { value: 1, color: [232, 250, 91] }
    ]
  }),
  /**
   * Classic turbidity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TURBIDITY: new T({
    stops: [
      { value: 0, color: [34, 31, 27] },
      { value: 0.13, color: [65, 50, 41] },
      { value: 0.25, color: [98, 69, 52] },
      { value: 0.38, color: [131, 89, 57] },
      { value: 0.5, color: [161, 112, 59] },
      { value: 0.63, color: [185, 140, 66] },
      { value: 0.75, color: [202, 174, 88] },
      { value: 0.88, color: [216, 209, 126] },
      { value: 1, color: [233, 246, 171] }
    ]
  }),
  /**
   * Classic velocity blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_BLUE: new T({
    stops: [
      { value: 0, color: [17, 32, 64] },
      { value: 0.13, color: [35, 52, 116] },
      { value: 0.25, color: [29, 81, 156] },
      { value: 0.38, color: [31, 113, 162] },
      { value: 0.5, color: [50, 144, 169] },
      { value: 0.63, color: [87, 173, 176] },
      { value: 0.75, color: [149, 196, 189] },
      { value: 0.88, color: [203, 221, 211] },
      { value: 1, color: [254, 251, 230] }
    ]
  }),
  /**
   * Classic velocity green color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_GREEN: new T({
    stops: [
      { value: 0, color: [23, 35, 19] },
      { value: 0.13, color: [24, 64, 38] },
      { value: 0.25, color: [11, 95, 45] },
      { value: 0.38, color: [39, 123, 35] },
      { value: 0.5, color: [95, 146, 12] },
      { value: 0.63, color: [152, 165, 18] },
      { value: 0.75, color: [201, 186, 69] },
      { value: 0.88, color: [233, 216, 137] },
      { value: 1, color: [255, 253, 205] }
    ]
  }),
  /**
   * Classic cube helix color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CUBEHELIX: new T({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.07, color: [22, 5, 59] },
      { value: 0.13, color: [60, 4, 105] },
      { value: 0.2, color: [109, 1, 135] },
      { value: 0.27, color: [161, 0, 147] },
      { value: 0.33, color: [210, 2, 142] },
      { value: 0.4, color: [251, 11, 123] },
      { value: 0.47, color: [255, 29, 97] },
      { value: 0.53, color: [255, 54, 69] },
      { value: 0.6, color: [255, 85, 46] },
      { value: 0.67, color: [255, 120, 34] },
      { value: 0.73, color: [255, 157, 37] },
      { value: 0.8, color: [241, 191, 57] },
      { value: 0.87, color: [224, 220, 93] },
      { value: 0.93, color: [218, 241, 142] },
      { value: 1, color: [227, 253, 198] }
    ]
  }),
  /**
   * The cividis color ramp is color blind friendly.
   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239
   * Defined in interval [0, 1], without unit.
   */
  CIVIDIS: new T({
    stops: [
      { value: 0, color: [0, 32, 77, 255] },
      { value: 0.125, color: [5, 54, 110, 255] },
      { value: 0.25, color: [65, 77, 108, 255] },
      { value: 0.375, color: [97, 100, 111, 255] },
      { value: 0.5, color: [125, 124, 121, 255] },
      { value: 0.625, color: [156, 149, 120, 255] },
      { value: 0.75, color: [190, 175, 111, 255] },
      { value: 0.875, color: [225, 204, 94, 255] },
      { value: 1, color: [255, 235, 70, 255] }
    ]
  }),
  /**
   * Classic turbo color ramp.
   * This is a luminance-constant alternative to the jet, making it more
   * clor-blind friendly.
   * Defined in interval [0, 1], without unit.
   */
  TURBO: new T({
    stops: [
      { value: 0, color: [48, 18, 59, 255] },
      { value: 0.125, color: [70, 107, 227, 255] },
      { value: 0.25, color: [40, 187, 236, 255] },
      { value: 0.375, color: [49, 242, 153, 255] },
      { value: 0.5, color: [162, 252, 60, 255] },
      { value: 0.625, color: [237, 208, 58, 255] },
      { value: 0.75, color: [251, 128, 34, 255] },
      { value: 0.875, color: [210, 49, 5, 255] },
      { value: 1, color: [122, 4, 3, 255] }
    ]
  }),
  /**
   * The rocket color ramp is perceptually uniform, which makes it more
   * color bliend friendly than the classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ROCKET: new T({
    stops: [
      { value: 0, color: [250, 235, 221, 0] },
      { value: 0.133, color: [250, 235, 221, 255] },
      { value: 0.266, color: [246, 170, 130, 255] },
      { value: 0.4, color: [240, 96, 67, 255] },
      { value: 0.533, color: [203, 27, 79, 255] },
      { value: 0.666, color: [132, 30, 90, 255] },
      { value: 0.8, color: [63, 27, 68, 255] },
      { value: 1, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * The mako color ramp is perceptually uniform and can be seen as
   * a color blind friendly alternative to bathymetry or yignbu.
   * Defined in interval [0, 1], without unit.
   */
  MAKO: new T({
    stops: [
      { value: 0, color: [11, 4, 5, 255] },
      { value: 0.125, color: [43, 28, 53, 255] },
      { value: 0.25, color: [62, 53, 107, 255] },
      { value: 0.375, color: [59, 86, 152, 255] },
      { value: 0.5, color: [53, 123, 162, 255] },
      { value: 0.625, color: [53, 158, 170, 255] },
      { value: 0.75, color: [73, 193, 173, 255] },
      { value: 0.875, color: [150, 221, 181, 255] },
      { value: 1, color: [222, 245, 229, 255] }
    ]
  })
};
async function ep(r, e, t = {}) {
  var a, o;
  if (!e.sourceId && !e.data)
    throw new Error("Creating a polyline layer requires an existing .sourceId or a valid .data property");
  let n = e.data;
  if (typeof n == "string") {
    if (nr(n))
      n = `https://api.maptiler.com/data/${e.data}/features.json?key=${j.apiKey}`;
    else if (((a = n.split(".").pop()) == null ? void 0 : a.toLowerCase().trim()) === "gpx") {
      const s = await (await fetch(n, t)).text();
      n = ii(s);
    } else if (((o = n.split(".").pop()) == null ? void 0 : o.toLowerCase().trim()) === "kml") {
      const s = await (await fetch(n, t)).text();
      n = si(s);
    } else {
      const i = Ji(n) ?? Yc(n);
      i && (n = i);
    }
    if (!n)
      throw new Error("Polyline data was provided as string but is incompatible with valid formats.");
  }
  return tp(r, {
    ...e,
    data: n
  });
}
function tp(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = {
    polylineLayerId: n,
    polylineOutlineLayerId: "",
    polylineSourceId: t
  };
  e.data && !r.getSource(t) && r.addSource(t, {
    type: "geojson",
    data: e.data
  });
  const o = e.lineWidth ?? 3, i = e.lineColor ?? wr(), s = e.lineOpacity ?? 1, l = e.lineBlur ?? 0, u = e.lineGapWidth ?? 0;
  let c = e.lineDashArray ?? null;
  const p = e.outlineWidth ?? 1, f2 = e.outlineColor ?? "#FFFFFF", d = e.outlineOpacity ?? 1, h = e.outlineBlur ?? 0;
  if (typeof c == "string" && (c = zn(c)), e.outline === true) {
    const m = `${n}_outline`;
    a.polylineOutlineLayerId = m, r.addLayer(
      {
        id: m,
        type: "line",
        source: t,
        layout: {
          "line-join": e.lineJoin ?? "round",
          "line-cap": e.lineCap ?? "round"
        },
        minzoom: e.minzoom ?? 0,
        maxzoom: e.maxzoom ?? 23,
        paint: {
          "line-opacity": typeof d == "number" ? d : z(d),
          "line-color": typeof f2 == "string" ? f2 : Fe(f2),
          "line-width": di(o, p),
          "line-blur": typeof h == "number" ? h : z(h)
        }
      },
      e.beforeId
    );
  }
  return r.addLayer(
    {
      id: n,
      type: "line",
      source: t,
      layout: {
        "line-join": e.lineJoin ?? "round",
        "line-cap": e.lineCap ?? "round"
      },
      minzoom: e.minzoom ?? 0,
      maxzoom: e.maxzoom ?? 23,
      paint: {
        "line-opacity": typeof s == "number" ? s : z(s),
        "line-color": typeof i == "string" ? i : Fe(i),
        "line-width": typeof o == "number" ? o : z(o),
        "line-blur": typeof l == "number" ? l : z(l),
        "line-gap-width": typeof u == "number" ? u : z(u),
        // For some reasons passing "line-dasharray" with the value "undefined"
        // results in no showing the line while it should have the same behavior
        // of not adding the property "line-dasharray" as all.
        // As a workaround, we are inlining the addition of the prop with a conditional
        // which is less readable.
        ...c && { "line-dasharray": c }
      }
    },
    e.beforeId
  ), a;
}
function rp(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = {
    polygonLayerId: n,
    polygonOutlineLayerId: e.outline ? `${n}_outline` : "",
    polygonSourceId: t
  };
  if (e.data && !r.getSource(t)) {
    let m = e.data;
    typeof m == "string" && nr(m) && (m = `https://api.maptiler.com/data/${m}/features.json?key=${j.apiKey}`), r.addSource(t, {
      type: "geojson",
      data: m
    });
  }
  let o = e.outlineDashArray ?? null;
  const i = e.outlineWidth ?? 1, s = e.outlineColor ?? "#FFFFFF", l = e.outlineOpacity ?? 1, u = e.outlineBlur ?? 0, c = e.fillColor ?? wr(), p = e.fillOpacity ?? 1, f2 = e.outlinePosition ?? "center", d = e.pattern ?? null;
  typeof o == "string" && (o = zn(o));
  const h = (m = null) => {
    if (r.addLayer(
      {
        id: n,
        type: "fill",
        source: t,
        minzoom: e.minzoom ?? 0,
        maxzoom: e.maxzoom ?? 23,
        paint: {
          "fill-color": typeof c == "string" ? c : Fe(c),
          "fill-opacity": typeof p == "number" ? p : z(p),
          // Adding a pattern if provided
          ...m && { "fill-pattern": m }
        }
      },
      e.beforeId
    ), e.outline === true) {
      let g;
      f2 === "inside" ? typeof i == "number" ? g = 0.5 * i : g = z(
        i.map(({ zoom: b, value: v }) => ({
          zoom: b,
          value: 0.5 * v
        }))
      ) : f2 === "outside" ? typeof i == "number" ? g = -0.5 * i : g = z(
        i.map((b) => ({
          zoom: b.zoom,
          value: -0.5 * b.value
        }))
      ) : g = 0, r.addLayer(
        {
          id: a.polygonOutlineLayerId,
          type: "line",
          source: t,
          layout: {
            "line-join": e.outlineJoin ?? "round",
            "line-cap": e.outlineCap ?? "butt"
          },
          minzoom: e.minzoom ?? 0,
          maxzoom: e.maxzoom ?? 23,
          paint: {
            "line-opacity": typeof l == "number" ? l : z(l),
            "line-color": typeof s == "string" ? s : Fe(s),
            "line-width": typeof i == "number" ? i : z(i),
            "line-blur": typeof u == "number" ? u : z(u),
            "line-offset": g,
            // For some reasons passing "line-dasharray" with the value "undefined"
            // results in no showing the line while it should have the same behavior
            // of not adding the property "line-dasharray" as all.
            // As a workaround, we are inlining the addition of the prop with a conditional
            // which is less readable.
            ...o && {
              "line-dasharray": o
            }
          }
        },
        e.beforeId
      );
    }
  };
  return d ? r.hasImage(d) ? h(d) : r.loadImage(d).then((m) => {
    r.addImage(d, m.data), h(d);
  }).catch((m) => {
    console.error("Could not load the pattern image.", m.message), h();
  }) : h(), a;
}
function np(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.minPointRadius ?? 10, n = e.maxPointRadius ?? 50, a = e.cluster ?? false, o = 20, i = Array.isArray(e.pointColor) ? e.pointColor : gi.TURBO.scale(10, e.cluster ? 1e4 : 1e3).resample("ease-out-square"), s = i.getBounds(), l = e.sourceId ?? Pt(), u = e.layerId ?? Rt(), c = e.showLabel ?? a, p = e.alignOnViewport ?? true, f2 = e.outline ?? false, d = e.outlineOpacity ?? 1, h = e.outlineWidth ?? 1, m = e.outlineColor ?? "#FFFFFF";
  let g;
  const b = e.zoomCompensation ?? true, v = e.minzoom ?? 0, x = e.maxzoom ?? 23;
  typeof e.pointOpacity == "number" ? g = e.pointOpacity : Array.isArray(e.pointOpacity) ? g = z(e.pointOpacity) : e.cluster ? g = sn(i, "point_count") : e.property ? g = sn(i, e.property) : g = z([
    { zoom: v, value: 0 },
    { zoom: v + 0.25, value: 1 },
    { zoom: x - 0.25, value: 1 },
    { zoom: x, value: 0 }
  ]);
  const C = {
    pointLayerId: u,
    clusterLayerId: "",
    labelLayerId: "",
    pointSourceId: l
  };
  if (e.data && !r.getSource(l)) {
    let E = e.data;
    typeof E == "string" && nr(E) && (E = `https://api.maptiler.com/data/${E}/features.json?key=${j.apiKey}`), r.addSource(l, {
      type: "geojson",
      data: E,
      cluster: a
    });
  }
  if (a) {
    C.clusterLayerId = `${u}_cluster`;
    const E = Array.from({ length: o }, (A, N) => {
      const le = s.min + N * (s.max - s.min) / (o - 1);
      return {
        value: le,
        pointRadius: t + (n - t) * (N / (o - 1)) ** 0.5,
        color: i.getColorHex(le)
      };
    });
    r.addLayer(
      {
        id: C.clusterLayerId,
        type: "circle",
        source: l,
        filter: ["has", "point_count"],
        paint: {
          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, "point_count"),
          "circle-color": typeof e.pointColor == "string" ? e.pointColor : an(E, "point_count"),
          "circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? z(e.pointRadius) : on(E, "point_count", false),
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          "circle-opacity": g,
          ...f2 && {
            "circle-stroke-opacity": typeof d == "number" ? d : z(d),
            "circle-stroke-width": typeof h == "number" ? h : z(h),
            "circle-stroke-color": typeof m == "string" ? m : Fe(m)
          }
        },
        minzoom: v,
        maxzoom: x
      },
      e.beforeId
    ), r.addLayer(
      {
        id: C.pointLayerId,
        type: "circle",
        source: l,
        filter: ["!", ["has", "point_count"]],
        paint: {
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,
          "circle-color": typeof e.pointColor == "string" ? e.pointColor : i.getColorHex(i.getBounds().min),
          "circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? z(e.pointRadius) : E[0].pointRadius * 0.75,
          "circle-opacity": g,
          ...f2 && {
            "circle-stroke-opacity": typeof d == "number" ? d : z(d),
            "circle-stroke-width": typeof h == "number" ? h : z(h),
            "circle-stroke-color": typeof m == "string" ? m : Fe(m)
          }
        },
        minzoom: v,
        maxzoom: x
      },
      e.beforeId
    );
  } else {
    let E = typeof e.pointColor == "string" ? e.pointColor : Array.isArray(e.pointColor) ? e.pointColor.getColorHex(e.pointColor.getBounds().min) : wr(), A = typeof e.pointRadius == "number" ? b ? z([
      { zoom: 0, value: e.pointRadius * 0.025 },
      { zoom: 2, value: e.pointRadius * 0.05 },
      { zoom: 4, value: e.pointRadius * 0.1 },
      { zoom: 8, value: e.pointRadius * 0.25 },
      { zoom: 16, value: e.pointRadius * 1 }
    ]) : e.pointRadius : Array.isArray(e.pointRadius) ? z(e.pointRadius) : b ? z([
      { zoom: 0, value: t * 0.05 },
      { zoom: 2, value: t * 0.1 },
      { zoom: 4, value: t * 0.2 },
      { zoom: 8, value: t * 0.5 },
      { zoom: 16, value: t * 1 }
    ]) : t;
    if (e.property && Array.isArray(e.pointColor)) {
      const N = Array.from({ length: o }, (le, Ye) => {
        const We = s.min + Ye * (s.max - s.min) / (o - 1);
        return {
          value: We,
          pointRadius: typeof e.pointRadius == "number" ? e.pointRadius : t + (n - t) * (Ye / (o - 1)) ** 0.5,
          color: typeof e.pointColor == "string" ? e.pointColor : i.getColorHex(We)
        };
      });
      E = an(N, e.property), A = on(N, e.property, b);
    }
    r.addLayer(
      {
        id: C.pointLayerId,
        type: "circle",
        source: l,
        layout: {
          // Contrary to labels, we want to see the small one in front. Weirdly "circle-sort-key" works in the opposite direction as "symbol-sort-key".
          "circle-sort-key": e.property ? ["/", 1, ["get", e.property]] : 0
        },
        paint: {
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          "circle-color": E,
          "circle-opacity": g,
          "circle-radius": A,
          ...f2 && {
            "circle-stroke-opacity": typeof d == "number" ? d : z(d),
            "circle-stroke-width": typeof h == "number" ? h : z(h),
            "circle-stroke-color": typeof m == "string" ? m : Fe(m)
          }
        },
        minzoom: v,
        maxzoom: x
      },
      e.beforeId
    );
  }
  if (c !== false && (e.cluster || e.property)) {
    C.labelLayerId = `${u}_label`;
    const E = e.labelColor ?? "#fff", A = e.labelSize ?? 12;
    r.addLayer(
      {
        id: C.labelLayerId,
        type: "symbol",
        source: l,
        filter: ["has", e.cluster ? "point_count" : e.property],
        layout: {
          "text-field": e.cluster ? "{point_count_abbreviated}" : `{${e.property}}`,
          "text-font": ["Noto Sans Regular"],
          "text-size": A,
          "text-pitch-alignment": p ? "viewport" : "map",
          "symbol-sort-key": ["/", 1, ["get", e.cluster ? "point_count" : e.property]]
          // so that the largest value goes on top
        },
        paint: {
          "text-color": E,
          "text-opacity": g
        },
        minzoom: v,
        maxzoom: x
      },
      e.beforeId
    );
  }
  return C;
}
function ap(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = e.minzoom ?? 0, o = e.maxzoom ?? 23, i = e.zoomCompensation ?? true, s = e.opacity ?? [
    { zoom: a, value: 0 },
    { zoom: a + 0.25, value: 1 },
    { zoom: o - 0.25, value: 1 },
    { zoom: o, value: 0 }
  ];
  let l = Array.isArray(e.colorRamp) ? e.colorRamp : gi.TURBO.transparentStart();
  const u = l.getBounds();
  (u.min !== 0 || u.max !== 1) && (l = l.scale(0, 1)), l.hasTransparentStart() || (l = l.transparentStart());
  const c = e.intensity ?? [
    { zoom: 0, value: 0.01 },
    { zoom: 4, value: 0.2 },
    { zoom: 16, value: 1 }
  ], p = e.property ?? null, f2 = e.weight ?? 1;
  let d = 1;
  p ? typeof f2 == "number" ? (d = f2, typeof e.weight == "number" && console.warn("The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`")) : Array.isArray(f2) ? d = hi(f2, p) : console.warn("The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`") : typeof f2 == "number" ? d = f2 : Array.isArray(f2) && console.warn("The options `.propertyValueWeights` can only be used when `.property` is provided.");
  const h = [
    { zoom: 0, value: 50 * 0.025 },
    { zoom: 2, value: 50 * 0.05 },
    { zoom: 4, value: 50 * 0.1 },
    { zoom: 8, value: 50 * 0.25 },
    { zoom: 16, value: 50 }
  ], m = e.radius ?? (i ? h : 10);
  let g = 1;
  typeof m == "number" ? g = m : Array.isArray(m) && "zoom" in m[0] ? g = z(m) : p && Array.isArray(m) && "propertyValue" in m[0] ? g = mi(m, p, i) : !p && Array.isArray(m) && "propertyValue" in m[0] ? (g = z(h), console.warn("The option `.radius` can only be property-driven if the option `.property` is provided.")) : g = z(h);
  const b = {
    heatmapLayerId: n,
    heatmapSourceId: t
  };
  if (e.data && !r.getSource(t)) {
    let v = e.data;
    typeof v == "string" && nr(v) && (v = `https://api.maptiler.com/data/${v}/features.json?key=${j.apiKey}`), r.addSource(t, {
      type: "geojson",
      data: v
    });
  }
  return r.addLayer(
    {
      id: n,
      type: "heatmap",
      source: t,
      minzoom: a,
      maxzoom: o,
      paint: {
        "heatmap-weight": d,
        "heatmap-intensity": typeof c == "number" ? c : z(c),
        "heatmap-color": yi(l),
        "heatmap-radius": g,
        "heatmap-opacity": typeof s == "number" ? s : z(s)
      }
    },
    e.beforeId
  ), b;
}
var lf = Object.freeze(Object.defineProperty({
  __proto__: null,
  addHeatmap: ap,
  addPoint: np,
  addPolygon: rp,
  addPolyline: ep,
  colorDrivenByProperty: an,
  colorPalettes: rn,
  computeRampedOutlineWidth: di,
  dashArrayMaker: zn,
  generateRandomLayerName: Rt,
  generateRandomSourceName: Pt,
  getRandomColor: wr,
  heatmapIntensityFromColorRamp: yi,
  lerpZoomNumberValues: nn,
  opacityDrivenByProperty: sn,
  paintColorOptionsToPaintSpec: Fe,
  radiusDrivenByProperty: on,
  radiusDrivenByPropertyHeatmap: mi,
  rampedOptionsToLayerPaintSpec: z,
  rampedPropertyValueWeight: hi,
  takeScreenshot: Wc
}, Symbol.toStringTag, { value: "Module" }));
function op(...r) {
  const e = r[0].length;
  return r.every((t) => t.length === e);
}
function rr(r, e, t) {
  return r + (e - r) * t;
}
function vi(r) {
  if (r.length === 0)
    throw new Error("[lerpArrayValues]: Array empty, nothing to interpolate");
  if (r.every((e) => e === null))
    throw new Error("[lerpArrayValues]: Cannot interpolate an array where all values are `null`");
  return r.map((e, t, n) => {
    if (typeof e == "number")
      return e;
    const [a, o] = sp(n, t), [i, s] = ip(n, t);
    if (a === null || o === null)
      return n[t + 1];
    if (i === null || s === null)
      return o;
    const l = (t - a) / (i - a);
    return rr(o, s, l);
  });
}
function ip(r, e) {
  for (let t = e + 1; t < r.length; t++)
    if (r[t] !== null)
      return [t, r[t]];
  return [null, null];
}
function sp(r, e) {
  for (let t = e - 1; t >= 0; t--)
    if (r[t] !== null)
      return [t, r[t]];
  return [null, null];
}
var lp = {
  defaultEasing: "Linear",
  pathSmoothing: {
    resolution: 20,
    epsilon: 5
  }
};
var Ua = ["MultiPoint", "LineString", "MultiLineString", "Polygon"];
function up(r, e = {}) {
  const { defaultEasing: t, pathSmoothing: n, ignoreFields: a } = {
    ...lp,
    ...e
  }, o = r.geometry, i = r.properties ?? {}, s = i["@easing"];
  s || console.warn(`[parseGeoJSONFeatureToKeyframes]: No '@easing' property found in GeoJSON properties, using default easing ${t}`);
  const l = i["@delta"];
  if (l || console.warn("[parseGeoJSONFeatureToKeyframes]: No '@delta' property found in GeoJSON properties, delta for each frame will default to its index divided by the total"), !o.type)
    throw new Error("[parseGeoJSONFeatureToKeyframes]: No geometry found in feature");
  if (!Ua.includes(o.type))
    throw new Error(`[parseGeoJSONFeatureToKeyframes]: Geometry type '${o.type}' is not supported. Accepted types are: ${Ua.join(", ")}`);
  const c = o.type !== "LineString" && o.type !== "MultiPoint" ? o.coordinates.flat() : o.coordinates, p = c.map((g) => g.length > 2 ? g[2] : null), f2 = p.every((g) => g === null), d = Object.entries({
    ...i,
    ...!f2 && { altitude: p }
  }).reduce((g, [b, v]) => b.startsWith("@") || a != null && a.includes(b) ? g : {
    ...g,
    [b]: v
  }, {}), h = l ?? c.map((g, b) => b / c.length), m = s ?? h.map(() => t ?? "Linear");
  if (c.some((g) => g.length > 2) && console.warn("[parseGeoJSONFeatureToKeyframes]: Smoothing is not supported for 3D paths, only 2D smoothing will be applied, ignoring altitude"), n) {
    const g = cp(c, n.resolution, n.epsilon), b = vi(Ba([0, 1], g.length)), v = b.map(() => t ?? "Linear"), x = Object.entries(d).reduce((C, [E, A]) => {
      if (!Array.isArray(A))
        return C;
      const N = g.length, le = Ba(A, N);
      return {
        ...C,
        [E]: le
      };
    }, {});
    return qa(g, b, v, x);
  }
  return qa(c, h, m, d);
}
function Ba(r, e) {
  const t = r.map((n, a) => {
    const o = a / (r.length - 1);
    return Math.round(o * (e - 1));
  });
  return Array.from({ length: e }, (n, a) => t.includes(a) ? r[t.indexOf(a)] : null);
}
function qa(r, e, t, n = {}) {
  if (!op(r, e, t, ...Object.values(n)))
    throw new Error(`
      [parseGeoJSONFeatureToKeyframes]: If smoothing is not applied, coordinates, deltas, easings and property arrays must be the same length

      Coordinates: ${r.length}
      Deltas: ${e.length}
      Easing: ${t.length}
      Properties:
        ${Object.entries(n).map(([o, i]) => `"${o}": ${i.length}`).join(`,
        `)}
    `);
  const a = r.some((o) => o.length > 2);
  return r.map((o, i) => {
    const s = e[i], l = t[i];
    return {
      props: {
        ...Object.entries(n).reduce((p, [f2, d]) => ({
          ...p,
          [f2]: d[i]
        }), {}),
        lng: o[0],
        lat: o[1],
        ...a && { altitude: o[2] ?? null }
      },
      delta: s,
      easing: l
    };
  });
}
function jr(r, e, t, n, a, o, i, s) {
  const l = [t[0] + (n[0] - e[0]) / 6, t[1] + (n[1] - e[1]) / 6], u = [n[0] - (a[0] - t[0]) / 6, n[1] - (a[1] - t[1]) / 6], c = 1 / o;
  let p = i - c;
  for (let h = i; h <= s; h += c) {
    const m = (1 - h) ** 3 * t[0] + 3 * (1 - h) ** 2 * h * l[0] + 3 * (1 - h) * h ** 2 * u[0] + h ** 3 * n[0], g = (1 - h) ** 3 * t[1] + 3 * (1 - h) ** 2 * h * l[1] + 3 * (1 - h) * h ** 2 * u[1] + h ** 3 * n[1];
    r.push([m, g]), p = h;
  }
  const f2 = (1 - s) ** 3 * t[0] + 3 * (1 - s) ** 2 * s * l[0] + 3 * (1 - s) * s ** 2 * u[0] + s ** 3 * n[0], d = (1 - s) ** 3 * t[1] + 3 * (1 - s) ** 2 * s * l[1] + 3 * (1 - s) * s ** 2 * u[1] + s ** 3 * n[1];
  s - p > 1e-10 ? r.push([f2, d]) : r[r.length - 1] = [f2, d];
}
function cp(r, e = 20, t) {
  const n = typeof t == "number" ? fp(r, t) : r;
  if (n.length < 4) return n;
  typeof t == "number" && (n[n.length - 1] = [...r[r.length - 1]]);
  const a = [], o = [2 * n[0][0] - n[1][0], 2 * n[0][1] - n[1][1]];
  jr(a, o, n[0], n[1], n[2], e, 0, 1);
  const i = 1 / e;
  for (let l = 1; l < n.length - 2; l++) {
    const u = n[l - 1], c = n[l], p = n[l + 1], f2 = n[l + 2];
    jr(a, u, c, p, f2, e, i, 1);
  }
  const s = [2 * n[n.length - 1][0] - n[n.length - 2][0], 2 * n[n.length - 1][1] - n[n.length - 2][1]];
  return jr(a, n[n.length - 3], n[n.length - 2], n[n.length - 1], s, e, i, 1), a;
}
function pp(r) {
  return r.map((e, t) => {
    if (t === 0) return 0;
    const n = r[t - 1], a = new Ne(e[0], e[1]), o = new Ne(n[0], n[1]);
    return a.distanceTo(o);
  }).reduce((e, t) => e + t, 0) / r.length;
}
function fp(r, e) {
  const t = dp(r, pp(r) * e);
  if (t.length < 2) return t;
  const n = [t[0]];
  let a = t[0];
  for (let o = 1; o < t.length; o++) {
    const i = t[o], s = new Ne(a[0], a[1]), l = new Ne(i[0], i[1]);
    s.distanceTo(l) >= e && (n.push(i), a = i);
  }
  return n.push([...r[r.length - 1]]), n;
}
function dp(r, e = 10) {
  if (r.length < 2) return r;
  const t = [r[0]];
  let n = e;
  for (let i = 0; i < r.length - 1; ) {
    const s = Ne.convert(r[i]), l = Ne.convert(r[i + 1]), u = s.distanceTo(l);
    if (u < n)
      n -= u, i++;
    else {
      const c = n / u, p = [rr(s.lng, l.lng, c), rr(s.lat, l.lat, c)];
      t.push(p), r[i] = p, n = e;
    }
  }
  const a = r[r.length - 1], o = t[t.length - 1];
  return (o[0] !== a[0] || o[1] !== a[1]) && t.push([a[0], a[1]]), t;
}
var Va = {
  animations: new Array(),
  running: false,
  /**
   * Adds an animation to the manager. If this is the first animation added,
   * it starts the animation loop.
   *
   * @param {MaptilerAnimation} animation - The animation to add.
   */
  add(r) {
    this.animations.push(r), this.running || (this.running = true, this.start());
  },
  /**
   * Removes an animation from the manager. If there are no more animations,
   * it stops the animation loop.
   *
   * @param {MaptilerAnimation} animation - The animation to remove.
   */
  remove(r) {
    this.animations = this.animations.filter((e) => e !== r), this.animations.length === 0 && this.stop();
  },
  /**
   * Stops the animation loop.
   */
  stop() {
    this.running = false;
  },
  /**
   * Starts the animation loop. This function is called recursively using
   * requestAnimationFrame to ensure smooth updates.
   */
  start() {
    if (!this.running)
      return;
    const r = () => {
      if (this.animations.length === 0) {
        this.running = false;
        return;
      }
      this.animations.forEach((e) => {
        e.isPlaying && e.updateInternal();
      }), requestAnimationFrame(r);
    };
    r();
  }
};
var ln = [
  "pause",
  "reset",
  "play",
  "stop",
  "timeupdate",
  "scrub",
  "playbackratechange",
  "animationstart",
  "animationend",
  "keyframe",
  "iteration"
];
var hp = {
  Linear: mp,
  QuadraticIn: yp,
  QuadraticOut: gp,
  QuadraticInOut: vp,
  CubicIn: bp,
  CubicOut: wp,
  CubicInOut: Sp,
  SinusoidalIn: xp,
  SinusoidalOut: kp,
  SinusoidalInOut: Lp,
  ExponentialIn: Ep,
  ExponentialOut: Cp,
  ExponentialInOut: Ap,
  ElasticIn: Tp,
  ElasticOut: Ip,
  ElasticInOut: _p,
  BounceIn: bi,
  BounceOut: Fn,
  BounceInOut: Mp
};
function mp(r) {
  return r;
}
function yp(r) {
  return r * r;
}
function gp(r) {
  return r * (2 - r);
}
function vp(r) {
  let e = r * 2;
  return e < 1 ? 0.5 * e * e : (e -= 1, -0.5 * (e * (e - 2) - 1));
}
function bp(r) {
  return r * r * r;
}
function wp(r) {
  return --r * r * r + 1;
}
function Sp(r) {
  let e = r * 2;
  return e < 1 ? 0.5 * e * e * e : (e -= 2, 0.5 * (e * e * e + 2));
}
function xp(r) {
  return 1 - Math.cos(r * Math.PI / 2);
}
function kp(r) {
  return Math.sin(r * Math.PI / 2);
}
function Lp(r) {
  return 0.5 * (1 - Math.cos(Math.PI * r));
}
function Ep(r) {
  return r === 0 ? 0 : 1024 ** (r - 1);
}
function Cp(r) {
  return r === 1 ? 1 : 1 - 2 ** (-10 * r);
}
function Ap(r) {
  if (r === 0) return 0;
  if (r === 1) return 1;
  const e = r * 2;
  return e < 1 ? 0.5 * 1024 ** (e - 1) : 0.5 * (-(2 ** (-10 * (e - 1))) + 2);
}
function Tp(r) {
  let e = 0.1;
  const t = 0.4;
  let n;
  return r === 0 ? 0 : r === 1 ? 1 : (e < 1 ? (e = 1, n = t / 4) : n = t * Math.asin(1 / e) / (2 * Math.PI), r -= 1, -(e * 2 ** (10 * r) * Math.sin((r - n) * (2 * Math.PI) / t)));
}
function Ip(r) {
  let e = 0.1;
  const t = 0.4;
  let n;
  return r === 0 ? 0 : r === 1 ? 1 : (e < 1 ? (e = 1, n = t / 4) : n = t * Math.asin(1 / e) / (2 * Math.PI), e * 2 ** (-10 * r) * Math.sin((r - n) * (2 * Math.PI) / t) + 1);
}
function _p(r) {
  let e = 0.1;
  const t = 0.4;
  let n;
  if (r === 0) return 0;
  if (r === 1) return 1;
  e < 1 ? (e = 1, n = t / 4) : n = t * Math.asin(1 / e) / (2 * Math.PI);
  const a = r * 2;
  if (a < 1) {
    const i = a - 1;
    return -0.5 * (e * 2 ** (10 * i) * Math.sin((i - n) * (2 * Math.PI) / t));
  }
  const o = a - 1;
  return e * 2 ** (-10 * o) * Math.sin((o - n) * (2 * Math.PI) / t) * 0.5 + 1;
}
function bi(r) {
  return 1 - Fn(1 - r);
}
function Fn(r) {
  if (r < 1 / 2.75)
    return 7.5625 * r * r;
  if (r < 2 / 2.75) {
    const t = r - 0.5454545454545454;
    return 7.5625 * t * t + 0.75;
  } else if (r < 2.5 / 2.75) {
    const t = r - 0.8181818181818182;
    return 7.5625 * t * t + 0.9375;
  }
  const e = r - 2.625 / 2.75;
  return 7.5625 * e * e + 0.984375;
}
function Mp(r) {
  return r < 0.5 ? bi(r * 2) * 0.5 : Fn(r * 2 - 1) * 0.5 + 0.5;
}
var $n = class _$n {
  constructor({ keyframes: e, duration: t, iterations: n, manualMode: a, delay: o }) {
    y(this, "playing", false);
    y(this, "iterations");
    y(this, "currentIteration", 0);
    y(this, "keyframes");
    y(this, "currentKeyframe");
    y(this, "duration");
    y(this, "effectiveDuration");
    y(this, "playbackRate");
    y(this, "currentTime");
    y(this, "currentDelta");
    y(this, "animationStartTime", 0);
    y(this, "lastFrameAt", 0);
    y(this, "delay", 0);
    y(this, "delayTimeoutID");
    y(this, "listeners", ln.reduce((e2, t2) => (e2[t2] = [], e2), {}));
    y(this, "previousProps");
    const i = e.map(({ props: c }) => Object.keys(c)).flat().reduce((c, p) => (p && !c.includes(p) && c.push(p), c), []), s = e.sort((c, p) => c.delta - p.delta).map((c) => {
      const p = i.reduce((f2, d) => d in f2 ? f2 : {
        ...f2,
        // set as null to infer that this proprty
        // does not have a value but will need to be
        [d]: null
      }, c.props);
      return {
        ...c,
        props: p
      };
    }), l = s.map(({ props: c }) => c).reduce((c, p) => {
      for (const [f2, d] of Object.entries(p))
        f2 in c || (c[f2] = []), c[f2].push(d);
      return c;
    }, {}), u = Object.entries(l).reduce((c, [p, f2]) => (c[p] = vi(f2), c), {});
    this.keyframes = s.map((c, p) => ({
      ...c,
      props: i.reduce((f2, d) => (f2[d] = u[d][p], f2), {}),
      easing: c.easing ?? "Linear",
      id: crypto.randomUUID()
    })), this.duration = t, this.iterations = n, this.delay = o ?? 0, this.playbackRate = 1, this.effectiveDuration = t / this.playbackRate, this.currentTime = 0, this.currentDelta = 0, a || Va.add(this);
  }
  /**
   * Indicates if the animation is currently playing
   * @returns {boolean} - true if the animation is playing, false otherwise
   */
  get isPlaying() {
    return this.playing;
  }
  /**
   * Starts or resumes the animation
   * @returns This animation instance for method chaining
   * @event "play"
   */
  play() {
    if (this.playing)
      return this;
    if (this.delayTimeoutID)
      return this;
    const e = () => {
      this.playing = true, this.animationStartTime = performance.now(), this.lastFrameAt = this.animationStartTime, this.emitEvent("play");
    };
    return this.delay > 0 ? this.delayTimeoutID = window.setTimeout(() => {
      e(), this.delayTimeoutID = void 0;
    }, this.delay / this.playbackRate) : e(), this;
  }
  /**
   * Pauses the animation
   * @returns This animation instance for method chaining
   * @event "pause"
   */
  pause() {
    return this.playing = false, this.emitEvent("pause"), this;
  }
  /**
   * Stops the animation and resets to initial state
   * @returns This animation instance for method chaining
   * @event "stop"
   */
  stop(e = false) {
    return this.playing = false, e || this.emitEvent("stop"), this;
  }
  /**
   * Resets the animation to its initial state without stopping
   * @returns This animation instance for method chaining
   * @event "reset"
   */
  reset(e = true) {
    return this.stop(true), window.clearTimeout(this.delayTimeoutID), this.currentTime = 0, this.currentDelta = this.playbackRate < 0 ? 1 : 0, this.emitEvent("reset"), this.update(false, true), e || this.play(), this;
  }
  /**
   * Updates the animation state if playing, this is used by the AnimationManager
   * to update all animations in the loop
   * @returns This animation instance for method chaining
   */
  updateInternal() {
    return this.playing ? this.update(false) : this;
  }
  /**
   * Updates the animation state, interpolating between keyframes
   * and emitting events as necessary
   * @event "timeupdate"
   * @event "keyframe"
   * @event "iteration"
   * @event "animationend"
   * @returns This animation instance for method chaining
   */
  update(e = true, t = false) {
    const n = performance.now();
    if (this.currentDelta >= 1 || this.currentDelta < 0)
      if (this.emitEvent("animationend"), this.iterations === 0 || this.currentIteration < this.iterations)
        this.reset(e);
      else
        return this.stop(), this;
    if (!t) {
      const l = e ? 16 : n - this.lastFrameAt, u = n - this.animationStartTime;
      this.lastFrameAt = n;
      const c = u * this.playbackRate;
      this.currentTime = c, this.currentDelta += l / this.effectiveDuration;
    }
    this.currentDelta > 1 && (this.currentIteration = 1), this.currentDelta < 0 && (this.currentDelta = 0);
    const { next: o, current: i } = this.getCurrentAndNextKeyFramesAtDelta(this.currentDelta);
    (i == null ? void 0 : i.id) !== this.currentKeyframe && this.emitEvent("keyframe", i, o), this.currentKeyframe = i == null ? void 0 : i.id;
    const s = Object.keys((i == null ? void 0 : i.props) ?? {}).reduce((l, u) => {
      if (i && o) {
        const c = i.props[u], p = o.props[u], f2 = (this.currentDelta - i.delta) / (o.delta - i.delta), h = (hp[i.easing] ?? ((m) => m))(f2);
        l[u] = rr(c, p, h);
      }
      return i && !o && (l[u] = i.props[u]), l;
    }, {});
    return this.previousProps || (this.previousProps = this.keyframes[0].props), this.emitEvent("timeupdate", i, o, s, this.previousProps), (this.currentDelta >= 1 || this.currentDelta < 0) && !t && (this.currentIteration += 1, this.emitEvent("iteration", null, null, {})), this.previousProps = { ...s }, this;
  }
  /**
   * Gets the current and next keyframes at a specific time
   * @param time - The time position to query
   * @returns Object containing current and next keyframes, which may be null
   */
  getCurrentAndNextKeyFramesAtTime(e) {
    return this.getCurrentAndNextKeyFramesAtDelta(e / this.effectiveDuration);
  }
  /**
   * Gets the current and next keyframes at a specific delta value
   * @param delta - The delta value to query
   * @returns Object containing current and next keyframes, which may be null
   */
  getCurrentAndNextKeyFramesAtDelta(e) {
    const t = this.keyframes.find((a) => a.delta > e) ?? null;
    return { current: this.keyframes.findLast((a) => a.delta <= e) ?? null, next: t };
  }
  /**
   * Gets the current time position of the animation
   * @returns The current time in milliseconds
   */
  getCurrentTime() {
    return this.currentTime;
  }
  /**
   * Sets the current time position of the animation
   * @param time - The time to set in milliseconds
   * @returns This animation instance for method chaining
   * @throws Error if time is greater than the duration
   * @event "scrub"
   */
  setCurrentTime(e) {
    if (e > this.effectiveDuration)
      throw new Error("Cannot set time greater than duration");
    return this.currentTime = e, this.currentDelta = e / this.effectiveDuration, this.emitEvent("scrub"), this;
  }
  /**
   * Gets the current delta value of the animation
   * @returns The current delta value (normalized progress between 0 and 1)
   */
  getCurrentDelta() {
    return this.currentDelta;
  }
  /**
   * Sets the current delta value of the animation
   * @param delta - The delta value to set (normalized progress between 0 and 1)
   * @returns This animation instance for method chaining
   * @throws Error if delta is greater than 1
   * @event "scrub"
   */
  setCurrentDelta(e) {
    if (e > 1)
      throw new Error("Cannot set delta greater than 1");
    return this.animationStartTime = performance.now(), this.lastFrameAt = this.animationStartTime, this.currentDelta = e, this.currentTime = e * this.effectiveDuration, this.update(false, true), this.emitEvent("scrub"), this;
  }
  /**
   * Sets the playback rate of the animation
   * @param rate - The playback rate (1.0 is normal speed)
   * @returns This animation instance for method chaining
   * @event "playbackratechange"
   */
  setPlaybackRate(e) {
    return this.playbackRate = e, this.effectiveDuration = this.duration / this.playbackRate, this.emitEvent("playbackratechange"), this;
  }
  /**
   * Gets the current playback rate
   * @returns The current playback rate
   */
  getPlaybackRate() {
    return this.playbackRate;
  }
  /**
   * Adds an event listener to the animation
   * @param type - The type of event to listen for
   * @param callback - The callback function to execute when the event occurs
   * @returns This animation instance for method chaining
   */
  addEventListener(e, t) {
    return e in this.listeners ? (this.listeners[e].push(t), this) : (console.warn(`Event type ${e} does not exist, ignoring`), this);
  }
  /**
   * Removes an event listener from the animation
   * @param type - The type of event to remove
   * @param callback - The callback function to remove
   * @returns This animation instance for method chaining
   */
  removeEventListener(e, t) {
    return e in this.listeners ? (this.listeners[e] = this.listeners[e].filter((n) => n !== t), this) : (console.warn(`Event type ${e} does not exist, ignoring`), this);
  }
  /**
   * Emits an event to all listeners of a specific type
   * @param event - The type of event to emit
   * @param keyframe - The keyframe that triggered the event
   * @param props - The interpolated properties at the current delta
   */
  emitEvent(e, t, n, a = {}, o) {
    this.listeners[e].forEach((i) => {
      i({
        type: e,
        target: this,
        currentTime: this.currentTime,
        currentDelta: this.currentDelta,
        playbackRate: this.playbackRate,
        keyframe: t,
        nextKeyframe: n ?? t,
        props: a,
        previousProps: o ?? a
      });
    });
  }
  /**
   * Creates a clone of this animation
   * @returns A new animation instance with the same properties as this one
   */
  clone() {
    return new _$n({
      keyframes: structuredClone(this.keyframes),
      duration: this.duration,
      iterations: this.iterations
    });
  }
  /**
   * Destroys the animation instance, removing all event listeners and stopping playback
   */
  destroy() {
    this.stop(), this.listeners = ln.reduce((e, t) => (e[t] = [], e), {}), Va.remove(this);
  }
};
var Ga = "animated-route-layer";
var uf = class {
  constructor({
    keyframes: e,
    source: t,
    duration: n,
    iterations: a,
    easing: o,
    delay: i,
    cameraAnimation: s = {},
    pathStrokeAnimation: l = {
      activeColor: [255, 0, 0, 1],
      inactiveColor: [0, 0, 255, 1]
    },
    autoplay: u,
    manualUpdate: c = false
  }) {
    y(this, "id", `${Ga}-${v4_default()}`);
    y(this, "type", "custom");
    y(this, "animationInstance", null);
    y(this, "keyframes", null);
    y(this, "source", null);
    y(this, "duration");
    y(this, "iterations");
    y(this, "delay");
    y(this, "easing");
    y(this, "map");
    y(this, "cameraMaptilerAnimationOptions");
    y(this, "pathStrokeAnimation");
    y(this, "autoplay", false);
    y(this, "manualUpdate", false);
    y(this, "enquedEventHandlers", ln.reduce((e2, t2) => (e2[t2] = [], e2), {}));
    y(this, "enquedCommands", []);
    this.keyframes = e ?? null, this.source = t ?? null, n && (this.duration = n), a && (this.iterations = a), i && (this.delay = i), this.easing = o, this.cameraMaptilerAnimationOptions = s ? {
      pathSmoothing: {
        resolution: 20,
        epsilon: 5
      },
      follow: true,
      ...s && s
    } : false, l && (this.pathStrokeAnimation = l), this.autoplay = u ?? false, this.manualUpdate = c, this.update = this.update.bind(this);
  }
  /**
   * This method is called when the layer is added to the map.
   * It initializes the animation instance and sets up event listeners.
   *
   * @param {MapLibreMap} map - The map instance (maplibre Map, but will be MapSDK at runtime)
   * @param {WebGLRenderingContext | WebGL2RenderingContext} _gl - The WebGL context (unused in this layer)
   */
  // eslint-disable-next-line @typescript-eslint/no-misused-promises
  async onAdd(e) {
    if (this.map = e, this.map.getLayersOrder().some((n) => n.includes(Ga) && this.id !== n))
      throw new Error("[AnimatedRouteLayer.onAdd]: Currently, you can only have one active AnimatedRouteLayer at a time. Please remove the existing one before adding a new one.");
    const t = await this.getMaptilerAnimationOptions();
    this.animationInstance = new $n({
      ...t,
      manualMode: this.manualUpdate
    }), this.animationInstance.addEventListener("timeupdate", this.update), Object.entries(this.enquedEventHandlers).forEach(([n, a]) => {
      const o = n;
      a.forEach((i) => {
        var s;
        (s = this.animationInstance) == null || s.addEventListener(o, i);
      }), this.enquedEventHandlers[o] = [];
    }), this.enquedCommands.forEach((n) => {
      n();
    }), this.enquedCommands = [], this.autoplay && this.animationInstance.play();
  }
  /**
   * Initializes the animation instance asynchronously.
   * This is called from onAdd but runs asynchronously to handle async data loading.
   */
  /**
   * This method is used to manually advance the animation
   *
   * @returns {AnimatedRouteLayer} - The current instance of AnimatedRouteLayer
   */
  frameAdvance() {
    return this.animationInstance && this.manualUpdate && this.animationInstance.update(true), this;
  }
  /**
   * Adds an event listener to the animation instance.
   *
   * @param {AnimationEventTypes} type - The type of event to listen for
   * @param {FrameCallback} callback - The callback function to execute when the event occurs
   */
  addEventListener(e, t) {
    return this.animationInstance ? (this.animationInstance.addEventListener(e, t), this) : (this.enquedEventHandlers[e].push(t), this);
  }
  /**
   * Removes an event listener from the animation instance.
   *
   * @param {AnimationEventTypes} type - The type of event to remove
   * @param {FrameCallback} callback - The callback function to remove
   */
  removeEventListener(e, t) {
    return this.animationInstance ? (this.animationInstance.removeEventListener(e, t), this) : this;
  }
  updateManual() {
    this.animationInstance && this.manualUpdate && this.animationInstance.update(true);
  }
  /**
   * Updates the layer's properties based on the animation event.
   * @private
   * @param {AnimationEvent} event - The animation event
   */
  update(e) {
    const { props: t, currentDelta: n } = e;
    if (this.source && this.pathStrokeAnimation) {
      const { activeColor: a, inactiveColor: o } = this.pathStrokeAnimation;
      n >= 1 ? this.map.setPaintProperty(this.source.layerID, "line-gradient", ["interpolate", ["linear"], ["line-progress"], 0, ["rgba", ...a], 1, ["rgba", ...a]]) : this.map.setPaintProperty(this.source.layerID, "line-gradient", [
        "interpolate",
        ["linear"],
        ["line-progress"],
        // Progress along the line
        0,
        ["rgba", ...a],
        // color at the start
        1e-4 + n,
        ["rgba", ...a],
        // color at the start
        11e-5 + n,
        ["rgba", ...o],
        // color at the transition
        1,
        ["rgba", ...o]
        // color at the end
      ]);
    }
    if (t && this.cameraMaptilerAnimationOptions && this.cameraMaptilerAnimationOptions.follow) {
      const { lng: a, lat: o, bearing: i, zoom: s, pitch: l, elevation: u } = t;
      this.map.jumpTo({
        center: [a, o],
        pitch: l ?? this.map.getPitch(),
        zoom: s ?? this.map.getZoom(),
        bearing: i ?? this.map.getBearing(),
        elevation: u ?? this.map.getCenterElevation()
      });
    }
  }
  /**
   * Plays the animation.
   *
   * @returns {AnimatedRouteLayer} - The current instance of AnimatedRouteLayer
   */
  play() {
    return this.animationInstance ? (this.animationInstance.play(), this) : (this.enquedCommands.push(() => {
      var e;
      (e = this.animationInstance) == null || e.play();
    }), this);
  }
  /**
   * Stops the animation.
   *
   * @returns {AnimatedRouteLayer} - The current instance of AnimatedRouteLayer
   */
  pause() {
    return this.animationInstance ? (this.animationInstance.pause(), this) : (this.enquedCommands.push(() => {
      var e;
      (e = this.animationInstance) == null || e.pause();
    }), this);
  }
  /**
   * Gets the source GeoJSON data from the map instance, parses it, and returns the animation options.
   *
   * @returns {Promise<MaptilerAnimationOptions>} - The MaptilerAnimation constructor options
   */
  async getMaptilerAnimationOptions() {
    const e = this.map;
    if (this.source) {
      const t = e.getSource(this.source.id);
      if (t) {
        let n = await (t == null ? void 0 : t.getData());
        if (!n)
          throw new Error("[AnimatedRouteLayer.onAdd]: No feature found in source data");
        if (n.type === "FeatureCollection" && (console.warn("[AnimatedRouteLayer.onAdd]: FeatureCollection found in source data, only single geojson features are currently supported, first feature will be used"), n = n.features[0]), n.type !== "Feature")
          throw new Error("[AnimatedRouteLayer.onAdd]: The first feature in the source data is not a valid GeoJSON of type `Feature`");
        const a = n;
        a.properties["@duration"] && (this.duration = a.properties["@duration"] ?? 1e3), a.properties["@iterations"] && (this.iterations = a.properties["@iterations"] ?? 0), a.properties["@delay"] && (this.delay = a.properties["@delay"] ?? 0), a.properties["@autoplay"] && (this.autoplay = a.properties["@autoplay"] ?? false);
        const o = up(a, {
          pathSmoothing: this.cameraMaptilerAnimationOptions ? this.cameraMaptilerAnimationOptions.pathSmoothing : false,
          defaultEasing: this.easing
        }), i = this.duration, s = this.iterations, l = this.delay, u = this.autoplay;
        return {
          keyframes: o,
          duration: i,
          iterations: s,
          delay: l,
          autoplay: u
        };
      }
    }
    if (this.keyframes)
      return {
        keyframes: this.keyframes,
        duration: this.duration,
        iterations: this.iterations,
        delay: this.delay,
        autoplay: this.autoplay
      };
    throw new Error("[AnimatedRouteLayer.onAdd]: No keyframes or source provided");
  }
  /**
   * This method is called when the layer is removed from the map.
   * It destroys the animation instance.
   */
  onRemove() {
    var e;
    (e = this.animationInstance) == null || e.destroy();
  }
  /**
   * This method is called to render the layer.
   * It is a no-op for this layer.
   */
  render() {
  }
};
function wi() {
  return "3.11.1";
}
var cf = import_maplibre_gl.default.Map;
var pf = import_maplibre_gl.default.Marker;
var ff = import_maplibre_gl.default.Popup;
var df = import_maplibre_gl.default.Style;
var hf = import_maplibre_gl.default.CanvasSource;
var mf = import_maplibre_gl.default.GeoJSONSource;
var yf = import_maplibre_gl.default.ImageSource;
var gf = import_maplibre_gl.default.RasterTileSource;
var vf = import_maplibre_gl.default.RasterDEMTileSource;
var bf = import_maplibre_gl.default.VectorTileSource;
var wf = import_maplibre_gl.default.VideoSource;
var Sf = import_maplibre_gl.default.NavigationControl;
var xf = import_maplibre_gl.default.GeolocateControl;
var kf = import_maplibre_gl.default.AttributionControl;
var Lf = import_maplibre_gl.default.LogoControl;
var Ef = import_maplibre_gl.default.ScaleControl;
var Cf = import_maplibre_gl.default.FullscreenControl;
var Af = import_maplibre_gl.default.TerrainControl;
var Tf = import_maplibre_gl.default.BoxZoomHandler;
var If = import_maplibre_gl.default.ScrollZoomHandler;
var _f = import_maplibre_gl.default.CooperativeGesturesHandler;
var Mf = import_maplibre_gl.default.KeyboardHandler;
var Pf = import_maplibre_gl.default.TwoFingersTouchPitchHandler;
var Rf = import_maplibre_gl.default.MapWheelEvent;
var Of = import_maplibre_gl.default.MapTouchEvent;
var zf = import_maplibre_gl.default.MapMouseEvent;
var Ff = import_maplibre_gl.default.config;
var $f = import_maplibre_gl.default.getVersion;
var {
  setRTLTextPlugin: Nf,
  getRTLTextPluginStatus: jf,
  LngLat: Ne,
  LngLatBounds: Pp,
  MercatorCoordinate: un,
  Evented: Df,
  AJAXError: Uf,
  prewarm: Bf,
  clearPrewarmedResources: qf,
  Hash: Vf,
  Point: Si,
  EdgeInsets: Gf,
  DragRotateHandler: Hf,
  DragPanHandler: Kf,
  TwoFingersTouchZoomRotateHandler: Zf,
  DoubleClickZoomHandler: Xf,
  TwoFingersTouchZoomHandler: Yf,
  TwoFingersTouchRotateHandler: Wf,
  getWorkerCount: Jf,
  setWorkerCount: Qf,
  getMaxParallelImageRequests: ed,
  setMaxParallelImageRequests: td,
  getWorkerUrl: rd,
  setWorkerUrl: nd,
  addSourceType: ad,
  importScriptInWorkers: od,
  addProtocol: id,
  removeProtocol: sd
} = import_maplibre_gl.default;
export {
  Uf as AJAXError,
  Ga as ANIM_LAYER_PREFIX,
  uf as AnimatedRouteLayer,
  Xp as AttributionControl,
  kf as AttributionControlMLGL,
  Wp as BoxZoomHandler,
  Tf as BoxZoomHandlerMLGL,
  Bp as CanvasSource,
  hf as CanvasSourceMLGL,
  T as ColorRamp,
  gi as ColorRampCollection,
  Qp as CooperativeGesturesHandler,
  _f as CooperativeGesturesHandlerMLGL,
  Ue as CubemapFaceNames,
  nc as CubemapImagesPresets,
  $t as CubemapLayer,
  Ee as DOMcreate,
  Et as DOMremove,
  Xf as DoubleClickZoomHandler,
  Kf as DragPanHandler,
  Hf as DragRotateHandler,
  Gf as EdgeInsets,
  Df as Evented,
  Bi as FullscreenControl,
  Cf as FullscreenControlMLGL,
  qp as GeoJSONSource,
  mf as GeoJSONSourceMLGL,
  ji as GeolocateControl,
  xf as GeolocateControlMLGL,
  bc as GeolocationType,
  Vf as Hash,
  Vp as ImageSource,
  yf as ImageSourceMLGL,
  zc as ImageViewer,
  ne as ImageViewerEvent,
  sf as ImageViewerMarker,
  Uc as ImageViewerMarkerEvent,
  ef as KeyboardHandler,
  Mf as KeyboardHandlerMLGL,
  O as Language,
  Ne as LngLat,
  Pp as LngLatBounds,
  Di as LogoControl,
  Lf as LogoControlMLGL,
  Go as Map,
  cf as MapMLGL,
  af as MapMouseEvent,
  zf as MapMouseEventMLGL,
  MapStyle,
  MapStyleVariant,
  nf as MapTouchEvent,
  Of as MapTouchEventMLGL,
  rf as MapWheelEvent,
  Rf as MapWheelEventMLGL,
  $n as MaptilerAnimation,
  Iu as MaptilerCustomControl,
  Wr as MaptilerExternalControl,
  Tu as MaptilerGeolocateControl,
  qn as MaptilerLogoControl,
  Cu as MaptilerNavigationControl,
  _u as MaptilerProjectionControl,
  Eu as MaptilerTerrainControl,
  Ni as Marker,
  pf as MarkerMLGL,
  un as MercatorCoordinate,
  Sf as NavigationControMLGL,
  Ya as NavigationControl,
  Si as Point,
  Dp as Popup,
  ff as PopupMLGL,
  Dt as RadialGradientLayer,
  Hp as RasterDEMTileSource,
  vf as RasterDEMTileSourceMLGL,
  Gp as RasterTileSource,
  gf as RasterTileSourceMLGL,
  ReferenceMapStyle,
  Ui as ScaleControl,
  Ef as ScaleControlMLGL,
  Jp as ScrollZoomHandler,
  If as ScrollZoomHandlerMLGL,
  qi as SdkConfig,
  ServiceError,
  Up as Style,
  df as StyleMLGL,
  Af as TerrainControMLGL,
  Yp as TerrainControl,
  tf as TwoFingersTouchPitchHandler,
  Pf as TwoFingersTouchPitchHandlerMLGL,
  Wf as TwoFingersTouchRotateHandler,
  Yf as TwoFingersTouchZoomHandler,
  Zf as TwoFingersTouchZoomRotateHandler,
  Kp as VectorTileSource,
  bf as VectorTileSourceMLGL,
  Zp as VideoSource,
  wf as VideoSourceMLGL,
  id as addProtocol,
  ad as addSourceType,
  areSameLanguages,
  bufferToPixelDataBrowser,
  canParsePixelData,
  circumferenceAtLatitude,
  qf as clearPrewarmedResources,
  j as config,
  Ff as configMLGL,
  coordinates,
  cp as createBezierPathFromCoordinates,
  ze as cubemapPresets,
  data,
  of as displayWebGLContextLostWarning,
  elevation,
  expandMapStyle,
  geocoding,
  geolocation,
  getAutoLanguage,
  pp as getAverageDistance,
  Bn as getBrowserLanguage,
  getBufferToPixelDataParser,
  getLanguageInfoFromCode,
  getLanguageInfoFromFlag,
  getLanguageInfoFromKey,
  $f as getMapLibreVersion,
  ed as getMaxParallelImageRequests,
  jf as getRTLTextPluginStatus,
  getTileCache,
  wi as getVersion,
  Qi as getWebGLSupportError,
  Jf as getWorkerCount,
  rd as getWorkerUrl,
  ii as gpx,
  Yc as gpxOrKml,
  oi as hasChildNodeWithName,
  lf as helpers,
  od as importScriptInWorkers,
  isLanguageInfo,
  si as kml,
  rr as lerp,
  vi as lerpArrayValues,
  mapStylePresetList,
  math,
  misc,
  up as parseGeoJSONFeatureToKeyframes,
  Bf as prewarm,
  sd as removeProtocol,
  dp as resamplePath,
  td as setMaxParallelImageRequests,
  Nf as setRTLTextPlugin,
  Qf as setWorkerCount,
  nd as setWorkerUrl,
  fp as simplifyPath,
  staticMaps,
  Rn as str2xml,
  Ba as stretchNumericalArray,
  styleToStyle,
  toLanguageInfo,
  Do as toggleProjection,
  jo as toggleTerrain,
  Fa as xml2str
};
//# sourceMappingURL=@maptiler_sdk.js.map
